<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>微信小程序基础知识</title>
    <link href="/unkown404.github.io/2023/02/27/applet/"/>
    <url>/unkown404.github.io/2023/02/27/applet/</url>
    
    <content type="html"><![CDATA[<p>小程序基础知识汇总。</p><span id="more"></span><h2 id="微信小程序结构"><a href="#微信小程序结构" class="headerlink" title="微信小程序结构"></a>微信小程序结构</h2><p>小程序的运行环境分成渲染层和逻辑层，其中 WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。视图层和逻辑层通过 Native 层进行进行通信，并且通过 Native 层获得原生能力。<br>逻辑层和视图层之间的工作方式为：数据变更通过 setData 驱动视图更新；视图层交互触发事件，然后触发逻辑层的事件响应函数，函数中修改数据再次触发视图更新。</p><h2 id="小程序框架"><a href="#小程序框架" class="headerlink" title="小程序框架"></a>小程序框架</h2><p>常见框架：mpvue、taro、uni-app<br>实现流程：</p><ul><li>编译阶段：将其他 DSL（domain-specific language） 转换为符合小程序语法的 WXML、WXSS、JS、JSON；</li><li>运行阶段：数据、事件、生命周期等部分的处理和对接；</li></ul><h3 id="mpvue"><a href="#mpvue" class="headerlink" title="mpvue"></a>mpvue</h3><p>特点：将 Vue 实例和小程序页面实例简单粗暴地做了关联，以达到使用 Vue 开发小程序的目的。</p><h3 id="taro"><a href="#taro" class="headerlink" title="taro"></a>taro</h3><p>特点：</p><ul><li>无 DSL 限制：无论是你们团队是 React 还是 Vue 技术栈，都能够使用 Taro 开发。</li><li>新特性无缝支持：由于 Taro Next 本质上是将 React&#x2F;Vue 运行在小程序上，因此，各种新特性也就无缝支持了。</li></ul><h3 id="uni-app"><a href="#uni-app" class="headerlink" title="uni-app"></a>uni-app</h3><p>特点：</p><ul><li>支持组件局部更新：mpvue 时小程序不支持自定义组件，所以组件编进 Page，更新也是 Page 级</li><li>setData 优化：将数据进行 diff，然后通过 setData 进行路径级别的更新</li></ul><h2 id="微信小程序生命周期"><a href="#微信小程序生命周期" class="headerlink" title="微信小程序生命周期"></a>微信小程序生命周期</h2><p>全局文件 app.js 中定义了一些声明周期的方法</p><p>onLaunch() 监听小程序初始化 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）<br>onShow() 监听小程序显示 当小程序启动，或从后台进入前台显示，会触发 onShow<br>onHide() 监听小程序隐藏 当小程序从前台进入后台，会触发 onHide</p><p>这是每个 page 页面的周期函数</p><p>onLoad() 页面加载时触发，全局只会调用一次，在该周期内可获取当前页面路径的参数<br>onShow() 页面显示时触发或者切入前台时触发，也就是在该周期内可以获取请求数据<br>onReady() 页面初次渲染完成时触发，只会调用一次，代表页面已经可以和视图层进行交互<br>onHide() 页面隐藏或者切入后台时触发，如底部 tab 切换到其他页面或小程序切入后台时触发。<br>onUnload() 页面卸载时触发</p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>英语笔记</title>
    <link href="/unkown404.github.io/2023/02/26/EnglishNotes/"/>
    <url>/unkown404.github.io/2023/02/26/EnglishNotes/</url>
    
    <content type="html"><![CDATA[<p>虽然自己现在不需要考证了，不过遇到有意思的演讲、文章还是记录一下自己不熟的词汇之类的，以防水平退步。</p><span id="more"></span><p>adrift adj. 漂流的，随波逐流的；松动的；<br>The survivors were adrift in a lifeboat for six days. 幸存者在救生艇上漂流了六天。<br>young people adrift in the big city 在大城市漂泊的年轻人</p><p>conceivable adj. 可想象的；可信的（possible）<br>It is conceivable that I’ll see her tomorrow. 我可能明天会见到她。</p><p>objective<br>n. 目标；目的<br>meet&#x2F;achieve your objectives 达到 ╱ 实现你的目标<br>adj. 客观的；(objectively adv.)</p><p>gnaw v.咬；啃；啮<br>She gnawed at her fingernails. 她咬手指甲。<br>Self-doubt began to gnaw away at her confidence. 对自己的怀疑渐渐吞噬了她的自信心。</p><p>resilient adj. 可迅速恢复的；有适应力的</p><p>renowned adj.~ (as&#x2F;for sth)有名的；闻名的；受尊敬的<br>It is renowned as one of the region’s best restaurants. 这是本地区最好的饭店之一。<br>She is renowned for her patience. 她的耐心是出了名的。</p><p>flounder<br>v.不知所措;艰苦挣扎<br>She was floundering around in the deep end of the swimming pool. 她在游泳池深水区挣扎着。<br>At that time the industry was floundering. 那时这个行业举步维艰。</p><p>transcendent adj. 卓越的；超常的；出类拔萃的<br>…the idea of a transcendent God who stood apart from mankind. …超越于人类之上的上帝的观点。</p><p>redeem v.补救，掩饰……之不足；挽回（声誉）;偿清；遵守（诺言）<br>The only redeeming feature of the job (&#x3D; good thing about it) is the salary. 这份工作唯一的可取之处就是它的工资。<br>redeem a loan&#x2F;mortgage 清偿贷款╱按揭贷款<br>redeem a pledge&#x2F;promise 遵守诺言</p><p>redemption n.拯救；救赎<br>BEYOND&#x2F;PAST REDEMPTION(too bad to be saved or improved) 无法挽救；不可救药</p><p>smug adj.沾沾自喜的；自鸣得意的</p><p>gist n. ~ (of sth)要点；主旨；大意<br>get (&#x3D; understand) the gist of an argument 理解辩论的主旨</p><p>banal adj.  平庸的；</p><p>cliché n.   陈词滥调；<br>She trotted out the old cliché that ‘a trouble shared is a trouble halved.’ 她又重复了“与人说愁愁减半”的陈词滥调。</p><p>malfunction n. 运转失常；失灵；出现故障</p>]]></content>
    
    
    <categories>
      
      <category>英语学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>词汇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node.js</title>
    <link href="/unkown404.github.io/2023/02/26/nodeJs/"/>
    <url>/unkown404.github.io/2023/02/26/nodeJs/</url>
    
    <content type="html"><![CDATA[<p>node 基础知识记录</p><span id="more"></span><h2 id="node-模块机制"><a href="#node-模块机制" class="headerlink" title="node 模块机制"></a>node 模块机制</h2><h3 id="require-的模块加载机制"><a href="#require-的模块加载机制" class="headerlink" title="require 的模块加载机制"></a>require 的模块加载机制</h3><ol><li>先计算模块路径</li><li>如果模块在缓存里面，取出缓存</li><li>加载模块</li><li>输出模块的 exports 属性即可</li></ol><h3 id="module-exports-vs-exports"><a href="#module-exports-vs-exports" class="headerlink" title="module.exports vs exports"></a>module.exports vs exports</h3><ul><li>exports 其实就是 module.exports，引用相同（module.exports 默认提供了空对象）</li><li>module.exports 可以直接赋值，exports 不可以，只能以增加健值的方式（模块加载时返回的是 module.exports 的内容）</li><li>如果要输出一个函数或数组，必须直接对 module.exports 对象赋值</li></ul><h3 id="npm-run-XXX-的流程"><a href="#npm-run-XXX-的流程" class="headerlink" title="npm run XXX 的流程"></a>npm run XXX 的流程</h3><ul><li>运行 npm run xxx 的时候，npm 会先在当前目录的 node_modules&#x2F;.bin 查找要执行的程序，如果找到则运行；</li><li>没有找到则从全局的 node_modules&#x2F;.bin 中查找，npm i -g xxx 就是安装到到全局目录；</li><li>如果全局目录还是没找到，那么就从 path 环境变量中查找有没有其他同名的可执行程序。</li></ul><h2 id="node-进程和线程"><a href="#node-进程和线程" class="headerlink" title="node 进程和线程"></a>node 进程和线程</h2><h3 id="进程和线程辨析"><a href="#进程和线程辨析" class="headerlink" title="进程和线程辨析"></a>进程和线程辨析</h3><p>进程：资源分配的最小单位，进程是线程的容器。<br>线程：操作系统能够进行运算调度的最小单位。线程是隶属于进程的，被包含于进程之中。一个线程只能隶属于一个进程，但是一个进程是可以拥有多个线程的。</p><h3 id="node-多进程架构"><a href="#node-多进程架构" class="headerlink" title="node 多进程架构"></a>node 多进程架构</h3><p>使用 child_process 开启多个进程实现多进程单线程模式，使 CPU 的利用率提升。子进程独立于父进程</p><h3 id="创建子进程方法"><a href="#创建子进程方法" class="headerlink" title="创建子进程方法"></a>创建子进程方法</h3><p>模块 child_process 具有以下方法：</p><ul><li>spawn()： 启动一个子进程来执行命令</li><li>exec(): 启动一个子进程来执行命令，与 spawn()不同的是其接口不同，它有一个回调函数获知子进程的状况</li><li>execFlie(): 启动一个子进程来执行可执行文件</li><li>fork(): 与 spawn()类似，不同在于它创建 Node 子进程需要执行 js 文件</li></ul><h2 id="express-vs-koa"><a href="#express-vs-koa" class="headerlink" title="express vs koa"></a>express vs koa</h2><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>Express 中间件实现是基于 Callback 回调函数同步的，它不会去等待异步（Promise）完成<br>Koa 的中间件机制中使用 Async&#x2F;Await（背后全是 Promise）以同步的方式来管理异步代码</p><h3 id="洋葱模型实现"><a href="#洋葱模型实现" class="headerlink" title="洋葱模型实现"></a>洋葱模型实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 中间件组合函数，可以参考 https://github.com/koajs/compose/blob/master/index.js</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> Array </span>&#125; middlewares </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span>(<span class="hljs-params">ctx, middlewares</span>) &#123;<br>  <span class="hljs-comment">// &#123;1&#125;</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(middlewares)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Middlewares stack must be an array!&#x27;</span>)<br>  <br>  <span class="hljs-comment">// &#123;2&#125;</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> fn <span class="hljs-keyword">of</span> middlewares) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Middleware must be composed of functions!&#x27;</span>)<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> len = middlewares.<span class="hljs-property">length</span>; <span class="hljs-comment">// &#123;3&#125; 获取数组长度</span><br>    <span class="hljs-keyword">const</span> dispatch = <span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) &#123; <span class="hljs-comment">// &#123;4&#125; 这里是我们实现的关键</span><br>      <span class="hljs-keyword">if</span> (len === i) &#123; <span class="hljs-comment">// &#123;5&#125; 中间件执行完毕</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">const</span> fn = middlewares[i]; <span class="hljs-comment">// &#123;6&#125;</span><br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// &#123;7&#125; 这里一定要 bind 下，不要立即执行</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">fn</span>(ctx, dispatch.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, (i + <span class="hljs-number">1</span>))));<br>        &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>          <span class="hljs-comment">// &#123;8&#125; 返回错误</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(err);<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> fn = <span class="hljs-title function_">compose</span>(ctx, middlewares);<br><br><span class="hljs-title function_">fn</span>();<br><br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>(1)<a href="https://juejin.cn/post/6844903951742025736">NodeJS 有难度的面试题，你能答对几个？</a><br>(2)<a href="https://juejin.cn/post/6844904071501971469">挑战一轮大厂后的面试总结 (含六个方向) - nodejs 篇</a><br>(3)<a href="https://juejin.cn/post/7078924628525056007">三面面试官：运行 npm run xxx 的时候发生了什么？</a><br>(4)<a href="https://juejin.cn/post/6844904099767386126">多维度分析 Express、Koa 之间的区别</a></p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack</title>
    <link href="/unkown404.github.io/2023/02/19/webpack/"/>
    <url>/unkown404.github.io/2023/02/19/webpack/</url>
    
    <content type="html"><![CDATA[<p>前端 webpack 打包工具方面知识整理。</p><span id="more"></span><h2 id="webpack-基本概念"><a href="#webpack-基本概念" class="headerlink" title="webpack 基本概念"></a>webpack 基本概念</h2><h3 id="webpack-作用"><a href="#webpack-作用" class="headerlink" title="webpack 作用"></a>webpack 作用</h3><p>静态模块打包工具。主要作用：</p><ul><li>模块打包。可以将不同模块的文件打包整合在一起，并且保证它们之间的引用正确，执行有序。</li><li>编译兼容。通过 webpack 的 Loader 机制，编译转换诸如.less，.vue，.jsx 这类在浏览器无法识别的格式文件</li><li>能力扩展。通过 webpack 的 Plugin 机制，我可以进一步实现诸如按需加载，代码压缩等一系列功能</li></ul><h3 id="webpack-构建流程"><a href="#webpack-构建流程" class="headerlink" title="webpack 构建流程"></a>webpack 构建流程</h3><p>初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler<br>编译：从 entry 出发，针对每个 Module 串行调用对应的 loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理<br>输出：将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中</p><h3 id="loader-和-plugin-区别"><a href="#loader-和-plugin-区别" class="headerlink" title="loader 和 plugin 区别"></a>loader 和 plugin 区别</h3><ul><li>功能方面：loader 是文件加载器，能够加载资源文件，并对这些文件进行一些处理；plugin 可以扩展 Webpack 的功能，监听在 Webpack 运行的生命周期中会广播出的许多事件并做处理，解决 loader 无法实现的其他事。</li><li>运行时机方面：loader 运行在打包文件之前；plugin 则是在整个编译周期都起作用。</li><li>配置书写方面：loader 在 module.rules 中配置，作为模块的解析规则，类型为数组，内部包含了 test(类型文件)、loader、options (参数)等属性需要配置。plugin 在 plugins 中单独配置，类型为数组，每一项是一个 plugin 的实例，参数都通过构造函数传入。</li></ul><h3 id="webpack-热更新原理"><a href="#webpack-热更新原理" class="headerlink" title="webpack 热更新原理"></a>webpack 热更新原理</h3><p>webpack-dev-server 与浏览器之间维护了一个 websocket，当本地资源发生变化时，webpack-dev-server 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 webpack-dev-server 发起 Ajax 请求来获取更改内容。后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由 HotModulePlugin 来完成</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/7196630860811075642">2023 前端面试系列– webpack &amp; Git 篇</a></p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode调试Node代码</title>
    <link href="/unkown404.github.io/2023/02/17/vscodeRunNode/"/>
    <url>/unkown404.github.io/2023/02/17/vscodeRunNode/</url>
    
    <content type="html"><![CDATA[<h2 id="实现操作"><a href="#实现操作" class="headerlink" title="实现操作"></a>实现操作</h2><ol><li>点击vscode左侧边栏的三角形状加🐛的符号，如果直接调试当前文件可以先打好断点、点击按钮Run and Debug；如果需要自定义然后点击create a launch.json file</li><li>编辑launch.json<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123;<br>    <span class="hljs-regexp">//</span> 使用 IntelliSense 了解相关属性。 <br>    <span class="hljs-regexp">//</span> 悬停以查看现有属性的描述。<br>    <span class="hljs-regexp">//</span> 欲了解更多信息，请访问: https:<span class="hljs-regexp">//g</span>o.microsoft.com<span class="hljs-regexp">/fwlink/</span>?linkid=<span class="hljs-number">830387</span><br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.2.0&quot;</span>,<br>    <span class="hljs-string">&quot;configurations&quot;</span>: [<br>        &#123;<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;node&quot;</span>,<br>            <span class="hljs-string">&quot;request&quot;</span>: <span class="hljs-string">&quot;launch&quot;</span>,<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;启动程序&quot;</span>,<br>            <span class="hljs-string">&quot;skipFiles&quot;</span>: [<br>                <span class="hljs-string">&quot;&lt;node_internals&gt;/**&quot;</span><br>            ],<br>            <span class="hljs-string">&quot;program&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ul><li>执行单一文件时：修改program的内容，改为要运行的可执行文件或源代码的路径</li><li>调试服务器时：将配置文件修改为如下内容：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;attach&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Attach NestJS WS&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9229</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;restart&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;stopOnEntry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;protocol&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;inspector&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure>request由launch改为了attach，目的是为了将Visual Studio Code的调试器绑定到一个已经处于运行状态的应用。这个配置文件的含义是告诉Visual Studio Code的调试进程，去连接127.0.0.1:9229上的应用调试进程去调试。</li></ul><ol start="3"><li>配置完后点击调试栏的运行，如果是调试服务器接口需要先执行debug指令运行起服务器，以eggjs为例是<code>egg-bin debug</code>；以nest为例是<code>nest start --debug --watch</code>。此时会启动127.0.0.1:9229的调试进程，如果事先打好断点，在postman上调试本地接口时会在对应接口的逻辑断点前停止运行。<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2>（1）<a href="https://juejin.cn/post/6981820158046109703">让你 nodejs 水平暴增的 debugger 技巧</a><br>（2）<a href="https://juejin.cn/post/6844903838864900110">如何用Visual Studio Code远程调试运行在服务器上的nodejs应用</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>工作技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试技巧</title>
    <link href="/unkown404.github.io/2023/02/15/interviewSkill/"/>
    <url>/unkown404.github.io/2023/02/15/interviewSkill/</url>
    
    <content type="html"><![CDATA[<ol><li>项目中你遇到的难解决的问题有哪些，最后怎么处理的这种问题<br>难解决的问题分为两种：1.业务问题，需求不清。这时需要拉上懂业务的同事理清需求，必要的时候需要调整设计。同时自主学习，增强对业务的了解。2.技术问题，可能是由于之前技术栈限制导致需求难以实现，或者说现有技术导致实现需求会有性能、可维护性问题，或者是自身储备或者周边资源不足(比如说没有现成的组件库)导致工期比预想长。可以通过最小限度实现需求、请教公司或同项目组的同事寻找合适的工具、交叉集成其他框架等方式解决，但最重要的是及早沟通。</li></ol>]]></content>
    
    
    <categories>
      
      <category>工作技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端使用shell指令</title>
    <link href="/unkown404.github.io/2023/01/16/shelljs/"/>
    <url>/unkown404.github.io/2023/01/16/shelljs/</url>
    
    <content type="html"><![CDATA[<h2 id="node-js-使用-shell-指令"><a href="#node-js-使用-shell-指令" class="headerlink" title="node.js 使用 shell 指令"></a>node.js 使用 shell 指令</h2><h3 id="child-process"><a href="#child-process" class="headerlink" title="child_process"></a>child_process</h3><p>node 提供的一个子进程 API</p><h4 id="常见指令"><a href="#常见指令" class="headerlink" title="常见指令"></a>常见指令</h4><h5 id="child-process-spawn-command-args-options"><a href="#child-process-spawn-command-args-options" class="headerlink" title="child_process.spawn(command[, args][, options])"></a>child_process.spawn(command[, args][, options])</h5><p>创建一个新进程来执行指令。指令执行的参数为该函数传入的第二个参数。child_process.spawn 返回 stdout 和 stderr 流对象。 程序可以通过 stdout 的 data、end 或者其他事件来获取子进程返回的数据。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> &#123; spawn &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>);<br><span class="hljs-keyword">const</span> ls = <span class="hljs-title function_">spawn</span>(<span class="hljs-string">&#x27;ls&#x27;</span>, [<span class="hljs-string">&#x27;-lh&#x27;</span>, <span class="hljs-string">&#x27;/usr&#x27;</span>]);<br><br>ls.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`stdout: <span class="hljs-subst">$&#123;data&#125;</span>`</span>);<br>&#125;);<br><br>ls.<span class="hljs-property">stderr</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`stderr: <span class="hljs-subst">$&#123;data&#125;</span>`</span>);<br>&#125;);<br><br>ls.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">code</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`child process exited with code <span class="hljs-subst">$&#123;code&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="child-process-exec-command-options-callback"><a href="#child-process-exec-command-options-callback" class="headerlink" title="child_process.exec(command[, options][, callback])"></a>child_process.exec(command[, options][, callback])</h5><p>创建一个 shell 执行指令。存在数据大小限制。 当子进程返回的数据超过默认大小时，程序就会产生”Error: maxBuffer exceeded”异常。</p><h5 id="child-process-execFile-file-args-options-callback"><a href="#child-process-execFile-file-args-options-callback" class="headerlink" title="child_process.execFile(file[, args][, options][, callback])"></a>child_process.execFile(file[, args][, options][, callback])</h5><p>同 exec 类似，但使用的是制定的文件创建进程执行。需要单独写.sh 文件，可编写复杂逻辑，但在 windows 上使用时会有兼容问题</p><h3 id="shelljs"><a href="#shelljs" class="headerlink" title="shelljs"></a>shelljs</h3><p>基于 nodeAPI 的一个扩展，要引入插件。相比原生的 child_process 的兼容性更好，使用更灵活。<br><strong>安装指令</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span>--save-dev <span class="hljs-keyword">shelljs</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">or</span><br><span class="hljs-keyword"></span>yarn <span class="hljs-keyword">add </span><span class="hljs-keyword">shelljs </span>-D<br></code></pre></td></tr></table></figure><p><strong>使用方法</strong></p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-comment">// 局部模式</span><br><span class="hljs-variable">var</span> <span class="hljs-variable">shell</span> = <span class="hljs-function"><span class="hljs-title">require</span>(<span class="hljs-string">&#x27;shelljs&#x27;</span>);</span><br><span class="hljs-function"><span class="hljs-variable">shell.exec</span>(<span class="hljs-string">&#x27;git add .&#x27;</span>);</span><br><span class="hljs-function"><span class="hljs-variable">shell.exec</span>(<span class="hljs-string">&quot;git commit -m &#x27;auto-commit&#x27;&quot;</span>)</span><br><span class="hljs-variable">shell.exec</span>(<span class="hljs-string">&#x27;git push&#x27;</span>)<br><br><span class="hljs-comment">// 全局模式下，就不需要用shell开头了。</span><br><span class="hljs-function"><span class="hljs-title">require</span>(<span class="hljs-string">&#x27;shelljs/global&#x27;</span>);</span><br><span class="hljs-function"><span class="hljs-title">exec</span>(<span class="hljs-string">&#x27;git add .&#x27;</span>);</span><br><span class="hljs-function"><span class="hljs-title">exec</span>(<span class="hljs-string">&quot;git commit -m &#x27;auto-commit&#x27;&quot;</span>)</span><br><span class="hljs-function"><span class="hljs-title">exec</span>(<span class="hljs-string">&#x27;git push&#x27;</span>)</span><br></code></pre></td></tr></table></figure><h2 id="shell-常用指令"><a href="#shell-常用指令" class="headerlink" title="shell 常用指令"></a>shell 常用指令</h2><h3 id="pwd-显示当前目录名称"><a href="#pwd-显示当前目录名称" class="headerlink" title="pwd - 显示当前目录名称"></a>pwd - 显示当前目录名称</h3><h3 id="ls-显示目录信息"><a href="#ls-显示目录信息" class="headerlink" title="ls - 显示目录信息"></a>ls - 显示目录信息</h3><p><strong>使用参数</strong></p><p>-a :显示包括隐藏文件和目录在内的所有目录和文件</p><p>-l :显示文件的详细信息</p><p>-h :配合-l 以人性化的方式显示文件大小</p><p>-t :按文件最后修改时间排序文件</p><h3 id="cd-目录切换"><a href="#cd-目录切换" class="headerlink" title="cd - 目录切换"></a>cd - 目录切换</h3><p><strong>使用示例</strong></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span> 返回根目录<br><span class="hljs-keyword">cd</span><br><span class="hljs-string">//</span> 返回上一级目录<br><span class="hljs-keyword">cd</span> <span class="hljs-string">..</span><br><span class="hljs-string">//</span> 前往当前文件夹下的某目录<br><span class="hljs-keyword">cd</span> &lt;directory&gt;<br></code></pre></td></tr></table></figure><h3 id="rm-删除文件"><a href="#rm-删除文件" class="headerlink" title="rm - 删除文件"></a>rm - 删除文件</h3><p><strong>使用参数</strong></p><p>-f :强制删除文件</p><p>-r :递归删除目录及内容</p><h3 id="cp-复制文件"><a href="#cp-复制文件" class="headerlink" title="cp - 复制文件"></a>cp - 复制文件</h3><p><strong>指令格式</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cp</span> [<span class="hljs-keyword">options</span>] <span class="hljs-symbol">&lt;source&gt;</span> <span class="hljs-symbol">&lt;dest&gt;</span><br></code></pre></td></tr></table></figure><p><strong>使用参数</strong><br>-a :复制时保留链接、文件属性</p><p>-f :覆盖已经存在的目标文件而不给出提示</p><p>-r :若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件</p><h3 id="echo-显示指定文本"><a href="#echo-显示指定文本" class="headerlink" title="echo - 显示指定文本"></a>echo - 显示指定文本</h3><p><strong>使用示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 显示普通字符串</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello world&quot;</span><br><br><span class="hljs-comment"># 显示转义字符</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\&quot;hello world\&quot;&quot;</span> <span class="hljs-comment"># 此时结果显示为&quot;hello world&quot;</span><br><br><span class="hljs-comment"># 显示变量</span><br>content=<span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;He said <span class="hljs-variable">$&#123;content&#125;</span>&quot;</span><br><br><span class="hljs-comment"># 显示换行</span><br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;hello \n&quot;</span> <span class="hljs-comment"># -e开启转义，即\n可以换行</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;world&quot;</span><br><br><span class="hljs-comment"># 显示结果定向至文件</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello world &gt; test&quot;</span><br></code></pre></td></tr></table></figure><h3 id="chmod-控制用户对文件的权限"><a href="#chmod-控制用户对文件的权限" class="headerlink" title="chmod - 控制用户对文件的权限"></a>chmod - 控制用户对文件的权限</h3><p><strong>指令格式</strong></p><ol><li>参数法</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">chmod <span class="hljs-selector-attr">[user]</span><span class="hljs-selector-attr">[operator]</span><span class="hljs-selector-attr">[permission]</span> &lt;filename&gt;<br></code></pre></td></tr></table></figure><p><strong>使用参数</strong><br><strong>user</strong>：限定权限调整的用户范围</p><ul><li>u：user 表示该文件的所有者</li><li>g：group 表示与该文件的所有者属于同一组( group )者，即用户组</li><li>o：other 表示其它用户组</li><li>a：all 表示这三者皆是</li></ul><p><strong>operator</strong>：权限调整内容</p><ul><li>+：增加权限</li><li>-：撤销权限</li><li>&#x3D;：设定权限</li></ul><p><strong>permission</strong>：权限内容</p><ul><li>r：read，表示可读取，对于一个目录，如果没有 r 权限，那么就意味着不能通过 ls 查看这个目录的内容。</li><li>w：write，表示可写入，对于一个目录，如果没有 w 权限，那么就意味着不能在目录下创建新的文件。</li><li>x：excute，表示可执行，对于一个目录，如果没有 x 权限，那么就意味着不能通过 cd 进入这个目录。</li></ul><ol start="2"><li>数字法</li></ol><p>chmod 命令可以使用八进制数来指定权限。文件或目录的权限位是由 9 个权限位来控制，每三位为一组，它们分别是文件所有者（User）的读、写、执行，用户组（Group）的读、写、执行以及其它用户（Other）的读、写、执行。一组权限位中已设置时置为 1，不设置时置为 0。<br>以权限 rwx 为例，其对应的二进制表示为 111，即 4+2+1，也就是 7.<br><strong>使用示例</strong></p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi"># 表示所有的用户都有读写执行文件<span class="hljs-keyword">file</span>的权利，等同于chmod a=wrx <span class="hljs-keyword">file</span><br>chmod <span class="hljs-number">777</span> <span class="hljs-keyword">file</span><br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://nodejs.org/dist/latest-v12.x/docs/api/child_process.html">Nodejs 文档</a><br>（2）<a href="https://juejin.cn/post/6921734567342637070">如何在 nodejs 执行 shell 指令</a><br>（3）<a href="https://juejin.cn/post/7161392772665540644">package.json 配置完全解读</a></p>]]></content>
    
    
    <categories>
      
      <category>工作技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node.js</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hash路由使用锚点解决方案</title>
    <link href="/unkown404.github.io/2022/12/16/hashAnchor/"/>
    <url>/unkown404.github.io/2022/12/16/hashAnchor/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>页面的锚点功能需要 url 的 hash 值与页面的 DOM id 相一致才能进行跳转；而路由在 hash 模式下已经将#占用, 页面的锚点功能失效</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="场景-1-原生锚点"><a href="#场景-1-原生锚点" class="headerlink" title="场景 1:原生锚点"></a>场景 1:原生锚点</h3><p>需要手动获取锚点元素，再使用scrollIntoView方法</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs JSX"><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">CustomLink</span>=(<span class="hljs-params">props:&#123;id:string, children:any&#125;</span>)=&gt; &#123;<br>  <span class="hljs-keyword">const</span> &#123;id,children&#125;=props<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClick</span> = (<span class="hljs-params">e:any</span>) =&gt; &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>();<br>    <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(id);<br>    <span class="hljs-comment">// scrollIntoView()将目标元素移动到浏览器顶部</span><br>    <span class="hljs-comment">// scrollIntoView(false)将目标元素移动到浏览器底部</span><br>    element?.<span class="hljs-title function_">scrollIntoView</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span>&#123;children&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> &gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;anchor&#x27;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">CustomLink</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;test1&#x27;</span>&gt;</span>test1<span class="hljs-tag">&lt;/<span class="hljs-name">CustomLink</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">CustomLink</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;test2&#x27;</span>&gt;</span>test2<span class="hljs-tag">&lt;/<span class="hljs-name">CustomLink</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">height:</span> &#x27;<span class="hljs-attr">600vh</span>&#x27;, <span class="hljs-attr">padding:</span> <span class="hljs-attr">8</span> &#125;&#125;&gt;</span>Scroll to bottom<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;test1&#x27;</span>&gt;</span>test1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Scroll to bottom<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">height:</span> &#x27;<span class="hljs-attr">600vh</span>&#x27;, <span class="hljs-attr">padding:</span> <span class="hljs-attr">8</span> &#125;&#125;&gt;</span>Scroll to bottom<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Scroll to bottom<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">height:</span> &#x27;<span class="hljs-attr">600vh</span>&#x27;, <span class="hljs-attr">padding:</span> <span class="hljs-attr">8</span> &#125;&#125; <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;test2&#x27;</span>&gt;</span>test2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Scroll to bottom<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="场景-2-antd-的-anchor-组件"><a href="#场景-2-antd-的-anchor-组件" class="headerlink" title="场景 2:antd 的 anchor 组件"></a>场景 2:antd 的 anchor 组件</h3><p>anchor 组件在点击锚点后会修改 URL，而单页应用中如果使用哈希模式的路由，当 URL 被修改后，刷新页面会导致当前路由没有定义而出现 404 的情况。<br>对于这一情况的解决方案就是利用组件的 onClick 事件阻止默认的 url 修改</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JSX"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Anchor</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;antd&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; useHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;umi&#x27;</span>;<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Link</span> &#125; = <span class="hljs-title class_">Anchor</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> history = <span class="hljs-title function_">useHistory</span>();<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Anchor</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;(event:</span> <span class="hljs-attr">Event</span>, <span class="hljs-attr">link:</span> &#123; <span class="hljs-attr">href:</span> <span class="hljs-attr">string</span>; <span class="hljs-attr">title</span>?<span class="hljs-attr">:</span> <span class="hljs-attr">string</span> &#125;) =&gt;</span> &#123;</span><br><span class="language-xml">        event.preventDefault();</span><br><span class="language-xml">        history.push(`$&#123;history.location.pathname&#125;$&#123;link.href&#125;`);</span><br><span class="language-xml">      &#125;&#125;</span><br><span class="language-xml">    &gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#何时使用&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;何时使用&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#代码演示&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;代码演示&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#api&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;API&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#anchor-props&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Anchor Props&quot;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#link-props&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Link Props&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#faq&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;FAQ&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Anchor</span>&gt;</span></span><br>  );<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>经过实际测试发现，调用 event.preventDefault()之后，只会阻止 URL 被修改，并不会阻止点击锚点后的滚动事件。所以不需要像原生场景一样使用 scrollView 函数。但为了url和锚点相对应，增加了history.push函数来实现。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://blog.csdn.net/weixin_43487782/article/details/108873639">antd的anchor组件点击锚点导致路由发生变化</a><br>（2）<a href="https://blog.csdn.net/Whoopsina/article/details/123804087">项目中使用了Hash路由时如何同时使用锚点？</a></p>]]></content>
    
    
    <categories>
      
      <category>踩坑经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端路由</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码样式调整</title>
    <link href="/unkown404.github.io/2022/12/15/codeFormat/"/>
    <url>/unkown404.github.io/2022/12/15/codeFormat/</url>
    
    <content type="html"><![CDATA[<p>为了使代码风格统一，更有利于阅读，可以借助一些工具进行优化。</p><span id="more"></span><h2 id="prettier"><a href="#prettier" class="headerlink" title="prettier"></a>prettier</h2><p>代码格式化工具。</p><h3 id="安装指令"><a href="#安装指令" class="headerlink" title="安装指令"></a>安装指令</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span>--save-dev prettier<br><span class="hljs-keyword">or</span><br><span class="hljs-keyword"></span>yarn <span class="hljs-keyword">add </span>prettier -D<br></code></pre></td></tr></table></figure><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><p>在根目录新建 .prettierrc.json，配置自己所需要的参数：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123;<br>  <span class="hljs-string">&quot;singleQuote&quot;</span>: true,  <span class="hljs-regexp">//</span> 使用单引号<br>  <span class="hljs-string">&quot;semi&quot;</span>: false,  <span class="hljs-regexp">//</span> 不使用分号<br>  <span class="hljs-string">&quot;bracketSpacing&quot;</span>: true,  <span class="hljs-regexp">//</span> 在对象,数组括号与文字之间加空格<br>  <span class="hljs-string">&quot;htmlWhitespaceSensitivity&quot;</span>: <span class="hljs-string">&quot;ignore&quot;</span>,  <span class="hljs-regexp">//</span> 对html的空格不敏感<br>  <span class="hljs-string">&quot;endOfLine&quot;</span>: <span class="hljs-string">&quot;auto&quot;</span>,  <span class="hljs-regexp">//</span> 行结尾统一样式，保持现有的行尾<br>  <span class="hljs-string">&quot;trailingComma&quot;</span>: <span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-regexp">//</span> 对象，数组等末尾不加逗号<br>  <span class="hljs-string">&quot;tabWidth&quot;</span>: <span class="hljs-number">2</span> <span class="hljs-regexp">//</span>  水平缩进的空格数为<span class="hljs-number">2</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="lint-staged"><a href="#lint-staged" class="headerlink" title="lint-staged"></a>lint-staged</h2><p>本地暂存代码检查工具。只检测 git add . 中暂存区的文件，对过滤出的文件执行脚本。</p><h3 id="安装指令-1"><a href="#安装指令-1" class="headerlink" title="安装指令"></a>安装指令</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span>lint-staged --save-dev<br><span class="hljs-keyword">or</span><br><span class="hljs-keyword"></span>yarn <span class="hljs-keyword">add </span>lint-staged -D<br></code></pre></td></tr></table></figure><h3 id="配置方式-1"><a href="#配置方式-1" class="headerlink" title="配置方式"></a>配置方式</h3><p>lint-staged 从 v3.1 开始可以使用不同的方式进行配置：</p><ul><li>package.json<br>示例：</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;lint-staged&quot;</span>: &#123;<br>    <span class="hljs-regexp">//</span> 匹配暂存区所有的js，vue文件，并执行命令<br>  <span class="hljs-string">&quot;*.&#123;js,vue,jsx,tsx&#125;&quot;</span>: [<br>    <span class="hljs-string">&quot;prettier --write&quot;</span>,<br>    <span class="hljs-string">&quot;eslint --cache --fix&quot;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>配置对象的 key 值为匹配的文件，右侧 value 对应执行指令。lint-staged 指令自动在最后包含了 git add 的操作，所以可以不用专门去写</p><ul><li>.lintstagedrc JSON 或 YML 格式的文件</li><li>lint-staged.config.js 格式的文件</li></ul><h2 id="husky"><a href="#husky" class="headerlink" title="husky"></a>husky</h2><p>Git hooks 工具，对 git 执行的一些命令，通过对应的 hooks 钩子触发，执行自定义的脚本程序。<br>常用的 gitHooks 包括：</p><ul><li>pre-commit：每次 commit 之前会执行的操作，常用于触发时进行代码格式验证</li><li>commit-msg：启动提交信息编辑器，常用于对 commit 消息和用户进行校验</li><li>pre-push：远程推代码前执行，常用于推代码前做单元测试和 e2e</li></ul><h3 id="安装指令-2"><a href="#安装指令-2" class="headerlink" title="安装指令"></a>安装指令</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">npm</span> install husky@<span class="hljs-number">4</span>.<span class="hljs-number">3</span> --save-dev<br><span class="hljs-attribute">or</span><br><span class="hljs-attribute">yarn</span> add husky@<span class="hljs-number">4</span>.<span class="hljs-number">3</span> -D<br></code></pre></td></tr></table></figure><h3 id="配置方式-2"><a href="#配置方式-2" class="headerlink" title="配置方式"></a>配置方式</h3><p>husky 版本在 6 以下时可以直接在 package.json 配置，例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;husky&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;hooks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;pre-commit&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;lint-staged&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>6 版本以上的 husky 把的配置提取到了根目录，package.json 中的配置在 husky 升级后无效了。需要执行指令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">npx husky <span class="hljs-keyword">add</span><span class="language-bash"> .husky/pre-commit <span class="hljs-string">&quot;npx lint-staged&quot;</span></span><br></code></pre></td></tr></table></figure><p>指令执行后会在根目录创建 .husky 文件夹，文件夹内部有一个 pre-commit 文件，包含指令 npx lint-staged</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://www.npmjs.com/package/lint-staged#Configuration">lint-staged 官方文档</a><br>（2）<a href="https://www.prettier.cn/docs/index.html">prettier 官方文档</a><br>（3）<a href="https://juejin.cn/post/6947200436101185566">GitHook 工具 —— husky（格式化代码）</a></p>]]></content>
    
    
    <categories>
      
      <category>工作技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>package.json分析</title>
    <link href="/unkown404.github.io/2022/12/15/packageJson/"/>
    <url>/unkown404.github.io/2022/12/15/packageJson/</url>
    
    <content type="html"><![CDATA[<p>虽然管理维护前端项目时经常需要跟该文件打交道，但在安装代码规范相关工具时，发现自己对其中的配置并不十分了解，所以想记录一下。</p><span id="more"></span><h2 id="文件配置"><a href="#文件配置" class="headerlink" title="文件配置"></a>文件配置</h2><p>描述配置在这里略过不计，除非自己要写包，不然感觉记忆没什么用</p><h3 id="workspaces"><a href="#workspaces" class="headerlink" title="workspaces"></a>workspaces</h3><p>workspaces 主要用于 monorepo 仓库管理模式、解决如何在一个顶层 root package 下管理多个子 packages 的问题，在 workspaces 声明目录下的 package 会软链到最上层 root package 的 node_modules 中，不用手动执行 npm link 操作。</p><p>通常子项目都会平铺管理在 packages 目录下，所以根目录下 workspaces 通常配置为：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-string">&quot;workspaces&quot;</span>: [<br>  <span class="hljs-string">&quot;packages/*&quot;</span><br>]<br></code></pre></td></tr></table></figure><h2 id="脚本配置"><a href="#脚本配置" class="headerlink" title="脚本配置"></a>脚本配置</h2><h3 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h3><p>指定项目的一些内置脚本命令，这些命令可以通过 npm run 来执行。npm run 的时候，就会自动创建一个 shell 脚本，将本地目录的 node_modules&#x2F;.bin 子目录加入 PATH 变量。这意味着，当前目录的 node_modules&#x2F;.bin 子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>  <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack&quot;</span>,<br>  <span class="hljs-string">&quot;prebuild&quot;</span>: <span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-regexp">//</span> build 执行之前的钩子<br>  <span class="hljs-string">&quot;postbuild&quot;</span>: <span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-regexp">//</span> build 执行之后的钩子<br>&#125;<br></code></pre></td></tr></table></figure><p>如果存在前缀指令<code>pre-*</code>、<code>post-*</code>的话，执行指令 npm run build 时会按照<code>prebuild - build - postbuild</code>执行顺序执行，这种语法现在并不推崇，需谨慎使用。</p><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>用于设置 scripts 里的脚本在运行时的参数。</p><h2 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h2><h3 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h3><p>运行依赖，也就是项目生产环境下需要用到的依赖。比如 react，vue，状态管理库以及组件库等。</p><p>使用 npm install xxx 或则 npm install xxx –save 时，会被自动插入到该字段中。</p><h3 id="devDependencies"><a href="#devDependencies" class="headerlink" title="devDependencies"></a>devDependencies</h3><p>开发依赖，项目开发环境需要用到而运行时不需要的依赖，用于辅助开发，通常包括项目工程化工具比如 webpack，vite，eslint 等。<br>使用 npm install xxx -D 或者 npm install xxx –save-dev 时，会被自动插入到该字段中。</p><h2 id="三方配置"><a href="#三方配置" class="headerlink" title="三方配置"></a>三方配置</h2><p>package.json 中也存在很多三方属性，比如 tsc 中使用的 types、构建工具中使用的 sideEffects,git 中使用的 husky，eslint 使用的 eslintIgnore。这里只列举部分属性。</p><h3 id="lint-staged"><a href="#lint-staged" class="headerlink" title="lint-staged"></a>lint-staged</h3><p>lint-staged 是一个在 Git 暂存文件上运行 linters 的工具，配置后每次修改一个文件即可给所有文件执行一次 lint 检查，通常配合 gitHooks 一起使用。</p><h3 id="browserslist"><a href="#browserslist" class="headerlink" title="browserslist"></a>browserslist</h3><p>browserslist 字段用来告知支持哪些浏览器及版本。也可以使用 .browserslistrc 单文件配置。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-string">&quot;browserslist&quot;</span>: [<br>  <span class="hljs-string">&quot;&gt; 1%&quot;</span>,<br>  <span class="hljs-string">&quot;last 2 versions&quot;</span><br>]<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/7099041402771734559">深入浅出 package.json</a><br>（2）<a href="https://juejin.cn/post/7023539063424548872">关于前端大管家 package.json，你知道多少？</a><br>（3）<a href="https://juejin.cn/post/7161392772665540644">package.json 配置完全解读</a></p>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端依赖包管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react中获取ref相关的函数总结</title>
    <link href="/unkown404.github.io/2022/12/09/reactRef/"/>
    <url>/unkown404.github.io/2022/12/09/reactRef/</url>
    
    <content type="html"><![CDATA[<p>虽然 react 中很少使用操作 DOM 的逻辑，但为了能够理解开源代码，还是整理记录了常用的几个相关函数。</p><span id="more"></span><h2 id="获取-react-元素"><a href="#获取-react-元素" class="headerlink" title="获取 react 元素"></a>获取 react 元素</h2><h3 id="createRef"><a href="#createRef" class="headerlink" title="createRef"></a>createRef</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>常用于 class 组件（函数组件也可以用）</li><li>可获取原生 DOM 和自定义 class 组件的引用</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">//父组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoFocusTextInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  constructor(props) &#123;<br>    <span class="hljs-keyword">super</span>(props);<br>    <span class="hljs-keyword">this</span>.textInput = <span class="hljs-type">React</span>.createRef();<br>  &#125;<br><br>  componentDidMount() &#123;<br>    <span class="hljs-keyword">this</span>.textInput.current.focusTextInput();<br>  &#125;<br><br>  render() &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;<span class="hljs-type">CustomTextInput</span> ref=&#123;<span class="hljs-keyword">this</span>.textInput&#125; /&gt;<br>    );<br>  &#125;<br>&#125;<br><span class="hljs-comment">//子组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomTextInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  constructor(props) &#123;<br>    <span class="hljs-keyword">super</span>(props);<br>    <span class="hljs-comment">// 创建一个 ref 来存储 textInput 的 DOM 元素</span><br>    <span class="hljs-keyword">this</span>.textInput = <span class="hljs-type">React</span>.createRef();<br>    <span class="hljs-keyword">this</span>.focusTextInput = <span class="hljs-keyword">this</span>.focusTextInput.bind(<span class="hljs-keyword">this</span>);<br>  &#125;<br><br>  focusTextInput() &#123;<br>    <span class="hljs-comment">// 直接使用原生 API 使 text 输入框获得焦点</span><br>    <span class="hljs-comment">// 注意：我们通过 &quot;current&quot; 来访问 DOM 节点</span><br>    <span class="hljs-keyword">this</span>.textInput.current.focus();<br>  &#125;<br><br>  render() &#123;<br>    <span class="hljs-comment">// 告诉 React 我们想把 &lt;input&gt; ref 关联到</span><br>    <span class="hljs-comment">// 构造器里创建的 `textInput` 上</span><br>    <span class="hljs-keyword">return</span> (<br>      &lt;div&gt;<br>        &lt;input<br>          <span class="hljs-class"><span class="hljs-keyword">type</span></span>=<span class="hljs-string">&quot;text&quot;</span><br>          ref=&#123;<span class="hljs-keyword">this</span>.textInput&#125; /&gt;<br>        &lt;input<br>          <span class="hljs-class"><span class="hljs-keyword">type</span></span>=<span class="hljs-string">&quot;button&quot;</span><br>          value=<span class="hljs-string">&quot;Focus the text input&quot;</span><br>          onClick=&#123;<span class="hljs-keyword">this</span>.focusTextInput&#125;<br>        /&gt;<br>      &lt;/div&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>createRef 每次渲染都会返回一个新的引用</li></ol><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const createRef = <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> &#123; current: <span class="hljs-literal">null</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol><li>只能用于函数组件</li><li>useRef 的引用存在于组件的整个生命周期</li></ol><h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">let obj = &#123; current: <span class="hljs-literal">null</span> &#125;<br><br>const useRef = <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> obj<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>createRef 与 useRef 区别</strong><br>虽然都是用于创建 ref 属性、访问 DOM 实例对象，但两者适用的组件语法略有差异：createRef 更适用于 class 组件，由于其并没有 Hooks 的效果，其内部的值会随着函数组件重复执行而不断被初始化，而在 class 组件中由于分离了生命周期，使初始化时机仅执行一次。</p></blockquote><p>以下面的代码为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; createRoot &#125; = <span class="hljs-title class_">ReactDOM</span>;<br><span class="hljs-keyword">const</span> &#123; useRef, useState, createRef &#125; = <span class="hljs-title class_">React</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>   <span class="hljs-keyword">const</span> [renderIndex,setRenderIndex] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> refFromUseRef = <span class="hljs-title function_">useRef</span>();<br>   <span class="hljs-keyword">const</span> refFromCreateRef = <span class="hljs-title function_">createRef</span>();<br><br><br>    <span class="hljs-keyword">if</span> (!refFromUseRef.<span class="hljs-property">current</span>)&#123;<br>       refFromUseRef.<span class="hljs-property">current</span>=renderIndex<br>   &#125;<br>    <span class="hljs-keyword">if</span> (!refFromCreateRef.<span class="hljs-property">current</span>) &#123;<br>        refFromCreateRef.<span class="hljs-property">current</span> = renderIndex<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>index &#123;renderIndex&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>refFromUseRef &#123;refFromUseRef.current&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>refFromCreateRef &#123;refFromCreateRef.current&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123; setRenderIndex(p=&gt;p+1)&#125;&#125;&gt;a<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ComponentDemo</span> = <span class="hljs-title class_">App</span>;<br><span class="hljs-title function_">createRoot</span>(mountNode).<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ComponentDemo</span> /&gt;</span></span>);<br><br></code></pre></td></tr></table></figure><p>在执行的过程中会发现即使组件重新渲染, 由于 refFromUseRef 的值一直存在(类似于 this ) , 无法重新赋值；而 refFromCreateRef 会随组件渲染不断改变引用值。</p><h2 id="父组件获取子组件内部的一个元素"><a href="#父组件获取子组件内部的一个元素" class="headerlink" title="父组件获取子组件内部的一个元素"></a>父组件获取子组件内部的一个元素</h2><h3 id="forwardRef"><a href="#forwardRef" class="headerlink" title="forwardRef"></a>forwardRef</h3><p>获取函数子组件内部元素的 ref 得用 forwardRef，因为 ref 不像 props 作为参数可以传递。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 父元素。可以直接获取 DOM button 的 ref：</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span>=(<span class="hljs-params"></span>)=&gt;&#123;<br>    <span class="hljs-keyword">const</span> ref = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>();<br>    <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">FancyButton</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span>&gt;</span>Click me!<span class="hljs-tag">&lt;/<span class="hljs-name">FancyButton</span>&gt;</span></span>)<br>&#125;<br><br><span class="hljs-comment">//子元素</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">FancyButton</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;FancyButton&quot;</span>&gt;</span></span><br><span class="language-xml">    &#123;props.children&#125;</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>));<br></code></pre></td></tr></table></figure><h2 id="父组件获取子组件内部多个元素-x2F-方法"><a href="#父组件获取子组件内部多个元素-x2F-方法" class="headerlink" title="父组件获取子组件内部多个元素&#x2F;方法"></a>父组件获取子组件内部多个元素&#x2F;方法</h2><h3 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h3><p>useImperativeHandle 需要和 forwardRef 结合使用。可以让你在使用 ref 时自定义暴露给父组件的实例值。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const FancyInput= React.forwardRef(props, ref) =&gt; &#123;<br>  const inputRef = useRef();<br>  useImperativeHandle(ref, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (&#123;<br>    focus: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      inputRef.current.focus();<br>    &#125;<br>  &#125;));<br>  <span class="hljs-keyword">return</span> &lt;input ref=&#123;inputRef&#125; ... /&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>本例中渲染<code> &lt;FancyInput ref=&#123;inputRef&#125; /&gt;</code> 的父组件可以调用 inputRef.current.focus()。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://blog.csdn.net/frontend_frank/article/details/104243286">什么是 useRef , useRef 与 createRef 区别, 以及在什么情况下使用 useRef</a><br>（2）<a href="https://juejin.cn/post/6844904079164964878">精读《useRef 与 createRef 的区别》</a><br>（3）<a href="https://juejin.cn/post/7146095092674068487">一文学会 useImperativeHandle</a></p>]]></content>
    
    
    <categories>
      
      <category>前端技术体系</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>页面置灰的实现方式</title>
    <link href="/unkown404.github.io/2022/12/02/cssUsage/"/>
    <url>/unkown404.github.io/2022/12/02/cssUsage/</url>
    
    <content type="html"><![CDATA[<p>记一次 css 踩坑经历</p><span id="more"></span><h2 id="业务需求描述"><a href="#业务需求描述" class="headerlink" title="业务需求描述"></a>业务需求描述</h2><p>涉及一些重要的悼念活动时，需要将网站主页面置为灰色，同时希望不要影响其他功能页面的颜色</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>可将页面的 CSS 样式设置为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css">.<span class="hljs-selector-attr">[classname]</span>  &#123;<br>    -webkit-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    -moz-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    -ms-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    -o-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    <span class="hljs-attribute">filter</span>: gray;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的点是如果页面组件有 fixed 定位，上述 css 写法可能会导致组件位置出现问题，根据 MDN 的文档，对 position 定位有下面一段描述：</p><blockquote><p><strong>fixed</strong><br>元素会被移出正常文档流，并不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform, perspective 或 filter 属性非 none 时，容器由视口改为该祖先。</p></blockquote><p><strong>解决方法：</strong><br>将 filter 的样式写在 html 上。<br><strong>注意点：</strong></p><ol><li>非 SPA 项目处理时书写方式最好是：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>  &#123;<br>    -webkit-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    -moz-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    -ms-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    -o-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    <span class="hljs-attribute">filter</span>: gray;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是因为尽管 html5.0 规范允许在<code>&lt;html&gt;</code>标签上添加 class 属性，但没有保证该 class 属性一定能生效。</p><ol start="2"><li>处理 SPA 页面时如果书写上述样式，会导致所有页面样式都会变灰。比较好的实现方式是利用页面的生命周期，为 html 节点手动添加样式。并在页面跳转时去除变灰样式。这里以 react 为例：</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">componentDidMount</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">if</span>(global.document)&#123;<br>      const html=document<span class="hljs-selector-class">.getElementsByTagName</span>(<span class="hljs-string">&#x27;html&#x27;</span>)<br>      <span class="hljs-built_in">if</span>(<span class="hljs-selector-tag">html</span><span class="hljs-selector-attr">[0]</span>)&#123;<br>        <span class="hljs-selector-tag">html</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.style</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;filter&#x27;</span> as any]</span>=<span class="hljs-string">&#x27;grayscale(100%)&#x27;</span><br>      &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">componentWillUnmount</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">if</span>(global.document)&#123;<br>        const html=document<span class="hljs-selector-class">.getElementsByTagName</span>(<span class="hljs-string">&#x27;html&#x27;</span>)<br>        <span class="hljs-built_in">if</span>(<span class="hljs-selector-tag">html</span><span class="hljs-selector-attr">[0]</span>)&#123;<br>            <span class="hljs-selector-tag">html</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.style</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;filter&#x27;</span>  as any]</span>=<span class="hljs-string">&#x27;none&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>使用 js 添加样式时，如果代码使用了 ts 语法，可能会报错：<code>Element implicitly has an &#39;any&#39; type because index expression is not of type &#39;number&#39;</code>，这是因为 CSSStyleDeclaration 它的 index 值设置为了 number 而不是 string，这个报错的根本原因，兼容浏览器的 css 属性<code>-webkit-*</code>、<code>-o-*</code>等已经不在 CSSStyleDeclaration 内部了。考虑到现在大部分浏览器都支持 css3 了，兼容性写法可以适时去掉</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position">MDN position</a><br>（2）<a href="https://stackoverflow.com/questions/53526178/element-implicitly-has-an-any-type-because-index-expression-is-not-of-type-nu">Element implicitly has an ‘any’ type because index expression is not of type ‘number’ [7015]</a></p>]]></content>
    
    
    <categories>
      
      <category>踩坑经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js实现从utf-8到base64编码</title>
    <link href="/unkown404.github.io/2022/11/29/encodeBase64/"/>
    <url>/unkown404.github.io/2022/11/29/encodeBase64/</url>
    
    <content type="html"><![CDATA[<p>编码知识小记</p><span id="more"></span><h2 id="编码相关概念的辨析"><a href="#编码相关概念的辨析" class="headerlink" title="编码相关概念的辨析"></a>编码相关概念的辨析</h2><h3 id="编码历史"><a href="#编码历史" class="headerlink" title="编码历史"></a>编码历史</h3><p>计算机起源之初，科学家对英语字符与二进制位之间的关系做了统一规定，定义了 128 个字符的编码规则，用七位二进制表示。这套编码规则被称为 ASCII 编码。随着计算机的普及，在不同的地区和国家，当地程序员为了适应本地的语言使用创建了新的字符编码。但不同国家间读取内容时由于编码方式的差异会导致内容乱码，对国际沟通交流造成了障碍。</p><p>这时候 Unicode 就出现了。 Unicode 是国际标准字符集，它将世界各种语言的每个字符定义一个唯一的编码，以满足跨语言、跨平台的文本信息转换。Unicode 字符集的编码范围是 0x0000 - 0x10FFFF , 可以容纳一百多万个字符， 每个字符都有一个独一无二的编码，也即每个字符都有一个二进制数值和它对应。</p><h3 id="Unicode、utf-8、utf-16-辨析"><a href="#Unicode、utf-8、utf-16-辨析" class="headerlink" title="Unicode、utf-8、utf-16 辨析"></a>Unicode、utf-8、utf-16 辨析</h3><p>Unicode 只是字符集，即很多个字符的集合；而 UTF-8、UTF-16、UTF-32 才是真正的字符编码规则：utf-8 是用一个字节来编码所有的字符，utf-16 是用两个字节来编码所有的字符，utf-32 则选择用 4 个字节来编码。<br>其中最常见的编码规则是 utf-8，因为互联网的大部分资源都是英文的，使用 utf-8 保存更节省空间。Unicode 转 utf-8 主要是变长编码，有具体表格展示不同 unicode 的编码规则，这里不再赘述。</p><h3 id="Base64-编码"><a href="#Base64-编码" class="headerlink" title="Base64 编码"></a>Base64 编码</h3><p>Base64 的编码方法要求把每三个 8bit 的字节转换成四个 6bit 的字节，然后把 6Bit 再添两位高位 0，组成四个 8Bit 的字节。经过 base64 编码后的字符串会比原来长 1&#x2F;3。</p><h2 id="前端页面表单数据转-base64"><a href="#前端页面表单数据转-base64" class="headerlink" title="前端页面表单数据转 base64"></a>前端页面表单数据转 base64</h2><p>需要注意的点是虽然 html 和 js 的编码是 utf-8，但 js 从页面得到的中文是 utf-16 编码，直接转 base64 是会出错的。<br>MDN 上给出了最简单的解决方法：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> utf8<span class="hljs-constructor">_to_b64(<span class="hljs-params">str</span>)</span> &#123;<br>  return window.btoa(unescape(encode<span class="hljs-constructor">URIComponent(<span class="hljs-params">str</span>)</span>));<br>&#125;<br><br><span class="hljs-keyword">function</span> b64<span class="hljs-constructor">_to_utf8(<span class="hljs-params">str</span>)</span> &#123;<br>  return decode<span class="hljs-constructor">URIComponent(<span class="hljs-params">escape</span>(<span class="hljs-params">window</span>.<span class="hljs-params">atob</span>(<span class="hljs-params">str</span>)</span>));<br>&#125;<br><br><span class="hljs-comment">// Usage:</span><br>utf8<span class="hljs-constructor">_to_b64(<span class="hljs-string">&quot;✓ à la mode&quot;</span>)</span>; <span class="hljs-comment">// &quot;4pyTIMOgIGxhIG1vZGU=&quot;</span><br>b64<span class="hljs-constructor">_to_utf8(<span class="hljs-string">&quot;4pyTIMOgIGxhIG1vZGU=&quot;</span>)</span>; <span class="hljs-comment">// &quot;✓ à la mode&quot;</span><br></code></pre></td></tr></table></figure><p>里面涉及的流程是：</p><ol><li>先用 encodeURIComponent 把 js 的字符串转成 UTF-8 的百分号编码形式。该方法不会对 ASCII 字母和数字及部分 ASCII 标点符号进行编码，非英文字符会先转为 UTF8 的字节码，然后前面加个%进行拼接；</li><li>再用 unescape 把百分号编码按字节转化成对应的含有 Latin-1 字符集字符的 js 字符串 （即使它是乱码）；</li><li>最后用 btoa 把只含有 Latin-1 的 js 字符串转换成 Base64 编码；根据 MDN 文档，btoa 可以将二进制字符串转为 base64 编码的 ASCII 字符串，在实际操作中发现如果直接对中文编码会抛出错误：‘The string to be encoded contains characters outside of the Latin1 range.’，可以推断 btoa 是可以处理 Latin-1 字符集字符的。</li></ol><p>关于这种编码方式，网上也看到有去掉 escape&#x2F;unescape 的版本，似乎同样能得到预期结果。但是这得到的编码并非 utf-8 转 base64 的结果，在只有 ASCII 码时 unescape 使用与否都能得到一样的答案，然而出现带百分号编码的字符串时省去 unescape 会使编码结果的长度增加了，因为 btoa 编码了百分号；且如果是将编码结果传给其他 API 时会很难理解其内容</p><h2 id="前端-node-js-转-base64"><a href="#前端-node-js-转-base64" class="headerlink" title="前端 node.js 转 base64"></a>前端 node.js 转 base64</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">//utf-8 转 base64</span><br>const txt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Buffer</span>(<span class="hljs-string">&#x27;文字&#x27;</span>).toString(<span class="hljs-string">&#x27;base64&#x27;</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(txt)<br><br><span class="hljs-comment">//base64 转 utf-8</span><br>const ztxt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Buffer</span>(txt, <span class="hljs-string">&#x27;base64&#x27;</span>).toString(<span class="hljs-string">&#x27;utf8&#x27;</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(ztxt)<br></code></pre></td></tr></table></figure><p>处理起来相对简单，可以直接用 buffer 模块的 api</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://zhuanlan.zhihu.com/p/427488961">Unicode、UTF-8、UTF-16 终于懂了</a><br>（2）<a href="https://developer.mozilla.org/en-US/docs/Glossary/Base64#Solution_2_%E2%80%93_escaping_the_string_before_encoding_it">Base64</a><br>（3）<a href="https://best33.com/311.moe">为什么 escape 可以使 btoa 正确处理 UTF-8 编码的字符串？</a><br>（4）<a href="https://stackoverflow.com/questions/30631927/converting-to-base64-in-javascript-without-deprecated-escape-call">Converting to Base64 in JavaScript without Deprecated ‘Escape’ call</a></p>]]></content>
    
    
    <categories>
      
      <category>工作技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>依赖失踪之谜 —— 记一次失败的问题查找</title>
    <link href="/unkown404.github.io/2022/11/29/nvmProblemSearch/"/>
    <url>/unkown404.github.io/2022/11/29/nvmProblemSearch/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>全局安装的依赖包突然找不到了，调用指令返回 <code>zsh: command not found:xxx</code> 的报错。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>对于上述报错问题，网上的回复基本统一是缺少环境变量配置。MAC 电脑的环境变量文件加载顺序为：</p><ul><li>&#x2F;etc&#x2F;profile，系统级文件，系统启动即加载</li><li>&#x2F;etc&#x2F;path，系统级文件，系统启动即加载</li><li>&#x2F;.bash_profile，用户级的环境变量配置文件，当该文件存在时忽略<del>&#x2F;.bash_login 、</del>&#x2F;.profile 、~&#x2F;.bashrc 文件的配置</li></ul><p>解决环境变量问题步骤：</p><ol><li>打开 zsh 控制台，输入指令：<code>open .zshrc</code></li><li>查看环境变量 PATH。PATH 的通常写法为</li></ol><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">export <span class="hljs-built_in">PATH</span> = &lt;<span class="hljs-built_in">path</span> <span class="hljs-number">1</span>&gt; : &lt;<span class="hljs-built_in">path</span> <span class="hljs-number">2</span>&gt; ... : &lt;<span class="hljs-built_in">path</span> n&gt; : $<span class="hljs-built_in">PATH</span><br></code></pre></td></tr></table></figure><p>涉及多个环境变量时用分号隔开。</p><p>当前电脑配置的 zshrc 内容为：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">NVM_DIR</span>=<span class="hljs-string">&quot;/Users/danhuipeng/.nvm&quot;</span><br>[ -s <span class="hljs-string">&quot;<span class="hljs-variable">$NVM_DIR</span>/nvm.sh&quot;</span> ] &amp;&amp; \. <span class="hljs-string">&quot;<span class="hljs-variable">$NVM_DIR</span>/nvm.sh&quot;</span>  # This loads nvm<br><br><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.yarn/bin:<span class="hljs-variable">$HOME</span>/.config/yarn/global/node_modules/.bin:<span class="hljs-variable">$PATH</span>&quot;</span><br><br>source ~/.bash_profile<br></code></pre></td></tr></table></figure><p>虽然有 yarn 的路径在环境变量中，但因为全局依赖包没有使用 yarn，所以现在的设置并不能解决问题。推测可能是因为当前的 path 内容并没有指向全局 npm 的依赖包目录下 。</p><ol start="3"><li>添加环境变量。使用指令<code>npm config get prefix</code>获取全局安装包时使用的 node，使用指令<code>npm root -g</code>来寻找全局仓库路径。得到的结果分别为：</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">～<span class="hljs-regexp">/.nvm/</span>versions<span class="hljs-regexp">/node/</span>v15.<span class="hljs-number">14.0</span><br>～<span class="hljs-regexp">/.nvm/</span>versions<span class="hljs-regexp">/node/</span>v15.<span class="hljs-number">14.0</span><span class="hljs-regexp">/lib/</span>node_modules<br></code></pre></td></tr></table></figure><p>根目录已省略。尝试将这两个变量添加到 path 后，执行指令发<code>source .zshrc</code>现并没有解决问题。为了明确为什么找不到依赖包执行了指令<code>cd ~/.nvm/versions/node/v15.14.0/lib/node_modules</code>到全局依赖目录下，尝试查看内容列表，然而执行指令<code>ls</code>后什么也没发生，即该目录下的内容已空！！为什么会空了呢？完全不知道原因，和其他版本的依赖目录比较发现连 npm 都没有了？？<br><img src="/unkown404.github.io/img/log.png"></p><p>问题排查到这里已经进行不下去了，只能进行依赖重装。</p><p>考虑到本人使用 node 15 的时候比较少，大多数项目使用的都是 14，所以采用指令<code>nvm alias default v14</code>调整 node 的默认版本。因为 node 15 现在连 npm 都没有了，所以使用<code>nvm uninstall v15</code>指令卸载 node15。使用指令<code>nvm ls</code>检查发现现在已经开始使用 node v14 了</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xl">       v10.<span class="hljs-number">24.1</span><br>       v12.<span class="hljs-number">16.3</span><br>       v12.<span class="hljs-number">22.1</span><br>-&gt;     v14.<span class="hljs-number">19.3</span><br><span class="hljs-function"><span class="hljs-title">default</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">v14</span> (-&gt;</span> v14.<span class="hljs-number">19.3</span>)<br><span class="hljs-function"><span class="hljs-title">iojs</span> -&gt;</span> N/A (default)<br><span class="hljs-function"><span class="hljs-title">unstable</span> -&gt;</span> N/A (default)<br><span class="hljs-function"><span class="hljs-title">node</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">stable</span> (-&gt;</span> v14.<span class="hljs-number">19.3</span>) (default)<br><span class="hljs-function"><span class="hljs-title">stable</span> -&gt;</span> <span class="hljs-number">14.19</span> (-&gt; v14.<span class="hljs-number">19.3</span>) (default)<br><span class="hljs-function"><span class="hljs-title">lts</span>/* -&gt;</span> <span class="hljs-function"><span class="hljs-title">lts</span>/hydrogen (-&gt;</span> N/A)<br><span class="hljs-function"><span class="hljs-title">lts</span>/argon -&gt;</span> <span class="hljs-function"><span class="hljs-title">v4</span>.9.1 (-&gt;</span> N/A)<br><span class="hljs-function"><span class="hljs-title">lts</span>/boron -&gt;</span> <span class="hljs-function"><span class="hljs-title">v6</span>.17.1 (-&gt;</span> N/A)<br><span class="hljs-function"><span class="hljs-title">lts</span>/carbon -&gt;</span> <span class="hljs-function"><span class="hljs-title">v8</span>.17.0 (-&gt;</span> N/A)<br><span class="hljs-function"><span class="hljs-title">lts</span>/dubnium -&gt;</span> v10.<span class="hljs-number">24.1</span><br><span class="hljs-function"><span class="hljs-title">lts</span>/erbium -&gt;</span> <span class="hljs-function"><span class="hljs-title">v12</span>.22.12 (-&gt;</span> N/A)<br><span class="hljs-function"><span class="hljs-title">lts</span>/fermium -&gt;</span> <span class="hljs-function"><span class="hljs-title">v14</span>.21.1 (-&gt;</span> N/A)<br><span class="hljs-function"><span class="hljs-title">lts</span>/gallium -&gt;</span> <span class="hljs-function"><span class="hljs-title">v16</span>.18.1 (-&gt;</span> N/A)<br><span class="hljs-function"><span class="hljs-title">lts</span>/hydrogen -&gt;</span> <span class="hljs-function"><span class="hljs-title">v18</span>.12.1 (-&gt;</span> N/A)<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>(1)<a href="https://wenku.baidu.com/view/2cb4a1ffae51f01dc281e53a580216fc700a53a9.html?_wkts_=1669702352151&bdQuery=zsh%E6%80%8E%E4%B9%88%E9%85%8D%E5%A4%9A%E4%B8%AA%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">Mac 在 bash 和 zsh 配置环境变量 path 的几种方法</a><br>(2)<a href="https://blog.csdn.net/Wildpiglolo/article/details/123828019">npm 全局安装后，对应的环境变量目录下找不到文件</a></p>]]></content>
    
    
    <categories>
      
      <category>踩坑经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>依赖安装</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小程序踩坑经历--canvas层级过高</title>
    <link href="/unkown404.github.io/2022/09/30/appletCanvas/"/>
    <url>/unkown404.github.io/2022/09/30/appletCanvas/</url>
    
    <content type="html"><![CDATA[<p>小程序开发弹窗功能时遇到的问题。</p><span id="more"></span><h2 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h2><p>需要在某一计算结果页设置收集信息弹窗，点击按钮时弹窗悬浮于页面正中；计算结果页包含绘制的饼图</p><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><p>canvas 属于原生组件，拥有最高层级，页面中其他组件无论设置 z-index 多少都无法覆盖在 canvas 上；且 canvas 标签不能使用<code>visibility:hidden</code>或 <code>opacity: 0;</code>去隐藏，放在父元素设置同样不可行</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>对于只需要展示文字或图片的简单弹窗，可以使用 cover-view 组件，该组件有小程序最高层级。<br>对于功能相对复杂的弹窗，则需要将 canvas 转为图片。<br>具体操作内容：</p><ol><li>模版部分：<br>新增替代 canvas 的图片模块，与 canvas 同级。这里为方便新增的模块和 canvas 同类名以便获取同样的样式大小设置。<br>新增变量 imgHide 和 chartImg，分别用于控制 canvas 到图片切换的过程和获取导出图片的临时路径。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Vue">&lt;template&gt;<br>    ...<br>    &lt;canvas<br>        :hidden=&quot;!imgHide&quot;<br>        class=&quot;chart-canvas&quot;<br>        canvas-id=&quot;ringCanvas&quot;<br>    &gt;&lt;/canvas&gt;<br>    &lt;view class=&quot;chart-canvas&quot; :hidden=&quot;imgHide&quot;&gt;<br>        &lt;img :src=&quot;chartImg&quot;/&gt;<br>    &lt;/view&gt;<br>    ...<br>    &lt;view @click=&quot;modalShow&quot;&gt;tap&lt;/view&gt;<br>    &lt;view class=&quot;modal&quot;&gt;<br>        ...<br>    &lt;/view&gt;<br>&lt;/template&gt;<br><br></code></pre></td></tr></table></figure><ol start="2"><li>JS 逻辑部分：<br>1）初始化 imgHide 和 chartImg，分别设为 false 和’’<br>2）增加新方法 canvasToImg，处理 canvas 导出图片的任务。这里 destWidth、destHeight 都设置为原宽高的 2 倍是因为 canvas 是位图，将它渲染到高清屏时,会被放大,每个像素点会用 devicePixelRatio 的平方个物理像素点来渲染,因此图片会变得模糊。使用 2 倍图可以解决问题。绘制成功时将文件路径赋值给 chartImg</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">canvasToImg</span>(<span class="hljs-params">width, height</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        wx.<span class="hljs-title function_">canvasToTempFilePath</span>(&#123;<br>            <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,<br>            <span class="hljs-attr">y</span>: <span class="hljs-number">0</span>,<br>            width,<br>            height,<br>            <span class="hljs-attr">destWidth</span>: width * <span class="hljs-number">2</span>,<br>            <span class="hljs-attr">destHeight</span>: height * <span class="hljs-number">2</span>,<br>            <span class="hljs-attr">canvasId</span>: <span class="hljs-string">&#x27;ringCanvas&#x27;</span>,<br>            <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>                <span class="hljs-keyword">const</span> filePath = res.<span class="hljs-property">tempFilePath</span><br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;tempFilePath&#x27;</span>, filePath)<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">chartImg</span> = filePath<br>            &#125;,<br>            <span class="hljs-attr">fail</span>: <span class="hljs-function"><span class="hljs-params">rej</span> =&gt;</span> &#123;<br>                <span class="hljs-keyword">throw</span> rej<br>            &#125;<br>        &#125;)<br>    &#125;, <span class="hljs-number">1000</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>选择 canvas 切 img 的时机。<br>如果在拿到导出图片路径时立即切图片，会导致页面的 chart 有一段不自然的闪烁看起来很奇怪；如果不考虑切换操作，直接在图片位置加 loading 图直到拿到导出图片路径，则体感加载时间会很长，因为 loading 时间包括了 canvas 绘制和图片导出，都是比较耗时的操作。<br>既然 canvas 换图片的操作是为了解决弹窗被遮挡的问题，那么可以将改变 imgHide 时机放置在点击按钮、弹出弹窗的方法中。<br>同时考虑到 canvas 导出图片的时间很长，如果在未完成该操作时弹窗就关闭的话用户就会看到空白的图片，所以需要在弹窗关闭的方法中增加是否需要切回 canvas 的判断。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">modalShow</span>(<span class="hljs-params"></span>) &#123;<br>    ...<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">imgHide</span> = <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-title function_">modalClose</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">chartImg</span> != <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">imgHide</span> = <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的点是如果 canvas 的面积大于弹窗的面积，那么当点击弹窗、canvas 尚未导出图片路径时，仍可以透过弹窗的 mask 看到没图的 img 元素的边框。<del>（这时最好不要做这个功能了）</del></p><ol start="4"><li>如果是需要反复绘制的场景，需要注意绘制前 canvas 是否仍然存在，否则 canvas 无法重新绘制，转成图片自然也不执行。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">onShow</span>(<span class="hljs-params"></span>) &#123;<br>    ...<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">imgHide</span> = <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://wenku.baidu.com/view/9d46b515ba0d6c85ec3a87c24028915f804d842d.html">微信小程序 canvas 层级过高，遮住弹窗解决方法</a></p>]]></content>
    
    
    <categories>
      
      <category>踩坑经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack配置踩坑经历</title>
    <link href="/unkown404.github.io/2022/09/20/webpackConfig/"/>
    <url>/unkown404.github.io/2022/09/20/webpackConfig/</url>
    
    <content type="html"><![CDATA[<h2 id="问题：webpack项目使用域名访问出现Invalid-Host-header，使用ip可访问"><a href="#问题：webpack项目使用域名访问出现Invalid-Host-header，使用ip可访问" class="headerlink" title="问题：webpack项目使用域名访问出现Invalid Host header，使用ip可访问"></a>问题：webpack项目使用域名访问出现Invalid Host header，使用ip可访问</h2><p><strong>原因</strong>：新版的webpack-dev-server出于安全考虑,默认检查hostname,如果hostname 不是配置内的,将中断访问。<br><strong>解决方法</strong>：找到server的配置文件，添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">devServer:</span> &#123;<br>  <span class="hljs-attr">disableHostCheck:</span> <span class="hljs-literal">true</span>,<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>踩坑经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue</title>
    <link href="/unkown404.github.io/2022/09/18/Vue/"/>
    <url>/unkown404.github.io/2022/09/18/Vue/</url>
    
    <content type="html"><![CDATA[<p>前端 vue 框架方面知识整理。</p><span id="more"></span><h2 id="Vue-相关基本概念"><a href="#Vue-相关基本概念" class="headerlink" title="Vue 相关基本概念"></a>Vue 相关基本概念</h2><h3 id="MVVM-和-MVC-的区别"><a href="#MVVM-和-MVC-的区别" class="headerlink" title="MVVM 和 MVC 的区别"></a>MVVM 和 MVC 的区别</h3><h4 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h4><ul><li>Model 代表数据模型，数据和业务逻辑都在 Model 层中定义；</li><li>View 代表 UI 视图，负责数据的展示；</li><li>ViewModel 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作；</li></ul><p>ViewModel 通过双向数据绑定连接 view 和 model，view 和 model 间的同步工作是自动的，无需手动操作 DOM</p><h4 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h4><ul><li>Model 代表数据模型，数据和业务逻辑都在 Model 层中定义，Model 发生的变化会通知到 View 层；</li><li>View 代表 UI 视图，负责数据的展示；</li><li>Controller 主要负责用户与应用的响应操作，用户与页面产生交互的时候，Controller 中的事件触发器会调用合适的 model 处理问题；</li></ul><h3 id="双向绑定-x2F-响应式原理"><a href="#双向绑定-x2F-响应式原理" class="headerlink" title="双向绑定&#x2F;响应式原理"></a>双向绑定&#x2F;响应式原理</h3><p>Object.defineProperty 劫持数据，添加 setter&#x2F;getter 属性监听数据变化情况，发消息给订阅者触发监听回调</p><ol><li>实现一个监听器 observer：遍历对象属性，添加 setter&#x2F;getter，数据改变时可通过 setter 听到变化</li><li>实现一个编译器 compiler：编译模版，将模版的变量替换为数据，指令节点绑定更新函数</li><li>实现一个订阅者 watcher：连接 observer 和 compiler 桥梁，订阅 observer 属性变化消息，接收变化时触发 compiler 更新函数</li><li>实现一个订阅器 dep：订阅发布管理模式，统一管理 watcher 和 observer</li></ol><h3 id="Vue-diff-算法"><a href="#Vue-diff-算法" class="headerlink" title="Vue diff 算法"></a>Vue diff 算法</h3><h4 id="vue-2-x-双端-diff"><a href="#vue-2-x-双端-diff" class="headerlink" title="vue 2.x - 双端 diff"></a>vue 2.x - 双端 diff</h4><p>双端 diff 算法是头尾指针向中间移动，分别判断头尾节点是否可以复用，如果没有找到可复用的节点再去遍历查找对应节点的下标，然后移动。全部处理完之后也要对剩下的节点进行批量的新增和删除。</p><h4 id="vue-3-最长递增子序列"><a href="#vue-3-最长递增子序列" class="headerlink" title="vue 3 - 最长递增子序列"></a>vue 3 - 最长递增子序列</h4><h3 id="Vue-属性"><a href="#Vue-属性" class="headerlink" title="Vue 属性"></a>Vue 属性</h3><h4 id="data-为什么是一个函数而不是对象"><a href="#data-为什么是一个函数而不是对象" class="headerlink" title="data 为什么是一个函数而不是对象"></a>data 为什么是一个函数而不是对象</h4><p>如果 data 是对象，当组件复用时，由于多个实例引用同一个对象，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。</p><h4 id="computed-和-watch-区别"><a href="#computed-和-watch-区别" class="headerlink" title="computed 和 watch 区别"></a>computed 和 watch 区别</h4><p><strong>computed</strong></p><ol><li>支持缓存</li><li>不支持异步</li><li>如果 computed 属性的属性值是函数，那么默认使用 get 方法，函数的返回值就是属性的属性值；在 computed 中，属性有一个 get 方法和一个 set 方法，当数据被赋值时，会调用 set 方法。</li><li>第一次加载时会监听</li><li>computed 属性函数需要 return</li></ol><p><strong>watch</strong></p><ol><li>不支持缓存</li><li>支持异步</li><li>监听数据必须是 data 中声明的或者父组件传递过来的 props 中的数据</li><li>第一次加载时默认不监听，除非 immediate 为 true</li><li>watch 属性函数不需要 return</li></ol><h3 id="Vue-模版指令"><a href="#Vue-模版指令" class="headerlink" title="Vue 模版指令"></a>Vue 模版指令</h3><h4 id="v-show-和-v-if-区别"><a href="#v-show-和-v-if-区别" class="headerlink" title="v-show 和 v-if 区别"></a>v-show 和 v-if 区别</h4><p>v-show 只是在 display: none 和 display: block 之间切换。DOM 一直存在<br>v-if 的话就得说到 Vue 底层的编译了。当属性初始为 false 时，组件就不会被渲染，直到条件为 true，并且切换条件时会触发销毁&#x2F;挂载组件</p><h4 id="v-if-和-v-for-共用时控制台报错"><a href="#v-if-和-v-for-共用时控制台报错" class="headerlink" title="v-if 和 v-for 共用时控制台报错"></a>v-if 和 v-for 共用时控制台报错</h4><p>当它们同时存在于一个节点上时，v-if 比 v-for 的优先级更高。这意味着 v-if 的条件将无法访问到 v-for 作用域内定义的变量别名<br>正确写法：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;todo in todos&quot;</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;!todo.isComplete&quot;</span>&gt;</span></span><br><span class="language-xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">todo.name</span> &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="Vue3-0-新特性"><a href="#Vue3-0-新特性" class="headerlink" title="Vue3.0 新特性"></a>Vue3.0 新特性</h3><h4 id="Proxy-替代-Object-defineProperty"><a href="#Proxy-替代-Object-defineProperty" class="headerlink" title="Proxy 替代 Object.defineProperty"></a>Proxy 替代 Object.defineProperty</h4><h5 id="Proxy-特点"><a href="#Proxy-特点" class="headerlink" title="Proxy 特点"></a>Proxy 特点</h5><ol><li>可以直接监听整个对象而非属性；</li><li>Proxy 可以直接监听数组的变化；</li><li>Proxy 与 Object.defineProperty 相比有更多拦截方法；</li><li>Proxy 返回的是一个新对象，可以只操作新的对象达到目的，而 Object.defineProperty 只能遍历对象属性直接修改;</li></ol><h5 id="Object-defineProperty-特点"><a href="#Object-defineProperty-特点" class="headerlink" title="Object.defineProperty 特点"></a>Object.defineProperty 特点</h5><ol><li>Object.defineProperty 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历</li><li>Object.defineProperty 也不能对 es6 新产生的 Map,Set 这些数据结构做出监听，不能监听数组和对象</li><li>Object.defineProperty 不能监听新增和删除操作</li></ol><h4 id="组合式-API"><a href="#组合式-API" class="headerlink" title="组合式 API"></a>组合式 API</h4><p>Vue 之前的风格可以说属于选项式 API，用包含多个选项的对象来描述组件的逻辑，例如 data、methods 和 mounted。组合式 API 是写在标签<code>&lt;script setup&gt;</code>的内部的，风格接近 react 钩子函数</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>1）生命周期钩子只有 onBeforeMount、onMounted、onBeforeUpdate、onUpdated、onBeforeUnmount 和 onUnmounted，不存在跟 beforeCreate 和 created 生命周期相关的钩子<br>2）父子组件之间的数据交互依赖于函数 defineProps 和 defineEmits、defineExpose<br>3）不会使用 this（因为不存在组件实例了）<br>4）需要使用 ref 或者 reactive 创建响应式数据</p><h5 id="ref-和-reactive-区别"><a href="#ref-和-reactive-区别" class="headerlink" title="ref 和 reactive 区别"></a>ref 和 reactive 区别</h5><p><strong>ref</strong>：通常用来定义常用的基础类型(String,Number,Boolean 等等)，ref 函数包裹的数据需要用.value 来查询<br><strong>reactive</strong>：通常用来定义对象</p><h4 id="支持-TypeScript"><a href="#支持-TypeScript" class="headerlink" title="支持 TypeScript"></a>支持 TypeScript</h4><p>Vue 3.0 是用 TypeScript 编写的，因此支持 TypeScript。<br>在单文件组件中使用 TypeScript，需要在 <code>&lt;script&gt;</code> 标签上加上 lang&#x3D;”ts” 的 attribute。<br><strong>类型推断对比</strong></p><table style="text-align:center;">    <tr>       <th></th>        <th>组合式API</th>      <th>选项式API</th>   </tr>   <tr>       <td>props类型推导</td>           <td>defineProps</td>           <td>defineComponent</td>   </tr>   <tr>       <td>emits类型推导</td>           <td>defineEmits</td>           <td>defineComponent</td>   </tr>   <tr>       <td>计算属性类型推导</td>           <td>泛型参数显式指定computed()类型</td>           <td>显式地标记出计算属性的类型</td>   </tr>   <tr>       <td>事件处理函数类型推导</td>           <td colspan="2">显式地强制转换 event 上的属性(例：event.target as HTMLInputElement）</td>   </tr>   <tr>       <td>ref类型推导</td>           <td>Ref传入泛型参数;ref初始化时也会推导类型</td>           <td rowspan="2">无</td>   </tr>    <tr>       <td>reactive类型推导</td>           <td>interface定义</td>   </tr></table><h3 id="新内置组件-Suspense、Teleport"><a href="#新内置组件-Suspense、Teleport" class="headerlink" title="新内置组件 Suspense、Teleport"></a>新内置组件 Suspense、Teleport</h3><ul><li><strong>Suspense</strong>：组件有两个插槽：#default 和 #fallback。两个插槽都只允许一个直接子节点。初始渲染时渲染默认的插槽内容。如果遇到异步依赖，则会进入挂起状态。在挂起状态期间，展示的是后备内容。当所有遇到的异步依赖都完成后，将展示出默认插槽的内容。</li><li><strong>Teleport</strong>：接收一个 to 的属性来指定传送的目标。to 的值可以是 CSS 选择器字符串，也可以是一个 DOM 元素对象。被 Teleport 标签包裹的模块将置于 to 指定的 DOM 之下。适用于子组件调用公共组件如全局提示框的场景</li></ul><h2 id="Vue-生命周期（Vue3-0-版本）"><a href="#Vue-生命周期（Vue3-0-版本）" class="headerlink" title="Vue 生命周期（Vue3.0 版本）"></a>Vue 生命周期（Vue3.0 版本）</h2><p><img src="/unkown404.github.io/img/life-cycle.png"></p><h3 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h3><p>实例初始化完成、props 解析之后、data() 和 computed 等选项处理之前立即调用。</p><h3 id="created"><a href="#created" class="headerlink" title="created"></a>created</h3><p>data、computed、method、watch 已经设置完成。跟 DOM 操作相关的属性方法仍不可使用。</p><h3 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h3><p>即将首次执行 DOM 渲染过程。</p><p>服务器渲染流程不包括该生命周期。</p><h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h3><p>组件挂载完之后调用。挂载完成的定义为：所有同步子组件都已经被挂载且其自身的 DOM 树已经创建完成并插入了父容器中。<br>该生命周期通常用于执行需要访问组件所渲染的 DOM 树相关的副作用。</p><p>服务器渲染流程不包括该生命周期。</p><h3 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h3><p>响应式数据更新时调用，可以用来在 Vue 更新 DOM 之前访问 DOM 状态。</p><p>服务器渲染流程不包括该生命周期。</p><h3 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h3><p>调用时，组件 DOM 已经更新，所以可以执行依赖于 DOM 的操作。</p><p>服务器渲染流程不包括该生命周期。</p><h3 id="beforeUnmount"><a href="#beforeUnmount" class="headerlink" title="beforeUnmount"></a>beforeUnmount</h3><p>一个组件实例被卸载之前调用。当这个钩子被调用时，组件实例依然还保有全部的功能。</p><p>服务器渲染流程不包括该生命周期。</p><h3 id="unmounted"><a href="#unmounted" class="headerlink" title="unmounted"></a>unmounted</h3><p>一个组件实例被卸载之后调用。可以在这个钩子中手动清理一些副作用，例如计时器、DOM 事件监听器或者与服务器的连接。</p><p>服务器渲染流程不包括该生命周期。<br><strong>备注</strong>：<br>Vue2 的生命周期钩子除了最后两个的名称是 beforeDestroy 和 destroyed，其他都一样</p><h3 id="KeepAlive-组件生命周期"><a href="#KeepAlive-组件生命周期" class="headerlink" title="KeepAlive 组件生命周期"></a>KeepAlive 组件生命周期</h3><h4 id="KeepAlive-组件简介"><a href="#KeepAlive-组件简介" class="headerlink" title="KeepAlive 组件简介"></a>KeepAlive 组件简介</h4><p>vue 的内置组件，它的功能是在多个组件间动态切换时缓存被移除的组件实例。</p><h4 id="activated"><a href="#activated" class="headerlink" title="activated"></a>activated</h4><p>在首次挂载、以及每次从缓存中被重新插入的时候调用</p><h4 id="deactivated"><a href="#deactivated" class="headerlink" title="deactivated"></a>deactivated</h4><p>在从 DOM 上移除、进入缓存以及组件卸载时调用</p><h3 id="适合做异步请求的生命周期"><a href="#适合做异步请求的生命周期" class="headerlink" title="适合做异步请求的生命周期"></a>适合做异步请求的生命周期</h3><p>created、beforeMount、mounted 都可以做异步请求，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。<br>考虑到服务端渲染不包括周期 beforeMount、mounted，异步请求放在 created 一致性更好；另一方面 created 调用异步数据相比其他周期调用页面加载时间会缩短。</p><h3 id="父子组件嵌套时，父组件和子组件生命周期钩子执行顺序"><a href="#父子组件嵌套时，父组件和子组件生命周期钩子执行顺序" class="headerlink" title="父子组件嵌套时，父组件和子组件生命周期钩子执行顺序"></a>父子组件嵌套时，父组件和子组件生命周期钩子执行顺序</h3><ul><li><strong>加载渲染过程</strong> 父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</li><li><strong>子组件更新过程</strong> 父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</li><li><strong>父组件更新过程</strong> 父 beforeUpdate -&gt; 父 updated</li><li><strong>销毁过程</strong> 父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</li></ul><h2 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h2><h3 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h3><p><strong>1）props</strong><br>通过 props 传递数据给子组件<br><strong>2）emit</strong><br>父组件可以通过 v-on 或 @ 来选择性地监听子组件上抛的事件，如示例中自定义的事件 increaseBy；该属性的处理函数可以写在父组件的 method 里<br>子组件调用内置的 $emit 方法，通过传入事件名称来抛出一个事件；也可以通过设置 emits 属性实现</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 父组件</span><br>&lt;MyButton <span class="hljs-meta">@increase</span>-<span class="hljs-keyword">by</span>=<span class="hljs-string">&quot;(n) =&gt; count += n&quot;</span> /&gt;<br><br><span class="hljs-comment">// 子组件</span><br>&lt;button <span class="hljs-meta">@click</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$emit</span>(&#x27;increaseBy&#x27;, 1)&quot;</span>&gt;<br>  Increase <span class="hljs-keyword">by</span> <span class="hljs-number">1</span><br>&lt;/button&gt;<br></code></pre></td></tr></table></figure><p><strong>3）v-model</strong><br>当 v-model 指令用于自定义的组件时，等效于如下写法：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir">&lt;CustomInput<br>  <span class="hljs-symbol">:modelValue=<span class="hljs-string">&quot;searchText&quot;</span></span><br>  <span class="hljs-variable">@update</span><span class="hljs-symbol">:modelValue=<span class="hljs-string">&quot;newValue =&gt; searchText = newValue&quot;</span></span><br>/&gt;<br></code></pre></td></tr></table></figure><p>如果要实现和原生元素 input 一样的绑定效果，自定义组件 CustomInput 内部需要做如下操作：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- CustomInput.vue --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;modelValue&#x27;</span>],</span><br><span class="language-javascript">  <span class="hljs-attr">emits</span>: [<span class="hljs-string">&#x27;update:modelValue&#x27;</span>]</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;modelValue&quot;</span></span><br><span class="hljs-tag">    @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;</span></span><br><span class="hljs-tag">  /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>子组件中通过将属性 modelValue 和原生元素 input 的 value 绑定，当 input 的值变化时通过 emit 向上传递变化的值</p><p><strong>4）ref</strong><br>使用选项式 API 时，可以通过 this.$refs.name 的方式获取指定元素或者组件</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs perl">// 父组件<br><br>&lt;template&gt;<br>&lt;child <span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;childNode&quot;</span>&gt;&lt;<span class="hljs-regexp">/child&gt;</span><br><span class="hljs-regexp">&lt;/</span>template&gt;<br>&lt;script&gt;<br>export default&#123;<br>  data()&#123;&#125;,<br>  methods:&#123;<br>    test()&#123;<br>      this.$refs.childNode.childMethod()<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;<span class="hljs-regexp">/script&gt;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><br><br>// 子组件(child)<br><br>&lt;script&gt;<br>export default&#123;<br>  data()&#123;&#125;,<br>  methods:&#123;<br>    childMethod()&#123;<br>      console.log(<span class="hljs-string">&#x27;test&#x27;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>5) $attrs</strong><br>子组件的$attrs 对象包含了除组件所声明的 props 和 emits 之外的所有其他 attribute，例如 class，style，v-on 监听器等等。子组件可以利用<code>v-bind=&quot;$attrs&quot;</code>将属性传到目标元素上。<br>vue2 中$listeners包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。而在vue3，$listeners 被移除了</p><h3 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h3><h4 id="parent"><a href="#parent" class="headerlink" title="$parent"></a>$parent</h4><p>$parent 可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法）<br>可以通过共同的父组件来管理状态和事件函数。比如说其中一个兄弟组件调用父组件传递过来的事件函数修改父组件中的状态，然后父组件将状态传递给另一个兄弟组件。</p><h4 id="eventBus"><a href="#eventBus" class="headerlink" title="eventBus"></a>eventBus</h4><p>Vue3 中移除了事件总线，但是可以借助于第三方工具来完成，Vue 官方推荐 mitt 或 tiny-emitter；<br>但基本的使用方法保持不变，组件 1 使用 emit 函数发送事件名和参数，组件 2 使用 on 函数监听对应的事件名，执行处理函数</p><h3 id="跨多层次组件通信"><a href="#跨多层次组件通信" class="headerlink" title="跨多层次组件通信"></a>跨多层次组件通信</h3><h4 id="provide、inject"><a href="#provide、inject" class="headerlink" title="provide、inject"></a>provide、inject</h4><p>祖先组件：使用 provide 属性或方法，指定想要提供给后代组件的数据或方法<br>后代组件：使用 inject 获取祖先组件的值</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">// 祖先组件</span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; ref, provide &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; fooSymbol &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./injectionSymbols&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 提供静态值</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 提供响应式的值</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;count&#x27;</span>, count)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 提供时将 Symbol 作为 key</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">provide</span>(fooSymbol, count)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml">/////////////////////////////////////////////////</span><br><span class="language-xml">// 后代组件</span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; inject &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; fooSymbol &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./injectionSymbols&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 注入值的默认方式</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> foo = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 注入响应式的值</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;count&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 通过 Symbol 类型的 key 注入</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> foo2 = <span class="hljs-title function_">inject</span>(fooSymbol)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 注入一个值，若为空则使用提供的默认值</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> bar = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;default value&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 注入时为了表明提供的默认值是个函数，需要传入第三个参数</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> fn = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;function&#x27;</span>, <span class="hljs-function">() =&gt;</span> </span></span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml"><span class="language-javascript">, <span class="hljs-literal">false</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"></span><br></code></pre></td></tr></table></figure><h2 id="Vue-生态"><a href="#Vue-生态" class="headerlink" title="Vue 生态"></a>Vue 生态</h2><h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><h4 id="前端路由和后端路由区别"><a href="#前端路由和后端路由区别" class="headerlink" title="前端路由和后端路由区别"></a>前端路由和后端路由区别</h4><p>前端路由：页面跳转的 URL 规则匹配由前端来控制，把渲染的任务交给了浏览器，通过客户端的算力来解决页面的构建<br>后端路由：浏览器地址输入栏输入 URL 回车时后端根据路径将对应的 html 模版渲染好返回给前端</p><h4 id="直接使用-a-链接与使用-router-link-的区别"><a href="#直接使用-a-链接与使用-router-link-的区别" class="headerlink" title="直接使用 a 链接与使用 router-link 的区别"></a>直接使用 a 链接与使用 router-link 的区别</h4><p>抹平了两种模式下 href 的书写方式，会得到正确的 href 值；history 模式下调用 pushState 并阻止默认行为。</p><h4 id="hash-模式和-history-模式区别"><a href="#hash-模式和-history-模式区别" class="headerlink" title="hash 模式和 history 模式区别"></a>hash 模式和 history 模式区别</h4><h5 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a>hash 模式</h5><p>开发中默认的模式，它的 URL 带着一个#。<br>特点：hash 值会出现在 URL 里面，但是不会出现在 HTTP 请求中，对后端完全没有影响。所以改变 hash 值，不会重新加载页面。<br>原理： hash 模式的主要原理就是监听 onhashchange()事件</p><h5 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a>history 模式</h5><p>传统的路由分发模式，即用户在输入一个 URL 时，服务器会接收这个请求，并解析这个 URL，然后做出相应的逻辑处理。URL 不会带#。<br>特点：history 模式下的某些路径如果后台没有配置，URL 输入访问时会返回 404。解决方法为需要在服务器上添加一个简单的回退路由。<br>原理：通过按钮进行的路由跳转用 pushState、replaceState 来改变路由但不触发后端请求，再用回调函数调用新页面组件；点击浏览器前进后退按钮时监听 popstate 事件进行页面切换</p><h4 id="route-和-router-的区别"><a href="#route-和-router-的区别" class="headerlink" title="$route 和$router 的区别"></a>$route 和$router 的区别</h4><p>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数<br>$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</p><h4 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h4><h5 id="全局路由钩子"><a href="#全局路由钩子" class="headerlink" title="全局路由钩子"></a>全局路由钩子</h5><p><strong>beforeEach</strong><br>触发时机：进入路由之前<br>应用：登录态判断跳转<br><strong>beforeResolve</strong><br>触发时机：进入路由之前、可以访问 route 配置中自定义的 meta 变量。在 beforeRouteEnter 之后<br>应用：页面访问权限判断跳转<br><strong>afterEach</strong><br>触发时机：进入路由之后<br>应用：跳转之后滚动条回到顶部</p><h5 id="单个路由钩子"><a href="#单个路由钩子" class="headerlink" title="单个路由钩子"></a>单个路由钩子</h5><p><strong>beforeEnter</strong><br>在路由配置文件中使用，beforeEnter 属性可传入函数数组<br>触发时机：只在进入路由时触发，不会在 params、query 或 hash 改变时触发。<br>应用：为不同的路由配置重定向逻辑</p><h5 id="路由组件内钩子"><a href="#路由组件内钩子" class="headerlink" title="路由组件内钩子"></a>路由组件内钩子</h5><p><strong>beforeRouteEnter</strong><br>触发时机 ∶ 进入组件前触发，此时组件未创建，不能用 this<br><strong>beforeRouteUpdate</strong><br>触发时机 ∶ 当前地址改变并且改组件被复用时触发，举例来说，带有动态参数的路径 foo&#x2F;∶id，在 &#x2F;foo&#x2F;1 和 &#x2F;foo&#x2F;2 之间跳转的时候，由于会渲染同样的 foo 组件，这个钩子在这种情况下就会被调用。发生在 beforeEnter 前<br><strong>beforeRouteLeave</strong><br>触发时机 ∶ 离开组件被调用<br>应用：离开页面前弹出提示语</p><h5 id="路由钩子执行生命周期的顺序"><a href="#路由钩子执行生命周期的顺序" class="headerlink" title="路由钩子执行生命周期的顺序"></a>路由钩子执行生命周期的顺序</h5><ol><li>导航被触发。</li><li>在失活的组件里调用 beforeRouteLeave 守卫。</li><li>调用全局的 beforeEach 守卫。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。</li><li>在路由配置里调用 beforeEnter。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫(2.5+)。</li><li>导航被确认。</li><li>调用全局的 afterEach 钩子。</li><li>触发 DOM 更新。</li><li>调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ol><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><p>为 Vue.js 应用程序开发的状态管理模式。</p><h4 id="vuex-属性"><a href="#vuex-属性" class="headerlink" title="vuex 属性"></a>vuex 属性</h4><ul><li>state：数据源存放地</li><li>getters：从基本数据 state 派生出来的数据，store 的计算属性</li><li>mutations：同步提交更改数据的方法(目的：方便调试)</li><li>actions：异步调用 mutation 方法</li><li>module：模块化 vuex</li></ul><h4 id="vuex-vs-localStorage"><a href="#vuex-vs-localStorage" class="headerlink" title="vuex vs localStorage"></a>vuex vs localStorage</h4><ol><li>存储位置：vuex 存储在内存，localStorage 则以文件的方式存储在本地</li><li>存储内容：localStorage 只能存储字符串类型的数据</li><li>持久性：刷新页面时 vuex 存储的值会丢失，localstorage 不会</li></ol><h3 id="pinia"><a href="#pinia" class="headerlink" title="pinia"></a>pinia</h3><p>全新的 Vue 状态管理库，vuex 的代替者。</p><h4 id="pinia-特点"><a href="#pinia-特点" class="headerlink" title="pinia 特点"></a>pinia 特点</h4><ol><li>Vue2 和 Vue3 都能支持</li><li>抛弃传统的 mutation ，只有 state, getter 和 action ，简化状态管理库</li><li>不需要嵌套模块，符合 Vue3 的 Composition api，让代码扁平化</li><li>TypeScript 支持</li></ol><h4 id="pinia-数据修改"><a href="#pinia-数据修改" class="headerlink" title="pinia 数据修改"></a>pinia 数据修改</h4><p><strong>简单数据修改</strong>：直接操作 <code>store.属性名</code>进行修改<br><strong>多条数据修改</strong>：</p><ol><li>使用$patch 方法。patch 接受对象和函数作为入参。在涉及集合的修改(例如，从数组中推送、移除、拼接一个元素)的操作，使用对象的语法更加耗时，官方文档推荐使用函数。代码示例：</li></ol><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">store</span>.$patch(&#123;<br>  var<span class="hljs-number">1</span>:<span class="hljs-keyword">store</span>.var<span class="hljs-number">1</span>++<span class="hljs-punctuation">,</span><br>  var<span class="hljs-number">2</span>:<span class="hljs-keyword">store</span>.var<span class="hljs-number">2</span>++<br>&#125;)<br><span class="hljs-keyword">store</span>.$patch((<span class="hljs-keyword">store</span>)<span class="hljs-operator">=</span>&gt;&#123;<br>  var<span class="hljs-number">1</span>:<span class="hljs-keyword">store</span>.var<span class="hljs-number">1</span>++<span class="hljs-punctuation">,</span><br>  var<span class="hljs-number">2</span>:<span class="hljs-keyword">store</span>.var<span class="hljs-number">2</span>++<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="2"><li>使用 store 的 action 方法</li></ol><h2 id="Vue-项目开发注意事项"><a href="#Vue-项目开发注意事项" class="headerlink" title="Vue 项目开发注意事项"></a>Vue 项目开发注意事项</h2><h3 id="assets-和-static-的区别"><a href="#assets-和-static-的区别" class="headerlink" title="assets 和 static 的区别"></a>assets 和 static 的区别</h3><p>相同点：都是存放静态资源文件。<br>不同点：assets 中存放的静态资源文件在项目打包时会进行压缩体积，代码格式化操作。static 文件夹下的文件则不会。</p><h3 id="Class-与-Style-如何动态绑定"><a href="#Class-与-Style-如何动态绑定" class="headerlink" title="Class 与 Style 如何动态绑定"></a>Class 与 Style 如何动态绑定</h3><p>使用对象语法或数组语法进行绑定。这里以 class 为例，style 类似</p><ul><li>对象语法</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> v-bind:<span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br><br>data: &#123;<br>  isActive: <span class="hljs-literal">true</span>,<br>  hasError: <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>数组语法</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;div v-bind:<span class="hljs-keyword">class</span>=&quot;[<span class="hljs-symbol">isActive</span> ? <span class="hljs-symbol">activeClass</span> : &#x27;&#x27;, <span class="hljs-symbol">errorClass</span>]&quot;&gt;&lt;/<span class="hljs-symbol">div</span>&gt;<br><br><span class="hljs-symbol">data: </span>&#123;<br>  activeClass: <span class="hljs-string">&#x27;active&#x27;</span>,<br>  errorClass: <span class="hljs-string">&#x27;text-danger&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/6964779204462247950/">「2021」高频前端面试题汇总之 Vue 篇（下）</a><br>（2）<a href="https://juejin.cn/post/7064368176846340132"> Vue 这一块拿捏了</a></p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES7装饰器语法</title>
    <link href="/unkown404.github.io/2022/09/02/decorator/"/>
    <url>/unkown404.github.io/2022/09/02/decorator/</url>
    
    <content type="html"><![CDATA[<p>装饰器是是一种与类（class）相关的语法，用来注释或修改类和类方法。装饰器在 Python 和 Java 等语言中也被大量使用。目前在前端框架 Nestjs 也已经有应用。因此本文主要记录装饰器相关的知识点，帮助理解 Nestjs 程序。</p><span id="more"></span><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>装饰器模式是一种结构型设计模式，它允许向一个现有的对象添加新的功能，同时又不改变其结构，是作为对现有类的一个包装。<br>装饰器是针对这种设计模式的一个语法糖。其用法是：使用 @ 作为标识符，紧跟返回装饰器函数的表达式，被放置在被装饰代码前面。<br>由于该语法目前还处于第 2 阶段提案中，使用它之前需要使用 Babel 模块编译成 ES5 或 ES6。</p><h2 id="装饰器用法"><a href="#装饰器用法" class="headerlink" title="装饰器用法"></a>装饰器用法</h2><p>装饰器主要用于:</p><ol><li>装饰类</li><li>装饰方法或属性</li></ol><h3 id="装饰类"><a href="#装饰类" class="headerlink" title="装饰类"></a>装饰类</h3><p>装饰类的时候，装饰器方法一般会接收一个目标类作为参数。</p><h4 id="babel-编译情况"><a href="#babel-编译情况" class="headerlink" title="babel 编译情况"></a>babel 编译情况</h4><p>编译前：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@annotation</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123; &#125;<br><br><span class="hljs-function">function <span class="hljs-title">annotation</span><span class="hljs-params">(<span class="hljs-keyword">target</span>)</span> </span>&#123;<br>   <span class="hljs-keyword">target</span>.annotated = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译后：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">var <span class="hljs-number">_</span><span class="hljs-keyword">class</span>;<br><br><span class="hljs-keyword">let</span> MyClass = <span class="hljs-keyword">annotation</span>(<span class="hljs-number">_</span><span class="hljs-keyword">class</span> = <span class="hljs-keyword">class</span> MyClass &#123;&#125;) || <span class="hljs-number">_</span><span class="hljs-keyword">class</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">annotation</span>(target) &#123;<br>  target.annotated = true;<br>&#125;<br></code></pre></td></tr></table></figure><p>从编译的结果可以看出类装饰器的第一个参数就是要装饰的类，它的功能就是对类进行处理。</p><h4 id="类装饰器的作用"><a href="#类装饰器的作用" class="headerlink" title="类装饰器的作用"></a>类装饰器的作用</h4><ol><li>给目标类增加静态属性</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> add<span class="hljs-constructor">Attribute(<span class="hljs-params">targetClass</span>)</span> &#123;<br>  targetClass.isUseDecorator = <span class="hljs-literal">true</span>;<br>&#125;<br><br>@addAttribute<br><span class="hljs-keyword">class</span> TargetClass &#123; &#125;<br><br>console.log(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TargetClass</span>.</span></span>isUseDecorator); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>在上面这个例子中，我们定义了 addAttribute 的装饰器，用于为 TargetClass 添加静态属性 isUseDecorator 并设置为 true。<br>另一方面，类装饰器可以使用表达式传入参数为静态属性赋值，利用装饰器工厂模式。如下面的代码：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">function</span> <span class="hljs-title function_">addAttribute</span>(<span class="hljs-params">content</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable">function</span> <span class="hljs-title function_">decFn</span>(<span class="hljs-params">targetClass</span>) &#123;<br>    <span class="hljs-variable">targetClass</span>.<span class="hljs-property">content</span> <span class="hljs-operator">=</span> <span class="hljs-variable">content</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable">targetClass</span>;<br>  &#125;;<br>&#125;<br><br>@<span class="hljs-title function_">addAttribute</span>(&#x27;这是内容～～～&#x27;)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TargetClass</span> &#123; &#125;<br><br><span class="hljs-variable">console</span>.<span class="hljs-property">log</span>(<span class="hljs-title class_">TargetClass</span>.<span class="hljs-property">content</span>); <span class="hljs-comment">// 这是内容～～～</span><br></code></pre></td></tr></table></figure><p>该示例就是为 TargetClass 添加静态属性 content 并用传入的参数‘这是内容～～～’为 content 赋值。这种使用方法更加灵活。</p><ol start="2"><li>添加原型方法<br>既然类装饰器接收的参数就是类定义本身，那么该装饰器也可以通过访问类的 prototype 属性来添加或修改原型方法</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">targetClass</span>) &#123;<br>  targetClass.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">decFun</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;这里是装饰器 decorator 添加的原型方法 decFun~&#x27;</span>);<br>  &#125;;<br>&#125;<br><br>@decorator<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TargetClass</span> &#123; &#125;<br><br><span class="hljs-keyword">const</span> targetClass = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TargetClass</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(targetClass);<br>targetClass.<span class="hljs-title function_">decFun</span>();<br></code></pre></td></tr></table></figure><h3 id="装饰方法和属性"><a href="#装饰方法和属性" class="headerlink" title="装饰方法和属性"></a>装饰方法和属性</h3><h4 id="预备知识：属性描述符"><a href="#预备知识：属性描述符" class="headerlink" title="预备知识：属性描述符"></a>预备知识：属性描述符</h4><p>属性描述符表达了一个属性的相关信息(元数据）,本质上是一个对象。属性主要分为两种：访问器属性和数据属性。</p><h5 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h5><p>特点：当给属性赋值或者取值的时候，会自动的运行一个函数。<br>具有描述符属性：configurable、enumerable、get、set</p><h5 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h5><p>特点：在我们使用对象的过程中，对一个对象进行取值和赋值的时候，该属性称之为 数据属性<br>具有描述符属性：configurable、enumerable、writable、value<br>如示例所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> o = &#123;&#125;;<br>o.a = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 等同于 :</span><br><span class="hljs-built_in">Object</span>.defineProperty(o, <span class="hljs-string">&quot;a&quot;</span>, &#123;<br>  value : <span class="hljs-number">1</span>,<br>  writable : <span class="hljs-keyword">true</span>,<br>  configurable : <span class="hljs-keyword">true</span>,<br>  enumerable : <span class="hljs-keyword">true</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>两种属性共有的属性为 configurable 和 enumerable。<br>configurable：是否可配置，默认为 false。为 true 时，表示当前属性的‘属性表述符’对象可以被更改，该属性可以使用 delete 删除<br>enumerable：是否可枚举，默认为 false。为 true 时，表示当前属性可以被枚举，也就是当前属性是否可以在 for…in 循环和 Object.keys() 中被遍历出来</p><p>(value 和 writable)与(get 和 set)是不共存的，只要定义了其中一个，就定下来了该描述符的性质是数据属性还是访问器属性。</p><h4 id="babel-编译情况-1"><a href="#babel-编译情况-1" class="headerlink" title="babel 编译情况"></a>babel 编译情况</h4><p>根据<a href="https://github.com/mqyqingfeng/Blog/issues/109">ES6 系列之我们来聊聊装饰器</a>,babel 编译后的方法装饰器可以分为 3 个处理步骤：</p><ol><li>拷贝需要装饰的属性其对应的属性描述符<br>使用 Object.getOwnPropertyDescriptor 可以获得指定属性的属性描述符。该函数接收两个参数：属性所在对象和要取得描述的属性。<br>其中 Babel 的 Class 为了与 decorator 配合而产生了一个属性 initializer</li><li>应用多个 decorators 方法：当同一个方法使用多个装饰器模型时，遵从洋葱模型，从外到内进入，然后由内向外执行</li></ol><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">decorator1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;decorator1&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">decFn1</span>(<span class="hljs-params">targetClass</span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;decFn1&#x27;</span>);<br>    <span class="hljs-keyword">return</span> targetClass;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">decorator2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;decorator2&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">decFn2</span>(<span class="hljs-params">targetClass</span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;decFn2&#x27;</span>);<br>    <span class="hljs-keyword">return</span> targetClass;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>假如存在装饰器 decorator1、decorator2，修饰同一个方法 targetFunc，其输出结果为：<code>decorator1-&gt;decorator2-&gt;decFn2-&gt;decFn1</code></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@decorator1</span>()<br><span class="hljs-variable">@decorator2</span>()<br>targetFunc()<br></code></pre></td></tr></table></figure><ol start="3"><li>处理需要装饰的属性或方法，属性描述符的调整最终还是由 Object.defineProperty 来实现</li></ol><h4 id="方法装饰器使用方法"><a href="#方法装饰器使用方法" class="headerlink" title="方法装饰器使用方法"></a>方法装饰器使用方法</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function">function <span class="hljs-title">readonly</span><span class="hljs-params">(<span class="hljs-keyword">target</span>, name, descriptor)</span> </span>&#123;<br>  descriptor.writable = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-keyword">return</span> descriptor;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-meta">@readonly</span><br>  name = <span class="hljs-string">&#x27;zhangsan&#x27;</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person();<br></code></pre></td></tr></table></figure><p>如示例所示，方法装饰器接收的入参同 Object.defineProperty 一致，包括：</p><ul><li>要定义属性的对象（obj）</li><li>要定义或修改的属性名或 Symbol（props）</li><li>要定义或修改的属性描述符（descriptor）</li></ul><h2 id="装饰器应用"><a href="#装饰器应用" class="headerlink" title="装饰器应用"></a>装饰器应用</h2><h3 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h3><p>使用高阶函数 connect 时，需要将代码写成以下格式：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyReactComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(<span class="hljs-type">MyReactComponent</span>);<br></code></pre></td></tr></table></figure><p>而使用装饰器后代码可简化为：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@connect</span>(mapStateToProps, mapDispatchToProps)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyReactComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;&#125;;<br></code></pre></td></tr></table></figure><p>语义也更加简洁明了</p><h3 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h3><p>在频繁触发事件的场景下，为了提升性能常会用防抖和节流函数，其特点是会返回一个匿名函数。为了能在组件销毁时能有效解绑事件，需要用变量将匿名函数存储起来。但使用装饰器语法后就不需要再设置多余的变量了。防抖装饰器的实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//防抖函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_debounce</span>(<span class="hljs-params">func, wait, immediate</span>) &#123;<br><br>    <span class="hljs-keyword">var</span> timeout;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> context = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-keyword">var</span> args = <span class="hljs-variable language_">arguments</span>;<br><br>        <span class="hljs-keyword">if</span> (timeout) <span class="hljs-built_in">clearTimeout</span>(timeout);<br>        <span class="hljs-keyword">if</span> (immediate) &#123;<br>            <span class="hljs-keyword">var</span> callNow = !timeout;<br>            timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>                timeout = <span class="hljs-literal">null</span>;<br>            &#125;, wait)<br>            <span class="hljs-keyword">if</span> (callNow) func.<span class="hljs-title function_">apply</span>(context, args)<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>                func.<span class="hljs-title function_">apply</span>(context, args)<br>            &#125;, wait);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//防抖装饰器</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">wait, immediate</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleDescriptor</span>(<span class="hljs-params">target, key, descriptor</span>) &#123;<br>    <span class="hljs-keyword">const</span> callback = descriptor.<span class="hljs-property">value</span>;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyntaxError</span>(<span class="hljs-string">&#x27;Only functions can be debounced&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> fn = <span class="hljs-title function_">_debounce</span>(callback, wait, immediate)<br><br>    <span class="hljs-keyword">return</span> &#123;<br>      ...descriptor,<br>      <span class="hljs-title function_">value</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">fn</span>()<br>      &#125;<br>    &#125;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在使用时只需要在目标函数上方添加@debounce，传入等待时间和是否立即响应的变量即可。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Toggle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br><br>  <span class="hljs-meta">@debounce</span>(<span class="hljs-number">500</span>, <span class="hljs-literal">true</span>)<br>  handleClick() &#123;<br>    console.log(&#x27;toggle&#x27;)<br>  &#125;<br><br>  render() &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;button onClick=&#123;<span class="hljs-keyword">this</span>.handleClick&#125;&gt;<br>        button<br>      &lt;/button&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>节流的实现也基本相似，这里不再列举。</p><h2 id="TypeScript-装饰器"><a href="#TypeScript-装饰器" class="headerlink" title="TypeScript 装饰器"></a>TypeScript 装饰器</h2><p>在 TypeScript 中，可以实现以下五种装饰器：类装饰器、方法装饰器、属性装饰器、访问器装饰器、参数装饰器</p><h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>格式：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs r"><span class="hljs-keyword">function</span> classDecorator<span class="hljs-operator">&lt;</span><span class="hljs-built_in">T</span> extends Constructor<span class="hljs-operator">&gt;</span><span class="hljs-punctuation">(</span>targetClass<span class="hljs-operator">:</span><span class="hljs-built_in">T</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">&#123;</span><br><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>入参：<br>targetClass - 类构造器</p><h3 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h3><p>格式：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-keyword">method</span><span class="hljs-constructor">Decorator(<span class="hljs-params">target</span>: Object, <span class="hljs-params">propertyName</span>: <span class="hljs-params">string</span>, <span class="hljs-params">propertyDescriptor</span>: PropertyDescriptor)</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>入参：<br>target - 如果是静态方法就是类的构造器（TargetClass），如果是实例方法就是类的原型（TargetClass.prototype）<br>propertyName - 函数名<br>propertyDescriptor - 函数的属性描述符</p><h3 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h3><p>格式：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> property<span class="hljs-constructor">Decorator(<span class="hljs-params">target</span>: Object, <span class="hljs-params">propertyName</span>: <span class="hljs-params">string</span>)</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>入参：<br>target - 如果是静态方法就是类的构造器（TargetClass），如果是实例方法就是类的原型（TargetClass.prototype）<br>propertyName - 属性名</p><h3 id="参数装饰器"><a href="#参数装饰器" class="headerlink" title="参数装饰器"></a>参数装饰器</h3><p>格式：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> parameter<span class="hljs-constructor">Decorator(<span class="hljs-params">target</span>: Object, <span class="hljs-params">propertyName</span>: <span class="hljs-params">string</span>, <span class="hljs-params">index</span>: <span class="hljs-params">number</span>)</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>入参：<br>target - 如果是静态方法就是类的构造器（TargetClass），如果是实例方法就是类的原型（TargetClass.prototype）<br>propertyName - 参数名<br>index - 参数在函数参数列表的位置</p><h3 id="访问器装饰器"><a href="#访问器装饰器" class="headerlink" title="访问器装饰器"></a>访问器装饰器</h3><p>格式：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> accessor<span class="hljs-constructor">Decorator(<span class="hljs-params">target</span>: Object, <span class="hljs-params">propertyName</span>: <span class="hljs-params">string</span>, <span class="hljs-params">propertyDescriptor</span>: PropertyDescriptor)</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>入参：<br>target - 如果是静态方法就是类的构造器（TargetClass），如果是实例方法就是类的原型（TargetClass.prototype）<br>propertyName - 属性名<br>propertyDescriptor - 函数的属性描述符</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://github.com/mqyqingfeng/Blog/issues/109">系列之我们来聊聊装饰器</a><br>（2）<a href="https://juejin.cn/post/7072883925764276254">Decorator 装饰器</a><br>（3）<a href="https://juejin.cn/post/6844904100144889864">都 2020 年了，你还不会 JavaScript 装饰器</a><br>（4）<a href="https://juejin.cn/post/6996590290555371534">TypeScript 装饰器的基本语法</a></p>]]></content>
    
    
    <categories>
      
      <category>前端技术体系</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6语法</title>
    <link href="/unkown404.github.io/2022/08/29/es6/"/>
    <url>/unkown404.github.io/2022/08/29/es6/</url>
    
    <content type="html"><![CDATA[<p>面试时常问的 ES6 特性</p><span id="more"></span><h2 id="let-const"><a href="#let-const" class="headerlink" title="let,const"></a>let,const</h2><p>创建块级作用域，若调用发生在声明前会暂时性死区<br>const 指向地址不能改变，但可以增加内部属性</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>特点：没有 this 和 arguments；不能作为构造函数；没有函数提升</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br> <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tyler&#x27;</span>,<br> <span class="hljs-attr">a</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;Anderson&#x27;</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-title function_">test</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>  &#125;<br>  <span class="hljs-title function_">test</span>()<br> &#125;,<br>&#125;<br>obj.<span class="hljs-title function_">a</span>()<br><br><span class="hljs-comment">// Tyler</span><br><span class="hljs-comment">// 找到最近的非箭头函数a，所以箭头函数的this 就是a 的this。</span><br><span class="hljs-comment">// a目前是由obj调用的，因此此时箭头函数的this 为obj</span><br></code></pre></td></tr></table></figure><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>使用方法：const proxy &#x3D; new Proxy(target, handler)<br>输入参数：</p><ul><li>target：拦截的目标对象</li><li>handler：定制拦截行为</li></ul><h3 id="Proxy-与-Object-defineProperty-对比"><a href="#Proxy-与-Object-defineProperty-对比" class="headerlink" title="Proxy 与 Object.defineProperty 对比"></a>Proxy 与 Object.defineProperty 对比</h3><p>Proxy 的优点：</p><ul><li>Proxy 可以直接监听整个对象而非属性。</li><li>Proxy 可以直接监听数组的变化。</li><li>Proxy 有 13 中拦截方法，如 ownKeys、deleteProperty、has 等是 Object.defineProperty 不具备的。</li><li>Proxy 返回的是一个新对象，我们可以只操作新的对象达到目的，而 Object.defineProperty 只能遍历对象属性直接修改;</li><li>Proxy 做为新标准将受到浏览器产商重点持续的性能优化,也就是传说中的新标准的性能红利。</li></ul><p>Object.defineProperty 的优点：</p><ul><li>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平。</li></ul><p>Object.defineProperty 的缺点：</p><ul><li>Object.defineProperty 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。</li><li>Object.defineProperty 不能监听数组。是通过重写数据的那 7 个可以改变数据的方法来对数组进行监听的。</li><li>Object.defineProperty 也不能对 es6 新产生的 Map,Set 这些数据结构做出监听。</li><li>Object.defineProperty 也不能监听新增和删除操作，通过 Vue.set()和 Vue.delete 来实现响应式的。</li></ul><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>导入导出方式：import、export</p><h3 id="commonJs-vs-ES6"><a href="#commonJs-vs-ES6" class="headerlink" title="commonJs vs ES6"></a>commonJs vs ES6</h3><ol><li>commonJs 输出是值的拷贝，es6 输出值的引用</li><li>commonJs 模块运行时加载（先加载全部模块再导入方法），es6 模块是编译时加载（指定加载某输出值）</li><li>commonJs 同步导入，es6 模块异步导入</li></ol><h3 id="其他模块化方法特点"><a href="#其他模块化方法特点" class="headerlink" title="其他模块化方法特点"></a>其他模块化方法特点</h3><p>amd 和 requireJs：依赖前置，提前执行<br>cmd 和 seaJs：依赖后置，延迟执行<br>umd：通用模块定义规范</p><h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>3 种状态：1）pending；2）resolved；3）rejected<br>特点：1）立即执行；2）then 异步回调；3）状态不可逆；4）链式调用</p><h4 id="promise-简易实现"><a href="#promise-简易实现" class="headerlink" title="promise 简易实现"></a>promise 简易实现</h4><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs pf">function myPromise(fn) &#123;<br>    <span class="hljs-keyword">const</span> that = this<br>    that.<span class="hljs-keyword">state</span> = &#x27;pending&#x27;<br>    that.value = null<br>    that.resolvedCallbacks = []<br>    that.rejectedCallbacks = []<br><br>    function resolve(value) &#123;<br>        if (that.<span class="hljs-keyword">state</span> === &#x27;pending&#x27;) &#123;<br>            that.<span class="hljs-keyword">state</span> = &#x27;resolved&#x27;<br>            that.value = value<br>            that.resolvedCallbacks.map(cb =&gt; cb(value))<br>        &#125;<br>    &#125;<br><br>    function reject(value) &#123;<br>        if (that.<span class="hljs-keyword">state</span> === &#x27;pending&#x27;) &#123;<br>            that.<span class="hljs-keyword">state</span> = &#x27;rejected&#x27;<br>            that.value = value<br>            that.rejectedCallbacks.map(cb =&gt; cb(value))<br>        &#125;<br>    &#125;<br>    try &#123;<br>        fn(resolve, reject)<br>    &#125; catch (e) &#123;<br>        reject(e)<br>    &#125;<br>&#125;<br>myPromise.prototype.then = function (<span class="hljs-keyword">on</span>Fulfilled, <span class="hljs-keyword">on</span>Rejected) &#123;<br>    <span class="hljs-keyword">const</span> that = this<br>    <span class="hljs-keyword">on</span>Fulfilled = typeof <span class="hljs-keyword">on</span>Fulfilled === &#x27;function&#x27; ? <span class="hljs-keyword">on</span>Fulfilled : v =&gt; v<br>    <span class="hljs-keyword">on</span>Rejected = typeof <span class="hljs-keyword">on</span>Rejected === &#x27;function&#x27; ? <span class="hljs-keyword">on</span>Rejected : e =&gt;<br>        throw e<br>    if (that.<span class="hljs-keyword">state</span> === &#x27;resolved&#x27;) <span class="hljs-keyword">on</span>Fulfilled(that.value)<br>    if (that.<span class="hljs-keyword">state</span> === &#x27;rejected&#x27;) <span class="hljs-keyword">on</span>Rejected(that.value)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h3><p>generator 的语法糖。<br>async 声明 function 是一个异步函数，返回一个 promise 对象，可以使用 then 方法添加回调函数。<br>await 操作符只能在异步函数 async function 内部使用。await 会阻塞后面的代码，等待接在 await 后面的表达式返回 Promise 对象结果。</p><h2 id="数据类型-Set、Map"><a href="#数据类型-Set、Map" class="headerlink" title="数据类型 Set、Map"></a>数据类型 Set、Map</h2><h3 id="Set-和-weakSet、Map-和-WeakMap-区别"><a href="#Set-和-weakSet、Map-和-WeakMap-区别" class="headerlink" title="Set 和 weakSet、Map 和 WeakMap 区别"></a>Set 和 weakSet、Map 和 WeakMap 区别</h3><p>weakSet 结构与 Set 类似，是不重复值集合，但 weakSet 只能是对象且为弱引用，且不可遍历<br>weakMap 结构与 Map 类似，但 weakMap 只接受对象为键名，键名是对象弱引用，且不可遍历</p><h3 id="Map-和-Object-的区别"><a href="#Map-和-Object-的区别" class="headerlink" title="Map 和 Object 的区别"></a>Map 和 Object 的区别</h3><p>1）Key filed：在 Object 中， key 必须是简单数据类型（整数，字符串或者是 symbol），而在 Map 中则可以是 JavaScript 支持的所有数据类型，也就是说可以用一个 Object 来当做一个 Map 元素的 key。<br>2）元素顺序：Map 元素的顺序遵循插入的顺序，而 Object 的则没有这一特性。<br>3）初始化、增查删改方式</p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>依赖包管理工具比较</title>
    <link href="/unkown404.github.io/2022/08/23/packageInfo/"/>
    <url>/unkown404.github.io/2022/08/23/packageInfo/</url>
    
    <content type="html"><![CDATA[<p>前端常用的包依赖管理工具有 npm、yarn 以及近期非常受欢迎的 pnpm，本文主要也是对比这几个工具之间的区别。</p><span id="more"></span><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>最早出现的安装包工具， Node.js 标准的软件包管理器。</p><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p>npm 是围绕着<a href="https://semver.org/">语义版本控制（semver）</a>的思想而设计的。大致的准则为：</p><ul><li>版本号由三部分组成：major.minor.patch，即主版本号.次版本号.修补版本号。<ul><li>主版本号：更改时代表了一个破坏兼容性的大变化。</li><li>次版本号：更改时不会破坏任何内容，增加了新功能。</li><li>修补版本号：更改时表示做了向后兼容的缺陷修复。</li></ul></li><li>版本是严格递增的，如该例所示：16.2.0 -&gt; 16.3.0 -&gt; 16.3.1</li><li>修补版本号有时后面可能还会有先行版本号，例如 1.0.0-alpha.1。常用的先行版本一般为 alpha（内部先行版），beta（公开测试版），rc（候选版），stable（稳定版）</li></ul><h4 id="版本控制符"><a href="#版本控制符" class="headerlink" title="版本控制符"></a>版本控制符</h4><p>使用 npm install 时，会发现 package.json 文件的版本号前面默认出现符号<code>^</code>，该符号即为版本控制符。常见的版本控制符包括：</p><ul><li><code>~</code> 会匹配最近的小版本依赖包，比如 ~1.2.3 会匹配所有 1.2.x 版本，但是不包括 1.3.0</li><li><code>^ </code>会匹配最新的大版本依赖包（npm i 默认的版本控制符），比如 ^1.2.3 会匹配所有 1.x.x 的包，包括 1.3.0，但是不包括 2.0.0</li><li><code>* </code>安装最新版本的依赖包，比如 *1.2.3 会匹配 x.x.x<br>除此之外还有其他版本控制方法：</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123; <span class="hljs-string">&quot;dependencies&quot;</span> :<br>  &#123; <span class="hljs-string">&quot;foo&quot;</span> : <span class="hljs-string">&quot;1.0.0 - 2.9999.9999&quot;</span>,<span class="hljs-regexp">//</span> 大于等于<span class="hljs-number">1.0</span>.<span class="hljs-number">0</span> 小于 <span class="hljs-number">2.9999</span>.<span class="hljs-number">9999</span><br>  <span class="hljs-string">&quot;bar&quot;</span> : <span class="hljs-string">&quot;&gt;=1.0.2 &lt;2.1.2&quot;</span>, <span class="hljs-regexp">//</span> 比较清晰  左闭右开<br>  <span class="hljs-string">&quot;baz&quot;</span> : <span class="hljs-string">&quot;&gt;1.0.2 &lt;=2.3.4&quot;</span>, <span class="hljs-regexp">//</span> 左开右闭<br>  <span class="hljs-string">&quot;boo&quot;</span> : <span class="hljs-string">&quot;2.0.1&quot;</span>, <span class="hljs-regexp">//</span> 规定版本<br>  <span class="hljs-string">&quot;qux&quot;</span> : <span class="hljs-string">&quot;&lt;1.0.0 || &gt;=2.3.1 &lt;2.4.5 || &gt;=2.5.2 &lt;3.0.0&quot;</span>, <span class="hljs-regexp">//</span> 表达式也算清晰<br>  <span class="hljs-string">&quot;asd&quot;</span> : <span class="hljs-string">&quot;http://asdf.com/asdf.tar.gz&quot;</span>, <span class="hljs-regexp">//</span> 指定下载地址代替版本<br>  <span class="hljs-string">&quot;til&quot;</span> : <span class="hljs-string">&quot;^1.2.3&quot;</span>, <span class="hljs-regexp">//</span> 同一主版本号，不小于<span class="hljs-number">1.2</span>.<span class="hljs-number">3</span> 即 <span class="hljs-number">1</span>.x.y  x&gt;=<span class="hljs-number">2</span> y&gt;=<span class="hljs-number">3</span><br>  <span class="hljs-string">&quot;elf&quot;</span> : <span class="hljs-string">&quot;~1.2.3&quot;</span>,  <span class="hljs-regexp">//</span> 同一主版本和次版本号 即<span class="hljs-number">1.2</span>.x x&gt;= <span class="hljs-number">2</span><br>  <span class="hljs-string">&quot;two&quot;</span> : <span class="hljs-string">&quot;2.x&quot;</span> , <span class="hljs-regexp">//</span> 这个比较形象，x&gt;=<span class="hljs-number">0</span>  即<span class="hljs-number">2.0</span>.<span class="hljs-number">0</span> 以上均可<br>  <span class="hljs-string">&quot;thr&quot;</span> : <span class="hljs-string">&quot;3.3.x&quot;</span> , <span class="hljs-regexp">//</span> 同上 x&gt;= <span class="hljs-number">0</span>  即<span class="hljs-number">3.3</span>.<span class="hljs-number">0</span> 以上<br>  <span class="hljs-string">&quot;lat&quot;</span> : <span class="hljs-string">&quot;latest&quot;</span>,  <span class="hljs-regexp">//</span> 最新版本<br>  <span class="hljs-string">&quot;dyl&quot;</span> : <span class="hljs-string">&quot;file:../dyl&quot;</span>,  <span class="hljs-regexp">//</span> 从本地下载<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="package-lock-json"><a href="#package-lock-json" class="headerlink" title="package-lock.json"></a>package-lock.json</h4><p>早期的 npm 没有锁定包版本的功能，如果某个依赖包发布了不兼容或者有 bug 版本，部署上线时项目就可能会发生问题。针对这一问题 yarn 提出了固化版本的方案，而 npm 在^5.x.x.x 以后才有的 package-lock.json。<br>不同版本 npm 对 package-lock.json 的实现是不同的。是在一直迭代和发展的：</p><ol><li>npm 5.0.x 版本，不管 package.json 怎么变，npm i 时都会根据 lock 文件下载。</li><li>5.1.0 版本后 npm install 会无视 lock 文件 去下载最新的 npm 包</li><li>5.4.2 版本如果改了 package.json，且 package.json 和 lock 文件不同，那么执行 npm i 时 npm 会根据 package 中的版本号以及语义含义去下载最新的包，并更新至 lock。<br>如果两者是同一状态，那么执行 npm i 都会根据 lock 下载，不会理会 package 实际包的版本是否有新。</li></ol><p>package-lock.json 的文件格式如下：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs perl">...<br><span class="hljs-string">&quot;@ant-design/colors&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;4.0.5&quot;</span>,<br>    <span class="hljs-string">&quot;resolved&quot;</span>: <span class="hljs-string">&quot;http://npm.internal.focus.cn:80/@ant-design%2fcolors/-/colors-4.0.5.tgz&quot;</span>,<br>    <span class="hljs-string">&quot;integrity&quot;</span>: <span class="hljs-string">&quot;sha1-19EA11Rcyo9iSVRgSmiS/Ei6Wq4=&quot;</span>,<br>    <span class="hljs-string">&quot;requires&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;tinycolor2&quot;</span>: <span class="hljs-string">&quot;^1.4.1&quot;</span><br>    &#125;<br>&#125;,<br><span class="hljs-string">&quot;@ant-design/icons&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;4.6.2&quot;</span>,<br>    <span class="hljs-string">&quot;resolved&quot;</span>: <span class="hljs-string">&quot;https://registry.npmjs.org/@ant-design/icons/-/icons-4.6.2.tgz&quot;</span>,<br>    <span class="hljs-string">&quot;integrity&quot;</span>: <span class="hljs-string">&quot;sha512-QsBG2BxBYU/rxr2eb8b2cZ4rPKAPBpzAR+0v6rrZLp/lnyvflLH3tw1vregK+M7aJauGWjIGNdFmUfpAOtw25A==&quot;</span>,<br>    <span class="hljs-string">&quot;requires&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;@ant-design/colors&quot;</span>: <span class="hljs-string">&quot;^6.0.0&quot;</span>,<br>    <span class="hljs-string">&quot;@ant-design/icons-svg&quot;</span>: <span class="hljs-string">&quot;^4.0.0&quot;</span>,<br>    <span class="hljs-string">&quot;@babel/runtime&quot;</span>: <span class="hljs-string">&quot;^7.11.2&quot;</span>,<br>    <span class="hljs-string">&quot;classnames&quot;</span>: <span class="hljs-string">&quot;^2.2.6&quot;</span>,<br>    <span class="hljs-string">&quot;rc-util&quot;</span>: <span class="hljs-string">&quot;^5.9.4&quot;</span><br>    &#125;,<br>    <span class="hljs-string">&quot;dependencies&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;@ant-design/colors&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;6.0.0&quot;</span>,<br>        <span class="hljs-string">&quot;resolved&quot;</span>: <span class="hljs-string">&quot;https://registry.npmjs.org/@ant-design/colors/-/colors-6.0.0.tgz&quot;</span>,<br>        <span class="hljs-string">&quot;integrity&quot;</span>: <span class="hljs-string">&quot;sha512-qAZRvPzfdWHtfameEGP2Qvuf838NhergR35o+EuVyB5XvSA98xod5r4utvi4TJ3ywmevm290g9nsCG5MryrdWQ==&quot;</span>,<br>        <span class="hljs-string">&quot;requires&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;@ctrl/tinycolor&quot;</span>: <span class="hljs-string">&quot;^3.4.0&quot;</span><br>        &#125;<br>    &#125;<br>    &#125;<br>&#125;,<br>...<br></code></pre></td></tr></table></figure><p>可以看到，安装包需要的依赖包，如果顶级依赖满足需求的，则不再安装，仅有 requires 属性；如果不满足，则会在对应文件夹下面根据依赖安装符合版本，如上面的文件里的@ant-design&#x2F;icons，内部仍有 dependencies 属性。</p><h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><h4 id="npm-2-x"><a href="#npm-2-x" class="headerlink" title="npm 2.x"></a>npm 2.x</h4><p>npm2.x 版本安装依赖包时会安装每一个包所依赖的所有依赖项，依赖项的依赖包也会安装在其 node_modules 目录下。如下图所示，即 node_modules 存在嵌套。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">.</span><br><span class="hljs-bullet"></span>└──node<span class="hljs-emphasis">_modules</span><br><span class="hljs-emphasis">        ├──test1</span><br><span class="hljs-emphasis">        └──test2</span><br><span class="hljs-emphasis">            └──node_</span>modules<br><span class="hljs-code">                    └──test3</span><br></code></pre></td></tr></table></figure><p>这样的处理方式造成了两个问题：</p><ol><li>多个包之间难免会有公共的依赖，这样嵌套的话，同样的依赖会复制很多次，会占据比较大的磁盘空间。</li><li>windows 的文件路径最长是 260 多个字符，这样嵌套是会超过 windows 路径的长度限制的。</li></ol><h4 id="npm-3"><a href="#npm-3" class="headerlink" title="npm 3+"></a>npm 3+</h4><p>同 yarn 一样采用了扁平化依赖的方式解决问题。与之前的目录相比，现在的文件夹结构更接近于</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">.</span><br><span class="hljs-bullet"></span>└──node_modules<br><span class="hljs-code">        ├──test1</span><br><span class="hljs-code">        ├──test2</span><br><span class="hljs-code">        └──test3</span><br></code></pre></td></tr></table></figure><p>所有的依赖都被拍平到 node_modules 目录下，不再有很深层次的嵌套关系。这样在安装新的包时，根据 node require 机制，会不停往上级的 node_modules 当中去找，如果找到相同版本的包就不会重新安装，解决了大量包重复安装的问题，而且依赖层级也不会太深。<br>但扁平化依赖方法存在的问题包括：</p><ul><li>依赖结构的不确定性。</li><li>扁平化算法本身的复杂性很高，耗时较长。</li><li>项目中仍然可以非法访问没有声明过依赖的包<br>依赖结构的不确定性是如果声明的依赖包 test1、test2 同时依赖另一个包 test3，但是是不同版本的时候，扁平化的结果可能有两种。</li></ul><p><em>npm2.x 下 test1、test2 依赖包结构</em></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c">.<br>└──node_modules<br>        ├──test1<br>        <span class="hljs-string">|   └──node_modules</span><br>        <span class="hljs-string">|           └──test3@1.0.1</span><br>        └──test2<br>            └──node_modules<br>                    └──test3@<span class="hljs-number">1.0</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><em>npm3+下 test1、test2 安装结果 1</em></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c">.<br>└──node_modules<br>        ├──test1<br>        └──test2<br>        <span class="hljs-string">|   └──node_modules</span><br>        <span class="hljs-string">|           └──test3@1.0.2</span><br>        └──test3@<span class="hljs-number">1.0</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><em>npm3+下 test1、test2 安装结果 2</em></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c">.<br>└──node_modules<br>        ├──test1<br>        <span class="hljs-string">|   └──node_modules</span><br>        <span class="hljs-string">|           └──test3@1.0.1</span><br>        ├──test2<br>        └──test3@<span class="hljs-number">1.0</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>两种结果都有可能存在，实际安装时取决于 test1 和 test2 在 package.json 中的位置，如果 test1 声明在前面，那么就是前面的结构，否则是后面的结构。<br>为了解决依赖结构的不确定性的问题，npm 5.x 推出 package-lock.json，保证第一次安装以后 node_modules 以后在添加依赖或者重装时也不会变。</p><h2 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h2><p>yarn 是在 npm2.x 版本没有很好的优化方案时提出的，主要用于解决嵌套超过 windows 路径的长度限制的 node_modules。虽然现在 npm 也日益趋同 yarn，但在安装速度上 yarn 还是优于 npm</p><h3 id="版本控制-1"><a href="#版本控制-1" class="headerlink" title="版本控制"></a>版本控制</h3><p>默认依赖都会生成 yarn.lock 文件，该文件会通过包名+版本来确定具体信息。<br>yarn.lock 文件格式如下，yarn 用的是自己设计的格式，语法上有点像 YAML，# 开头的行是注释。依赖的依赖不会被记录在 dependencies，依赖包的依赖版本如果不存在语义冲突则会合并信息</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-string">&quot;@angular-devkit/core@12.2.10&quot;</span>:<br>  version <span class="hljs-string">&quot;12.2.10&quot;</span><br>  resolved <span class="hljs-string">&quot;http://npm.internal.focus.cn:80/@angular-devkit%2fcore/-/core-12.2.10.tgz#3da62eceef3904f92cd3f860618b4ae513029ce2&quot;</span><br>  integrity sha1-PaYuzu85BPks<span class="hljs-number">0</span>/hgYYtK5RMCnOI=<br>  dependencies:<br>    ajv <span class="hljs-string">&quot;8.6.2&quot;</span><br>    ajv-formats <span class="hljs-string">&quot;2.1.0&quot;</span><br>    fast-json-stable-stringify <span class="hljs-string">&quot;2.1.0&quot;</span><br>    magic-string <span class="hljs-string">&quot;0.25.7&quot;</span><br>    rxjs <span class="hljs-string">&quot;6.6.7&quot;</span><br>    source-<span class="hljs-keyword">map</span> <span class="hljs-string">&quot;0.7.3&quot;</span><br></code></pre></td></tr></table></figure><p>Yarn 仅以 flatten 格式 描述各个包之间的依赖关系，并依赖于其当前实现来创建目录结构。这意味着如果其内部算法发生变化，结构也会发生变化。</p><h3 id="依赖关系-1"><a href="#依赖关系-1" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>同 npm 基本一样，其共有的问题是：如果你有 100 个项目使用了某个依赖（dependency），就会有 100 份该依赖的副本保存在硬盘上</p><h2 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h2><p>同 npm 和 Yarn，都属于 Javascript 包管理安装工具，它较 npm 和 Yarn 在性能上得到很大提升，被称为快速的，节省磁盘空间的包管理工具。</p><h3 id="依赖关系-2"><a href="#依赖关系-2" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>为了解决 npm、yarn 安装时依赖可能复制多次、占用磁盘空间的问题，pnpm 采用了全局仓库保存依赖、项目通过 link 的方式访问内容。<br><img src="/unkown404.github.io/img/pnpm.png"></p><p>当执行 pnpm install 时，项目的 node_modules 文件夹下除了安装的包名 bar、其依赖保持原有的树状、不进行提升，还会有.pnpm 目录，目录下是以展平结构管理每个版本包的源码内容，以硬链接方式指向 pnpm-store 中的文件地址。pnpm-store 是全局的 store，存储所有 npm 包，同一版本的包仅存储一份内容，甚至不同版本的包也仅存储 diff 内容。<br>如上图所示一个包的寻找需要经过三层结构：<code>node_modules/bar</code> &gt; 软链接 <code>node_modules/.pnpm/bar@1.0.0/node_modules/bar</code> &gt; 硬链接 <code>~/.pnpm-store/v3/files/00/xxxxxx</code>。</p><h4 id="备注：软链接和硬链接"><a href="#备注：软链接和硬链接" class="headerlink" title="备注：软链接和硬链接"></a>备注：软链接和硬链接</h4><p>在 Linux 系统中，内核为每一个新创建的文件分配一个 Inode(索引结点)，每个文件都有一个惟一的 inode 号。文件属性保存在索引结点里，在访问文件时，索引结点被复制到内存在，从而实现文件的快速访问。<br>Linux 中包括两种链接：硬链接(Hard Link)和软链接(Soft Link)，软链接又称为符号链接（Symbolic link）。<br>硬链接说白了是一个指针，指向文件索引节点，系统并不为它重新分配 inode，他将与源文件共用一个 inode。<br>软链接相当于 windows 的快捷方式，软链接文件会将 inode 指向源文件的 block，原文件＆链接文件拥有不同的 inode 号</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/6932046455733485575">关于现代包管理器的深度思考——为什么现在我更推荐 pnpm 而不是 npm&#x2F;yarn?</a><br>（2）<a href="https://juejin.cn/post/6844904022718038024">yarn or npm 版本固化如何选择</a><br>（3）<a href="https://juejin.cn/post/7127295203177676837">pnpm 是凭什么对 npm 和 yarn 降维打击的</a><br>（4）<a href="https://mp.weixin.qq.com/s/bZ7AVSjBcZrZ3I387_esmg">该用 pnpm 了，“快、准、狠”。</a></p>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端依赖包管理</tag>
      
      <tag>npm</tag>
      
      <tag>yarn</tag>
      
      <tag>pnpm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>koroFileHeader使用技巧</title>
    <link href="/unkown404.github.io/2022/08/18/koroHeader/"/>
    <url>/unkown404.github.io/2022/08/18/koroHeader/</url>
    
    <content type="html"><![CDATA[<p>本来并不想记的，奈何记忆力太差，有些快捷键操作老要翻文档也很讨厌，所以在此简单记录下。</p><span id="more"></span> <h2 id="配置-setting-json"><a href="#配置-setting-json" class="headerlink" title="配置 setting.json"></a>配置 setting.json</h2><p><strong>方法 1</strong><br>点击顶部工具栏的 code 选项，按<code>首选项 &gt; 设置 &gt; 搜索fileheader &gt; 在setting.json中编辑</code>的步骤进入 setting.json 文件<br><strong>方法 2</strong><br>mac: command + p window: ctrl + p 的快捷键指令打开 vscode 命令面板，输入<code>&gt; Open Settings</code></p><h2 id="配置文件头部注释"><a href="#配置文件头部注释" class="headerlink" title="配置文件头部注释"></a>配置文件头部注释</h2><p>头部注释快捷键：window：ctrl+win+i,mac：ctrl+cmd+i</p><p>文件头部注释的配置修改主要在 fileheader.customMade 内部操作，通过增加或删除内部的属性来 DIY 合适的文件说明。</p><p>默认配置如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;fileheader.customMade&quot;</span>: &#123;<br>  <span class="hljs-string">&quot;Date&quot;</span>: <span class="hljs-string">&quot;Do not edit&quot;</span>, <span class="hljs-regexp">//</span> 文件创建时间(不变)<br>  <span class="hljs-regexp">//</span> 文件最后编辑者<br>  <span class="hljs-string">&quot;LastEditors&quot;</span>: <span class="hljs-string">&quot;git config user.name &amp;&amp; git config user.email&quot;</span>,<br>  <span class="hljs-string">&quot;LastEditTime&quot;</span>: <span class="hljs-string">&quot;Do not edit&quot;</span>, <span class="hljs-regexp">//</span> 文件最后编辑时间<br>  <span class="hljs-string">&quot;FilePath&quot;</span>: <span class="hljs-string">&quot;Do not edit&quot;</span> <span class="hljs-regexp">//</span> 文件在项目中的相对路径 自动更新<br>&#125;<br><span class="hljs-regexp">//</span> 不填写对应属性即关闭对应功能<br></code></pre></td></tr></table></figure><h2 id="配置函数注释"><a href="#配置函数注释" class="headerlink" title="配置函数注释"></a>配置函数注释</h2><p>文件头部注释的配置修改主要在 fileheader.cursorMode 内部操作，通过增加或删除内部的属性来 DIY 合适的函数说明。</p><p>默认配置如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;fileheader.cursorMode&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;param&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;return&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="配置函数使用方法"><a href="#配置函数使用方法" class="headerlink" title="配置函数使用方法"></a>配置函数使用方法</h3><p>函数识别快捷键：window：ctrl+win+t,mac：ctrl+cmd+t<br><strong>单行函数声明参数提取</strong><br>将鼠标光标放置于函数声明那一行，然后按函数注释快捷键生成<br><strong>多行函数声明参数提取</strong><br>当函数内参数过多时经过 prettier 优化的函数声明会变成多行，这时需要用鼠标左键选择多行函数声明区域，函数声明区域尽量精准，按快捷键生成</p><h3 id="插件配置项"><a href="#插件配置项" class="headerlink" title="插件配置项"></a>插件配置项</h3><p>可以用于决定自动生成注释的时机、注释的格式等内容</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://hub.fastgit.xyz/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE">koroFileHeader配置</a></p>]]></content>
    
    
    <categories>
      
      <category>工作技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vscode插件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工具函数</title>
    <link href="/unkown404.github.io/2022/08/18/toolFunc/"/>
    <url>/unkown404.github.io/2022/08/18/toolFunc/</url>
    
    <content type="html"><![CDATA[<p>记录一些常用的工具函数（不定期更新）。</p><span id="more"></span><ol><li>两个数组求交集</li></ol><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">intersectArr</span>(<span class="hljs-params">arr1,arr2</span>)&#123;<br>    <span class="hljs-keyword">return</span> arr1.<span class="hljs-built_in">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>arr2.<span class="hljs-built_in">includes</span>(item))<br>&#125;<br></code></pre></td></tr></table></figure><p>延伸：判断某数组是否包含另一数组的参数（适用于权限验证，用户的权限是否与路由设置的角色权限匹配）</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isIntersect</span>(<span class="hljs-params">arr1,arr2</span>)&#123;<br>    <span class="hljs-keyword">return</span> arr1.some(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>arr2.<span class="hljs-built_in">includes</span>(item))<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>删除对象中的 null 或 undefined 值</li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const removeNullorUndefinedofObj = <span class="hljs-function"><span class="hljs-params">(obj)</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.entries(obj).reduce(<br>    <span class="hljs-function"><span class="hljs-params">(cur, [key, value])</span> =&gt;</span> (value === <span class="hljs-literal">null</span> || value === <span class="hljs-literal">undefined</span> ? cur : (cur[key] = value), cur),<br>    &#123;&#125;,<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="3"><li>url 中搜索参数格式化</li></ol><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">const</span> parseQuery = () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">search</span> = <span class="hljs-keyword">window</span>.location.<span class="hljs-keyword">search</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">search</span><br>    .slice(1)<br>    .<span class="hljs-keyword">split</span>(<span class="hljs-string">&quot;&amp;&quot;</span>)<br>    .reduce((<span class="hljs-keyword">query</span>, it) =&gt; &#123;<br>      <span class="hljs-keyword">const</span> [key, value] = it.<span class="hljs-keyword">split</span>(<span class="hljs-string">&quot;=&quot;</span>);<br>      <span class="hljs-keyword">query</span>[key] = decodeURIComponent(value);<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">query</span>;<br>    &#125;, &#123;&#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="4"><li>快速创建 0 - n-1 范围的数组</li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Array</span>.<span class="hljs-keyword">from</span>(&#123;length: n&#125;, <span class="hljs-function"><span class="hljs-params">(_, i)</span> =&gt;</span> i)<br><br>[...<span class="hljs-built_in">Array</span>(n).keys()]<br><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n).fill(<span class="hljs-number">1</span>).map(<span class="hljs-function"><span class="hljs-params">(_, i)</span> =&gt;</span> i)<br></code></pre></td></tr></table></figure><ol start="5"><li>多个数组全组合的情况统计</li></ol><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">zuhe</span>(<span class="hljs-params">arr,n</span>)&#123;<br>    <span class="hljs-keyword">var</span> pass = <span class="hljs-keyword">new</span> Set();<br>    <span class="hljs-keyword">var</span> zh = []<br>    <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">0</span> || arr.<span class="hljs-built_in">length</span> &lt; n)&#123;throw <span class="hljs-string">&#x27;参数错误&#x27;</span>&#125;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">for</span>(let _arr of arr)&#123;<br>            <span class="hljs-keyword">for</span>(let v of _arr)&#123;<br>                <span class="hljs-keyword">if</span>(!pass.has(v))&#123; <span class="hljs-comment">//去重</span><br>                    pass.add(v);<br>                    zh.<span class="hljs-built_in">push</span>([v]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> zh;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(let i=<span class="hljs-number">0</span>; i &lt;= arr.<span class="hljs-built_in">length</span>-n; i++ )&#123;<br>        <span class="hljs-keyword">for</span>(let v of arr[i])&#123;<br>            <span class="hljs-keyword">if</span>(!pass.has(v))&#123; <span class="hljs-comment">//去重</span><br>                pass.add(v);<br>                let _zh = zuhe(arr.<span class="hljs-built_in">slice</span>(i+<span class="hljs-number">1</span>),n<span class="hljs-number">-1</span>).<span class="hljs-built_in">map</span>(<span class="hljs-function"><span class="hljs-params">a</span>=&gt;</span>&#123;<br>                    a.unshift(v)<br>                    <span class="hljs-keyword">return</span> a;<br>                &#125;)<br>                zh = zh.concat(_zh)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> zh;<br>&#125;<br><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>];<br><span class="hljs-keyword">var</span> arr2 = [<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>];<br><span class="hljs-keyword">var</span> arr3 = [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>];<br><br><span class="hljs-keyword">var</span> zh2 = zuhe([arr1,arr2,arr3],<span class="hljs-number">2</span>)<br><span class="hljs-keyword">var</span> zh3 = zuhe([arr1,arr2,arr3],<span class="hljs-number">3</span>)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(zh2)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(zh3)<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://segmentfault.com/q/1010000018650936">js多个数组元素两两组合三三组合</a></p>]]></content>
    
    
    <categories>
      
      <category>工作技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rollup打包工具使用</title>
    <link href="/unkown404.github.io/2022/08/08/rollup/"/>
    <url>/unkown404.github.io/2022/08/08/rollup/</url>
    
    <content type="html"><![CDATA[<p>rollup 使用指南和相关知识梳理。</p><span id="more"></span><h2 id="rollup-概述"><a href="#rollup-概述" class="headerlink" title="rollup 概述"></a>rollup 概述</h2><p>rollup 是一个 js 模块打包器。与 webpack 相比，rollup 更适合打包库，而 webpack 适合打包项目；同体积的代码条件下 rollup 打包的代码体检要小于 webpack。rollup 对于代码的 Tree-shaking 和 ES6 模块有着先天的算法优势上的支持，而 webpack 在代码分割、静态资源导入及热模块替换(HMR)有着更多优势。</p><h2 id="rollup-使用"><a href="#rollup-使用" class="headerlink" title="rollup 使用"></a>rollup 使用</h2><h3 id="安装-rollup-工具"><a href="#安装-rollup-工具" class="headerlink" title="安装 rollup 工具"></a>安装 rollup 工具</h3><p>创建一个新的空工程，打开命令行执行<code>npm install --global rollup </code>指令。指令执行完成后项目的结构变为：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">├── node_modules<br>└── <span class="hljs-keyword">package</span>.json<br></code></pre></td></tr></table></figure><p>此时工程里已经预装了一些插件，允许我们用 cli 命令来打包。但复杂的工程中这种方式就比较麻烦。所以需要配置文件。</p><h3 id="配置打包文件"><a href="#配置打包文件" class="headerlink" title="配置打包文件"></a>配置打包文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs es6">import babel from &quot;@rollup/plugin-babel&quot;;<br>import commonjs from &quot;rollup-plugin-commonjs&quot;;<br>import resolve from &quot;@rollup/plugin-node-resolve&quot;;<br>import size from &quot;rollup-plugin-sizes&quot;;<br>import &#123; terser &#125; from &quot;rollup-plugin-terser&quot;;<br>import cleanup from &quot;rollup-plugin-cleanup&quot;;<br><br>export default &#123;<br>  input: &quot;./index.js&quot;,<br>  output: [<br>    &#123;<br>      file: &quot;./dist/dofin.js&quot;,<br>      format: &quot;umd&quot;,<br>      name: &quot;DOFIN&quot;,<br>    &#125;,<br>    &#123;<br>      file: &quot;./dist/dofin.min.js&quot;,<br>      format: &quot;iife&quot;,<br>      name: &quot;DOFIN&quot;,<br>      plugins: [terser()],<br>    &#125;,<br>  ],<br>  plugins: [<br>    resolve(),<br>    size(),<br>    cleanup(&#123;<br>      comments: &quot;none&quot;,<br>    &#125;),<br>    babel(&#123;<br>      babelHelpers: &quot;runtime&quot;,<br>      exclude: &quot;node_modules/**&quot;,<br>    &#125;),<br>    commonjs(),<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure><p>以上述某一配置文件 rollup.config.js 为例，该文件通常需要需要的核心参数包括：</p><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><p>打包文件入口</p><h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><p>文件输出配置</p><ul><li><strong>file</strong> 表示输出文件的路径</li><li><strong>format</strong> 表示输出的格式</li><li><strong>name</strong> 当 format 为 iife 和 umd 时必须提供，将作为全局变量挂在 window(浏览器环境)下：window.A&#x3D;…</li></ul><h4 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h4><p>使用的插件</p><h4 id="external"><a href="#external" class="headerlink" title="external"></a>external</h4><p>使用的外部依赖，不会被打包进输出文件</p><h4 id="global"><a href="#global" class="headerlink" title="global"></a>global</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">global:&#123;<br>    <span class="hljs-string">&#x27;jquery&#x27;</span>:<span class="hljs-string">&#x27;$&#x27;</span> <span class="hljs-regexp">//</span>告诉rollup 全局变量$即是jquery<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="执行打包指令"><a href="#执行打包指令" class="headerlink" title="执行打包指令"></a>执行打包指令</h3><p>可以直接在执行终端输入<code>rollup -c</code>默认执行 rollup.config.js 文件，也可以在 package.json 文件里的 scripts 属性配置指令：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs perl">&#123;<br><br>  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;build-browser&quot;</span>: <span class="hljs-string">&quot;rollup --config browser.rollup.config.js &quot;</span>,<br>、  &#125;,<br>  <span class="hljs-string">&quot;dependencies&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;@babel/runtime&quot;</span>: <span class="hljs-string">&quot;^7.14.6&quot;</span>,<br>    <span class="hljs-string">&quot;@rollup/plugin-json&quot;</span>: <span class="hljs-string">&quot;^4.1.0&quot;</span>,<br>    <span class="hljs-string">&quot;rollup-plugin-cleanup&quot;</span>: <span class="hljs-string">&quot;^3.2.1&quot;</span>,<br>    <span class="hljs-string">&quot;rollup-plugin-sizes&quot;</span>: <span class="hljs-string">&quot;^1.0.4&quot;</span>,<br>    <span class="hljs-string">&quot;tti-polyfill&quot;</span>: <span class="hljs-string">&quot;^0.2.2&quot;</span><br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>rollup 指令命令行常用的参数包括：</p><ul><li><code>-c</code>。指定 rollup 的配置文件。</li><li><code>-w</code>。监听源文件是否有改动，如果有改动，重新打包。</li><li><code>-f</code>。-f 参数是–format 的缩写，它表示生成代码的格式。</li><li><code>-o</code>。-o 指定了输出的路径<br>执行<code>npm run build-browser</code>即可打包完成，控制台会显示输出结果</li></ul><h2 id="输出代码格式说明"><a href="#输出代码格式说明" class="headerlink" title="输出代码格式说明"></a>输出代码格式说明</h2><p>通过配置文件，我们可以指定其输出 amd , cjs , esm , iife , umd , system 六种格式的文件。</p><h3 id="amd"><a href="#amd" class="headerlink" title="amd"></a>amd</h3><p>“Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。<br>打包后的代码其核心内容是一个全局方法 define。</p><p>define 方法可以有三个入参，以文章<a href="https://juejin.cn/post/7051236803344334862">说不清 rollup 能输出哪 6 种格式 😥 差点被鄙视</a>中的代码为例，分别是：</p><ul><li>模块名称 Test，如果没有指定不会出现</li><li>[exports, lodash] 分别表示模块的输出和外部依赖</li><li>代表模块的实际内容的一个匿名函数，一个以 exports 和 lodash 作为入参的方法。</li></ul><h4 id="运行方法"><a href="#运行方法" class="headerlink" title="运行方法"></a>运行方法</h4><p>调用打包后的模块内容时，需要执行以下操作：</p><ol><li>在浏览器内引入 require.js</li><li>通过 requirejs.config 方法定义全局的依赖</li><li>通过 requirejs.define 注册模块</li><li>通过 requirejs() 完成模块引入</li></ol><h4 id="适合场景"><a href="#适合场景" class="headerlink" title="适合场景"></a>适合场景</h4><p>只需要在浏览器端使用的场景。</p><h3 id="cjs"><a href="#cjs" class="headerlink" title="cjs"></a>cjs</h3><p>CommonJS 标准。是为了解决 node.js 在模块化上的缺失， 于 2009 年 10 月提出。所以并不能用于浏览器上。</p><h4 id="运行方法-1"><a href="#运行方法-1" class="headerlink" title="运行方法"></a>运行方法</h4><p>js 文件里使用 require 方法引入打包文件</p><h4 id="适合场景-1"><a href="#适合场景-1" class="headerlink" title="适合场景"></a>适合场景</h4><p>只需要在服务器端使用的场景。</p><h3 id="esm"><a href="#esm" class="headerlink" title="esm"></a>esm</h3><p>遵循 es6 模块化语法，通过 export 命令显式指定输出的代码，再通过 import 命令输入。</p><h4 id="运行方法-2"><a href="#运行方法-2" class="headerlink" title="运行方法"></a>运行方法</h4><p>如果需要在浏览器上使用，需要用<code>&lt;script type=&quot;module&quot;&gt;</code>标签才能支持模块引入语法，用<code>import ... from ...</code>导入代码。</p><h4 id="适合场景-2"><a href="#适合场景-2" class="headerlink" title="适合场景"></a>适合场景</h4><ol><li>还会被引用、二次编译的场景（如组件库等）</li><li>浏览器调试场景如 vite.js 的开发时</li><li>对浏览器兼容性非常宽松的场景。</li></ol><h3 id="iife"><a href="#iife" class="headerlink" title="iife"></a>iife</h3><p>IIFE 的全称是 “immediately invoked function expression”，即自执行函数。打包出来是一个匿名函数，对外部的依赖通过入参的形式传入该函数</p><h4 id="运行方法-3"><a href="#运行方法-3" class="headerlink" title="运行方法"></a>运行方法</h4><p>如果它没有其他依赖，只需要去引入文件，然后在 window 上取打包时命名的模块名即可。</p><p>jquery 就是典型的自执行函数模式，当你引入<code>http://cdn.bootcss.com/jquery/3.3.1/jquery.min.js</code>文件后，它就会挂在到 window.$ 上，可以直接在 js 文件使用 jquery 语法如<code>$(&#39;.input&#39;).addClass(&#39;test&#39;)</code></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p><strong>优点：</strong></p><ul><li>通过闭包营造了一个“私有”命名空间，防止影响全局，并防止被从外部修改私有变量。</li><li>简单易懂</li><li>对代码体积的影响不大<br><strong>缺点：</strong></li><li>输出的变量可能影响全局变量；引入依赖包时依赖全局变量。</li><li>需要使用者自行维护 script 标签的加载顺序。</li></ul><h4 id="适合场景-3"><a href="#适合场景-3" class="headerlink" title="适合场景"></a>适合场景</h4><p>适合部分场景作为 SDK 进行使用，尤其是需要把自己挂到 window 上的场景。</p><h3 id="umd"><a href="#umd" class="headerlink" title="umd"></a>umd</h3><p>umd 主要是处理兼容性问题，可以让模块同时兼容让模块同时兼容 AMD、CommonJs 和浏览器变量挂载的规范。</p><h4 id="运行方法-4"><a href="#运行方法-4" class="headerlink" title="运行方法"></a>运行方法</h4><ul><li>在浏览器端，它的运行方式可以和 amd 完全一致，也可以采用 iife 的调用方式</li><li>在 node.js 端，它则和 CommonJS 的运行方式完全一致</li></ul><h4 id="适合场景-4"><a href="#适合场景-4" class="headerlink" title="适合场景"></a>适合场景</h4><p>既可能在浏览器端也可能在 node.js 里使用的场景</p><h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><p>采用了 SystemJS 代码语法。由于很少使用该语法，这里暂时不展开。</p><h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><h3 id="resolve-插件"><a href="#resolve-插件" class="headerlink" title="resolve 插件"></a>resolve 插件</h3><h4 id="安装指令"><a href="#安装指令" class="headerlink" title="安装指令"></a>安装指令</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">npm i -D @rollup/plugin-<span class="hljs-keyword">node</span><span class="hljs-title">-resolve</span><br></code></pre></td></tr></table></figure><p><strong>注释</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"> <span class="hljs-selector-tag">i</span>  是 install 的简写<br>-S 就是 <span class="hljs-attr">--save</span> 的简写，安装的插件会被写入到 dependencies 区块里面去，在生产环境也存在对该包的依赖<br>-D 就是 <span class="hljs-attr">--save-dev</span> 的简写， 安装的插件会被写入到 devDependencies 域里面去，即插件只用于开发环境<br></code></pre></td></tr></table></figure><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>将我们编写的源码与依赖的第三方库代码进行合并，打包后的代码里会出现引用模块的代码。在使用 resolve 模块下，如果希望依赖的模块不被打包，保持外部引用状态时，就需要 config 文件使用 external 属性，来告诉 rollup.js 哪些是外部的类库。</p><h3 id="commonJs-插件"><a href="#commonJs-插件" class="headerlink" title="commonJs 插件"></a>commonJs 插件</h3><h4 id="安装指令-1"><a href="#安装指令-1" class="headerlink" title="安装指令"></a>安装指令</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i -D @rollup/plugin-commonjs<br></code></pre></td></tr></table></figure><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>rollup 编译源码中的模块引用默认只支持 ES6+的模块方式 import&#x2F;export。然而大量的 npm 模块是基于 CommonJS 模块方式，为支持这些模块的引入，支持 commonjs 语法的插件应运而生。</p><h3 id="babel-插件"><a href="#babel-插件" class="headerlink" title="babel 插件"></a>babel 插件</h3><h4 id="安装指令-2"><a href="#安装指令-2" class="headerlink" title="安装指令"></a>安装指令</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i -D @rollup/plugin-babel<br></code></pre></td></tr></table></figure><p>安装完成后在根目录文件夹下添加.babelrc 文件，配置内容</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>&#123;<br>  <span class="hljs-regexp">//</span> 开启默认预设<br>  <span class="hljs-string">&quot;presets&quot;</span>: [<br>    [<br>      <span class="hljs-string">&quot;@babel/env&quot;</span>,<br>      &#123;<br>        <span class="hljs-string">&quot;modules&quot;</span>: false  <span class="hljs-regexp">//</span> 关闭 esm 转化，统一交由 rollup 处理，防止冲突<br>      &#125;<br>    ]<br>  ],<br>  <span class="hljs-string">&quot;plugins&quot;</span>: [<span class="hljs-string">&quot;@babel/plugin-transform-runtime&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>完成后安装插件安装@babel&#x2F;core 和 @babel&#x2F;preset-env</p><h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><p>将代码中的 es6 语法转为 es5，防止打包后的模块在部分浏览器中无法正常运行</p><h3 id="typescript-插件"><a href="#typescript-插件" class="headerlink" title="typescript 插件"></a>typescript 插件</h3><h4 id="安装指令-3"><a href="#安装指令-3" class="headerlink" title="安装指令"></a>安装指令</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i -D @rollup/plugin-typescript<br></code></pre></td></tr></table></figure><p>该模块依赖于 tslib 和 typescript 模块，所以还需要再安装这两个组件。安装完后还需我们新建 tsconfig 配置，完成后才可在 package.json 的 plugins 配置该插件</p><h4 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h4><p>可以编译打包 ts 文件</p><h3 id="terser-插件"><a href="#terser-插件" class="headerlink" title="terser 插件"></a>terser 插件</h3><h4 id="安装指令-4"><a href="#安装指令-4" class="headerlink" title="安装指令"></a>安装指令</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i -D rollup-plugin-terser<br></code></pre></td></tr></table></figure><h4 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h4><p>压缩代码。rollup 中虽然也有 rollup-plugin-uglify 插件，但只适用于 es5 语法，所以还是需要 terser</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>（1）<a href="https://juejin.cn/post/6844904058394771470">Rollup 打包工具的使用（超详细，超基础，附代码截图超简单）</a><br>（2）<a href="https://juejin.cn/post/7051236803344334862">说不清 rollup 能输出哪 6 种格式 😥 差点被鄙视</a><br>（3）<a href="https://juejin.cn/post/6869551115420041229">一文带你快速上手 Rollup</a></p>]]></content>
    
    
    <categories>
      
      <category>前端技术体系</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rollup</tag>
      
      <tag>前端打包工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript基础</title>
    <link href="/unkown404.github.io/2022/06/18/javascript/"/>
    <url>/unkown404.github.io/2022/06/18/javascript/</url>
    
    <content type="html"><![CDATA[<h2 id="js-简介"><a href="#js-简介" class="headerlink" title="js 简介"></a>js 简介</h2><p>“解释型语言”，是通过解释器来实现的。运行过程：JS 代码-&gt;解析成 AST (期间伴随词法分析、语法分析)-&gt;生成字节码（V8）-&gt;生成机器码（编译器）</p><h2 id="js-数据类型"><a href="#js-数据类型" class="headerlink" title="js 数据类型"></a>js 数据类型</h2><ul><li>基本类型：null,undefined,string,bool,number,bigInt,symbol</li><li>引用类型：object,array,date</li></ul><p>存储位置：</p><ul><li>基本类型：栈，占据空间小，大小固定</li><li>引用类型：堆，占据空间大，大小不固定；栈中存储指向实体起始地址</li></ul><p>null vs undefined：null 是空对象，undefined 是声明的变量未定义</p><h2 id="js-类型判断"><a href="#js-类型判断" class="headerlink" title="js 类型判断"></a>js 类型判断</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>适用于判断基本类型，除 typeof null&#x3D;&#x3D;‘object’其他都可以识别</p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>使用于判断引用类型，其原理是是判断在其原型链中能否找到该类型的原型。</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myInstanceOf</span>(<span class="hljs-literal">left</span>,<span class="hljs-literal">right</span>)&#123;<br>  <span class="hljs-keyword">var</span> <span class="hljs-variable">prototype</span>=<span class="hljs-literal">right</span>.prototype<br>  <span class="hljs-keyword">var</span> <span class="hljs-variable">left</span>=<span class="hljs-literal">left</span>._proto_<br>  while(<span class="hljs-literal">true</span>)&#123;<br>    if(<span class="hljs-literal">left</span>==null||<span class="hljs-literal">left</span>==undefined)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><span class="hljs-comment">;</span><br>    if(<span class="hljs-literal">left</span>==prototype)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><span class="hljs-comment">;</span><br>    <span class="hljs-literal">left</span>=<span class="hljs-literal">left</span>._proto_<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call"></a>Object.prototype.toString.call</h3><p>辨析：为什么不直接用 obj.toString？<br>Array、Function 类型作为 Object 实例重写了 toString 方法</p><h3 id="延伸问题：数组判断"><a href="#延伸问题：数组判断" class="headerlink" title="延伸问题：数组判断"></a>延伸问题：数组判断</h3><ol><li>Array.isArray（arr）</li><li>arr instanceof Array</li><li>Object.prototype.toString.call（arr）</li></ol><h2 id="js-类型转换"><a href="#js-类型转换" class="headerlink" title="js 类型转换"></a>js 类型转换</h2><h3 id="其他类型转换为-boolean"><a href="#其他类型转换为-boolean" class="headerlink" title="其他类型转换为 boolean"></a>其他类型转换为 boolean</h3><table><thead><tr><th align="center">原类型</th><th align="center">boolean</th></tr></thead><tbody><tr><td align="center">false、null、undefined、0、’’、NaN</td><td align="center">false</td></tr><tr><td align="center">其他</td><td align="center">true</td></tr></tbody></table><h3 id="其他类型转换为-number"><a href="#其他类型转换为-number" class="headerlink" title="其他类型转换为 number"></a>其他类型转换为 number</h3><table><thead><tr><th align="center">原类型</th><th align="center">number</th></tr></thead><tbody><tr><td align="center">undefined</td><td align="center">NaN</td></tr><tr><td align="center">null</td><td align="center">0</td></tr><tr><td align="center">false</td><td align="center">0</td></tr><tr><td align="center">true</td><td align="center">1</td></tr><tr><td align="center">string</td><td align="center">NaN</td></tr><tr><td align="center">‘’</td><td align="center">0</td></tr><tr><td align="center">非空对象</td><td align="center">NaN</td></tr></tbody></table><h3 id="其他类型转换为-string"><a href="#其他类型转换为-string" class="headerlink" title="其他类型转换为 string"></a>其他类型转换为 string</h3><table><thead><tr><th align="center">原类型</th><th align="center">string</th></tr></thead><tbody><tr><td align="center">undefined</td><td align="center">‘undefined’</td></tr><tr><td align="center">null</td><td align="center">‘null’</td></tr><tr><td align="center">false</td><td align="center">‘false’</td></tr><tr><td align="center">true</td><td align="center">‘true’</td></tr><tr><td align="center">number</td><td align="center"><code>$&#123;number&#125;</code></td></tr><tr><td align="center">[ 1,2 ]</td><td align="center">‘1,2’</td></tr><tr><td align="center">非空对象</td><td align="center">[ object Object ]</td></tr></tbody></table><h3 id="x3D-x3D-强制转换规则"><a href="#x3D-x3D-强制转换规则" class="headerlink" title="&#x3D;&#x3D;强制转换规则"></a>&#x3D;&#x3D;强制转换规则</h3><p><img src="/unkown404.github.io/img/type-change.jpeg"><br>如图所示，主要有以下几个步骤：</p><ol><li>类型是否相同</li><li>是否 null&#x3D;&#x3D;undefined</li><li>string&#x3D;&#x3D;number？是的话统一 number</li><li>是否有 boolean？有的话 boolean 转 number</li><li>object&#x3D;&#x3D;string&#x2F;number&#x2F;symbol？是的话 object 返回原始类型比较</li><li>返回 false</li></ol><h4 id="object-转原始类型"><a href="#object-转原始类型" class="headerlink" title="object 转原始类型"></a>object 转原始类型</h4><ol><li>调用 valueOf，如果转换为基础类型，则返回</li><li>调用 toString，如果转换为基础类型，则返回</li><li>报错</li></ol><h4 id="x3D-x3D-与-Object-is-的区别"><a href="#x3D-x3D-与-Object-is-的区别" class="headerlink" title="&#x3D;&#x3D;与 Object.is 的区别"></a>&#x3D;&#x3D;与 Object.is 的区别</h4><p>&#x3D;&#x3D;存在隐形类型转换<br>使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，即不存在类型转换。它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。</p><h3 id="四则运算转换"><a href="#四则运算转换" class="headerlink" title="四则运算转换"></a>四则运算转换</h3><p>1）+情况一方是字符串，则字符串拼接；如果一方不是字符串或者数字，那么会将它转换为数字或者字符串<br>2）其他情况存在数字另一方则转数字</p><h2 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>定义：拷贝对象间享有相同的引用数据</p><ol><li><strong>Object.assign</strong></li><li><strong>…展开扩展符</strong></li><li><strong>slice、concat</strong></li></ol><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>定义：两个对象有各自的存储区间</p><ol><li><strong>JSON.stringify</strong><br>缺点：不能拷贝函数和循环引用</li><li>递归函数</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> deep<span class="hljs-constructor">CloneObj(<span class="hljs-params">obj</span>)</span>&#123;<br>  var newObj=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>is<span class="hljs-constructor">Array(<span class="hljs-params">obj</span>)</span>?<span class="hljs-literal">[]</span>:&#123;&#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj)&#123;<br>    <span class="hljs-keyword">if</span>(obj.has<span class="hljs-constructor">OwnProperty(<span class="hljs-params">key</span>)</span>)&#123;<br>      newObj<span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span>=typeof obj<span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span>==&#x27;<span class="hljs-keyword">object</span>&#x27;?deep<span class="hljs-constructor">CloneObj(<span class="hljs-params">obj</span>[<span class="hljs-params">key</span>])</span>:obj<span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span><br>    &#125;<br>  &#125;<br>  return newObj<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><p><strong>原型</strong>：<em>proto</em>指向的对象<br><strong>原型链</strong>：当对象某一属性在当前对象找不到时会沿<em>proto</em>属性向上一个对象查找，如果没有就沿着<em>proto</em>属性继续向上查找，这个查找依据的规则就是原型链<br><img src="/unkown404.github.io/img/proto-pic.jpg"></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-type">Child</span>.proto<span class="hljs-keyword">type</span>=new <span class="hljs-type">Parent</span>()<br></code></pre></td></tr></table></figure><p>基本思路：利用原型让一个引用类型继承另一个引用类型的属性和方法<br>特点：引用类型被共享，不可向父实例传参</p><h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span><span class="hljs-params">()</span>&#123;<br>  Parent.call(<span class="hljs-keyword">this</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>基本思路：在子类型的构造函数中调用超类型构造函数<br>特点：每次创建实例都会创建一次方法，不能继承原型属性或者方法。</p><h3 id="组合继承（原型链继承-构造函数继承）"><a href="#组合继承（原型链继承-构造函数继承）" class="headerlink" title="组合继承（原型链继承+构造函数继承）"></a>组合继承（原型链继承+构造函数继承）</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">Child()</span>&#123;<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Parent</span>.</span></span>call(this)<br>&#125;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Child</span>.</span></span>prototype=<span class="hljs-keyword">new</span> <span class="hljs-constructor">Parent()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Child</span>.</span></span>prototype.constructor=Child<br></code></pre></td></tr></table></figure><p>基本思路：使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。<br>特点：调用了两次父类函数</p><h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">object</span>(o)&#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title">F</span>()&#123;&#125;;<br>    F.prototype = o;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">new</span> F();<br>&#125;<br></code></pre></td></tr></table></figure><p>基本思路：可以基于已有的对象创建新的对象，同时还不必因此创建自定义类型。<br>特点：可以实现基于一个对象的简单继承，不必创建构造函数；但缺点类似原型链继承</p><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>基本思路：创建一个仅用于封装继承过程的函数，该函数在内部以某种方式增强对象，最后返回这个对象。<br>特点：在主要考虑对象而不是自定义类型和构造函数的情况下，实现简单的继承；缺点类似构造函数继承</p><h3 id="寄生组合型继承"><a href="#寄生组合型继承" class="headerlink" title="寄生组合型继承"></a>寄生组合型继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">extend</span>(<span class="hljs-params">subClass,superClass</span>)&#123;<br>  <span class="hljs-keyword">var</span> f=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;<span class="hljs-comment">//预防子类原型和父类原型共用，原型链不清</span><br>  f.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>=superClass.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br>  subClass.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>=<span class="hljs-keyword">new</span> <span class="hljs-title function_">f</span>()<br>  subClass.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>=subClass<br>  <span class="hljs-keyword">return</span> subClass<br>&#125;<br></code></pre></td></tr></table></figure><p>基本思路：继承原型时，继承的不是超类的实例对象，而是原型对象是超类原型对象的一个实例对象，这样就解决了基类的原型对象中增添了不必要的超类的实例对象中的所有属性的问题。<br>特点：解决了组合型调用 2 次父类构造函数的问题</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h3><p>this 指向最后调用它的对象</p><h3 id="改变-this-指向的方法"><a href="#改变-this-指向的方法" class="headerlink" title="改变 this 指向的方法"></a>改变 this 指向的方法</h3><p>1）箭头函数 2）call、apply、bind 3）new</p><h3 id="this-绑定"><a href="#this-绑定" class="headerlink" title="this 绑定"></a>this 绑定</h3><p>显式绑定：call、apply、bind<br>隐式绑定：直接被对象所包含的函数调用时<br>默认绑定：全局环境默认绑定到 window<br>new 绑定</p><h3 id="call-和-apply-区别"><a href="#call-和-apply-区别" class="headerlink" title="call 和 apply 区别"></a>call 和 apply 区别</h3><p>传入的参数不同，apply 传入 this 指向和参数数组（或类数组）两个变量；call 传入 this 指向和其他参数，传入的参数数量不固定</p><h3 id="call、apply、bind-的实现"><a href="#call、apply、bind-的实现" class="headerlink" title="call、apply、bind 的实现"></a>call、apply、bind 的实现</h3><ol><li>call</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">call</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>)&#123;<br>  <span class="hljs-keyword">var</span> context=context||<span class="hljs-variable language_">window</span><br>  context.<span class="hljs-property">fn</span>=<span class="hljs-variable language_">this</span><br>  <span class="hljs-keyword">var</span> args=[...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">var</span> res=context.<span class="hljs-title function_">fn</span>(...args)<br>  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span><br>  <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>apply</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">apply</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>)&#123;<br>  <span class="hljs-keyword">var</span> context=context||<span class="hljs-variable language_">window</span><br>  context.<span class="hljs-property">fn</span>=<span class="hljs-variable language_">this</span><br>  <span class="hljs-keyword">var</span> res<br>  <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>])&#123;<br>    res=context.<span class="hljs-title function_">fn</span>(...args)<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    res=context.<span class="hljs-title function_">fn</span>()<br>  &#125;<br>  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span><br>  <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>bind</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bind</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>)&#123;<br>  <span class="hljs-keyword">var</span> args=[...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>),_this=<span class="hljs-variable language_">this</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">// 函数作为构造函数时this指向改变</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> F)&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>(...args,...<span class="hljs-variable language_">arguments</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> _this.<span class="hljs-title function_">apply</span>(context,args.<span class="hljs-title function_">concat</span>(...<span class="hljs-variable language_">arguments</span>))<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>bind 多次时 this 的指向以第一次为准</p><h3 id="new-的过程"><a href="#new-的过程" class="headerlink" title="new 的过程"></a>new 的过程</h3><ol><li>创建新对象</li><li>对象原型指向构造函数 prototype</li><li>改变 this 指向</li><li>返回对象</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">create</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> obj=&#123;&#125;,<span class="hljs-title class_">Construct</span>=[].<span class="hljs-property">shift</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>)<br>  obj.<span class="hljs-property">_proto_</span>=<span class="hljs-title class_">Construct</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br>  <span class="hljs-keyword">var</span> res=<span class="hljs-title class_">Construct</span>.<span class="hljs-title function_">apply</span>(obj,<span class="hljs-variable language_">arguments</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> res===<span class="hljs-string">&#x27;object&#x27;</span>?<span class="hljs-attr">res</span>:obj<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="作用域相关"><a href="#作用域相关" class="headerlink" title="作用域相关"></a>作用域相关</h2><p>作用域：源码中定义变量的区域<br>词法作用域：函数的作用域在函数定义时决定<br>动态作用域：函数的作用域在函数调用时决定<br><strong>js 采用的是静态作用域，即函数的作用域在函数定义时就确定了。</strong></p><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>定义：当前代码的执行环境，包括全局上下文、函数上下文、eval 上下文</p><h4 id="执行上下文-3-个重要属性"><a href="#执行上下文-3-个重要属性" class="headerlink" title="执行上下文 3 个重要属性"></a>执行上下文 3 个重要属性</h4><ol><li>变量对象（VO）：存储了上下文定义的变量和函数声明</li><li>作用域链：一组对象列表，包括自身变量对象和指向父级变量对象作用域链属性</li><li>this</li></ol><h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><ol><li>进入执行上下文阶段<br>变量对象内容：</li></ol><ul><li>1）函数所有形参</li><li>2）函数声明：由函数名+对应值变成变量对象属性；若变量对象由同名属性，则替换该属性</li><li>3）变量声明：由变量名+undefined 变成变量对象属性；若变量名称与函数或形参相同，则不干扰已存在属性</li></ul><ol start="2"><li>代码执行：根据代码修改变量对象的值<br>PS：函数上下文的变量对象初始化只包括 arguments</li></ol><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>定义：可以获取其他函数内变量的函数<br>优点：1.可创建私有变量；2.防止全局变量污染；3.模仿块级作用域<br>缺点：容易内存泄露（eg.意外的全局变量、定时器未及时清理、闭包循环引用）</p><h3 id="偏函数与柯里化"><a href="#偏函数与柯里化" class="headerlink" title="偏函数与柯里化"></a>偏函数与柯里化</h3><p>偏函数：将一个 n 元函数转为 n-x 函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">partial</span>(<span class="hljs-params">fn</span>)&#123;<br>  <span class="hljs-keyword">var</span> args=[...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> newArgs=args.<span class="hljs-title function_">concat</span>([...<span class="hljs-variable language_">arguments</span>])<br>    <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,newArgs)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>柯里化：将一个 n 元函数转为 n 个一元函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">fn</span>)&#123;<br>  <span class="hljs-keyword">var</span> args=[...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> newArgs=args.<span class="hljs-title function_">concat</span>([...<span class="hljs-variable language_">arguments</span>])<br>    <span class="hljs-keyword">if</span>(newArgs.<span class="hljs-property">length</span>&lt;fn.<span class="hljs-property">length</span>)&#123;<br>      <span class="hljs-keyword">return</span> curry.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,fn,newArgs)<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,newArgs)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="JavaScript-异步编程"><a href="#JavaScript-异步编程" class="headerlink" title="JavaScript 异步编程"></a>JavaScript 异步编程</h3><h4 id="异步编程的实现方式"><a href="#异步编程的实现方式" class="headerlink" title="异步编程的实现方式"></a>异步编程的实现方式</h4><ul><li><strong>callback</strong>：多个回调函数嵌套的时候会造成回调函数地狱</li><li><strong>promise</strong>：使用 Promise 的方式可以将嵌套的回调函数作为链式调用。</li><li><strong>generator</strong>：可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。</li><li><strong>async</strong>：generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</li></ul><h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><h5 id="浏览器事件循环"><a href="#浏览器事件循环" class="headerlink" title="浏览器事件循环"></a>浏览器事件循环</h5><ul><li>macrotasks(宏任务):script(整体代码)、setTimeout、setInterval、setImmediate、I&#x2F;O、UI rendering</li><li>microtasks(微任务):process.nextTick、Promises、Object.observe、MutationObserver</li></ul><h6 id="浏览器循环机制"><a href="#浏览器循环机制" class="headerlink" title="浏览器循环机制"></a>浏览器循环机制</h6><p>JavaScript 有一个主线程和调用栈，所有的任务最终都会被放到调用栈等待主线程执行。宏任务会被放在调用栈中，按照顺序等待主线程依次执行。主线程之外存在一个回调队列，微任务有了结果后，会放入回调队列中。调用栈中任务执行完毕后，此时主线程处于空闲状态，会从回调队列中获取任务进行处理。上述过程不断重复。</p><ul><li>首先执行同步代码，这属于宏任务</li><li>当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行</li><li>执行所有微任务</li><li>当执行完所有微任务后，如有必要会渲染页面</li><li>然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 setTimeout 中的回调函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>)<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">async2</span>()<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 end&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async2 end&#x27;</span>)<br>&#125;<br><span class="hljs-title function_">async1</span>()<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Promise&#x27;</span>)<br>  <span class="hljs-title function_">resolve</span>()<br>&#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>)<br>  &#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)<br></code></pre></td></tr></table></figure><h6 id="概念区分：进程-vs-线程"><a href="#概念区分：进程-vs-线程" class="headerlink" title="概念区分：进程 vs 线程"></a>概念区分：进程 vs 线程</h6><p>进程：资源分配的基本单位<br>线程：cpu 调度的基本单位</p><h4 id="nodejs-事件循环"><a href="#nodejs-事件循环" class="headerlink" title="nodejs 事件循环"></a>nodejs 事件循环</h4><p>nodejs 的事件循环主要分为 6 个阶段：</p><ul><li>timers 阶段：这个阶段执行 timer（setTimeout、setInterval）的回调</li><li>I&#x2F;O callbacks：执行一些系统调用错误，比如网络通信的错误回调</li><li>idle,prepare：仅 node 内部使用</li><li>poll：获取新的 I&#x2F;O 事件, 适当的条件下 node 将阻塞在这里<br>1）有到期的定时器，执行定时器回调<br>2）处理 poll 队列：<ul><li>若队列为空：有 setImmediate 方法时 poll 阶段停止进入 check，执行回调；无 setImmediate 方法时等待新事件</li><li>若队列不为空：遍历回调队列并同步执行</li></ul></li><li>check：执行 setImmediate() 的回调</li><li>close callbacks：执行 socket 的 close 事件回调</li></ul><p><img src="/unkown404.github.io/img/eventLoop.png"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/6941194115392634888">「2021」高频前端面试题汇总之 JavaScript 篇（下）</a></p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动端开发的踩坑经历</title>
    <link href="/unkown404.github.io/2022/06/18/mobileBrowser/"/>
    <url>/unkown404.github.io/2022/06/18/mobileBrowser/</url>
    
    <content type="html"><![CDATA[<p>记录移动端开发时出现的各种兼容性问题。</p><span id="more"></span> <h2 id="问题1-部分模块在uc浏览器不显示"><a href="#问题1-部分模块在uc浏览器不显示" class="headerlink" title="问题1:部分模块在uc浏览器不显示"></a>问题1:部分模块在uc浏览器不显示</h2><p><strong>原因</strong>：uc浏览器内置样式文件，与自定义的样式文件存在覆盖关系。例如如果模块命名为ad-wrap，则该模块会被强制隐藏。</p><h2 id="问题2-使用em为单位的模块在qq浏览器上比例失效"><a href="#问题2-使用em为单位的模块在qq浏览器上比例失效" class="headerlink" title="问题2:使用em为单位的模块在qq浏览器上比例失效"></a>问题2:使用em为单位的模块在qq浏览器上比例失效</h2><p><strong>原因</strong>：父元素的font-size的赋值问题。有的浏览器会存在最小font-size，小于该阈值则设置无效。qq浏览器下font-size最小8px，所以父元素的font-size的设置不能小于8px</p><p><del>如果不是老项目的旧样式太多太难改了还是尽可能的用vw吧</del></p>]]></content>
    
    
    <categories>
      
      <category>踩坑经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React</title>
    <link href="/unkown404.github.io/2022/06/09/React/"/>
    <url>/unkown404.github.io/2022/06/09/React/</url>
    
    <content type="html"><![CDATA[<p>前端 react 框架方面知识整理。</p><span id="more"></span><h2 id="React相关基本概念"><a href="#React相关基本概念" class="headerlink" title="React相关基本概念"></a>React相关基本概念</h2><h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><h4 id="JSX定义"><a href="#JSX定义" class="headerlink" title="JSX定义"></a>JSX定义</h4><p>一个类似于XML的 JavaScript 的语法扩展。用js语法表示UI的类模版语言，用于创建虚拟DOM。</p><p>JSX的本质是React.createElement(component, props, …children)方法的语法糖。通过babel可以将jsx文件转为 React.createElement</p><h4 id="JSX语法特点"><a href="#JSX语法特点" class="headerlink" title="JSX语法特点"></a>JSX语法特点</h4><ul><li>只能有一个根元素</li><li>存在多行dom内容时，可以将内容包裹在括号中</li><li>标签首字母：<br>如果是小写字母开头，React则将改标签转为html中同名元素，若html没有同名标签，则报错<br>如果是大写字母开头，React就去渲染对应的组件，若组件没有定义，则报错</li><li>样式的类名指定不用class，要用className；style内部样式属性也同样用camelCase（小驼峰命名）来定义。这是因为jsx本质不是html</li><li>{}中不能写JS语句</li></ul><h3 id="受控组件和非受控组件"><a href="#受控组件和非受控组件" class="headerlink" title="受控组件和非受控组件"></a>受控组件和非受控组件</h3><p>受控组件：表单组件如<code>&lt;input&gt;&lt;select&gt;&lt;textearea&gt;</code>等元素受外部数据源state控制，更新只能通过onChange事件内部设置 setState()来更新。<br>非受控组件：表单组件是通过使用 ref 来从 DOM 节点中获取表单数据、defaultValue设置初始值。</p><p>根据React官方文档，绝大部分时候推荐使用受控组件来实现表单，因为在受控组件中，表单数据由React组件负责处理；如果选择受受控组件的话，表单数据就由DOM本身处理。</p><p>实际工作中，仅用于单次表单提交、提交时校验的情况使用非受控组件即可，其特点是更方便快捷，代码量小，但是控制能力比较弱。涉及对数据进行即时校验，格式化输入数据等需求，受控组件更适合使用，其控制能力强，但是代码量会比较多。在开发中应该权衡需求，进度进行相应的选择。</p><h3 id="react组件重新渲染的方式"><a href="#react组件重新渲染的方式" class="headerlink" title="react组件重新渲染的方式"></a>react组件重新渲染的方式</h3><ol><li>state 改变</li><li>props改变</li><li>forceUpdate</li><li>父组件重新渲染（即使传入子组件的 props 未发生变化，那么子组件也会重新渲染）<h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><h4 id="虚拟DOM实现原理"><a href="#虚拟DOM实现原理" class="headerlink" title="虚拟DOM实现原理"></a>虚拟DOM实现原理</h4>从本质上来说，Virtual Dom是一个JavaScript对象，通过对象的方式来表示DOM结构。将页面的状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。<h4 id="虚拟DOM优缺点"><a href="#虚拟DOM优缺点" class="headerlink" title="虚拟DOM优缺点"></a>虚拟DOM优缺点</h4>优点：</li><li>保证性能下限<br>在回流、重绘的情况下，真实DOM操作需要重建所有的DOM，而虚拟DOM操作可以用diff算法统一更新必要的DOM<br>Virtual DOM的更新DOM的准备工作耗费更多的时间，也就是JS层面，相比于更多的DOM操作它的消费是极其便宜的。</li><li>可以跨平台</li><li>无需手动操作DOM<br>缺点：</li><li>无法极致优化<h4 id="React-diff算法原理"><a href="#React-diff算法原理" class="headerlink" title="React diff算法原理"></a>React diff算法原理</h4></li></ol><ul><li>真实的 DOM 首先会映射为虚拟 DOM；</li><li>当虚拟 DOM 发生变化后，就会根据差距计算生成 patch，这个 patch 是一个结构化的数据，内容包含了增加、更新、移除等；</li><li>根据 patch 去更新真实的 DOM，反馈到用户的界面上。</li></ul><p>在 React16 之前，React 是直接递归渲染 vdom 的，setState 会触发重新渲染，对比渲染出的新旧 vdom，对差异部分进行 dom 操作。<br>在 React16 之后，为了优化性能，会先把 vdom 转换成 fiber，也就是从树转换成链表，然后再渲染。整体渲染流程分成了两个阶段：</p><p>render 阶段：从 vdom 转换成 fiber，并且对需要 dom 操作的节点打上 effectTag 的标记<br>commit 阶段：对有 effectTag 标记的 fiber 节点进行 dom 操作，并执行所有的 effect 副作用函数。</p><p>从 vdom 转成 fiber 的过程叫做 reconcile（调和），这个过程是可以打断的，由 scheduler 调度执行。</p><p>React 的 diff 算法是分成两次遍历的：<br><strong>第一轮遍历</strong>，一一对比 vdom 和老的 fiber，如果key和type相同则认为该节点可以复用、处理下一个节点，否则就结束遍历。<br>如果所有的新的 vdom 处理完了，那就把剩下的老 fiber 节点删掉就行。<br>如果还有 vdom 没处理，那就进行第二次遍历；<br><strong>第二轮遍历</strong>，主要是解决节点移动的问题：遍历新的 vdom 节点，每一个都去看看这个节点在旧fiber链中的位置（旧位置），如果旧位置在最新固定节点的右边，说明这个节点位置不变，就是可复用，移动过来打上更新的标记，并成为新的固定节点；如果旧位置在最新固定节点的左边，当前这个节点的位置要往右挪。最后把剩下的老 fiber 删掉，剩下的新 vdom 新增。</p><h4 id="React列表渲染为什么要用key？"><a href="#React列表渲染为什么要用key？" class="headerlink" title="React列表渲染为什么要用key？"></a>React列表渲染为什么要用key？</h4><p>diff 算法中通过 tag 和 key 来判断是否是同一个节点，因此必须用 key。且<br><a href="https://juejin.cn/post/7099745927413366797">key值最好不是 index</a>，因为列表依赖的数据长度可能会变化，而使用index作为key不能表征数据的变化，影响性能；在列表结构内部使用其他元素如input时diff算法会认为其没有发生变化，因此内部的数据也不会更新<br>key值也不能是random、不然会增加diff计算量</p><h2 id="React-事件机制"><a href="#React-事件机制" class="headerlink" title="React 事件机制"></a>React 事件机制</h2><h3 id="事件机制特点（以-react-16-为例）"><a href="#事件机制特点（以-react-16-为例）" class="headerlink" title="事件机制特点（以 react 16 为例）"></a>事件机制特点（以 react 16 为例）</h3><ol><li>在 jsx 文件中 onClick 或 onChange 绑定的事件处理函数,根本就没有注册到真实的 dom 上。是绑定在 document 上（react 17 以后是根节点上）统一管理的。</li><li>真实的 dom 上的 click 事件被单独处理,已经被 react 底层替换成空函数。</li><li>react 绑定的事件如 onChange，在 document 上，可能有多个事件与之对应。</li><li>react 并不是一开始，把所有的事件都绑定在 document 上，而是采取了一种按需绑定，比如发现了 onClick 事件,再去绑定 document click 事件。</li></ol><h3 id="事件机制流程"><a href="#事件机制流程" class="headerlink" title="事件机制流程"></a>事件机制流程</h3><h4 id="注册合成事件"><a href="#注册合成事件" class="headerlink" title="注册合成事件"></a>注册合成事件</h4><p>构建初始化 React 合成事件和原生事件的对应关系，合成事件和对应的事件处理插件关系。</p><h4 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h4><ol><li>react dom 对应的 fiber 会在 memoizedProps 和 pendingProps 保存事件</li><li>diff 阶段如果判断是 react 合成事件，则会按照事件系统逻辑单独处理。</li><li>根据 React 合成事件类型，找到对应的原生事件的类型，然后调用判断原生事件类型，大部分事件都按照冒泡逻辑处理，少数事件会按照捕获逻辑处理（比如 scroll 事件）。</li><li>调用 addTrappedEventListener 进行真正的事件绑定，绑定在 document 上，dispatchEvent 为统一的事件处理函数。</li></ol><h4 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h4><ol><li>以触发点击事件为例，首先执行的是 dispatchEvent 函数，该函数包括的操作有：<br>1）根据真实的事件源对象，找到 e.target 真实的 dom 元素。<br>2）根据 dom 元素，找到与它对应的 fiber 对象 targetInst，在我们 demo 中，找到 button 按钮对应的 fiber。<br>3）进入 react 的 legacy 模式，在这个模式下，批量更新。</li><li>执行事件对应的处理插件中的 extractEvents，模拟事件捕获-&gt;事件源-&gt;事件冒泡这一过程。具体操作：<br>1）形成合成事件源对象<br>2）每次 React 会从事件源开始，从上遍历类型为 hostComponent 即 dom 类型的 fiber,判断 props 中是否有当前事件比如 onClick,对于冒泡阶段的事件(onClick)，将 push 到执行队列后面 ， 对于捕获阶段的事件(onClickCapture)，将 unShift 到执行队列的前面。最终形成一个事件执行队列。<br>3）将事件执行队列，保存到 React 事件源对象上。等待执行。</li><li>runEventsInBatch 执行事件队列，如果发现阻止冒泡，那么 break 跳出循环，最后重置事件源，放回到事件池中，完成整个流程。</li></ol><h3 id="React-事件-vs-原生事件"><a href="#React-事件-vs-原生事件" class="headerlink" title="React 事件 vs 原生事件"></a>React 事件 vs 原生事件</h3><p>1）事件名称命名方式：原生事件为全小写，react 事件采用小驼峰<br>2）事件函数处理语法：原生事件为字符串，react 事件为函数<br>3）默认行为处理：react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用 preventDefault()来阻止默认行为<br>4）执行时机：两种事件同时存在时会先执行原生事件，再执行 react 合成事件<br>5）阻止冒泡行为的影响：原生事件（阻止冒泡）会阻止合成事件的执行，react 合成事件（阻止冒泡）不会阻止原生事件的执行</p><h3 id="react-使用合成事件的优点"><a href="#react-使用合成事件的优点" class="headerlink" title="react 使用合成事件的优点"></a>react 使用合成事件的优点</h3><ol><li>兼容所有浏览器，更好的跨平台；</li><li>将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。</li><li>方便 react 统一管理和事务机制。</li></ol><h2 id="React-Fiber"><a href="#React-Fiber" class="headerlink" title="React Fiber"></a>React Fiber</h2><p>React Fiber 并不是真正意义上的纤程（微线程、协程），而是一种基于浏览器的单线程调度算法：在这个过程中，React 渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。该算法依赖 requestIdleCallback（在一帧时间 16ms (1000ms &#x2F; 60)内，如果浏览器处理完包括用户输入、js 执行、动画、布局、绘制的任务之后，还有盈余时间，浏览器就会调用 requestIdleCallback 的回调）。</p><p>React V15 在渲染时，会递归比对 VirtualDOM 树，找出需要变动的节点，然后同步更新它们。在这个过程期间更新不能中断， 由于 React 占据着浏览器资源，用户触发的事件无法得到响应，导致用户感觉到卡顿。</p><p>而 Fiber 是一种将 reconciliation （递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢复。</p><h2 id="React-class-组件"><a href="#React-class-组件" class="headerlink" title="React class 组件"></a>React class 组件</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="/unkown404.github.io/img/life-cycle-detail.jpeg"><br>react 16.4 以上的生命周期如图所示，列举了常用的生命周期函数，主要分为 3 个阶段</p><h4 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h4><ul><li><strong>constructor</strong>：进行 state 的初始化，给事件处理方法绑定 this</li><li><strong>getDerivedStateFromProps</strong>：静态方法，会返回一个对象用于更新 state、或者返回 null 不更新。在接收到新的 props 或者调用了 setState 和 forceUpdate 时该函数会被调用。</li><li><strong>render</strong>：纯函数，根据 state 和 props 渲染组件。可返回的内容包括原生的 DOM、React 组件、Fragment、Portals、字符串和数字、Boolean 和 null 等</li><li><strong>componentDidMount</strong>：组件挂载完成后调用，可以进行以下操作：</li></ul><ol><li>执行依赖于 DOM 的操作；</li><li>发送网络请求；（官方建议）</li><li>添加订阅消息；（会在 componentWillUnmount 取消订阅）</li></ol><h4 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h4><p>当组件的 props 改变了，或组件内部调用了 setState&#x2F;forceUpdate，会触发更新重新渲染，这个过程可能会发生多次。</p><ul><li><strong>getDerivedStateFromProps</strong></li><li><strong>shouldComponentUpdate</strong>：有两个参数 nextProps 和 nextState，表示新的属性和变化之后的 state，返回一个布尔值，true 表示会触发重新渲染，false 表示不会触发重新渲染，默认返回 true,我们通常利用此生命周期来优化 React 程序性能</li><li><strong>render</strong></li><li><strong>getSnapshotBeforeUpdate</strong>：该函数有两个传入参数 prevProps 和 prevState，表示之前的属性和之前的 state，这个函数有一个返回值，会作为第三个参数传给 componentDidUpdate，通常默认会返回 null。此生命周期函数必须与 componentDidUpdate 搭配使用</li><li><strong>componentDidUpdate</strong>：该函数有 3 个传入参数 prevProps、prevState 和 snapshot。可以用于当组件更新后，对 DOM 进行操作或者 props 变化时执行网络请求</li></ul><h4 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h4><ul><li><strong>componentWillUnmount</strong>：主要操作包括</li></ul><ol><li>清除 timer，取消网络请求或清除</li><li>取消在 componentDidMount() 中创建的订阅等<br>这个生命周期在一个组件被卸载和销毁之前被调用，因此你不应该再这个方法中使用 setState。</li></ol><h3 id="废弃的生命周期"><a href="#废弃的生命周期" class="headerlink" title="废弃的生命周期"></a>废弃的生命周期</h3><h4 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a>componentWillMount</h4><p>在挂载阶段 render() 之前调用。可以使用 componentDidMount 和 constructor 来代替</p><h4 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a>componentWillReceiveProps</h4><p>props 更新时调用此方法用于更新 state。会破坏 state 数据的单一数据源，导致组件状态变得不可预测，另一方面也会增加组件的重绘次数。如果在 componentWillReceiveProps 生命周期直接调用父组件的某些有调用 setState 的函数，会导致程序死循环。可以使用 getDerivedStateFromProps 来代替</p><h4 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a>componentWillUpdate</h4><p>在更新阶段组件渲染 render()之前调用，通常，此方法可以替换为 componentDidUpdate()和 getSnapshotBeforeUpdate()。</p><p>对于异步渲染情况，渲染可分为两个阶段：reconciliation 和 commit 。前者过程是可以打断的，后者不能暂停，会一直更新界面直到完成。</p><table><thead><tr><th align="center">Reconciliation 阶段</th><th align="center">Commit 阶段</th></tr></thead><tbody><tr><td align="center">componentWillMount</td><td align="center">componentDidMount</td></tr><tr><td align="center">componentWillReceiveProps</td><td align="center">componentDidUpdate</td></tr><tr><td align="center">shouldComponentUpdate</td><td align="center">componentWillUnmount</td></tr><tr><td align="center">componentWillUpdate</td><td align="center"></td></tr></tbody></table><p>因为 Reconciliation 阶段是可以被打断的，所以 Reconciliation 阶段会执行的生命周期函数就可能会出现调用多次的情况，从而引起 Bug。由此对于 Reconciliation 阶段调用的几个函数，除了 shouldComponentUpdate 以外，其他都应该避免去使用。</p><h3 id="适合做异步请求的生命周期"><a href="#适合做异步请求的生命周期" class="headerlink" title="适合做异步请求的生命周期"></a>适合做异步请求的生命周期</h3><p>componentDidmount</p><h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><h4 id="setState用法"><a href="#setState用法" class="headerlink" title="setState用法"></a>setState用法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">setState</span>(object nextState[, <span class="hljs-keyword">function</span> callback])<br></code></pre></td></tr></table></figure><p>传入的参数包括：</p><ul><li>nextState，对象属性。将要设置的新状态，该状态会和当前的state合并</li><li>callback，回调函数。可选参数。该函数会在setState设置成功，且组件重新渲染后调用。等价于在 componentDidUpdate 生命周期内执行。在这个回调函数中你可以拿到更新后 state 的值。<h4 id="setState调用流程"><a href="#setState调用流程" class="headerlink" title="setState调用流程"></a>setState调用流程</h4>setState方法会将将新的 state 放进组件的状态队列里，等待合适的时机，批量更新state，重新构建 React 元素树并且着手重新渲染整个UI界面。<h4 id="setState同步还是异步"><a href="#setState同步还是异步" class="headerlink" title="setState同步还是异步"></a>setState同步还是异步</h4>setState 并不是单纯同步&#x2F;异步的，它的表现会因调用场景的不同而不同。在源码中，通过 isBatchingUpdates 来判断setState 是先存进 state 队列还是直接更新，如果值为 true 则执行异步操作，为 false 则直接更新。</li></ul><p>“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值。</p><p>异步： 在 React 可以控制的地方，就为 true，比如在 React 生命周期事件和合成事件中，都会走合并操作，延迟更新的策略。<br>同步： 在 React 无法控制的地方，比如原生事件，具体就是在 addEventListener 、setTimeout、setInterval 等事件中，就只能同步更新。</p><h2 id="React函数组件"><a href="#React函数组件" class="headerlink" title="React函数组件"></a>React函数组件</h2><h2 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h2><h3 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h3><p>父组件-&gt;子组件：通过 props 传递数据给子组件<br>子组件-&gt;父组件：子组件通过调用父组件传来的函数传递数据给父组件</p><h3 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h3><p>可以通过共同的父组件来管理状态和事件函数。比如说其中一个兄弟组件调用父组件传递过来的事件函数修改父组件中的状态，然后父组件将状态传递给另一个兄弟组件。</p><h3 id="跨多层次组件通信"><a href="#跨多层次组件通信" class="headerlink" title="跨多层次组件通信"></a>跨多层次组件通信</h3><p>可以使用Context API</p><h3 id="任意组件"><a href="#任意组件" class="headerlink" title="任意组件"></a>任意组件</h3><p>可以通过 Redux 或者 Event Bus 解决，另外如果你不怕麻烦的话，可以使用这种方式解决上述所有的通信情况</p><h2 id="React-生态"><a href="#React-生态" class="headerlink" title="React 生态"></a>React 生态</h2><h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/7068649069610024974">React 事件机制</a><br>（2）<a href="https://juejin.cn/post/6955636911214067720">「react 进阶」一文吃透 react 事件系统原理</a><br>（3）<a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">react 生命周期</a><br>（4）<a href="https://juejin.cn/post/6940942549305524238">「2021」高频前端面试题汇总之React篇（下）</a><br>（5）<a href="https://juejin.cn/post/7131741751152214030">图解 React 的 diff 算法：核心就两个字 —— 复用</a><br>（6）<a href="https://juejin.cn/post/6919302952486174733">深入理解React Diff算法</a></p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML/CSS</title>
    <link href="/unkown404.github.io/2022/06/07/HTML/"/>
    <url>/unkown404.github.io/2022/06/07/HTML/</url>
    
    <content type="html"><![CDATA[<p>前端HTML&#x2F;CSS方面知识整理。</p><span id="more"></span><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="html5-0-新特性"><a href="#html5-0-新特性" class="headerlink" title="html5.0 新特性"></a>html5.0 新特性</h2><ol><li>语义化标签</li><li>拖拽释放 API</li><li>媒体标签</li><li>表单控件</li><li>数据存储 localStorage、sessionStorage</li></ol><h2 id="html5-0-移除特性"><a href="#html5-0-移除特性" class="headerlink" title="html5.0 移除特性"></a>html5.0 移除特性</h2><ol><li>纯表现标签</li><li>产生负面影响标签</li></ol><h2 id="语义化标签特点"><a href="#语义化标签特点" class="headerlink" title="语义化标签特点"></a>语义化标签特点</h2><ol><li>对机器友好，有利于 SEO 和堵屏软件解析</li><li>对开发者友好增加可读型</li></ol><h2 id="HTML-元素"><a href="#HTML-元素" class="headerlink" title="HTML 元素"></a>HTML 元素</h2><p>行内元素：多个行内元素可占一行，只能设置 padding、margin 左右<br>块元素：一个块元素占一行，可设置宽高</p><h2 id="src-和-href-区别"><a href="#src-和-href-区别" class="headerlink" title="src 和 href 区别"></a>src 和 href 区别</h2><ol><li>资源类型：src 是资源引用，href 是超文本引用</li><li>解析资源方式：浏览器解析 src 资源时会暂停其他资源下载，直至该资源下载执行完毕；href 时浏览器会并行下载资源，不停止文档解析</li></ol><h2 id="script-标签中-defer-和-async-的区别"><a href="#script-标签中-defer-和-async-的区别" class="headerlink" title="script 标签中 defer 和 async 的区别"></a>script 标签中 defer 和 async 的区别</h2><p><strong>defer</strong>：script 下载不会打断 html 解析，在 html 解析完成之后 script 会按顺序执行<br><strong>async</strong>：script 下载会打断 html 解析，先加载完先执行</p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="css-新特性"><a href="#css-新特性" class="headerlink" title="css 新特性"></a>css 新特性</h2><ol><li>圆角、文字特效、渐变、动画</li><li>选择器 eg. last-child</li><li>媒体查询</li><li>多栏布局</li><li>flex 布局</li></ol><h2 id="css-选择器"><a href="#css-选择器" class="headerlink" title="css 选择器"></a>css 选择器</h2><h3 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h3><p>!important &gt; 内联 &gt; id &gt; class &gt; tag &gt; *</p><h3 id="伪元素-vs-伪类"><a href="#伪元素-vs-伪类" class="headerlink" title="伪元素 vs 伪类"></a>伪元素 vs 伪类</h3><p>伪元素（eg. ::after）：该元素在 dom 树下不存在，仅在 css 下渲染<br>伪类（eg. :hover）：为已存在的元素设置样式</p><h2 id="css-属性相关"><a href="#css-属性相关" class="headerlink" title="css 属性相关"></a>css 属性相关</h2><p><strong>position 属性</strong><br>static：默认<br>absolute：脱离文档流，相对非 static 父元素<br>fixed：脱离文档流，相对浏览器窗口<br>relative：相对原位置定位<br>sticky：须指定 top、left、right、bottom，跨域特定阈值前是 relative，之后是 fixed<br><strong>line-height 属性</strong><br>子元素如何继承父元素 line-height 属性？</p><ol><li>父元素的 line-height 写了具体数值，比如 30px，则子元素 line-height 继承该值。</li><li>父元素的 line-height 写了比例，比如 1.5 或 2，则子元素 line-height 也是继承该比例。</li><li>父元素的 line-height 写了百分比，比如 200%，则子元素 line-height 继承的是父元素 font-size * 200% 计算出来的值。</li></ol><h2 id="css-布局"><a href="#css-布局" class="headerlink" title="css 布局"></a>css 布局</h2><h3 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h3><p><strong>容器属性</strong></p><ul><li>flex-direction：主轴方向，默认 row</li><li>flex-wrap：换行方式</li><li>flex-flow：flex-direction 属性和 flex-wrap 属性的简写形式</li><li>justify-content：主轴对齐方式</li><li>align-items：交叉轴对齐方式</li><li>align-content：多轴对齐方式<br><strong>item 属性</strong></li><li>order：项目的排列顺序。数值越小，排列越靠前，默认为 0。</li><li>flex-grow：项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。属性都为 1，则它们将等分剩余空间（如果有的话）</li><li>flex-shrink：属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。为 0 时即使空间不足也不缩小</li><li>flex-basis：在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小。</li><li>flex：flex 属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。flex 为 1 时对应 3 个值 1 1 0</li><li>align-self：单个项目有与其他项目不一样的对齐方式</li></ul><h3 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h3><p>宽高用百分比表示<br>子元素属性的百分比相对于父元素的宽：width,margin,padding,left,right<br>子元素属性的百分比相对于父元素的高：height,top,bottom</p><h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><p>利用媒体查询获取屏幕宽高再设置宽度区间</p><h3 id="自适应布局"><a href="#自适应布局" class="headerlink" title="自适应布局"></a>自适应布局</h3><p>根据分辨率创建多个静态布局</p><h3 id="弹性布局"><a href="#弹性布局" class="headerlink" title="弹性布局"></a>弹性布局</h3><p>以 rem 为单位（rem 相对于根元素 font-size，em 相对于父元素 font-size）</p><h3 id="vw-布局"><a href="#vw-布局" class="headerlink" title="vw 布局"></a>vw 布局</h3><p>使用 vw、vh 作为单位</p><h2 id="块级格式化上下文（BFC）"><a href="#块级格式化上下文（BFC）" class="headerlink" title="块级格式化上下文（BFC）"></a>块级格式化上下文（BFC）</h2><p>特点：有独立渲染的区域，子元素不会影响到区域外；2 个块元素在区域内垂直分布；计算高度时浮动元素的高度也代入计算；不与浮动元素重叠<br>触发条件：</p><ol><li>根元素</li><li>overflow 不为 visible</li><li>display 为 inline-block 或 table</li><li>position 为 absolute 或 fixed</li><li>float 不为 none</li></ol><h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><p>存在问题：父元素未设置高度且子元素浮动时父元素高度会坍塌<br>解决方法：</p><ol><li>父元素加高度</li><li>父元素加 float</li><li>父元素 overflow：hidden</li><li>增加 clear：both 空元素</li><li>父元素加伪元素</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span>&#123;<br>    zoom:<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span>&#123;<br>    <span class="hljs-attribute">content</span>:<span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-attribute">display</span>:block;<br>    <span class="hljs-attribute">height</span>:<span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">clear</span>:both;<br>    <span class="hljs-attribute">visibility</span>:hidden;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="外部引入-css-方式：link-vs-import"><a href="#外部引入-css-方式：link-vs-import" class="headerlink" title="外部引入 css 方式：link vs @import"></a>外部引入 css 方式：link vs @import</h2><ol><li>link 是 html 标签，@import 是 css 属性</li><li>link 可设置 rel，@import 只能引入 css</li><li>link 在页面加载时加载，@import 在加载完页面后加载</li><li>link 无兼容问题，@import 支持 IE5 以上</li><li>link 支持 js 控制 dom 改样式，@import 不支持</li></ol><h2 id="css-场景应用"><a href="#css-场景应用" class="headerlink" title="css 场景应用"></a>css 场景应用</h2><h3 id="画一个三角形-x2F-扇形"><a href="#画一个三角形-x2F-扇形" class="headerlink" title="画一个三角形&#x2F;扇形"></a>画一个三角形&#x2F;扇形</h3><p>思路：div 的宽高设置为 0，border 的宽度设置大一点，除一边外其余边颜色透明；扇形需要有 border-radius</p><h3 id="宽高自适应的正方形"><a href="#宽高自适应的正方形" class="headerlink" title="宽高自适应的正方形"></a>宽高自适应的正方形</h3><p>width：30vw；height：30vw；</p><h3 id="多行文本溢出"><a href="#多行文本溢出" class="headerlink" title="多行文本溢出"></a>多行文本溢出</h3><p>overflow:hidden;<br>text-overflow:ellipsis;<br>display:-webkit-box;<br>-webkit-box-orient:vertical;<br>-webkit-line-clamp:3;</p><h3 id="居中方式"><a href="#居中方式" class="headerlink" title="居中方式"></a>居中方式</h3><h4 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h4><p>1）行内元素：text-align：center；<br>2）块元素：margin：0 auto；<br>3）position：absolute；left：50%；transform：translateX（-50%）；<br>4）display：flex；justify-content：center；</p><h4 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h4><p>1）单行文本：line-height&#x3D;height<br>2）display：table-cell；vertical-align：middle；<br>3）position：absolute；top：50%；transform：translateY（-50%）；<br>4）display：flex；align-items：center；</p><h4 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h4><p>1）margin：auto；left：0；right：0；top：0；bottom：0；<br>2）position：absolute；left：50%；top：50%；transform：translate（-50%，-50%）；<br>3）display：flex；align-items：center；justify-content：center；</p><h3 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h3><p>1）float+margin<br>2）float+overflow<br>3）grid-template-columns<br>4）flex<br>5）absolute*2</p><h3 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h3><h3 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#wrapper</span>&#123;<span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;<span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;<span class="hljs-attribute">height</span>:<span class="hljs-number">50px</span>;&#125;<br> <span class="hljs-selector-id">#center</span>&#123;<span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span> <span class="hljs-number">100px</span> <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;&#125;<br><span class="hljs-selector-id">#left</span>&#123;<span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;<span class="hljs-attribute">margin-left</span>:-<span class="hljs-number">100%</span>;<span class="hljs-attribute">width</span>:<span class="hljs-number">200px</span>;<span class="hljs-attribute">height</span>:<span class="hljs-number">50px</span>;&#125;<br><span class="hljs-selector-id">#right</span>&#123;<span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;<span class="hljs-attribute">margin-left</span>:-<span class="hljs-number">100px</span>;<span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;<span class="hljs-attribute">height</span>:<span class="hljs-number">50px</span>;&#125;<br></code></pre></td></tr></table></figure><h3 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#parent</span>&#123;<span class="hljs-attribute">height</span>:<span class="hljs-number">50px</span>;<span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span> <span class="hljs-number">100px</span> <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;&#125;<br> <span class="hljs-selector-id">#center</span>&#123;<span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;<span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;<span class="hljs-attribute">height</span>:<span class="hljs-number">50px</span>;&#125;<br> <span class="hljs-selector-id">#left</span>&#123;<span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;<span class="hljs-attribute">margin-left</span>:-<span class="hljs-number">100%</span>;<span class="hljs-attribute">width</span>:<span class="hljs-number">200px</span>;<span class="hljs-attribute">height</span>:<span class="hljs-number">50px</span>;<span class="hljs-attribute">position</span>:relative;<span class="hljs-attribute">left</span>:-<span class="hljs-number">200px</span>;&#125;<br> <span class="hljs-selector-id">#right</span>&#123;<span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;<span class="hljs-attribute">margin-left</span>:-<span class="hljs-number">100px</span>;<span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;<span class="hljs-attribute">height</span>:<span class="hljs-number">50px</span>;<span class="hljs-attribute">position</span>:relative;<span class="hljs-attribute">right</span>:<span class="hljs-number">100px</span>;&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>表单提交功能的注意事项</title>
    <link href="/unkown404.github.io/2022/06/05/formSubmit/"/>
    <url>/unkown404.github.io/2022/06/05/formSubmit/</url>
    
    <content type="html"><![CDATA[<p>表单提交的操作可以被多个元素触发，包括 input、button、回车键等，需要辨析其中的区别。</p><span id="more"></span><h2 id="input-type-x3D-”submit”"><a href="#input-type-x3D-”submit”" class="headerlink" title="input[type&#x3D;”submit”]"></a>input[type&#x3D;”submit”]</h2><p>如果将 input 的 type 设置为 submit 的话，该组件会变成一个按钮。以下面的代码为例：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata">&lt;<span class="hljs-keyword">form</span>&gt;<br>  &lt;<span class="hljs-keyword">input</span> name=<span class="hljs-string">&quot;name&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;提交&quot;</span>&gt;<br>&lt;/<span class="hljs-keyword">form</span>&gt;<br></code></pre></td></tr></table></figure><p>input 的 type 默认值为 text，所以第一个 input 显示为文本框。input 设置 type&#x3D;submit 后，输入控件会变成一个按钮，显示的文字为其 value 值，默认值是 Submit。<br>form 具有属性 method，默认值为 GET，所以提交后会使用 GET 方式进行页面跳转。<br>在上述表单中如果输入 111111 后提交则 url 会变更为&#x2F;?name&#x3D;111111</p><h2 id="button"><a href="#button" class="headerlink" title="button"></a>button</h2><p>button 也具有 type 和 value 属性，除 IE 浏览器以外 type 都默认 submit。所以会触发表单提交。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;name&#x27;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>确定<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="回车提交"><a href="#回车提交" class="headerlink" title="回车提交"></a>回车提交</h2><p>当表单中只有一个单行 input 的时候可以用回车提交。</p><p>以上提交操作都涉及到 URL 的改变，触发页面刷新。如果希望阻止页面的默认提交、自己设计提交逻辑，可以在 form 的 onsubmit 属性对应的函数内部添加<code>e.preventDefault();</code>来阻止页面提交刷新。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>（1）<a href="https://www.yisu.com/zixun/118760.html">html 中 input submit、button 和回车键提交数据的示例分析</a><br>（2）<a href="https://blog.csdn.net/weixin_33974433/article/details/93702424">react 监听 移动端 手机键盘 enter 事件</a></p>]]></content>
    
    
    <categories>
      
      <category>踩坑经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/unkown404.github.io/2022/05/30/networkBasic/"/>
    <url>/unkown404.github.io/2022/05/30/networkBasic/</url>
    
    <content type="html"><![CDATA[<h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><h3 id="网络模型一览"><a href="#网络模型一览" class="headerlink" title="网络模型一览"></a>网络模型一览</h3><table style="text-align:center;">    <tr>         <th>OSI模型</th>      <th>五层模型</th>        <th>TCP/IP模型</th>   </tr>   <tr>       <td>应用层</td>           <td rowspan="3">应用层</td>           <td rowspan="3">应用层</td>   </tr>   <tr>       <td>表示层</td>   </tr>   <tr>       <td>会话层</td>   </tr>   <tr>       <td>传输层</td>           <td>传输层</td>           <td>传输层</td>   </tr>   <tr>       <td>网络层</td>           <td>网络层</td>           <td>网络层</td>   </tr>   <tr>       <td>数据链路层</td>           <td>数据链路层</td>           <td rowspan="2">网络接口层</td>   </tr>    <tr>       <td>物理层</td>           <td>物理层</td>   </tr></table><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>功能：为应用进程提供服务。<br>示例：http、ftp、dns</p><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>特点：无状态、无连接、灵活简单</p><h5 id="HTTP-版本"><a href="#HTTP-版本" class="headerlink" title="HTTP 版本"></a>HTTP 版本</h5><p><strong>HTTP1.0</strong>:默认短连接；支持 get、post；资源全请求；<br><strong>HTTP1.1</strong>:默认长连接（connection 为 keep-alive）；支持 put、options、head；资源可请求部分；请求和响应必包含 host、区分同一主机不同虚拟主机域名<br><strong>HTTP2.0</strong>:<br>1）二进制分帧；<br>2）多路复用：一个连接里客户端和浏览器可同时发送多个请求，无需按顺序一一对应，依赖于二进制分帧头部信息标记自己属于哪个流；<br>3）头部压缩；<br>4）服务器推送；<br><em>（HTTP2.0 存在问题：队头阻塞，出现丢包时整个 TCP 连接等待重传）</em><br><strong>HTTP3.0</strong>:QUIC，基于 UDP，省去握手时间，可多路复用不会队头阻塞</p><h5 id="HTTP-vs-HTTPS"><a href="#HTTP-vs-HTTPS" class="headerlink" title="HTTP vs HTTPS"></a>HTTP vs HTTPS</h5><p>1）安全性：http 明文传送，https 有 SSL 加密<br>2）费用：https 需要 CA 证书<br>3）端口号：http 端口号 80，https 端口号 443</p><h5 id="HTTPS-加密方式"><a href="#HTTPS-加密方式" class="headerlink" title="HTTPS 加密方式"></a>HTTPS 加密方式</h5><p>1）客户端预先向服务端发送其支持的加密协议及版本<br>2）server-client：服务端发送证书和公钥到客户端<br>3）客户端向证书认证机构确认公钥的真实性<br>4）client-server：客户端用公钥加密通话公钥给服务端<br>5）服务端用私钥解密后获得通话公钥<br>6）使用通话密钥对称加密信息</p><h5 id="HTTP-报文格式"><a href="#HTTP-报文格式" class="headerlink" title="HTTP 报文格式"></a>HTTP 报文格式</h5><p>HTTP 请求报文：请求方法+URI+协议版本+请求首部字段+内容<br>HTTP 响应报文：协议版本+状态码+响应首部字段+实体</p><h5 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h5><p>post vs get：<br>1）长度：get 传递大小受 URL 长度限制（来自浏览器），post 可传递更多<br>2）安全性：get 相对于 post 不安全<br>3）缓存：浏览器对 get 请求缓存，post 不会<br>4）幂等性：get 又幂等性，post 没有，post 可能会改写资源<br>5）回退刷新时：get 无影响、post 会再提交</p><h5 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h5><p><strong>1xx</strong>：信息<br>100 - continue<br><strong>2xx</strong>：成功<br>200 - OK<br>204 - no content<br><strong>3xx</strong>：重定向<br>301 - permanently moved<br>302 - found（不会像 301 一样更新书签）<br>304 - not modified<br><strong>4xx</strong>：客户端错误<br>400 - bad request<br>401 - unauthorized<br>403 - forbidden<br>404 - not found<br><strong>5xx</strong>：服务器错误<br>500 - internal error<br>502 - bad gateway</p><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><h5 id="DNS-域名解析"><a href="#DNS-域名解析" class="headerlink" title="DNS 域名解析"></a>DNS 域名解析</h5><p>1）查看本地 hosts 文件是否有映射<br>2）本地 DNS 解析缓存是否有 IP 映射<br>3）查询本地 DNS 服务器<br>4）设置本地 DNS 服务器查询方式：</p><ul><li>转发模式：请求层层上传</li><li>非转发模式：请求直接给根服务器</li></ul><h6 id="DNS-查询方式"><a href="#DNS-查询方式" class="headerlink" title="DNS 查询方式"></a>DNS 查询方式</h6><ul><li>迭代查询：根 DNS 返回给本地 DNS 下一个管理域名的 DNS 地址，让本地 DNS 向该 DNS 查询</li><li>递归查询：DNS 代替主机进行域名查询</li></ul><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>功能：为进程提供数据传输服务<br>示例：udp、tcp</p><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><h5 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h5><p>1）client-server：发送同步序列号 SYN，请求连接<br>2）server-client：收到请求，发送确认应答 SYN+ACK<br>3）client-server：发送确认 ACK，服务端确认后连接建立</p><h5 id="三次握手的原因"><a href="#三次握手的原因" class="headerlink" title="三次握手的原因"></a>三次握手的原因</h5><p>防止失效的请求连接到达服务器</p><h5 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h5><p>1）client-server：客户端发送请求释放报文<br>2）server-client：服务器收到请求，发送确认应答 ACK，客户端不能向服务器发送数据<br>3）server-client：服务器不需要连接、发送请求释放报文 FIN<br>4）client-server：发送确认应答 ACK，等待 2MSL 释放连接；服务器释放连接</p><h5 id="四次挥手原因"><a href="#四次挥手原因" class="headerlink" title="四次挥手原因"></a>四次挥手原因</h5><p>服务器收到释放报文的时候还要传数据，不能立即响应</p><h5 id="TCP-可靠性原因"><a href="#TCP-可靠性原因" class="headerlink" title="TCP 可靠性原因"></a>TCP 可靠性原因</h5><ul><li>1.超时重传</li><li>2.确认应答</li><li>3.流量控制：发送窗由接收窗剩余大小决定，发送端收到应答后会移动窗口</li><li>4.拥塞机制：<br>1）慢开始和拥塞避免：初始窗为 1，每经过一次 RTT 翻倍窗口，至阈值时窗口变化由翻倍变为+1；超时后阈值减半、窗口大小恢复初始<br>2）快重传和快恢复：收到 3 个重复确认后立即重传未收到的报文；阈值设为窗口一半，直接拥塞避免算法</li></ul><h5 id="TCP-vs-UDP"><a href="#TCP-vs-UDP" class="headerlink" title="TCP vs UDP"></a>TCP vs UDP</h5><p>1）tcp 面向连接，udp 无连接<br>2）tcp 面向字节流，udp 面向报文<br>3）tcp 点对点，udp 支持一对一、一对多<br>4）tcp 首部至少 20 字节、udp 首部 8 字节<br>5）tcp 可靠交付，udp 不可靠交付</p><p>tcp 支持的协议：telnet、ftp、smtp、http<br>udp 支持的协议：nfs、snmp、dns、tftp</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>功能：为主机提供数据传输服务<br>示例：路由、ip</p><h3 id="数据链层"><a href="#数据链层" class="headerlink" title="数据链层"></a>数据链层</h3><p>功能：将网络层的 IP 数据报封装成帧，在链路节点传输数据</p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>功能：确保数据在物理媒介上传输</p><h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><h3 id="xss-跨站脚本攻击"><a href="#xss-跨站脚本攻击" class="headerlink" title="xss 跨站脚本攻击"></a>xss 跨站脚本攻击</h3><p>将可执行代码注入到网页中<br>分类：<br>1）存储型：作用于数据库<br>2）反射型：作用于 URL<br>3）DOM 型：作用于 js<br>解决方法：<br>1）转义字符<br>2）设置 content-security-policy<br>3）cookie 设置 httpOnly</p><h3 id="CSRF-跨站请求伪造"><a href="#CSRF-跨站请求伪造" class="headerlink" title="CSRF 跨站请求伪造"></a>CSRF 跨站请求伪造</h3><p>诱导用户跳转到三方网站获取到用户跳转前网站的登录态，冒充用户来攻击网站<br>解决方法：<br>1）token、验证码验证<br>2）cookie 的 same-site<br>3）referer 检查</p><p><strong>同源策略可以预防 csrf 吗？</strong></p><p>同源策略可以预防 csrf，但通过跨域方法可以绕过同源策略的限制</p><h3 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h3><p>设置透明按钮诱导用户点击<br>解决方法：<br>1）js 防御：监听到 iframe 点击后将跳转页置空<br>2）设置 X-FRAME-OPTIONS</p><h3 id="DDos-分布式拒绝服务"><a href="#DDos-分布式拒绝服务" class="headerlink" title="DDos 分布式拒绝服务"></a>DDos 分布式拒绝服务</h3><p>伪造大量 IP 发送请求<br>解决方法：<br>1）限制单 IP 请求次数<br>2）缩短超时时间</p><h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><p>中间人截取服务端公钥，伪造证书、密钥给服务器<br>解决方法：<br>1）增加安全信道</p><h2 id="CDN-内容分发网络"><a href="#CDN-内容分发网络" class="headerlink" title="CDN 内容分发网络"></a>CDN 内容分发网络</h2><p>定义：将缓存服务器分布到用户访问集中到地区或网络中，用户访问网站时将访问指向最近的缓存服务器 ip<br>A：dns 解析记录里原 ip 映射结果 cname：cdn 服务商地址<br>cdn 回源：缓存服务器没有符合请求的资源时会回到源服务器请求资源</p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器</title>
    <link href="/unkown404.github.io/2022/05/29/browser/"/>
    <url>/unkown404.github.io/2022/05/29/browser/</url>
    
    <content type="html"><![CDATA[<p>浏览器相关知识点。</p><span id="more"></span><h2 id="浏览器存储"><a href="#浏览器存储" class="headerlink" title="浏览器存储"></a>浏览器存储</h2><table><thead><tr><th align="center"></th><th align="center">cookie</th><th align="center">localStorage</th><th align="center">sessionStorage</th><th align="center">indexDB</th></tr></thead><tbody><tr><td align="center">生命周期</td><td align="center">服务器生成，可没过期时间</td><td align="center">一直存在</td><td align="center">会话结束后清理</td><td align="center">一直存在</td></tr><tr><td align="center">存储大小</td><td align="center">4KB</td><td align="center">5MB</td><td align="center">5MB</td><td align="center">无限</td></tr><tr><td align="center">服务端通信</td><td align="center">携带于 header 中</td><td align="center">不参与</td><td align="center">不参与</td><td align="center">不参与</td></tr></tbody></table><h3 id="cookie-属性"><a href="#cookie-属性" class="headerlink" title="cookie 属性"></a>cookie 属性</h3><p><strong>value</strong>：保存用户登录态<br><strong>httpOnly</strong>：js 不可访问<br><strong>secure</strong>：只能 https 携带<br><strong>same-site</strong>：是否允许跨站携带<br><strong>domain</strong>：哪个域的 cookie 是有效的</p><h4 id="辨析：跨域（cross-origin）和跨站（cross-site）的区别"><a href="#辨析：跨域（cross-origin）和跨站（cross-site）的区别" class="headerlink" title="辨析：跨域（cross origin）和跨站（cross site）的区别"></a>辨析：跨域（cross origin）和跨站（cross site）的区别</h4><p>同源是指两个 URL 的协议&#x2F;主机名&#x2F;端口一致。<br>同站只要两个 URL 的 eTLD+1 相同即可，不需要考虑协议和端口。其中，eTLD 表示有效顶级域名，注册于 Mozilla 维护的公共后缀列表（Public Suffix List）中，例如，<code>.com</code>、<code>.co.uk</code>、<code>.github.io</code> 等。eTLD+1 则表示，有效顶级域名+二级域名，例如 <code>taobao.com </code>等。</p><h3 id="cookie-vs-session"><a href="#cookie-vs-session" class="headerlink" title="cookie vs session"></a>cookie vs session</h3><ol><li>存储位置：cookie 在浏览器，session 在服务器</li><li>存储容量：cookie 4KB，session 无理论上限</li><li>存储内容：cookie 只保存 ascii 字符串，session 接受任何字符类型</li><li>隐私策略：cookie 只能在浏览器查看</li><li>有效期：cookie 受 expires、max-age 限制，session 受 sessionId</li></ol><h3 id="浏览器垃圾回收机制"><a href="#浏览器垃圾回收机制" class="headerlink" title="浏览器垃圾回收机制"></a>浏览器垃圾回收机制</h3><p>1）标记清除：进入环境的变量都标记为进入环境，变量所占内存不得释放；离开环境时标记离开环境<br>2）引用计数：变量引用时计数+1，取别的值-1，计数为 0 时释放内存（存在问题：循环引用）</p><h3 id="浏览器缓存位置"><a href="#浏览器缓存位置" class="headerlink" title="浏览器缓存位置"></a>浏览器缓存位置</h3><ol><li><strong>service worker</strong>：浏览器的独立线程，必须 https<br>实现缓存的方式：<br>1）注册 service worker<br>2）监听 install 事件，回调中缓存所需文件<br>3）拦截所有请求事件，查询是否有缓存</li><li><strong>memory cache</strong>：会随进程释放而释放</li><li><strong>disk cache</strong></li><li><strong>push cache</strong>：上述 3 种缓存都未命中时使用，只存在于会话中</li></ol><h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><ol><li>expires：http1.0 产物，格林威治时间</li><li>cache-control：http1.1 产物，max-age 单位 s</li></ol><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><ol><li>Last-Modified&#x2F;If-Modified-Since</li><li>ETag&#x2F;If-None-Matched：适用文件周期查看、内容没变的情况</li></ol><h4 id="刷新操作对缓存内容影响"><a href="#刷新操作对缓存内容影响" class="headerlink" title="刷新操作对缓存内容影响"></a>刷新操作对缓存内容影响</h4><p>正常操作（地址栏输入 url，跳转链接，前进后退等）：强制缓存有效，协商缓存有效。<br>手动刷新（f5，点击刷新按钮，右键菜单刷新）：强制缓存失效，协商缓存有效。<br>强制刷新（ctrl + f5，shift+command+r）：强制缓存失效，协商缓存失效。</p><h2 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h2><h3 id="回流-vs-重绘"><a href="#回流-vs-重绘" class="headerlink" title="回流 vs 重绘"></a>回流 vs 重绘</h3><p>回流：布局或集合地点属性改变<br>重绘：节点更改外观、不影响布局</p><p>重绘不会引起回流，回流一定会导致重绘</p><p>减少回流的方法：<br>1）transform 代替 top<br>2）visibility：hidden 代替 display：none<br>3）不用 table 布局<br>4）避免 css 表达式<br>5）动画选择 requestAnimationFrame</p><h3 id="浏览器从输入-URL-到返回页面的过程"><a href="#浏览器从输入-URL-到返回页面的过程" class="headerlink" title="浏览器从输入 URL 到返回页面的过程"></a>浏览器从输入 URL 到返回页面的过程</h3><p>1）DNS 解析网址<br>2）tcp3 次握手建立连接，发送 http 请求<br>3）解析 html 文件转换为 dom 树<br>4）解析 css 生成 css dom 树<br>5）dom 树和 css dom 树结合生成 render 树（过滤掉 display：none、head、script 等结构）<br>6）根据 render 树布局，gpu 绘制、合成图层，显示在屏幕</p><h3 id="浏览器同源策略"><a href="#浏览器同源策略" class="headerlink" title="浏览器同源策略"></a>浏览器同源策略</h3><p>协议、域名、端口号一致</p><h3 id="跨域方法"><a href="#跨域方法" class="headerlink" title="跨域方法"></a>跨域方法</h3><p>1）<strong>jsonp</strong>：script（img、link、iframe 可跨域）设置 script 的 src 为要访问的网址并设置回调函数接收数据。<br>特点：简单、兼容性好、但只能处理 get 请求</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonp</span>(<span class="hljs-params">url,callback,success</span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> script=<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>)<br>  script.src=<span class="hljs-built_in">url</span><br>  script.async=<span class="hljs-literal">true</span><br>  script.type=<span class="hljs-string">&#x27;text/javascript&#x27;</span><br>  <span class="hljs-built_in">window</span>[callback]=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<br>    success&amp;&amp;success(data)<br>  &#125;<br>  <span class="hljs-built_in">document</span>.body.append(script)<br>&#125;<br></code></pre></td></tr></table></figure><p>2）<strong>CORS</strong>：跨域资源共享。服务端设置 Access-Control-Allow-Origin<br>简单请求：</p><ol><li>使用 get、post、head 请求</li><li>content-type 仅限于 text&#x2F;plain,multipart&#x2F;form-data,application&#x2F;x-www-form-urlencoded</li><li>xmlHttpRequestUpload 没注册任何事件监听且可使用 xmlHttpRequest.upload 访问<br>复杂请求：<br>会使用 option 发预检请求、Access-Control—Request-Method 告知服务器实际使用的方法，Access-Control-Request-Header 告知服务器实际请求所携带自定义首部字段；预检请求完成后发送实际请求</li></ol><p>3）<strong>document.domain</strong>：只适用于二级域名相同的情况（备注：Chrome 101 版本开始，document.domain 将变为可读属性。即无法通过将两个页面的 document.domain 都设置为二级域名的方法绕过同源策略）<br>4）<strong>location.hash</strong>：通过中间页，不同域之间 iframe 用 location.hash 传值，相同域通过 js 访问<br>5）<strong>window.name</strong>：跨域数据由 iframe 的 window.name 从外域传到本地域，利用 window.name 在不同页面加载后仍然存在<br>6）<strong>postMessage</strong>：一个页面发信息，另一个页面监听该事件接收消息<br>7）<strong>nginx 反向代理</strong>：服务器代理目标服务器（eg.百度）将请求传给内部服务器</p><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><h3 id="事件的三个阶段"><a href="#事件的三个阶段" class="headerlink" title="事件的三个阶段"></a>事件的三个阶段</h3><ul><li>事件捕获</li><li>处于目标阶段</li><li>事件冒泡</li></ul><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>利用事件冒泡原理将监听注册在父元素上<br>优点：1）减少事件注册、减少内存消耗 2）新增对象时不需要加监听事件</p><h3 id="常见事件"><a href="#常见事件" class="headerlink" title="常见事件"></a>常见事件</h3><p>event.preventDefault()：阻止默认事件<br>event.stopPropagation()：阻止冒泡<br>event.stopImmediatePropagation()：阻止该节点其他注册事件及冒泡</p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红蓝宝书1000题个人知识点笔记</title>
    <link href="/unkown404.github.io/2022/05/29/JapaneseNotes/"/>
    <url>/unkown404.github.io/2022/05/29/JapaneseNotes/</url>
    
    <content type="html"><![CDATA[<h2 id="红蓝宝书1000题"><a href="#红蓝宝书1000题" class="headerlink" title="红蓝宝书1000题"></a>红蓝宝书1000题</h2><h3 id="unit-1（1-36）"><a href="#unit-1（1-36）" class="headerlink" title="unit 1（1-36）"></a>unit 1（1-36）</h3><p>化粧：けしょ</p><p>～からといって虽说因为。。。，但是。。。<br>～が、かといって虽然。。。，但是（也不）。。。前面接短句<br>N　＋　からいって从。。。来看</p><p>健康診断（固定搭配）</p><p>そそっかしい冒失的<br>心細い（こころぼそい）心中没底的，胆怯的</p><p>ｖ原形　＋　ことはない（建议）没必要。。。</p><p>船便：ふなびん<br>航空便：こうくうびん</p><p>突き当たる：碰撞<br>凭れる（もたれる）：倚靠<br>物語る：讲述</p><p>～折に：。。的时候<br>～ごとに：每。。。</p><p>余地（よち） 余裕（よゆう） 余る（あまる）</p><p>絞る（しぼる）：squeeze<br>縮める（ちぢめる）：shorten</p><p>大雨（おおあめ）ーーー小雨（こさめ）</p><p>せっせと：勤恳地<br>のろのろ：慢吞吞的</p><p>普遍的（ふへんてき）</p><p>賑わう（にぎわう）：热闹<br>栄える（さかえる）：繁荣</p><p>劣る（おとる）：比不上</p><h3 id="unit-2（37-72）"><a href="#unit-2（37-72）" class="headerlink" title="unit 2（37-72）"></a>unit 2（37-72）</h3><p>とっくに很早</p><p>感心する敬佩</p><p>列島（れっとう）</p><p>食事を済ませる 解决早餐<br>持たせる（もたせる）让。。拿着，维持</p><p>～どころか（A／NA／N）别说。。。，甚至。。<br>～ところが然而</p><p>慌ただしい（あわただし）<br>喧しい（やかましい）</p><p>ｖ（ます）＋さえすれば只要。。。就。。。<br>NA＋でこそあれ／ｖーます・Ｎ＋こそすれ只能是。。。，（其他不可能）</p><p>～ことに（は）（A&#x2F;NA-な／ｖ－た）令人。。。的是、、</p><p>夕立（ゆうだち）傍晚雷阵雨</p><p>～にかけて（は）在。。方面（优秀）<br>～と同時に。。的同时<br>～に至って到了。。阶段</p><p>大体（だいたい）　　大抵（たいてい）</p><p>縮む（ちぢむ）：（自动词）缩小 縮める（ちぢめる）：（他动词）使。。缩小　縮れる（ちぢれる）：卷曲</p><p>振り向く：回头</p><p>厳重（げんじゅう）严肃，严格</p><p>お目にかかる＝会う自谦语<br>お目にかける＝見せる自谦语<br>拝見する＝みる自谦语<br>申（もう）し上げる、申す＝いう自谦语<br>おる＝いる自谦语<br>ござる＝ある自谦语</p><h3 id="unit-3（73-108）"><a href="#unit-3（73-108）" class="headerlink" title="unit 3（73-108）"></a>unit 3（73-108）</h3><p>安易（あんい）</p><p>見積もりを出す：做预算，估价<br>料理を注文する</p><p>見合い相亲</p><p>一斉に（いっせいに）一起，同时<br>一向に（いっこうに）気にしない丝毫不在意</p><p>以上（は）既然。。。就。。。<br>以上に／の：超出。。。</p><p>実施（じっし）　施設（しせつ）</p><p>取り付ける<br>１）合意（ごうい）を取り付ける：达成一致<br>２）カメラを取り付ける：安装照相机</p><p>準備を整える（ととのえる）</p><p>手ごろな価格／サイズ 合适的价格&#x2F;尺寸<br>手軽：简便</p><p>～も～ば～も～：既。。。又。。。</p><p>“动词连用形+ている”或”动词连用形+よう(う)十とする(としている)”＋ところへ：正在……的时候……<br>ｖーた＋ところで：即使。。。也。。<br>～ところが：然而</p><p>負債（ふさい）　負傷（ふしょう）</p><p>傾く（かたむく）：歪斜，倾向　賛成に傾く</p><p>N＋の／ｖーた＋あげく接消极的结果<br>N＋反面，表示事物的正反面</p><p>N＋はおろか</p><ol><li>别说～；就是～也～；不用说是…；就连…也（～はもちろん</li><li>「Aは言うまでもなく、更にBも～」。）<br>10日はおろか、1月かかってもできない。&#x2F;别说10 天，就是一个月也完不成。<br>彼は汉字はおろか、ひらがなも书けない。&#x2F;他别说汉字了，就是平假名也不会写。<br>事故でけがをして、走ることはおろか歩くこともできない。&#x2F;在事故中受伤了，不要说是跑，连走路都不行了。</li></ol><p>N＋もとより<br>①当然；不用说。<br>②一开始就…；本来；原来。<br>◆彼はアメリカはもとより日本にも行ったことがない。<br>别说去美国，他连日本都没去过</p><p>全滅（ぜんめつ）　絶滅（ぜつめつ）<br>勤続（きんぞく）：连续工作　勤続年数<br>連続（れんぞく）：持续　連続ドラマ　連続関数　火事が連続して起こる</p><p>ながら：接在名詞、動詞［ます］形（连用形）&#x2F;ない形（未然形）、形容詞终止形、形容动词词干的后面。<br>ものの：接在名詞+である、動詞・形容詞・形容动词连体形后面<br>ものの的转折口气要比ながら强很多，意为“一般来说，有了前者，自然而然地就会有后者，但出乎意料地不是”这个意思（带因果）</p><p>目前（もくぜん）に迫る<br>手前にある箸</p><p>～わけではない并不是<br>～ものではない不应该</p><h3 id="unit-4-109-144"><a href="#unit-4-109-144" class="headerlink" title="unit 4(109-144)"></a>unit 4(109-144)</h3><p>親孝行（おやこうこう）　親しむ（したしむ）</p><p>取り替える　電池を取り替える　<br>取り消す　注文を取り消す<br>取り入れる　先進技術を取り入れる</p><p>名詞「の形」+うえで<br>動詞「た形」+うえで<br>動詞「た形」+うえでの+名詞<br>意思：<br>表示同一个人做完前项之后再采取下一步行动。而且前项的动作或行为是为后项做准备的。主要用于口语。“……之后” 。</p><p>名詞「の形」＋もとで…<br>在…下…（在某影响所及的范围里）<br>◆彼女は厳格(げんかく)な両親のもとで育(そだ)った。<br>她在父母的严格管教下成长。</p><p>出生：<br>役所では「しゅっしょう」というケースが多い気がしますが、日常会話では「しゅっせい」と発音する人も多いです。</p><p>紙を適切な位置で切る＝切る場所に誤差を認めない。<br>紙を適当な位置で切る＝切る場所に誤差を認める。</p><p>浜辺（はまべ）　海辺（うみべ）</p><p>苦痛（くつう）を訴える（うったえる）</p><p>N＋にかぎって偏偏；限于<br>N＋において在。。方面</p><p>損得（そんとく）　損害（そんがい）　損失（そんしつ）</p><p>きっぱり汉语翻译：<br>［断固と］断然;<br>［あっさり］干脆,斩钉截铁『成』;<br>［はっきり］清楚,明确.<br>きっぱり言いきる／斩钉截铁地说;一口咬定.<br>きっぱり拒否した／断然〔干脆〕拒绝了.<br>話をきっぱりする必要がある／有必要把话讲清楚.</p><p>人たらし<br>最初は、「人をだますこと。また、その人」の意味でしたが、今では「多くの人々に好かれること。また、その人」</p><p>光景（こうけい）</p><p>意欲を高める：热情高昂<br>意図（いと）を隠す：隐藏意图</p><p>若々しい（わかわかしい）：有活力的<br>厚かましい（あつかましい）：厚脸皮的</p><p>ｖーた＋途端に</p><p>判子（はんこ）：印章</p><p>応募（おうぼ）　募集（ぼしゅう）</p><p>返却（へんきゃく）：退还（物品）<br>返済（へんさい）：偿还钱款</p><p>N＋の＋ことだから：正因为是。。。</p><h3 id="unit-5-145-180"><a href="#unit-5-145-180" class="headerlink" title="unit 5(145-180)"></a>unit 5(145-180)</h3><p>平等（びょうどう）</p><p>上達（じょうたつ）が早い：进步迅速   発達（はったつ）が目覚ましい：发展惊人</p><p>書留（かきとめ） 勢い（いきおい）　趣（おもむき）<br>施す（ほどこす）eg.策を施す&#x2F;恩恵を施す</p><p>ｖーない＋こともない<br>◆買えないこともないが、最近お金を使いすぎたので、あまり使いたくない<br>～ことではない<br>ｖーます＋そうもない<br>今週は忙しくて、明日の映画は行けそうもない</p><p>動ます形＋（なんか）でもしたら 　<br>名詞＋（なんか）でもしたら<br>意味：<br>一旦…的话,就会… 　<br>如果…就（糟了）…<br>大切なものを奪われでもしたら、私は死ぬ気で奪い返す。</p><p>登山（とざん）</p><p>うんざり:厌烦</p><p>口を挟む：插嘴</p><p>……かのようだ<br>接续：<br>各名詞＋である＋かのようだ<br>動詞普通体＋かのようだ<br>意思：<br>表示虽然实际上不是那么回事，但是给人的感觉好像是那么回事。有时也用于说话人的一种遐想。比起（～ようだ）的表达形式来，更增添了一种不确切的推断语气。“就像……”。<br>例子：<br>1、彼は自分のものであるかのように勝手にぼくの物を使っている。&#x2F;他像是在用自个儿的东西似的，随意用我的东西。</p><p>髪の毛（け）</p><p>感染（かんせん）　伝染（でんせん）</p><p>好ましい（このましい）<br>（1）令人喜欢的。（気に入っている。）<br>好ましい返事。／令人满意的答复。<br>好ましくない印象。／不愉快的印象；印象不好。<br>好ましからぬ人。／讨厌的人；不受欢迎的人。<br>（2）令人满意的。（望ましい。）<br>これは決して好ましいことではないが、やむをえない。／这决不能令人满意，但是只好如此。</p><h3 id="unit-6-181-216"><a href="#unit-6-181-216" class="headerlink" title="unit 6(181-216)"></a>unit 6(181-216)</h3><p>輸入（ゆうにゅう）　輸送（ゆそう）</p><p>肌が荒れる（あれる）</p><p>錆びる（さびる）</p><p>砂漠（さばく）　土砂降り（どしゃぶり）</p><p>ｖーない＋ずに・ないで済む<br>&lt;接续&gt;<br>名／形动／动词连体形＋にすぎない<br>&lt;意思&gt;<br>只是，只不过是。表示“只是……”的意思。伴有“这并不重要”的语气。（…以上のものではない。ただ…だけだ。）<br>たんなる人違いにすぎない。／只不过是弄错人了。<br>「～にすぎない」（no more than,just,only)<br>程度が低いことを表す表現で、「大したことはない、価値があまりない」という気持ちが込められます。<br>・彼の言葉は言い訳にすぎない。<br>・彼はただの友達にすぎない。<br>・それは勝手な妄想にすぎない。</p><p>「にほかならない」（no other than,none other than,nothing but)<br>判断や考えを強調して、断定する表現で、「それ以外のものでは決してない。まさしくそうである。」という気持ちが込められます。<br>・彼が成功したのは彼の努力の成果にほかならない。<br>・私を勇気づけたのは彼の一言にほかならない。<br>・私を変えたのは、彼の存在にほかならない。<br>～からにほかならない</p><p>「共通（きょうつう）」是指“对于多个事物均适用的东西”，<br>eg.共通の利害&#x2F;共同的利害</p><p>「共有（きょうゆう）」就是指“共同所有”，是在“拥有”上的「共同」，与「専有」相对。<br>eg.財産を共有にする</p><p>釣り合う<br>（1）平衡，均衡。（二つの物の平衡が取れている。）<br>収入と支出が釣り合う。／收支平衡。<br>（2）匀称，适称，相称，调和。〔似合う。〕<br>着物の柄と帯とがよく釣り合う。／和服的花样和带子很调和。<br>油絵は日本間にはつりあわない。／日本式房间挂油画不适称。<br>釣り合わぬは不縁のもと。／（夫妇）不般配是造成离婚的根源。</p><p>代金を立て替えること:垫付，垫付款。</p><p>待ち合わせ　会う約束のための日時設定<br>待ち合わせ時間に合わせて、家を出る。</p><p>顔合わせ　お互いが誰であるかを会って確かめ合う<br>今日はチームメイトとコーチとの初顔合わせの日だ。</p><p>間近（まぢか）まもなく<br>身近（みぢか）<br>１）切身　身近に感じる<br>２）身边　危険が身近にせまる</p><p>間際　出発間際に腹痛に襲われる</p><p>病（やまい）</p><p>主催（しゅさい）　主要（しゅよう）</p><p>リストラ　【英】restructuring 的略语；在日本，多指裁员和雇用调整。</p><p>夕食を奢る（おごる）</p><h3 id="unit-7-217-252"><a href="#unit-7-217-252" class="headerlink" title="unit 7(217-252)"></a>unit 7(217-252)</h3><p>知識（ちしき）　承認（しょうにん）</p><p>[方面] [ほうめん] 。指的是限定了方向的笼统地域，多指那一带、那片区域。<br>如：<br>東京方面へ出張する。&#x2F;到东京地区出差。</p><p>[方向]  [ほうこう] 。意思是：方向、方位。<br>如：<br>方向を誤る。&#x2F;走错方向。<br>逆の方向へ行く。&#x2F;走向相反的方向。</p><p>思い切って→ためらわないで、勇気を出してなにかをする、始める。<br>eg.<br>思い切って転職する。<br>思い切って留学する。<br>思い切って告白する。</p><p>思い切り→行動の程度が大きい、強い。存分に（？）<br>eg.<br>バットを思い切りふる。<br>旅を思い切り楽しむ。<br>紙に思い切り大きく絵を書く。</p><p>道端（みちばた）</p><p>一切合切（いっさいがっさい）表示全部</p><p>「一概に（いちがいに） 必ずしも めったに」表示的是否定部分，而「一切（いっさい）」为全面，彻底否定。</p><p>刻む（きざむ）　削る（けずる）</p><p>としか言いようがない 就表示“只能说是….”</p><p>のぼせあがる头昏眼花;头昏脑胀</p><p>唆す（そそのかす）</p><p>キャリアを積む：积累经验</p><p>見当（けんとう）<br>1.方位，方向。<br>2.估计，推测，推断，猜测。<br>3.大约，左右，上下，大体数量。<br>4.标尺。</p><p>見解（けんかい）　見方（みかた）</p><p>N＋を除いて（のぞいて）</p><p>粗末(そまつ)<br>１）粗糙。粗陋。简陋。<br>粗末な着物。<br>２）糟蹋。作践。不爱惜。<br>親を粗末にする。<br>怠慢父母。<br>物を粗末にする。<br>糟蹋东西。</p><p>出荷（しゅっか）　入荷（にゅうか）</p><p>1，～ために<br>「～ために」表示目的的时候，前后句子必须为同一主语。而且「ために」前边的动词必须是动作主靠自己的意志可以实现的事情。<br>接续：<br>名词+の+ために<br>动词原形（意向性动词）+ために<br>例句：<br>将来のために、今から頑張らなければならない。&#x2F;为了将来，现在必须要努力奋斗了。<br>ダイエットするために晩御飯の後散歩することにした。&#x2F;为了减肥决定在晚饭后散步。（减肥靠说话人的个人意志可以控制）</p><p>2，～ように<br>表示“为了使该状态&#x2F;状况成立、实现而……”前边多使用「なる」、「できる」等与人的意向无关的行为动词或者动词否定形等表示状态性的意思的表达方式、动词的可能态，后边的句子一般表示动作主意向行为的动词。前后主语无需一致。其中「～ように」的「に」可省略。<br>接续：<br>动词原形（无意向动词）+ように<br>动词ない形+ように<br>动词的可能态+ように<br>例句：<br>後ろの人が聞こえるように大きな声で話した。&#x2F;为了后面的人听得到，大声讲话。（“后边的人听得到”不是表达自己意志的）<br>風邪を引かないようにコートを着て出かけた。&#x2F;为了不感冒穿着外套出门了。<br>子供にも読めるよう名前に振り仮名をつけた。&#x2F;为了让孩子也能读出名字，在旁边标注上了假名。</p><p>惑星（わくせい）：1.行星。2.前途不可限量的人。</p><p>勘定（かんじょう）：<br>1.数，计数，计算。（計算する。）<br>2.算账，计算收支。（収支・代金計算。）<br>勘定合って銭足らず。&#x2F;理论与实践不一致。</p><p>ナ形容詞【な形】＋ばかりに<br>イ形容詞と動詞の辞書形＋ばかりに<br>文の【た形】＋ばかりに<br>～たい&#x2F;ほしい＋ばかりに<br>意思：<br>就因为前项的原因，才导致了后项预想不到的坏结果。</p><p>促す（うながす）<br>1.促使，促进。<br>2.催促，促使。<br>注意を促す　借金の返済を促す<br>催す（もよおす）<br>1.举行，举办；主办。<br>2.感觉（要……）。<br>会を催す　眠けを催す</p><p>下敷きになる被压在底下　eg.～を下敷きにする。／以～为榜样。</p><p>下書き：草稿</p><h3 id="unit-8-253-294"><a href="#unit-8-253-294" class="headerlink" title="unit 8(253-294)"></a>unit 8(253-294)</h3><p>不正な取引（ふせいなとりひき）</p><p>根気（こんき）</p><p>かえって…相反；反而；反倒<br>◆心配をかけまいと無理に明(あか)るく振(ふ)る舞(ま)ったが、かえって家族に心配をかけてしまった。<br>　为了不让家人担心而故做开朗，反而让家人更担心。</p><p>ことか：多么……啊！是一种感叹表现，表说感叹，叹息。<br>多与「どんなに・どれほど・何度・なんと」等副词呼应使用。</p><p>ものか：决不会……。表示强烈的否定。口语为「～もんか」、郑重体是「～ものですか／～もんですか」。</p><p>追いつく，追上，差がほどんどない<br>追いかける，追赶、差を縮め（ちぢめ）よう</p><p>保守（ほしゅ）　保管（ほかん）　保存（ほぞん）</p><p>散らばる可以表示抽象的分散。偏向于表示原本整理好的、归拢在一起的东西分散了，同种类的事物分散了<br>散らかる是乱七八糟的意思。<br>散らす是自动词<br>散らかす是他动词。</p><p>著しい（いちじるしい）　著す（あらわす）<br>華々しい（はなばなしい）</p><p>納品（のうひん）</p><p>～と言うことだ 也就是说，听说<br>～というものだ 表评价</p><p>利口（りこう）</p><p>吹雪（ふぶき）</p><p>まごまご张皇失措　うろうろ彷徨，徘徊，转来转去．　うとうと迷迷糊糊．　</p><p>【<del>てもらう】和【</del>てくれる】这两个句型都可以用于为我方做某事。<br>（他人に）<del>てもらう  更侧重我方请求对方做某事，主动方是我方。<br>私はタイ人の友達にタイ料理を教えてもらった。我请泰国朋友教我学做了泰国菜。<br>（他人が）</del>てくれる 更侧重对方主动为我方做了某事。</p><p>需要（じゅよう）　重要（じゅうよう）　要望（ようぼう）</p><p>続出（ぞくしゅつ）：接连发生<br>雨のため各地でスリップ事故が続出している／因雨各地接连发生打滑事故.<br>存続（そんぞく）: その存在が続くこと (similar to “to remain it”, or “to keep existing”)<br>伝統文化を存続させる<br>継続（けいぞく）: 前から続いていることを、続行すること (similar “to have been doing it and to keep doing it”)<br>持続（じぞく）：持续，继续，维持；［あくまでも］坚持．<br>続行（ぞっこう）: 引き続いて行うこと (similar to “to keep doing it”, that is it is not important if you have been doing it or not but you are doing it)</p><p>N＋踏まえて：在。。基础上</p><h3 id="unit-9-295-324"><a href="#unit-9-295-324" class="headerlink" title="unit 9(295-324)"></a>unit 9(295-324)</h3><p>交渉（こうしょう）</p><p>～うえは：既然。。就，和【以上】用法接近<br>～上に：不仅。。而且<br>N・ｖーた＋上で：在。。之后</p><p>つもりだ<br>1.接续：动词&#x2F;形容词&#x2F;形容动词连体形&#x2F;名词の + つもりだ<br>解说：接在表状态的动词后，表示主观想法，自我感觉。可译为“自以为…”。<br>彼女はすべてを知っているつもりだが、本当は何も知らない。&#x2F;她自以为自己什么都懂，其实她什么也不知道。<br>2.接续：动词过去式 + つもりだ<br>解说：“つもり”接在动词过去式“…た”之后，表示一种假定，即尽管实际并非如此，暂且主观上认定是这样。可译为“就当做…，就以为…”。<br>自分の家に帰ったつもりで、ゆっくりお休みください。&#x2F;就像回到自己家里一样，好好休息吧!</p><p>v-たらどう？</p><p>献立（こんだて）　文献（ぶんけん）</p><p>すっと<br>（１）〔勢いよく〕［動作が］迅速地，轻快地；［時間的に］一下子，悠地，立刻．<br>（例）手を～差し出す／敏捷地伸出手来．<br>（例）～立ち上がる／立刻站起来；悠地一下站了起来．<br>（２）〔気分がさわやかで〕［さわやか］爽快；［うっぷんを晴らして］痛快，轻松．<br>（例）頭痛が治まって～する／头不痛了，觉得很清爽．</p><p>ほっと<br>（１）〔ため息〕叹气．<br>（例）～ため息をつく／叹一口气．<br>（２）〔安心〕放心．<br>（例）～胸をなでおろした／放了心，松了一口气．</p><p>ざっと<br>（１）〔大まかに〕粗略地，简略地，略微；［だいたい］大略，大致，大体上．<br>（例）～目を通す／略一过目；粗粗地看了一遍．<br>（例）～読んでみた／大致读了一下．<br>（例）～列挙してみる／笼统地列举一下．<br>（２）〔おおよそ〕大约，大概．<br>（例）～１万人が集まった／大约聚集了一万人．<br>（３）〔水音が〕哗啦，刷地．<br>（例）～夕立が来た／刷地一下子下起阵雨来了．<br>ざっとう【雑踏】 </p><p>うちだす【打ち出す・撃ち出す】<br>（１）〔模様を〕锤成或压出凸花纹．<br>（例）花模様を～／锤出凸花纹．<br>（２）〔対策などを〕提出（主张）．<br>（例）主題をはっきりと～／突出主题．<br>（例）問題解決の新しい方途を～／提出解决问题的新方法．<br>（３）〔興行で打ち出し太鼓を打つ〕打散场鼓，散戏．<br>（４）〔うち始める〕开始打，打起来．<br>（例）大砲を～／开炮．<br>（例）テレタイプがそのニュースを打ち出していた／电传打字机已把这个消息打出来了．</p><p>うちけす【打ち消す】<br>（１）〔否定する〕否定；［否認する］否认．<br>（例）事実を～／否定事实．<br>（例）うわさを懸命に打ち消した／极力否认风传的流言；极力辟谣．<br>（２）〔音を消す〕消除．<br>（例）波の音に打ち消されてカモメの声は聞こえない／海鸥的叫声被波涛湮没，听不到了．</p><p>うちあげる【打ち上げる】<br>（１）〔空に〕打上去；［ロケットなどを］发射．<br>（例）花火を～／放焰火．<br>（例）人工衛星を成功裏に打ち上げた／成功地发射了人造卫星．<br>（２）〔岸に〕波浪把东西冲上岸．<br>（例）砂浜に波が～／波浪冲拍着沙滩．<br>（例）津波で大きな船が岸に打ち上げられた／因为海啸大船被冲上岸来．<br>（３）〔興行を〕结束．<br>（例）３か月の芝居興行を打ち上げた／结束了三个月的戏剧演出．<br>（４）〈碁〉拿掉．</p><p>傑作（けっさく）</p><p>要旨（ようし）<br>（例）～をまとめる／归纳要点．<br>（例）彼の話は～があいまいだ／他的话重点不突出．<br>要領（ようりょう）：［ポイント］要领，要点；［こつ］诀窍，窍门<br>～がいい：<br>（１）〔手際がいい〕灵巧．<br>（例）彼はプロだけあってさすがに～がいい／他不愧是专业，要领掌握得很好．<br>（２）〔悪賢く振る舞う〕精明．<br>（例）なんて～のいいやつだ／多么精明的家伙！<br>～が悪い：（遇事）抓不到点子上；做事笨拙；不会找窍门．<br>～を得ない：不得要领（成）．<br>（例）きみの言うことはまったく～を得ない／你说的话完全不得要领．<br>（例）～を得ない話だ／这个话不得要领．</p><p>めっきり（变化）显著，急剧．</p><p>ｖーた＋ところ做了前项，发生了后项意料之外的结果</p><p>ｖ原形＋よりほか(に&#x2F;は)ない・ほかしかたがない・ほかはない<br>除此之外，没有…<br>自立(じりつ)するためにはまず両親のもとを離(はな)れるよりほかない。要独立自主，首先必须要离开父母身边。</p><p>提供（ていきょう）　供給（きょうきゅう）　供える（そなえる）</p><p>携わる（たずさわる）：参与，参加，从事，有关系．<br>（例）教育に～／从事教育．<br>（例）政治に携わらない／不参与政治．</p><p>備わる（そなわる）<br>（１）〔設置〕装备，设置；装有．<br>（例）最新の設備が備わっている／设有最新设备．<br>（２）〔資質など〕具有，具备．<br>（例）生まれながらの資質が備わっている／具有与生俱来的资质．</p><p>ｖ<del>ます</del>＋つつある正在…不断地…(表示某动作，事态正朝某一方向持续发展）<br>ｖ<del>ます</del>＋っぱなし本该做的事情却不去做，还是保持原样。某个状态的持续</p><h3 id="unit-10（325-360）"><a href="#unit-10（325-360）" class="headerlink" title="unit 10（325-360）"></a>unit 10（325-360）</h3><p>わりと意外地</p><p>滞在（たいざい）逗留，停留；<br>（例）海外に～する／在海外居住；旅居海外．</p><p>渋滞（じゅうたい）堵塞，不通畅；不顺利<br>（例）交通～に巻き込まれる／遇上交通堵塞．<br>（例）～のない文章／流畅的文章．</p><p>潤い（うるおい）<br>（１）〔湿り気〕湿润．<br>（例）肌の～を保つ化粧品／润肤化妆品．<br>（２）〔利益〕补益（書）．<br>（例）少々の援助でも財政の～になる／再少的援助，对财政也是有所补益的．<br>（３）〔情趣〕风趣，情趣．<br>（例）～のある声／甘美的声调．</p><p>蛇口（じゃぐち）</p><p>ぶかぶか<br>（１）〔服などが〕肥大．<br>（例）このズボンは～だ／这条裤子肥肥的．<br>（２）〔ラッパなどの音〕达达达地．<br>（例）～とラッパを吹く／达达达地吹喇叭．</p><p>N＋の・A・ｖ　＋わりには</p><p>N&#x2F;Na （である）に越したことはない<br>A-いに越したことはない<br>V-るに越したことはない<br>表示「没有比这更好的、这是最好的」等意思。<br>お金はあるに越したことはない。有钱是再好不过的了。</p><p>湿気（しっけ）<br>豊作（ほうさく）　豊富（ほうふ）<br>N＋向けに 面向。。。，以。。为对象　<br>N＋に向けて<br>1）人或交通工具等朝着某个方向、目的地行进。（～に向かって）的意思基本相同。<br>2）针对某人、某团体采取什么态度或什么行为，和（～に向かって&#x2F;に対して）的意思基本相同。<br>3）表示以某个事情为目标而努力。相当于（～を目指して）的意思。</p><p>交代（こうたい）交替，替换，换班；［輪番の］轮流，轮换．<br>生地（きじ）　保障（ほしょう）</p><p>アイデアをおもいつく</p><p>ｖーた・ｖ＋か＋ｖ－ない＋か＋のうちに刚。。。就。。。</p><p>喪失（そうしつ）　紛失（ふんしつ）</p><p>一種（いっしゅ）</p><p>ところを强调被中断，打断。经常会被用在被人发现和抓住的情况，所以接续一般为「見る、見つける、見かける、発見する、捕まる、捕まえる、襲う、助ける」<br>ところに&#x2F;へ强调动作发生时间点。表示正在做某动作时，发生了另一个事情受到了影响，而这个事情通常是令人意外的或者因此受到了阻碍，原本需要做的动作因为此事做出了调整，用中文来说，就是“正在～的时候”。</p><p>ご存知です：「知っている」<br>存じておる</p><p>ｖーている・A・N＋の　＋最中に</p><p>「〜ものがある」经常和「～には」「～のは」搭配使用。<br>含义：“有…的一面””的确很…”<br>动词［辞書形］＋ものがある<br>动词［ない形］＋ものがある<br>い形容词［ーい］＋ものがある<br>な形容词［ーな］＋ものがある</p><h3 id="unit-11（361-396）"><a href="#unit-11（361-396）" class="headerlink" title="unit 11（361-396）"></a>unit 11（361-396）</h3><p>【ちかぢか】 1.最近。不久 2.近距离地。直接。 </p><p>たちまち【忽ち】<br>（１）〔すぐに〕转瞬间，立刻，马上，登时；［まもなく］不大工夫．<br>（例）音楽会の切符は～売り切れた／音乐会的票不大工夫就卖完了．<br>（２）〔にわかに〕忽然，突然．<br>（例）～大粒の雨が降り出した／突然下起了大雨点的雨．</p><p>決行（けっこう）</p><p>か何か ：。。。什么的<br>例如： コーヒーか何か飲みませんか。 喝点咖啡什么的吧<br>かどうか：表示是否，是……还是（不）<br>例如： 彼は来るかどうか知りますか 他来还是不来你知道吗？<br>かいなか：硬い表現で、書き言葉です。意味は「かどうか」と同じです。</p><p>競馬（けいば）　競う（きそう）<br>分布（ぶんぷ）<br>～を通じて<br>N＋に渡る：长达。。。，多达。。。（时间、空间范围）</p><p>繁盛（はんじょう）　繁栄（はんえい）<br>徒歩（とほ）</p><p>ぎっしり满满的．</p><p>（例）かばんは～詰まっている／挎包装得满满的．</p><p>（例）会場は人で～だ／会场挤满了人．</p><p>（例）～詰まったスケジュール／排得满满的日程表．</p><p>（例）両側に家が～立ち並んでいる／两旁房屋鳞次栉比．</p><p>どっさり很多，好些．</p><p>（例）お年玉を～もらう／得到了好些压岁钱．</p><p>（例）ここでは毎年米が～とれる／这里每年可收好多稻米．</p><p>（例）果物を～買い込んでくる／买回很多水果．</p><p>くっきり特别鲜明，显眼，清楚．</p><p>（例）青空に山が～見える／在蔚蓝的天空可以清楚地看见山峰．</p><p>N＋につき<br>1） 关于…，就…。（→について。）<br>世界の政治情勢―述べる。／关于世界的政治局势讲解。<br>2）由于，以…的理由。〔理由をのべる。…という理由で。…のために〕<br>祭日につき休業。／因节日歇业。<br>病気につき欠席する。／因病缺席。<br>3）每，对…。〔…あたり〕<br>5人につきひとりの割合。／每五人有一人的比例</p><p>証拠（しょうこ）<br>大使（たいし）　大事（だいじ）　大臣（だいじん）</p><p>けっそく【結束】<br>（１）〔束ねる〕捆束，捆扎．<br>（２）〔団結する〕团结．</p><p>（例）～をかたくする／加强团结．<br>（例）～して敵に当たる／团结对敌．<br>（例）あの組織は～がかたい／那个组织团结紧密．</p><p>がち：侧重表达某种动作或状态出现的次数多，中文为“动不动就怎么了”，往往用于负面。含有“今～という状態である&#x2F;ない（现在是&#x2F;不是……状态）”的语感。<br>気味（ぎみ）：侧重表达感觉上有一点点不好的倾向。含有“今～という状態である（现在是……状态）”的语感 。<br>っぽい：主要表达具备某种事物的性质和特征，“看上去感觉怎么样”。 含有“今～という状態がよくわからない（现在是…状态不清楚）”的语感。</p><h3 id="unit-12（397-）"><a href="#unit-12（397-）" class="headerlink" title="unit 12（397-）"></a>unit 12（397-）</h3><p>過去（かこ）</p><p>ｖ可能形＋ものなら：如果能。。。的话，可能性很小的假设<br>ばかりに：正因为，就因为．<br>（例）大儲けした～に人生が狂った／正因为挣了大钱，人生才开始潦倒．<br>（例）寝過ごした～に試験を受けられなかった／只因为睡过了头，没能参加考试．</p>]]></content>
    
    
    <categories>
      
      <category>日语学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>词汇</tag>
      
      <tag>语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git指令回顾</title>
    <link href="/unkown404.github.io/2022/04/27/gitCommand/"/>
    <url>/unkown404.github.io/2022/04/27/gitCommand/</url>
    
    <content type="html"><![CDATA[<p>最近 VsCode 图形化界面操作太过于习惯，一些 git 指令操作感觉有点生疏，所以回顾一下。</p><span id="more"></span><p>进入正题前可配合以下 VsCode 操作文章一起阅读，体会也许更深：<br>1）<a href="https://cloud.tencent.com/developer/article/1793472">VS Code 使用 Git 可视化管理源代码详细教程</a><br>2）<a href="https://almvm.devopshub.cn/labs/azuredevops/git/">Version Controlling with Git in Visual Studio Code and Azure DevOps</a><br>虽说界面化是挺好的，但万一哪天需要书写或修改部署文件时会比较头疼，所以还是要记录一点</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>git 是一个分布式版本控制软件。其工作流程如下图所示：<br><img src="/unkown404.github.io/img/git.jpeg"></p><p>涉及的基本工作区概念有：<br><strong>Workspace</strong>：工作区，平时开发时改动的地方<br><strong>Index</strong>：暂存区，执行<code>git add</code>指令后工作区的文件修改内容就会被推到暂存区<br><strong>Repository</strong>：本地仓库，位于自己的本地电脑，执行<code>git commit</code>指令后暂存区的文件修改内容就会被推到本地仓库<br><strong>Remote</strong>：远程仓库，用来托管代码的服务器，比较常见的包括 GitHub、Gitee、GitLab，可以被多个处于协作的本地仓库修改，执行<code>git push</code>指令后本地仓库的文件修改内容就会被推到远程仓库</p><p>一般来说 git 的开发流程主要包括以下步骤：</p><ol><li>使用<code>git clone</code>将远程仓库代码拉到本地</li><li>按照业务从 master 分支拉取新分支、使用<code>git branch &lt;branch-name&gt; </code>、<code>git checkout &lt;branch-name&gt; </code>在新分支上进行开发</li><li>本地开发完成使用<code>git add .</code>添加所有修改到暂存区</li><li>使用<code>git commit -m &lt;message&gt;</code>将修改提交到本地仓库</li><li>使用<code>git push</code>将修改推送到远程仓库</li></ol><h2 id="git-常用配置"><a href="#git-常用配置" class="headerlink" title="git 常用配置"></a>git 常用配置</h2><h3 id="全局配置用户名、用户邮箱"><a href="#全局配置用户名、用户邮箱" class="headerlink" title="全局配置用户名、用户邮箱"></a>全局配置用户名、用户邮箱</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;xxx&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;xxx@xx.com&quot;</span><br></code></pre></td></tr></table></figure><h3 id="配置-SSH-Key"><a href="#配置-SSH-Key" class="headerlink" title="配置 SSH Key"></a>配置 SSH Key</h3><p>SSH Key 允许本地电脑和远程仓库间建立一个安全链接。和 https 拉取远程代码的不同点是，https 方式需要手动输入用户名和密码，ssh 的方式配置完毕后 Git 都会使用你本地的私钥和远程仓库的公钥进行验证是否是一对秘钥，从而简化了操作流程。</p><h4 id="查看-SSH-Key"><a href="#查看-SSH-Key" class="headerlink" title="查看 SSH Key"></a>查看 SSH Key</h4><p>Windows 终端可输入如下指令：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">type</span> <span class="hljs-variable">%userprofile%</span>\.ssh\id_rsa.pub<br></code></pre></td></tr></table></figure><p>GNU&#x2F;Linux&#x2F;Mac&#x2F;PowerShell 则可以使用该指令：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">cat ~<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub<br></code></pre></td></tr></table></figure><p>如果返回开头为<code>ssh-rsa</code>一长串字符，可以跳过生成 SSH Key 过程</p><h4 id="生成-SSH-Key"><a href="#生成-SSH-Key" class="headerlink" title="生成 SSH Key"></a>生成 SSH Key</h4><p>使用指令：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;xxx@xxx.com&quot;</span><br></code></pre></td></tr></table></figure><p>后续关于文件名、passphrase 的设置最好直接回车采用默认值，以免影响自动调用 SSH Key 的流程。<br>如果之后需要修改 key 值，可以使用如下语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">ssh-keygen -p <span class="hljs-tag">&lt;<span class="hljs-name">keyname</span>&gt;</span><br></code></pre></td></tr></table></figure><p>完成后再使用如下指令查看 SSH Key：<br>Windows：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">type</span> <span class="hljs-variable">%userprofile%</span>\.ssh\id_rsa.pub<br></code></pre></td></tr></table></figure><p>GNU&#x2F;Linux&#x2F;Mac&#x2F;PowerShell：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">cat ~<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub<br></code></pre></td></tr></table></figure><h4 id="复制-SSH-Key"><a href="#复制-SSH-Key" class="headerlink" title="复制 SSH Key"></a>复制 SSH Key</h4><p>Windows 命令:</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">type %userprofile%\.ssh\id_rsa.pub | <span class="hljs-keyword">clip</span><br></code></pre></td></tr></table></figure><p>Windows PowerShell:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">cat ~<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub | <span class="hljs-built_in">clip</span><br></code></pre></td></tr></table></figure><p>Mac:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">pbcopy &lt; ~<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub<br></code></pre></td></tr></table></figure><p>GNU&#x2F;Linux (需要 xclip):</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">xclip -sel <span class="hljs-built_in">clip</span> &lt; ~<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub<br></code></pre></td></tr></table></figure><h4 id="添加-SSH-Key"><a href="#添加-SSH-Key" class="headerlink" title="添加 SSH Key"></a>添加 SSH Key</h4><p>打开 gitlab，在左侧栏找到 profile setting，点击 SSH Keys，将复制的 SSH Key 内容粘贴在 keys 一栏，点击<code>add key</code>完成。</p><h3 id="查看-git-配置"><a href="#查看-git-配置" class="headerlink" title="查看 git 配置"></a>查看 git 配置</h3><p>使用指令<code>git config --list</code>可以查看当前配置所有项</p><h2 id="工作区常用-git-指令"><a href="#工作区常用-git-指令" class="headerlink" title="工作区常用 git 指令"></a>工作区常用 git 指令</h2><h3 id="新建本地仓库"><a href="#新建本地仓库" class="headerlink" title="新建本地仓库"></a>新建本地仓库</h3><h4 id="本地项目-git-管理"><a href="#本地项目-git-管理" class="headerlink" title="本地项目 git 管理"></a>本地项目 git 管理</h4><p>使用指令<code>git init</code>使项目 git 化</p><h4 id="远程仓库项目本地操作"><a href="#远程仓库项目本地操作" class="headerlink" title="远程仓库项目本地操作"></a>远程仓库项目本地操作</h4><p>使用指令<code>git clone &lt;url&gt;</code>，例如 <code>git clone git@gitee.com:unknown-four-hundred-and-four/unknown_404.git</code>。这里的 url 最好用 SSH 而非 HTTPS，避免手动输入用户名和密码的麻烦。<br>在克隆完每个远程仓库后，远程仓库默认为 origin。如果想用其他的主机名，需要用 git clone 命令的-o 选项指定。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone -o jQuery https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/jquery/</span>jquery.git<br></code></pre></td></tr></table></figure><h3 id="开发新业务"><a href="#开发新业务" class="headerlink" title="开发新业务"></a>开发新业务</h3><h4 id="查看当前仓库分支情况"><a href="#查看当前仓库分支情况" class="headerlink" title="查看当前仓库分支情况"></a>查看当前仓库分支情况</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">branch </span>查看本地仓库分支情况，*表示当前位于的分支<br>git <span class="hljs-keyword">branch </span>-a 查看本地和远程所有分支情况<br></code></pre></td></tr></table></figure><h4 id="创建业务分支开发"><a href="#创建业务分支开发" class="headerlink" title="创建业务分支开发"></a>创建业务分支开发</h4><p>使用指令<code>git checkout -b &lt;branchname&gt;</code>使工作区切到新建的分支上。该指令是<code>git branch &lt;branchname&gt;</code>和<code>git checkout &lt;branchname&gt;</code>合在一起的结果。</p><h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><p>1）使用指令<code>git add</code>将代码提交到暂存区。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">// 添加某个文件到暂存区，后面可以跟多个文件，以空格区分</span><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> xxx<br><span class="hljs-comment">// 添加当前更改的所有文件到暂存区。</span><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> .<br></code></pre></td></tr></table></figure><p>2）使用指令<code>git commit</code>将代码提交到本地仓库。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 提交暂存的更改，会新开编辑器进行编辑<br>git commit<br><span class="hljs-regexp">//</span> 提交暂存的更改，并记录下备注<br>git commit -m <span class="hljs-string">&quot;you message&quot;</span><br><span class="hljs-regexp">//</span> 等同于 git add . &amp;&amp; git commit -m<br>git commit -am<br><span class="hljs-regexp">//</span> 对最近一次的提交的信息进行修改,此操作会修改commit的hash值<br>git commit --amend<br></code></pre></td></tr></table></figure><h4 id="提交规范补充"><a href="#提交规范补充" class="headerlink" title="提交规范补充"></a>提交规范补充</h4><p>commit 的内容规范不应该被轻视，一个调理清晰的 commit 记录有助于后面的人做维护工作。实际工作中可能常会遇到之前项目下掉的某功能需要重新恢复，如果能有清晰的 commit 说明维护人员就能很快定位功能代码位置做出调整；而如果提交记录只有类似 fix 、bugfix 的说明则会给维护工作造成麻烦。</p><p>目前广泛接受的 commit 格式规范是 angular 团队规范，它的 message 格式如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;<span class="hljs-regexp">//</span> header部分<br>&lt;BLANK LINE&gt;<span class="hljs-regexp">//</span> 空行<br>&lt;body&gt;<span class="hljs-regexp">//</span> body部分<br>&lt;BLANK LINE&gt;<span class="hljs-regexp">//</span> 空行<br>&lt;footer&gt;<span class="hljs-regexp">//</span> 注释footer部分<br></code></pre></td></tr></table></figure><p>主要分为三个部分：</p><h5 id="header-部分"><a href="#header-部分" class="headerlink" title="header 部分"></a>header 部分</h5><p>必填内容, 描述主要修改类型和内容。规范将 header 分为 type、scope、subject 三部分。<br><strong>type</strong>：提交的代码修改所属类型，必填项。应在以下几种中选择一种：</p><ul><li>feat: 一项新功能</li><li>fix: 一个错误修复</li><li>docs: 仅文档更改</li><li>style: 不影响代码含义的更改（空白，格式，缺少分号等）</li><li>refactor: 既不修正错误也不增加功能的代码更改（重构）</li><li>perf: 改进性能的代码更改</li><li>test: 添加缺失或更正现有测试</li><li>build: 影响构建系统或外部依赖项的更改（gulp，npm 等）</li><li>ci: 对 CI 配置文件和脚本的更改</li><li>chore: 更改构建过程或辅助工具和库，例如文档生成</li></ul><p><strong>scope</strong>：本次提交的影响范围，描述提交更改的位置如模块名或文件名。可选项<br><strong>subject</strong>：指本次提交的简要描述。</p><h5 id="body-部分"><a href="#body-部分" class="headerlink" title="body 部分"></a>body 部分</h5><p>选填部分。</p><h5 id="footer-部分"><a href="#footer-部分" class="headerlink" title="footer 部分"></a>footer 部分</h5><p>主要备注以下内容：</p><ul><li><strong>BREAKING CHANGE</strong>：当前修改是否发生了版本升级、接口参数减少、接口删除、迁移等破坏性调整。</li><li><strong>关闭 Issue</strong>：填写格式<code>Closes #ISSUE_ID, #ISSUE_ID</code></li></ul><p>当前使用比较广泛的规范化工具是<a href="https://www.npmjs.com/package/cz-conventional-changelog">commitizen</a>。</p><p>3）使用指令<code>git push</code>将代码提交到远程仓库。</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">git push <span class="hljs-attribute">&lt;远程主机名&gt;</span> <span class="hljs-attribute">&lt;本地分支名&gt;</span>:<span class="hljs-attribute">&lt;远程分支名&gt;</span><br></code></pre></td></tr></table></figure><p>如果省略远程分支名，则会将本地分支推送到对应名称的远程分支（两者有追踪关系），如果该远程分支不存在，则会被新建。<br>如果省略本地分支名，则是将空分支推到远程分支，等同于删除指定的远程分支。<br>如果省略本地分支和远程分支、且当前分支与远程分支之间存在追踪关系时，将当前分支推送到 origin 主机的对应分支；如果追踪关系只有一个可以直接<code>git push</code>。</p><h4 id="文件暂存"><a href="#文件暂存" class="headerlink" title="文件暂存"></a>文件暂存</h4><p>有的时候我们的功能开发了一半，因为某些原因我们需要 checkout 到其他的分支上查看代码或者是执行某个工作。这个时候由于功能并没有开发完成，所以并不希望提交代码，此时可以用<code>git stash</code>指令来将本地还没有提交的改动全部存储起来。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 保存改动并注释本次改动<br>git stash [save] &lt;message&gt;<br><span class="hljs-regexp">//</span> 将新创建并且还没有被 git 管理的文件也一并储藏起来<br>git stash  [--include-untracked/-u]<br><span class="hljs-regexp">//</span> 查看全部存储记录<br>git stash list<br><span class="hljs-regexp">//</span> 恢复，num是可选项，通过git stash list可查看具体值。只能恢复一次<br>git stash pop stash@&#123;num&#125;<br><span class="hljs-regexp">//</span>恢复，num是可选项，通过git stash list可查看具体值。能恢复多次<br>git stash apply stash@&#123;num&#125;<br><br></code></pre></td></tr></table></figure><p>git stash 在没有 add 之前才能执行。</p><h4 id="业务协作"><a href="#业务协作" class="headerlink" title="业务协作"></a>业务协作</h4><p>当同事开发的内容和自己在同一分支且对方已经提交代码的情况下，可以使用指令 git pull，git pull 等同于 git fetch &amp;&amp; git merge</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 拉取远程分支代码的更新,对当前工作区的代码没有影响<br>git fetch &lt;远程主机名(eg. origin)&gt; &lt;分支名&gt;<br><span class="hljs-regexp">//</span> 将当前分支与指定分支进行合并<br>git merge &lt;分支名&gt;<br><span class="hljs-regexp">//</span> 从远程仓库拉取代码并合并到本地<br>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;<br></code></pre></td></tr></table></figure><h5 id="辨析：git-merge-和-git-rebase-的区别"><a href="#辨析：git-merge-和-git-rebase-的区别" class="headerlink" title="辨析：git merge 和 git rebase 的区别"></a>辨析：git merge 和 git rebase 的区别</h5><p>相同点：两个指令都可以用于分支合并。<br>不同点：<br>1）提交记录里，merge 在非快速模式下会多一条 Merge branch ‘xxx’ into ‘xxx’的提交信息，而 rebase 不会<br>2）合并冲突时，merge 只需要处理一次冲突，rebase 需要解决一次又一次冲突<br>3）rebase 的交互模式可以将多次提交压缩成一次，具体步骤是：</p><ul><li>a）执行指令<code>git rebase -i &lt;base-commit&gt;</code>，参数 base-commit 就是指明操作的基点提交对象，基于这个基点进行 rebase 的操作</li><li>b）指令结束后会进入一个 vim 的交互式页面，将基点以后的节点都设置为了 pick，且后面会有指令提示，常用的指令包括</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">pick：使用该次提交<br>squash：将该<span class="hljs-keyword">commit</span>和前一个<span class="hljs-keyword">commit</span>合并<br></code></pre></td></tr></table></figure><p>通常将第一个提交的后面的 pick 改成 squash 即可。</p><ul><li>c）保存，退出编辑页面（点击 Esc 键后输入:wq），进入 commit message 页面。之后同样是输入 i 进入编辑界面，修改自己的 commit message</li><li>d）保存，退出。至此，git rebase 一个流程走完。<blockquote><p>特别注意，只能在自己使用的 feature 分支上进行 rebase 操作，不允许在集成分支上进行 rebase，因为这种操作会修改集成分支的历史记录。</p></blockquote></li></ul><h4 id="部分需求交付"><a href="#部分需求交付" class="headerlink" title="部分需求交付"></a>部分需求交付</h4><p>在开发新功能时因各种客观原因赶不上交付期限的時候，可能需要交付部分需求。针对这一情境，有两种指令可以解决具体的问题。</p><ul><li>1）git cherry-pick<br>使用格式：</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">git cherry-pick &lt;commit-<span class="hljs-built_in">id</span>&gt;<br></code></pre></td></tr></table></figure><p>commit-id 为某次提交的 hash 值。该指令可以理解为”挑拣”提交，和 merge 合并一个分支的所有提交不同的是，它会获取某一个分支的单次提交，并作为一个新的提交引入到你当前分支上。</p><p>当新需求分支里的 bug 修复代码要提前于需求上线时，可以使用 git cherry-pick 将 feature 分支上 bug 修复那次提交生成的 hash 码提取出来作为一个新的提交加在 master 分支上。过程中，如果出现冲突，需要解决冲突、之后进行 git add ，接着执行 git cherry-pick –continue。</p><p>如果存在多个提交需要同步到目标分支，可以简写为 <code>git cherry-pick &lt;first-commit-id&gt;...&lt;last-commit-id&gt;</code>，这是一个左开右闭的区间，也就时说 first-commit-id 提交带来的代码的改动不会被合并过去，如果需要合并过去，可以使用<code> git cherry-pick &lt;first-commit-id&gt;^...&lt;last-commit-id&gt;</code>。</p><ul><li>2）git revert<br>使用格式：</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">git revert &lt;commit-<span class="hljs-built_in">id</span>&gt;<br></code></pre></td></tr></table></figure><p>commit-id 为某次提交的 hash 值。该指令会创建一个新的提交来去除指定的某次 commit 的内容。</p><p>当新需求中某一项功能因为种种原因不能上线时可以使用该指令。这样既可以留下记录又不会导致其他人分支不同步。<br>revert的时候会进入编辑器模式，如果没有指定编辑器，通常会默认使用系统的编辑器，即<code>vi</code>。界面提示”Please enter a commit message for your changes”。在该行之前输入<code>i</code>进入插入阶段，输入想要的内容后单击esc退出插入模式，输入<code>:wq</code>回车即可保存退出。</p><h3 id="仓库、分支迁移"><a href="#仓库、分支迁移" class="headerlink" title="仓库、分支迁移"></a>仓库、分支迁移</h3><p>因业务需求、工作交接等原因，有时需要对仓库或者分支内容迁移到别处。</p><h3 id="仓库迁移"><a href="#仓库迁移" class="headerlink" title="仓库迁移"></a>仓库迁移</h3><ul><li>1）将原仓库代码拉到本地</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">&lt;origin_address</span>&gt;<br></code></pre></td></tr></table></figure><ul><li>2）将原仓库 gitlab 地址替换成为目标仓库的 gitlab 地址</li></ul><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">git</span> <span class="hljs-string">remote</span> <span class="hljs-built_in">set-url</span> <span class="hljs-string">origin</span> &lt;<span class="hljs-string">target_address</span>&gt;<br></code></pre></td></tr></table></figure><ul><li>3）本地仓库推送到远程</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">git <span class="hljs-built_in">push</span> origin --<span class="hljs-built_in">all</span> 推送主干和分支<br><br>git <span class="hljs-built_in">push</span> --tags 推送标签<br></code></pre></td></tr></table></figure><h4 id="仓库迁移可能存在的问题"><a href="#仓库迁移可能存在的问题" class="headerlink" title="仓库迁移可能存在的问题"></a>仓库迁移可能存在的问题</h4><p>问题：上述操作完成之后由于目标仓库的部分分支被保护、原仓库同分支名的推送失败，导致原仓库的其他分支与该被保护分支之间历史不同，git merge 发生<code>fatal: refusing to merge unrelated histories</code>的报错。<br>解决方法：git merge 时增加–allow-unrelated-histories 让 git 允许提交不关联的历史代码。</p><h3 id="分支迁移"><a href="#分支迁移" class="headerlink" title="分支迁移"></a>分支迁移</h3><ul><li>1）将原仓库代码拉到本地</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">&lt;origin_address</span>&gt;<br></code></pre></td></tr></table></figure><ul><li>2）将目标仓库的 gitlab 地址添加进来并为仓库取一个新名字（下面的指令是将仓库命名为了 global）</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">git remote <span class="hljs-built_in">add</span> <span class="hljs-keyword">global</span> <span class="hljs-symbol">&lt;target_address&gt;</span><br></code></pre></td></tr></table></figure><ul><li>3）将当前分支内容推送到目标仓库的分支</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">git push <span class="hljs-keyword">global</span> &lt;branch-<span class="hljs-built_in">name</span>&gt;<br></code></pre></td></tr></table></figure><p>如果是本地初始化的工程可以先拉取远程仓库某一分支，使用 git merge 指令将本地工程的代码合到远程仓库。<br>根据网上资料可以使用<code>git pull --rebase global &lt;branch-name&gt;</code>解决将本地代码推到远程仓库时报错<code>error: failed to push some refs to XXX</code>。实际操作的时候出现了很多错误，不得不取消了 rebase 操作。究其原因应该是该方法只适用于远程库与本地库代码没有同步的情况，而不是本地代码和远程代码完全无关的情况。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>（1）<a href="https://juejin.cn/post/6934292467160514567#heading-0">commit 规范+commitlint+CHANGELOG 自动生成一条龙服务</a><br>（2）<a href="https://blog.csdn.net/M__L__/article/details/104573220">git rebase -i 合并多次提交</a><br>（3）<a href="https://juejin.cn/post/6844904191203213326">多年 Git 使用心得 &amp; 常见问题整理</a><br>（4）<a href="https://juejin.cn/post/6974184935804534815">我在工作中是如何使用 git 的</a><br>（5）<a href="https://ithelp.ithome.com.tw/articles/10244481">DAY11-git cherry-pick 和 revert</a><br>（6）<a href="https://stackoverflow.com/questions/73012357/please-enter-a-commit-message-for-your-changes">“Please enter a commit message for your changes”</a></p>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React Hooks学习笔记</title>
    <link href="/unkown404.github.io/2022/04/08/reactHooks/"/>
    <url>/unkown404.github.io/2022/04/08/reactHooks/</url>
    
    <content type="html"><![CDATA[<p>记录常用的 React 钩子的使用方法。</p><span id="more"></span><h2 id="React-Hook-规则"><a href="#React-Hook-规则" class="headerlink" title="React Hook 规则"></a>React Hook 规则</h2><p>（1）只在最顶层使用 Hook：不要在循环，条件或嵌套函数中调用 Hook<br>（2）只在 React 函数中调用 Hook：可以在 React 组件或自定义钩子中调用</p><h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><p>使用示例：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">[<span class="hljs-literal">self</span>State,<span class="hljs-built_in">set</span>SelfState]=useState(initialState)<br></code></pre></td></tr></table></figure><p>输入参数：初始状态 initialState。如果 initialState 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用。<br>返回参数：当前状态名 selfState 和更新状态函数名 setSelfState<br>setSelfState 可以传入新值来变更状态 setSelfState(newState)；如果需要根据先前的状态更新状态，也可以使用回调函数 setSelfState(prevState &#x3D;&gt; newState)<br>注意点：<br>（1）因为 state 只在组件首次渲染的时候被创建。在下一次重新渲染时，useState 返回给我们当前的 state。<br>（2）initialState 可以是数组或对象，不像 class 中的 this.setState，更新 state 变量总是替换它而不是合并它。<br>（3）过时状态问题：class 和 hooks 的写法里，异步操作的过程中如何改变 state 的值，最后打印的时候都是最初的值或者说异步操作开始定义的时候的 state 的值。如下面的函数组件中 setTimeout 取到的都是旧值，是因为 react 中一直遵循一个原则，即 state 指向的内容是不可变的，所以每一次 state 的更新都是指向变了。因为闭包的原因，setTimeout 中依然指向的原来的对象，所以旧的 state 没有释放，所以会取到旧值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">DelayedCount</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClickAsync</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">delay</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);<br>    &#125;, <span class="hljs-number">3000</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;count&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClickAsync&#125;</span>&gt;</span>Increase async<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码点击多次时不能正确记录点击次数。解决方法是使用 setCount(count &#x3D;&gt; count + 1)，这样不依赖外部变量、确保将最新状态值作为参数提供给更新状态函数，过时闭包的问题解决了。</p><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>使用示例：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">useEffect(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    ...<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;&#125;<br>&#125;,[variable])<br></code></pre></td></tr></table></figure><p>第一参数的回调函数函数可以没有返回值，第二参数的书写不是必要的，如果设置了变量 variable，当且仅当 variable 改变时才会触发第一参数回调</p><h3 id="useEffect-与生命周期关系"><a href="#useEffect-与生命周期关系" class="headerlink" title="useEffect 与生命周期关系"></a>useEffect 与生命周期关系</h3><h4 id="useEffect-实现-componentDidMount"><a href="#useEffect-实现-componentDidMount" class="headerlink" title="useEffect 实现 componentDidMount"></a>useEffect 实现 componentDidMount</h4><p>useEffect 的第二个参数设置为一个空数组时，初始化调用一次之后不再执行回调，相当于周期 componentDidMount</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">useEffect</span><span class="hljs-params">(()</span></span> =&gt; &#123;<br>    console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br>&#125;, <span class="hljs-selector-attr">[]</span>)<br></code></pre></td></tr></table></figure><h4 id="useEffect-实现-componentDidMount-和-componentDidUpdate"><a href="#useEffect-实现-componentDidMount-和-componentDidUpdate" class="headerlink" title="useEffect 实现 componentDidMount 和 componentDidUpdate"></a>useEffect 实现 componentDidMount 和 componentDidUpdate</h4><p>当 useEffect 没有第二个参数时,组件的初始化和更新都会执行。<br>当 useEffect 有第二个参数时,组件的更新仅当 variable 改变时会执行。</p><h4 id="useEffect-实现-componentDidMount-和-componentWillMount"><a href="#useEffect-实现-componentDidMount-和-componentWillMount" class="headerlink" title="useEffect 实现 componentDidMount 和 componentWillMount"></a>useEffect 实现 componentDidMount 和 componentWillMount</h4><p>useEffect 设置返回一个函数，这个函数在组件卸载时会执行。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">use<span class="hljs-constructor">Effect(()</span> =&gt; &#123;<br>    <span class="hljs-keyword">function</span> handle<span class="hljs-constructor">StatusChange(<span class="hljs-params">status</span>)</span> &#123;<br>      set<span class="hljs-constructor">IsOnline(<span class="hljs-params">status</span>.<span class="hljs-params">isOnline</span>)</span>;<br>    &#125;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChatAPI</span>.</span></span>subscribe<span class="hljs-constructor">ToFriendStatus(<span class="hljs-params">props</span>.<span class="hljs-params">friend</span>.<span class="hljs-params">id</span>, <span class="hljs-params">handleStatusChange</span>)</span>;<br>    <span class="hljs-comment">// Specify how to clean up after this effect:</span><br>    return <span class="hljs-keyword">function</span> cleanup<span class="hljs-literal">()</span> &#123;<br>      <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChatAPI</span>.</span></span>unsubscribe<span class="hljs-constructor">FromFriendStatus(<span class="hljs-params">props</span>.<span class="hljs-params">friend</span>.<span class="hljs-params">id</span>, <span class="hljs-params">handleStatusChange</span>)</span>;<br>    &#125;;<br>&#125;,<span class="hljs-literal">[]</span>);<br></code></pre></td></tr></table></figure><h3 id="useEffect-无限循环陷阱"><a href="#useEffect-无限循环陷阱" class="headerlink" title="useEffect 无限循环陷阱"></a>useEffect 无限循环陷阱</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title function_">useState</span>(&#123; <span class="hljs-attr">hits</span>: [] &#125;);<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">axios</span>(<br>      <span class="hljs-string">&#x27;http://localhost/api/v1/search?query=redux&#x27;</span>,<br>    );<br><br>    <span class="hljs-title function_">setData</span>(result.<span class="hljs-property">data</span>);<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">      &#123;data.hits.map(item =&gt; (</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item.objectID&#125;</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&#123;item.url&#125;</span>&gt;</span>&#123;item.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">      ))&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><p>以该组件为例，初次渲染执行 useEffect 内部请求、返回数据后，由于使用了 setData 组件 state 改变，引起重新渲染，同时由于 useEffect 没有依赖项，再次渲染时仍然会触发内部的回调，因此出现了无限循环的问题。</p><p>解决方式：如果只希望在组件 mount 时执行请求，可以传递一个空数组作为 useEffect 的第二个参数</p><h3 id="useEffect-与-async-同时使用时的报错"><a href="#useEffect-与-async-同时使用时的报错" class="headerlink" title="useEffect 与 async 同时使用时的报错"></a>useEffect 与 async 同时使用时的报错</h3><p>async 函数会返回 promise，但 useEffect 只允许返回一个清除函数，所以在控制台可以看到警告提醒</p><div class="note note-info">            <p>Warning: useEffect function must return a cleanup function or nothing. Promises and useEffect(async () &#x3D;&gt; …) are not supported, but you can call an async function inside an effect</p>          </div><p>解决方式：async 函数的定义分离出 useEffect 回调函数，回调函数内部执行 async 函数。</p><h3 id="useEffect-vs-useLayoutEffect"><a href="#useEffect-vs-useLayoutEffect" class="headerlink" title="useEffect vs useLayoutEffect"></a>useEffect vs useLayoutEffect</h3><p>执行时期：useEffect 在全部渲染完毕后才会执行，useLayoutEffect 会在浏览器布局之后，绘制之前执行<br>执行方式：useEffect 异步，useLayoutEffect 同步</p><h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><p>使用示例：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const memo=useMemo(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    ...<br>    <span class="hljs-keyword">return</span> compute(props.v)<br>&#125;,[variable])<br></code></pre></td></tr></table></figure><p>传入 useMemo 的函数会在渲染期间执行。如果没有设置第二参数依赖变量，则每次渲染都会执行第一参数的函数来计算。类比生命周期就是 shouldComponentUpdate<br>适用场景：<br>（1）父组件将某个值传给子组件、且父组件有频繁更新的情况。父组件其他值变化时，子组件同样也会重新渲染。因此可以使用 useMemo、将依赖设置为父组件传递的值，只有当其发生变化时子组件才更新。<br>（2）组件内部计算成本比较高的逻辑。需要通过控制依赖来减少不必要的计算。<br>注意点：<br>（1）useMemo 内部不要使用 setState 相关操作，会导致无限循环<br>（2）包括后面的 useCallback，如果是用在父子组件传值的场景，子组件通常用高阶函数 React.memo 包裹<br><strong>辨析：React.memo 和 useMemo</strong><br>React.memo：高阶组件，基础思想：props 没有改变则无需渲染组件。使用方法：<code>React.memo(Component, [areEqual])</code>其中 areEqual 函数不是必须要有的，当 props 浅比较无法实现预计的更新逻辑时才需要传入自己手写的比较逻辑。</p><p>useMemo：组件初次渲染时，执行一次包裹的函数，把函数返回值缓存起来。当组件重新渲染时，通过浅比较检查依赖数组 dependencies 有没有变化。如果没有直接返回之前缓存的结果。</p><h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><p>使用示例：</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">const</span> <span class="hljs-function"><span class="hljs-keyword">fn</span>=<span class="hljs-title">useCallback</span><span class="hljs-params">(<span class="hljs-params">()</span>=&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    ...</span></span><br><span class="hljs-params"><span class="hljs-function">    doSomething<span class="hljs-params">(variable)</span></span></span><br><span class="hljs-params"><span class="hljs-function">&#125;,[variable])</span></span><br></code></pre></td></tr></table></figure><p>useCallback(fn, deps) 相当于 useMemo(() &#x3D;&gt; fn, deps)。类似生命周期 shouldComponentUpdate<br>适用场景：<br>（1）父组件将某个函数传给子组件、且父组件有频繁更新的情况。父组件其他值变化时，由于函数重新创建等原因子组件同样也会重新渲染。</p><h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><p>使用示例：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const refContainer <span class="hljs-operator">=</span> useRef(initialValue)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>输入参数 initialValue 将赋给 ref 的 current 属性。ref 作用于 HTML 元素时 ref 接收底层 DOM 元素作为其 current 属性；作用于组件时，ref 对象接收组件的挂载实例作为其 current 属性。<br>useRef() 和自建一个 {current: …} 对象的唯一区别是，useRef 会在每次渲染时返回同一个 ref 对象。<br>适用场景：<br>（1）引用如 input 等有参数频繁变动更新的 dom 元素。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/6952509261519781918#heading-0">useEffect 你真的会用吗？</a><br>（2）<a href="https://juejin.cn/post/7053695602370019335">React Hooks 及其性能优化之 React.memo,useCallBack,useMemo</a><br>（3）<a href="https://juejin.cn/post/7090820276547485709">解读 useMemo, useCallback 和 React.memo，不再盲目做优化</a></p>]]></content>
    
    
    <categories>
      
      <category>前端技术体系</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/unkown404.github.io/2022/04/05/regexp/"/>
    <url>/unkown404.github.io/2022/04/05/regexp/</url>
    
    <content type="html"><![CDATA[<p>正则表达式构建相关知识点。</p><span id="more"></span> <h2 id="单字符匹配"><a href="#单字符匹配" class="headerlink" title="单字符匹配"></a>单字符匹配</h2><ol><li>数字、字母：直接书写</li><li>特殊字符（eg.空格、换行、*）：使用转义字符<code>\</code><br>需要记忆的特殊字符：<table><thead><tr><th align="center">特殊字符</th><th align="center">正则表达式</th></tr></thead><tbody><tr><td align="center">转行符</td><td align="center">&#x2F;n</td></tr><tr><td align="center">空白符</td><td align="center">&#x2F;s</td></tr><tr><td align="center">制表符</td><td align="center">&#x2F;t</td></tr><tr><td align="center">回车符</td><td align="center">&#x2F;r</td></tr></tbody></table></li></ol><h2 id="多字符匹配"><a href="#多字符匹配" class="headerlink" title="多字符匹配"></a>多字符匹配</h2><ol><li>[] eg.[a-z],[0-9]</li><li>简便正则表达式<table><thead><tr><th align="center">特殊字符</th><th align="center">正则表达式</th></tr></thead><tbody><tr><td align="center">除了换行符之外的任何字符</td><td align="center">.</td></tr><tr><td align="center">匹配空白符，包括空格、制表符、换页符和换行符</td><td align="center">&#x2F;s</td></tr><tr><td align="center">匹配非空白字符([^ \t\v\n\r\f])</td><td align="center">&#x2F;S</td></tr><tr><td align="center">单个数字, [0-9]</td><td align="center">&#x2F;d</td></tr><tr><td align="center">除了0-9([^0-9])</td><td align="center">&#x2F;D</td></tr><tr><td align="center">包括下划线在内的单个字符，[A-Za-z0-9_]</td><td align="center">&#x2F;w</td></tr><tr><td align="center">非单个字符([^A-Za-z0-9_])</td><td align="center">&#x2F;W</td></tr></tbody></table></li></ol><h2 id="重复次数"><a href="#重复次数" class="headerlink" title="重复次数"></a>重复次数</h2><table><thead><tr><th align="center">特殊字符</th><th align="center">重复次数</th></tr></thead><tbody><tr><td align="center">?</td><td align="center">0-1</td></tr><tr><td align="center">*</td><td align="center">0-n</td></tr><tr><td align="center">+</td><td align="center">1-n</td></tr><tr><td align="center">{n}</td><td align="center">n</td></tr><tr><td align="center">{min,max}</td><td align="center">min-max</td></tr></tbody></table><h3 id="贪婪匹配和惰性匹配"><a href="#贪婪匹配和惰性匹配" class="headerlink" title="贪婪匹配和惰性匹配"></a>贪婪匹配和惰性匹配</h3><p>贪婪匹配：重复次数不是固定而是一个范围时通常尽可能多的匹配。</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/\d&#123;2,5&#125;/g</span>;<br><span class="hljs-keyword">var</span> <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;12345&quot;</span>;<br><span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">string</span>.match(regex) ); <br><span class="hljs-comment">// =&gt; [&quot;12345&quot;]</span><br></code></pre></td></tr></table></figure><p>懒惰匹配：在上述表格的字符后面加上<code>?</code>，尽可能少的匹配。</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/\d&#123;2,5&#125;?/g</span>;<br><span class="hljs-keyword">var</span> <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;12345&quot;</span>;<br><span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">string</span>.match(regex) ); <br><span class="hljs-comment">// =&gt; [&quot;12&quot;,&quot;34&quot;]</span><br></code></pre></td></tr></table></figure><h2 id="分组与回溯引用"><a href="#分组与回溯引用" class="headerlink" title="分组与回溯引用"></a>分组与回溯引用</h2><p><strong>分组</strong>：括号()所包裹的表达式内容即为一个分组。</p><p><strong>回溯引用</strong>：模式的后面部分引用前面已经匹配到的子字符串。<br>示例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">var</span> regex = /\d&#123;<span class="hljs-number">4</span>&#125;(-|\/|\.)\d&#123;<span class="hljs-number">2</span>&#125;\<span class="hljs-number">1</span>\d&#123;<span class="hljs-number">2</span>&#125;/;<br></code></pre></td></tr></table></figure><p>在这个正则表达式中\1，表示的引用之前的那个分组<code>(-|\/|\.)</code>。不管它匹配到什么（比如-），\1都匹配那个同样的具体某个字符。<br>使用replace替换字符串时，涉及到的引用变量及其意义包括：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$1</span>,<span class="hljs-variable">$2</span>,...,<span class="hljs-variable">$99</span> 匹配第<span class="hljs-number">1</span>~<span class="hljs-number">99</span>个分组里捕获的文本<br><span class="hljs-variable">$&amp;</span> 匹配到的子串文本<br><span class="hljs-variable">$`</span> 匹配到的子串的左边文本<br><span class="hljs-variable">$&#x27;</span> 匹配到的子串的右边文本<br></code></pre></td></tr></table></figure><h3 id="非捕获分组-p"><a href="#非捕获分组-p" class="headerlink" title="非捕获分组(?:p)"></a>非捕获分组(?:p)</h3><p>该语法仅承担分组的作用而不参与引用，即既不在API里引用，也不在正则里反向引用。</p><h2 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h2><h3 id="位置特性"><a href="#位置特性" class="headerlink" title="位置特性"></a>位置特性</h3><p>位置是相邻字符之间的位置。例如：<br>“halo”&#x3D;&#x3D;“”+“h”+“”+“a”+“”+“l”+“”+“o”</p><h3 id="位置边界"><a href="#位置边界" class="headerlink" title="位置边界"></a>位置边界</h3><ol><li>单词边界：\b<br>示例：<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> result = <span class="hljs-string">&quot;[JS] Lesson_01.mp4&quot;</span>.<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/\b/g</span>, <span class="hljs-string">&#x27;#&#x27;</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(result); <br><span class="hljs-comment">// =&gt; &quot;[#JS#] #Lesson_01#.#mp4#&quot;</span><br></code></pre></td></tr></table></figure>可以看到\b匹配的位置都是由<code>\w</code>到<code>\W</code>或者<code>\W</code>到<code>\w</code>的位置</li><li>字符串边界：<code>^</code>开头匹配，<code>$</code>结尾匹配<h3 id="位置查找"><a href="#位置查找" class="headerlink" title="位置查找"></a>位置查找</h3><h4 id="前向查找-x3D-p"><a href="#前向查找-x3D-p" class="headerlink" title="前向查找(?&#x3D;p)"></a>前向查找(?&#x3D;p)</h4>匹配内容p前面的字符。<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> result = <span class="hljs-string">&quot;hello&quot;</span>.<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/(?=l)/g</span>, <span class="hljs-string">&#x27;#&#x27;</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(result); <br><span class="hljs-comment">// =&gt; &quot;he#l#lo&quot;</span><br></code></pre></td></tr></table></figure><h4 id="后向查找-lt-x3D-p"><a href="#后向查找-lt-x3D-p" class="headerlink" title="后向查找(?&lt;&#x3D;p)"></a>后向查找(?&lt;&#x3D;p)</h4>匹配内容p后面的字符。<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> result = <span class="hljs-string">&quot;hello&quot;</span>.<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/(?=l)/g</span>, <span class="hljs-string">&#x27;#&#x27;</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(result); <br><span class="hljs-comment">// =&gt; &quot;hel#l#o&quot;</span><br></code></pre></td></tr></table></figure><h4 id="前向负查找-p"><a href="#前向负查找-p" class="headerlink" title="前向负查找(?!p)"></a>前向负查找(?!p)</h4>不匹配内容p前面的字符。可以看作是前向查找的反面<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> result = <span class="hljs-string">&quot;hello&quot;</span>.<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/(?!l)/g</span>, <span class="hljs-string">&#x27;#&#x27;</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(result); <br><span class="hljs-comment">// =&gt; &quot;#h#ell#o#&quot;</span><br></code></pre></td></tr></table></figure><h4 id="后向负查找-lt-p"><a href="#后向负查找-lt-p" class="headerlink" title="后向负查找(?&lt;!p)"></a>后向负查找(?&lt;!p)</h4>不匹配内容p后面的字符。可以看作是后向查找的反面<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">var result = &quot;hello&quot;.replace(/(?<span class="hljs-meta">&lt;!l)/g, <span class="hljs-string">&#x27;#&#x27;</span>);</span><br><span class="hljs-meta"><span class="hljs-keyword">console</span>.log(<span class="hljs-keyword">result</span>); </span><br><span class="hljs-meta">// =&gt;</span> &quot;#h#e#llo#&quot;<br></code></pre></td></tr></table></figure><h2 id="正则表达式相关API"><a href="#正则表达式相关API" class="headerlink" title="正则表达式相关API"></a>正则表达式相关API</h2><h3 id="RegExp-对象方法"><a href="#RegExp-对象方法" class="headerlink" title="RegExp 对象方法"></a>RegExp 对象方法</h3><h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4>检索字符串中指定的值。返回找到的值及index，并确定其位置。<br>exec方法能接着上一次匹配后继续匹配。正则实例lastIndex属性，表示下一次匹配开始的位置。<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coq">const patternMatch = (<span class="hljs-built_in">pattern</span>, content) =&gt; &#123;<br>    var positions = []<br>    var <span class="hljs-keyword">match</span> = <span class="hljs-built_in">pattern</span>.exec(content)<br>    while (<span class="hljs-keyword">match</span>) &#123;<br>        positions.push(<span class="hljs-keyword">match</span>.index)<br>        <span class="hljs-keyword">match</span> = <span class="hljs-built_in">pattern</span>.exec(content)<br>    &#125;<br>    <span class="hljs-keyword">return</span> positions<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4>检索字符串中指定的值。返回 true 或 false。<h3 id="String-对象方法"><a href="#String-对象方法" class="headerlink" title="String 对象方法"></a>String 对象方法</h3>第1参数都支持正则和字符串<h4 id="match"><a href="#match" class="headerlink" title="match"></a>match</h4>找到一个或多个正则表达式的匹配。返回找到的值<br>当正则没有g时，使用match返回的信息比较多。但是有g后，就没有关键的信息index了。<h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4>检索与正则表达式相匹配的值。返回与指定查找的字符串或者正则表达式相匹配的 String 对象起始位置，没有则是-1。<h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4>替换与正则表达式匹配的子串。<br>replace第2个参数可以是一个普通的字符串或是一个回调函数。如果第2个参数是回调函数，每匹配到一个结果就回调一次，每次回调都会传递以下参数：<figure class="highlight wasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs wasm"><span class="hljs-keyword">result</span>: 本次匹配到的结果<br><br><span class="hljs-variable">$1</span>,...<span class="hljs-variable">$9</span>: 正则表达式中有几个<span class="hljs-punctuation">()</span>，就会传递几个参数，<span class="hljs-variable">$1</span>~<span class="hljs-variable">$9</span>分别代表本次匹配中每个<span class="hljs-punctuation">()</span>提取的结果，最多<span class="hljs-number">9</span>个<br><br><span class="hljs-keyword">offset</span>:记录本次匹配的开始位置<br><br>source:接受匹配的原始字符串<br></code></pre></td></tr></table></figure></li></ol><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>（1）js数字每三位加逗号间隔（除了toLocaleString方法）</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">num.<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/\d&#123;1,3&#125;(?=(\d&#123;3&#125;)+(\.\d*)?$)/g</span>,<span class="hljs-string">&#x27;$&amp;,&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>$&amp; </code>匹配到的子串文本</p><p>（2）驼峰变量名转下划线变量</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">str.<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/([a-z])([A-Z])/g</span>,<span class="hljs-string">&#x27;$1_$2&#x27;</span>)<br></code></pre></td></tr></table></figure><p>（3）下划线变量转驼峰变量名</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">str.<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/\_([a-z])/g</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">res,$<span class="hljs-number">1</span></span>)&#123;<span class="hljs-keyword">return</span> $<span class="hljs-number">1.</span>toUpperCase()&#125;)<br></code></pre></td></tr></table></figure><p>（4）成对html标签匹配</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/&lt;([^&gt;]+)&gt;[\d\D]*&lt;\/\1&gt;/</span>;<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/6844903845227659271#heading-0">正则表达式不要背</a><br>（2）<a href="https://juejin.cn/post/6844903487155732494#heading-38">JS正则表达式完整教程（略长）</a></p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于登录拦截和history.back()的二三事</title>
    <link href="/unkown404.github.io/2022/03/31/login/"/>
    <url>/unkown404.github.io/2022/03/31/login/</url>
    
    <content type="html"><![CDATA[<p>记录一个维护老项目时发现的古早bug。</p><span id="more"></span> <h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>WAP项目首页通常有一个用户中心的图标供用户进入自己个人页面。当点击这个用户中心图标时后端会根据请求是否包含登录态来绝对是否重定向请求。例如说目标连接是user.domain.com，在这个域名下的代码由于没有拿到用户个人信息进行了302重定向，重定向后的连接为login.domain.com?to&#x3D;user.domain.com。但如果user.domain.com的代码找到了用户数据就会渲染前端页面。</p><img class="center clear login.jpg 登录逻辑"><p>目前为止看起来是不是毫无问题？</p><p>但如果重定向页面login.domain.com?to&#x3D;user.domain.com有回退按钮呢？前端回退通常使用的方法是history.back()，可以返回上一级页面，此时回退的话就会就会退回user.domain.com，该域名下的代码会再次执行判断登录态的逻辑，发现没有登录态依然会继续重定向，因此实际的页面效果看起来就像登录页面刷新，无法回退到首页。而到了Safari浏览器，由于该移动端浏览器不会重新执行返回的页面的代码，所以浏览器的url停留在user.domain.com，且没有渲染页面，看起来就像白屏故障一样。</p><img class="center clear login-problem.jpg 登录页回退逻辑"><h2 id="解决方式？"><a href="#解决方式？" class="headerlink" title="解决方式？"></a>解决方式？</h2><p>（1）后端的登录跳转逻辑调整（<del>具体怎么改是后端的事跟我有什么关系呢</del> ）</p><p>（2）前端用户中心跳转的链接随获取用户登录态接口的数据而调整</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://t.zoukankan.com/yanggb-p-11675315.html">javascript解决在safari浏览器中使用history.back()返回上一页后页面不会刷新的问题</a></p>]]></content>
    
    
    <categories>
      
      <category>踩坑经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
      <tag>WEB API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小程序海报绘制</title>
    <link href="/unkown404.github.io/2022/03/28/poster/"/>
    <url>/unkown404.github.io/2022/03/28/poster/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>小程序海报绘制目前主要的实现方法有两种：</p><ol><li>前端使用 canvas 绘图并生成</li><li>后端使用后端绘图库进行绘制，返回给小程序端</li></ol><p>第一种方法的主要问题是 canvas 和纯 html 布局相去甚远，不同设备、不同版本的情况下绘图效果不可预期。但第二种方法开发难度也不小，且服务器压力会增大，后端未必愿意接受。所以压力又来到了前端。。。<br>尽管目前前端已经有一些生成海报的插件，如<a href="https://github.com/Kujiale-Mobile/Painter">painter</a>，可以以 json 的格式将元素的定位及样式传给画板。但如果需求出现了较为个性化的要求，例如根据内容海报高度自适应、一行开头不可以有标点等，还是自己手写原生比较好。<br>由于开发使用的是 Taro 框架所以关于 API 的介绍使用也主要以 Taro 为主。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="单位换算"><a href="#单位换算" class="headerlink" title="单位换算"></a>单位换算</h3><p>canvas 绘制使用的是 px 单位，但不同设备的 px 是需要换算的，所以在组件中统一使用 rpx 单位，这里就涉及到单位怎么换算问题。<br>小程序默认屏幕宽度为 750rpx，通过 wx.getSystemInfoSync 获取设备屏幕尺寸宽度，就可以获得实际 px 单位与 rpx 之间的比例，以此做单位转换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">rpx2px</span>(<span class="hljs-params">distance</span>) &#123;<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isNaN</span>(distance)) &#123;<br>        result = wx.<span class="hljs-title function_">getSystemInfoSync</span>().<span class="hljs-property">windowWidth</span> * distance / <span class="hljs-number">750</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">px2rpx</span>(<span class="hljs-params">distance</span>) &#123;<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isNaN</span>(distance)) &#123;<br>        result = distance * <span class="hljs-number">750</span> / wx.<span class="hljs-title function_">getSystemInfoSync</span>().<span class="hljs-property">windowWidth</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="canvas-隐藏"><a href="#canvas-隐藏" class="headerlink" title="canvas 隐藏"></a>canvas 隐藏</h3><p>在绘制海报过程时，因为不想让用户看到 canvas，所以我们必须把 canvas 隐藏起来。实现方法为控制 canvas 的绝对定位，将其移出可视界面。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.poster-canvas</span> &#123;<br>  <span class="hljs-attribute">position</span>: fixed;<br>  <span class="hljs-attribute">top</span>: -<span class="hljs-number">10000</span>rpx;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="canvas初始化"><a href="#canvas初始化" class="headerlink" title="canvas初始化"></a>canvas初始化</h2><p>canvas的初始化操作本身并不难，在模版中添加一个canvas组件并命名，在点击生成海报按钮时拿到canvas实例并设置宽高。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">const</span> ctx = Taro.<span class="hljs-property">createCanvasContext</span>(<span class="hljs-string">&#x27;poster-canvas&#x27;</span>)<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-built_in">width</span>, <span class="hljs-built_in">height</span> &#125; = <span class="hljs-variable">this</span>.<span class="hljs-property">state</span><br><span class="hljs-comment">// 底版</span><br>ctx.<span class="hljs-property">width</span> = <span class="hljs-built_in">width</span><br>ctx.<span class="hljs-property">height</span> = <span class="hljs-built_in">height</span><br></code></pre></td></tr></table></figure><p>如果海报宽高固定，直接赋值即可。但如果希望完成海报高度随文字内容自适应变化的需求时，则需要多一步操作：可以先在渲染阶段制造一个DOM结构，将该DOM按照设计稿的需求绘制文字、外框间距等内容，在点击生成海报时利用createSelectorQuery获取海报中可变DOM元素(如海报正文DOM）的宽高，以及海报最外层DOM的宽高。注意该方法获取到的结果单位是px。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Taro.nextTick(() =&gt; &#123;<br>    <span class="hljs-keyword">const</span> query = Taro.createSelectorQuery()<br>    query.select(<span class="hljs-string">&#x27;.key-box&#x27;</span>).boundingClientRect()<br>    query.exec(res =&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">const</span> height = px2rpx(res[<span class="hljs-number">0</span>].height)<br>            <span class="hljs-keyword">const</span> width = px2rpx(res[<span class="hljs-number">0</span>].width)<br>            <span class="hljs-keyword">this</span>.setState(&#123; width, height &#125;)<br>            <span class="hljs-keyword">this</span>.drawPosterCanvas()<span class="hljs-comment">//绘制canvas</span><br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>            <span class="hljs-keyword">this</span>.failCb()<span class="hljs-comment">//错误处理</span><br><br>        &#125;<br>    &#125;)<br><br>&#125;)<br></code></pre></td></tr></table></figure><p>使用Taro框架时需注意查询DOM属于异步内容无法立即获取只能利用nextTick函数等待下一个时间片获取，获取到以后存储到state里便于绘图时取出。这里需要注意即使将查询内容放在nextTick里，也有少数未查到DOM结果的情况，需要进行错误处理。</p><h2 id="图形篇"><a href="#图形篇" class="headerlink" title="图形篇"></a>图形篇</h2><h3 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h3><p>由于小程序打包的大小有限制，因此图片建议使用 CDN 保存。在绘制图片前需要对远程的图片进行下载的操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">downloadSharePic = <span class="hljs-function">(<span class="hljs-params">url</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-title class_">Taro</span>.<span class="hljs-title function_">downloadFile</span>(&#123;<br>            url,<br>            <span class="hljs-title function_">success</span>(<span class="hljs-params">res</span>) &#123;<br>                <span class="hljs-keyword">if</span> (res.<span class="hljs-property">statusCode</span> === <span class="hljs-number">200</span>) &#123;<br>                    <span class="hljs-title function_">resolve</span>(res.<span class="hljs-property">tempFilePath</span>)<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-title function_">reject</span>(res)<br>                &#125;<br>            &#125;,<br>            <span class="hljs-title function_">fail</span>(<span class="hljs-params">err</span>) &#123;<br>                <span class="hljs-title function_">reject</span>(err)<br>            &#125;<br>        &#125;)<br>    &#125;)<br><br>&#125;<br></code></pre></td></tr></table></figure><p>下载成功后会获得一个临时文件路径，就可以调用 drawImage 函数来绘制了。注意点：下载图片属于异步操作，需要在等待返回值以后才可以绘制。<br>ctx.drawImage 有 3 种写法：</p><ul><li>drawImage(imageResource, dx, dy)</li><li>drawImage(imageResource, dx, dy, dWidth, dHeight)</li><li>drawImage(imageResource, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) 从 1.9.0 起支持<br>如果无法使用第三种方案、需要自己调整图片宽高按设计比例显示在 canvas 上的话，可以采用如下函数：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">getDrawImgParams = <span class="hljs-function">(<span class="hljs-params">src,defaultWidth,defaultHeight</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-title class_">Taro</span>.<span class="hljs-title function_">getImageInfo</span>(&#123;<br>            src,<br>            <span class="hljs-attr">success</span>: <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">const</span> &#123; width, height &#125; = res<br>                <span class="hljs-keyword">let</span> sx = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">let</span> sy = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">let</span> sWidth = width<br>                <span class="hljs-keyword">let</span> sHeight = height<br>                <span class="hljs-keyword">const</span> w2h = width / height<br>                <span class="hljs-keyword">const</span> defaultW2H = defaultWidth / defaultHeight<br>                <span class="hljs-keyword">if</span> (w2h &gt; defaultW2H) &#123; <span class="hljs-comment">// 更宽</span><br>                    sWidth = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(height * defaultW2H)<br>                    sx = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((width - sWidth) / <span class="hljs-number">2</span>)<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (w2h &lt; defaultW2H) &#123; <span class="hljs-comment">// 更高</span><br>                    sHeight = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(width / defaultW2H)<br>                    sy = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((height - sHeight) / <span class="hljs-number">2</span>)<br>                &#125;<br>                <span class="hljs-title function_">resolve</span>(&#123;<br>                    sx,<br>                    sWidth,<br>                    sy,<br>                    sHeight<br>                &#125;)<br>            &#125;,<br>            <span class="hljs-attr">fail</span>: <span class="hljs-function"><span class="hljs-params">rej</span> =&gt;</span> &#123;<br>                <span class="hljs-title function_">reject</span>(rej)<br>            &#125;<br>        &#125;)<br>    &#125;)<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="绘制圆形"><a href="#绘制圆形" class="headerlink" title="绘制圆形"></a>绘制圆形</h3><p>需要用到的函数是 canvasContext.arc，作用是绘制一条曲线。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">canvasContext.arc(x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>, r: <span class="hljs-built_in">number</span>, sAngle: <span class="hljs-built_in">number</span>, eAngle: <span class="hljs-built_in">number</span>, counterclockwise?: <span class="hljs-built_in">boolean</span>)<br></code></pre></td></tr></table></figure><p>x、y 对应圆心坐标，sAngle 是起始弧度，eAngle 是终止弧度。创建一个圆可以指定起始弧度为 0，终止弧度为 2 * Math.PI。<br>如果是画线框就使用 ctx.stroke();如果是画色块就使用 ctx.fill()。</p><h3 id="绘制圆角矩形"><a href="#绘制圆角矩形" class="headerlink" title="绘制圆角矩形"></a>绘制圆角矩形</h3><p>canvas 并没有提供绘制圆角矩形的方法，因此我们需要以另一种方法来实现它。方法的核心是将圆角矩形拆解成四个直角圆弧和四条直线连接的图形。具体的实现如下面的代码所示。圆弧的绘制除了上面提到的arc之外，还有一个叫 CanvasContext.arcTo 的方法，其特点是控制点和半径绘制圆弧路径。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">drawArcFrame = <span class="hljs-function">(<span class="hljs-params">ctx, x, y, r, w, h</span>) =&gt;</span> &#123;<br>    ctx.<span class="hljs-title function_">beginPath</span>()<br>    ctx.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&#x27;transparent&#x27;</span>;<br>    <span class="hljs-comment">// 左上角</span><br>    ctx.<span class="hljs-title function_">arc</span>(x + r, y + r, r, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">1.5</span>)<br><br>    <span class="hljs-comment">// border-top</span><br>    ctx.<span class="hljs-title function_">moveTo</span>(x + r, y)<br>    ctx.<span class="hljs-title function_">lineTo</span>(x + w - r, y)<br>    ctx.<span class="hljs-title function_">lineTo</span>(x + w, y + r)<br>    <span class="hljs-comment">// 右上角</span><br>    ctx.<span class="hljs-title function_">arc</span>(x + w - r, y + r, r, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">1.5</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>)<br><br>    <span class="hljs-comment">// border-right</span><br>    ctx.<span class="hljs-title function_">lineTo</span>(x + w, y + h - r)<br>    ctx.<span class="hljs-title function_">lineTo</span>(x + w - r, y + h)<br>    <span class="hljs-comment">// 右下角</span><br>    ctx.<span class="hljs-title function_">arc</span>(x + w - r, y + h - r, r, <span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">0.5</span>)<br><br>    <span class="hljs-comment">// border-bottom</span><br>    ctx.<span class="hljs-title function_">lineTo</span>(x + r, y + h)<br>    ctx.<span class="hljs-title function_">lineTo</span>(x, y + h - r)<br>    <span class="hljs-comment">// 左下角</span><br>    ctx.<span class="hljs-title function_">arc</span>(x + r, y + h - r, r, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">0.5</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>)<br><br>    <span class="hljs-comment">// border-left</span><br>    ctx.<span class="hljs-title function_">lineTo</span>(x, y + r)<br>    ctx.<span class="hljs-title function_">lineTo</span>(x + r, y)<br><br>    <span class="hljs-comment">// 这里是使用 fill 还是 stroke都可以，二选一即可，但是需要与上面对应</span><br>    ctx.<span class="hljs-title function_">fill</span>()<br>    <span class="hljs-comment">// ctx.stroke()</span><br>    ctx.<span class="hljs-title function_">closePath</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是绘制图片的外框，我们通常需要对原图进行剪切获得我们需要的样式。在我们调用 CanvasContext.clip()进行剪切时，之后的绘图都会被限制在被剪切的区域内（不能访问画布上的其他区域）。因此在使用 clip 方法前通过使用 save 方法对当前画布区域进行保存，在裁剪完图片后通过 restore 方法对其进行恢复。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">ctx.<span class="hljs-title function_">save</span>()<span class="hljs-comment">// 1)保存画布区域</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawArcFrame</span>(ctx, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">12</span>, width, height)<span class="hljs-comment">//2)绘制圆角</span><br>ctx.<span class="hljs-title function_">clip</span>()<span class="hljs-comment">//3）裁剪画板</span><br>ctx.<span class="hljs-title function_">setFillStyle</span>(<span class="hljs-string">&#x27;#F8F9FB&#x27;</span>)<br>ctx.<span class="hljs-title function_">fillRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height)<span class="hljs-comment">//4）在剪切后的画板绘图</span><br>ctx.<span class="hljs-title function_">restore</span>()<span class="hljs-comment">//5）恢复画板区域</span><br></code></pre></td></tr></table></figure><h3 id="绘制阴影"><a href="#绘制阴影" class="headerlink" title="绘制阴影"></a>绘制阴影</h3><p>微信小程序本体从基础库 1.9.90 开始支持设置。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 阴影的x偏移<br>ctx.shadowOffsetX = <span class="hljs-number">10</span>;<br><span class="hljs-regexp">//</span> 阴影的y偏移<br>ctx.shadowOffsetY = <span class="hljs-number">10</span>;<br><span class="hljs-regexp">//</span> 阴影颜色<br>ctx.shadowColor = <span class="hljs-string">&#x27;rgba(0,0,0,0.5)&#x27;</span>;<br><span class="hljs-regexp">//</span> 阴影的模糊半径<br>ctx.shadowBlur = <span class="hljs-number">10</span>;<br><span class="hljs-regexp">//</span> 绘制图形<br>ctx.fillStyle = <span class="hljs-string">&#x27;rgba(255,0,0,0.5)&#x27;</span><br>ctx.fillRect(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p>阴影的设置一定要在图形绘制前。</p><h3 id="圆形内阴影和圆角矩形内阴影"><a href="#圆形内阴影和圆角矩形内阴影" class="headerlink" title="圆形内阴影和圆角矩形内阴影"></a>圆形内阴影和圆角矩形内阴影</h3><p>大致思路：先绘制边框和阴影，再用clip把外阴影裁掉。</p><h2 id="文字篇"><a href="#文字篇" class="headerlink" title="文字篇"></a>文字篇</h2><h3 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h3><p>Taro 框架支持的关于字体的方法只有 setFontSize，用于修改字体大小。<br>但微信小程序本体从基础库 1.9.90 开始支持设置字体样式 canvasContext.font。涉及到的参数如下所示：</p><table><thead><tr><th align="center">属性</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">style</td><td align="center">字体样式。仅支持 italic, oblique, normal</td></tr><tr><td align="center">weight</td><td align="center">字体粗细。仅支持 normal, bold</td></tr><tr><td align="center">size</td><td align="center">字体大小</td></tr><tr><td align="center">family</td><td align="center">字体族名。注意确认各平台所支持的字体</td></tr></tbody></table><p>示例：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ctx.font</span> = <span class="hljs-string">&#x27;normal bold 40px sans-serif&#x27;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>关于字体粗细的问题据说安卓手机只 400 和 700 的 font-weight，如果设置其他的权重也无法实现效果。需要注意点是如果设置了加粗属性 bold，那么在后续文字书写中 weight 的属性值必须设置为 400 而不是 normal，否则在安卓机上后续绘制的文字仍然加粗，尽管开发者工具上正常。</p><h3 id="单行文字"><a href="#单行文字" class="headerlink" title="单行文字"></a>单行文字</h3><p>需要用到的函数是 canvasContext.fillText。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">canvasContext.fill<span class="hljs-constructor">Text(<span class="hljs-params">text</span>: <span class="hljs-params">string</span>, <span class="hljs-params">x</span>: <span class="hljs-params">number</span>, <span class="hljs-params">y</span>: <span class="hljs-params">number</span>, <span class="hljs-params">maxWidth</span>?: <span class="hljs-params">number</span>)</span><br></code></pre></td></tr></table></figure><p>x、y 对应文字左上角坐标。<br>需要注意的点是绘制文字前需要使用 setTextBaseline 函数确定文字竖直方向对齐方式，不设置的话似乎默认是 normal，而不同系统设备上各个基准都不太一样，绘制的效果可能达不到预期。通常设置 top 即可满足需求，如果设置了 middle 则 y 值应该为文字左上的 y 坐标+fontSize&#x2F;2。</p><h3 id="多行文字"><a href="#多行文字" class="headerlink" title="多行文字"></a>多行文字</h3><p>canvas 绘制文字时，只会一股脑的在单行上一直画下去而不会根据容器宽度自动换行。如果希望进行折行、分段，则可以使用 CanvasContext.measureText(string text)的方法，具体步骤包括：</p><ul><li>1）准备工作：去除文本里面和空格相关的字符，保留的话可能在安卓机上出现绘制异常</li><li>2）用tempText变量存储单行字段，逐字遍历文本，用measureText测截至当前字符的文段长度是否超过限定宽度，没有则将当前字符添加到tempText；注意设置阈值时要减去一个字宽，防止遍历到接近折行的位置已经存储的字段tempText已经接近于限制宽度、此时再加一个字符超过设计宽度的情况。</li><li>3）measureText测截至当前字符的文段长度超过限定宽度时将该字段推入数组中保存；同时清空tempText，用于下一行文字的测算。</li><li>4）循环结束后不要忘记将最后一行的结果推入数组row中</li><li>5）遍历行数组row，每行用fillText完成</li><li>6）如果考虑行数限制，可以在遍历row时增加判断条件，在绘制到最后一行时将最后一个字替换为省略号</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">processWord = <span class="hljs-function">(<span class="hljs-params">ctx, text, width,fontSize,lineHeight,maxLine</span>) =&gt;</span> &#123;<br>    text=text.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\s*/g</span>,<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">let</span> row = []<br>    <span class="hljs-keyword">let</span> tempText = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> wordIndex = <span class="hljs-number">0</span>; wordIndex &lt; text.<span class="hljs-property">length</span>; wordIndex++) &#123;<br>        <span class="hljs-keyword">if</span> (ctx.<span class="hljs-title function_">measureText</span>(tempText).<span class="hljs-property">width</span> &lt; width - fontSize) &#123;<br>            tempText += text[wordIndex]<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 折行位置</span><br>            wordIndex--<br>            row.<span class="hljs-title function_">push</span>(tempText)<br>            tempText = <span class="hljs-string">&#x27;&#x27;</span><br>        &#125;<br>    &#125;<br>    row.<span class="hljs-title function_">push</span>(tempText)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> rowNum = <span class="hljs-number">0</span>; rowNum &lt; row.<span class="hljs-property">length</span>&amp;&amp;rowNum&lt;maxLine; rowNum++) &#123;<br>        <span class="hljs-keyword">let</span> text = row[rowNum]<br>        <span class="hljs-keyword">if</span> (row.<span class="hljs-property">length</span> &gt; maxLine &amp;&amp; rowNum == maxLine-<span class="hljs-number">1</span>) &#123;<br>            text = text.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, text.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>) + <span class="hljs-string">&#x27;...&#x27;</span><br>        &#125;<br>        ctx.<span class="hljs-title function_">setTextBaseline</span>(<span class="hljs-string">&#x27;top&#x27;</span>)<br>        ctx.<span class="hljs-title function_">fillText</span>(text, <span class="hljs-number">70</span>, <span class="hljs-number">258</span> + rowNum * lineHeight)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="附加要求：标点不可以出现在首行"><a href="#附加要求：标点不可以出现在首行" class="headerlink" title="附加要求：标点不可以出现在首行"></a>附加要求：标点不可以出现在首行</h4><p>在上述算法的基础上在折行处增加while判断，如果字符是标点就加在当前行tempText，一直到下一个是汉字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> wordIndex = <span class="hljs-number">0</span>; wordIndex &lt; text.<span class="hljs-property">length</span>; wordIndex++) &#123;<br>    <span class="hljs-keyword">if</span> (ctx.<span class="hljs-title function_">measureText</span>(tempText).<span class="hljs-property">width</span> &lt; width - fontSize) &#123;<br>        tempText += text[wordIndex]<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 折行位置</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-regexp">/[，。”！？、：）》；]/</span>.<span class="hljs-title function_">test</span>(text[wordIndex])) &#123;<br>            tempText += text[wordIndex++]<br>        &#125;<br>        wordIndex--<br>        row.<span class="hljs-title function_">push</span>(tempText)<br>        tempText = <span class="hljs-string">&#x27;&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="绘制展示"><a href="#绘制展示" class="headerlink" title="绘制展示"></a>绘制展示</h2><h3 id="canvas转image"><a href="#canvas转image" class="headerlink" title="canvas转image"></a>canvas转image</h3><p>绘制完成后需要调用Taro.canvasToTempFilePath将canvas转为图片输出，需要注意的点包括：1）Taro.canvasToTempFilePath需要写在ctx.draw的回调中；2）draw的回调函数是异步的，canvasToTempFilePath需要在setTimeout中做一些延时，一般1s就可以了。<br>生成的临时url传入Image组件中就可以在屏幕中显示了。</p><h3 id="海报预览使用-scroll-view-展示时，该组件没有显示-css-样式的圆角"><a href="#海报预览使用-scroll-view-展示时，该组件没有显示-css-样式的圆角" class="headerlink" title="海报预览使用 scroll-view 展示时，该组件没有显示 css 样式的圆角"></a>海报预览使用 scroll-view 展示时，该组件没有显示 css 样式的圆角</h3><p>解决方法：在 scroll-view 元素上添加以下样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">overflow</span>: hidden;<br><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">0</span>);<br><span class="hljs-attribute">border-radius</span>: <span class="hljs-number">16</span>rpx;<br></code></pre></td></tr></table></figure><p>当海报的高度没有超过设计稿的可视高度时，scroll-view作为套在海报外层的组件也不应该有滚动条。可以在海报生成组件的state里再维护一个isScroll的变量，判断和赋值的位置可以在<a href="#canvas%E5%88%9D%E5%A7%8B%E5%8C%96">canvas初始化</a>执行。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="http://www.yanghuiqing.com/web/350">在Canvas中实现矩形、圆形、圆角矩形内阴影效果</a>  </li><li><a href="hhttps://juejin.cn/post/6983574104167170061">手把手教你用canvas绘制小程序海报（一）</a>  </li><li><a href="https://juejin.cn/post/6844903663840788493#heading-0">轻松生成小程序分享海报</a>  </li><li><a href="https://juejin.cn/post/7039199842421178382#heading-1">微信小程序《海报生成》</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小程序</tag>
      
      <tag>canvas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript</title>
    <link href="/unkown404.github.io/2022/03/27/typescript/"/>
    <url>/unkown404.github.io/2022/03/27/typescript/</url>
    
    <content type="html"><![CDATA[<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>类型系统按照「是否允许隐式类型转换」来分类，可以分为强类型和弱类型。<br>JavaScript 就属于弱类型语言，灵活性强，但不利的一点是没有编译过程，语言的类型错误只有运行时才会发现（JavaScript 因此被称为动态语言）。而 TypeScript 可以弥补这一点：TypeScript 在运行前需要先编译为 JavaScript，而在编译阶段就会进行类型检查并报错（TypeScript 对应称为静态语言）。同时 TypeScript 增强了编辑器（IDE）的功能，包括代码补全、接口提示、跳转到定义、代码重构等，这在很大程度上提高了开发效率。</p><p>本文主要记录一些常用的 typescript 语法及一些需要辨析的注意点。</p><h2 id="anyScript-使用方法"><a href="#anyScript-使用方法" class="headerlink" title="anyScript 使用方法"></a>anyScript 使用方法</h2><p>用于代码标红但确实不知道如何声明的场景</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> @ts-nocheck 禁用整个文件的ts校验，置于文件头顶<br><span class="hljs-regexp">//</span> @ts-ignore 禁用单行ts校验，放在报错行的上方使用<br>any和unknown<br></code></pre></td></tr></table></figure><p>在遇到确实难以定义类型的场景下可以使用以上方法逃课，以后再思考可能的改进方式。</p><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><p>在 TypeScript 3.1 的文档里，基础类型包括：boolean,string,number,Array&lt;&gt;,Tuple,any,void,undefined,null,never<br>简单记录下使用偏少的类型它的特点。</p><p>辨析点：</p><h3 id="1）unknown-vs-any"><a href="#1）unknown-vs-any" class="headerlink" title="1）unknown vs any"></a>1）unknown vs any</h3><p>unknown 与 any 一样，所有类型都可以分配给 unknown，unknown 类型的值只能赋给 unknown 本身和 any 类型。但 unknown 仍然有静态检测能力，个人理解是 unknown 没有放弃类型的推断，并不是所有类型的内部方法 unknown 类型数据都可以随便调用</p><h3 id="2）void，null-和-undefined"><a href="#2）void，null-和-undefined" class="headerlink" title="2）void，null 和 undefined"></a>2）void，null 和 undefined</h3><p>相同点是这 3 个本身在声明变量的过程中用处不大。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-attr">unusable</span>: <span class="hljs-keyword">void</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">u</span>: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">n</span>: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>默认情况下 null 和 undefined 是所有类型的子类型。<br>undefined 也是 void 的一个子集。当你对函数返回值并不在意（number、boolean、undefined 都可以是返回值）时，使用 void 而不是 undefined。</p><h2 id="接口与类型别名"><a href="#接口与类型别名" class="headerlink" title="接口与类型别名"></a>接口与类型别名</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>可用于对象类型命名和定义类型参数。<br>基本语法：<code>interface SquareConfig &#123;&#125;</code><br>接口名开头需大写，因为定义的是一种类型。</p><h4 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h4><p>使用写法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">interface SquareConfig &#123;<br>  <span class="hljs-attribute">color</span>?: string;<br>  <span class="hljs-attribute">width</span>?: number;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据使用经验，在调用该类型 SquareConfig 的变量其属性时编译等效于：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SquareConfig</span> &#123;<br>  <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span>｜<span class="hljs-literal">undefined</span>;<br>  <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>｜<span class="hljs-literal">undefined</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以假如使用变量的 color 属性调用 string 的默认方法或者赋值给一个 string 变量时就会报错</p><h4 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h4><p>一些对象属性只能在对象刚刚创建的时候修改其值。可以在属性名前用 readonly 来指定只读属性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">readonly</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-keyword">readonly</span> <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>辨析点：<br><strong>const vs readonly</strong>：const 可以防止变量的值被修改，readonly 可以防止变量的属性被修改。</p><h4 id="索引签名"><a href="#索引签名" class="headerlink" title="索引签名"></a>索引签名</h4><p>描述了对象索引的类型，还有相应的索引返回值类型。索引签名只支持以下两种：</p><ul><li>字符串索引签名</li><li>数字索引签名<br>一个接口中最多只能定义一个字符串索引签名，该签名会约束对象类型的所有属性类型。</li></ul><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">interface</span> NumberDictionary &#123;<br>  [<span class="hljs-built_in">index</span>: string]: <span class="hljs-keyword">number</span>;<br>  length: <span class="hljs-keyword">number</span>;    // 可以，length是<span class="hljs-keyword">number</span>类型<br>  <span class="hljs-keyword">name</span>: string       // 错误，`<span class="hljs-keyword">name</span>`的类型与索引类型返回值的类型不匹配<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名声明可以为 TypeScript 中任意类型命名<br>基本语法：<code>type AliasType=string｜boolean｜number</code></p><h3 id="interface-与-type-区别"><a href="#interface-与-type-区别" class="headerlink" title="interface 与 type 区别"></a>interface 与 type 区别</h3><ol><li>type 可以用于非对象类型，而接口只能用于对象类型</li><li>接口可以继承其他对象类型，type 不支持继承只能用交叉类型实现继承效果。</li></ol><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- type类型扩展方式 --&gt;</span></span><br><span class="language-xml">type Name = </span><span class="hljs-template-variable">&#123; name: string &#125;</span><span class="language-xml">;</span><br><span class="language-xml">type Person = Name &amp; </span><span class="hljs-template-variable">&#123; age: number &#125;</span><span class="language-xml">;</span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- interface类型扩展方式 --&gt;</span></span><br><span class="language-xml">interface IName </span><span class="hljs-template-variable">&#123; name: string &#125;</span><span class="language-xml">;</span><br><span class="language-xml">interface IPerson extends IName </span><span class="hljs-template-variable">&#123; age: number &#125;</span><span class="language-xml">;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>接口具有声明合并的行为，type 没有</li></ol><h2 id="运算符使用"><a href="#运算符使用" class="headerlink" title="运算符使用"></a>运算符使用</h2><h3 id="非空断言运算符"><a href="#非空断言运算符" class="headerlink" title="非空断言运算符 !"></a>非空断言运算符 !</h3><p>置于变量名后，用于强调元素不是 null 或 undefined。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">const</span> test=(<span class="hljs-keyword">func</span>:<span class="hljs-params">()</span>=&gt;<span class="hljs-title function_">void</span>)=&gt;&#123;<br>    <span class="hljs-keyword">func</span>!<span class="hljs-params">()</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="可选链运算符"><a href="#可选链运算符" class="headerlink" title="可选链运算符 ?."></a>可选链运算符 ?.</h3><p>ES11(ES2020)新增的特性。?.用来判断左侧的变量是否存在，不存在不会继续表达式运算。例如书写 a?.b 时实际上等效于</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">a === <span class="hljs-literal">null</span> || a === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : a.b;<br></code></pre></td></tr></table></figure><h3 id="空值合并运算符"><a href="#空值合并运算符" class="headerlink" title="空值合并运算符 ??"></a>空值合并运算符 ??</h3><p>ES11(ES2020)新增的特性。当左侧的操作数为 null 或者 undefined 时，返回其右侧操作数，否则返回左侧操作数。<br>let b &#x3D; a ?? 10 等效于</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">let</span> <span class="hljs-string">b</span> <span class="hljs-string">=</span> <span class="hljs-string">a</span> <span class="hljs-type">!==</span> <span class="hljs-literal">null</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">a</span> <span class="hljs-type">!==</span> <span class="hljs-string">void</span> <span class="hljs-number">0</span> <span class="hljs-string">?</span> <span class="hljs-attr">a :</span> <span class="hljs-number">10</span><span class="hljs-string">;</span><br></code></pre></td></tr></table></figure><h3 id="数字分割符"><a href="#数字分割符" class="headerlink" title="数字分割符_"></a>数字分割符_</h3><p>可以用于长数字分隔，方便阅读，不会编译进 JavaScript。个人理解类似计算器的数字每隔 3 位加一个逗号方便阅读的作用。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">let</span> num:number = <span class="hljs-number">12</span>_345.<span class="hljs-number">678</span>_9<br></code></pre></td></tr></table></figure><h2 id="内置工具类型"><a href="#内置工具类型" class="headerlink" title="内置工具类型"></a>内置工具类型</h2><h3 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial<T></h3><p>作用是将泛型 T 所有属性变为可选属性。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">Partial</span>&lt;<span class="hljs-type">T</span>&gt; = &#123;<br>[<span class="hljs-type">P</span> in keyof <span class="hljs-type">T</span>]?: <span class="hljs-type">T</span>[<span class="hljs-type">P</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required<T></h3><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elm">作用是将泛型<span class="hljs-type">T</span>所有属性变为必选属性。<br><span class="hljs-keyword">type</span> <span class="hljs-type">Required</span>&lt;<span class="hljs-type">T</span>&gt; = &#123;<br>  [<span class="hljs-type">P</span> in keyof <span class="hljs-type">T</span>]-?: <span class="hljs-type">T</span>[<span class="hljs-type">P</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Record-lt-K-T-gt"><a href="#Record-lt-K-T-gt" class="headerlink" title="Record&lt;K, T&gt;"></a>Record&lt;K, T&gt;</h3><p>作用是将 K 中所有属性值转化为 T 类型。K 提供对象属性名的联合类型，T 提供对象属性类型。<br>因为 K 是用作对象属性名设置，所以参数 K 必须能够赋值给 string ｜ number ｜ symbol 类型。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Record&lt;K</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">any</span>,<span class="hljs-title">T&gt;</span> </span>= &#123;<br>  [key in <span class="hljs-type">K</span>]: <span class="hljs-type">T</span><br>&#125;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">type</span> K=<span class="hljs-string">&#x27;x&#x27;</span>|<span class="hljs-string">&#x27;y&#x27;</span><br><span class="hljs-keyword">type</span> R=<span class="hljs-keyword">Record</span>&lt;K,number&gt;<br><span class="hljs-keyword">const</span> a:R=<span class="hljs-comment">&#123;x:0,y:0&#125;</span><br></code></pre></td></tr></table></figure><h3 id="Pick-lt-T-K-gt"><a href="#Pick-lt-T-K-gt" class="headerlink" title="Pick&lt;T, K&gt;"></a>Pick&lt;T, K&gt;</h3><p>作用是将 T 类型中的 K 键列表提取，K 必须为对象类型 T 存在的属性。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Pick&lt;T</span>, <span class="hljs-title">K</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">T&gt;</span> </span>= &#123;<br>  [<span class="hljs-type">P</span> in <span class="hljs-type">K</span>]: <span class="hljs-type">T</span>[<span class="hljs-type">P</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">interface <span class="hljs-built_in">Point</span>=&#123;<span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>,<span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>&#125;<br>type T=Pick&lt;<span class="hljs-built_in">Point</span>,<span class="hljs-string">&#x27;x&#x27;</span>|<span class="hljs-string">&#x27;y&#x27;</span>&gt;<span class="hljs-comment">//&#123;x:number,y:number&#125;</span><br></code></pre></td></tr></table></figure><h3 id="Omit-lt-T-K-gt"><a href="#Omit-lt-T-K-gt" class="headerlink" title="Omit&lt;T, K&gt;"></a>Omit&lt;T, K&gt;</h3><p>与<code>Pick&lt;T, K&gt;</code>互补。用于去除类型 T 中包含 K 的键值对。如果 K 为 T 不存在的属性则新类型等同于 T。</p><h3 id="Exclude-lt-T-U-gt"><a href="#Exclude-lt-T-U-gt" class="headerlink" title="Exclude&lt;T, U&gt;"></a>Exclude&lt;T, U&gt;</h3><p>在 T 类型中，去除 T 类型和 U 类型的交集。</p><h3 id="Extract-lt-T-U-gt"><a href="#Extract-lt-T-U-gt" class="headerlink" title="Extract&lt;T, U&gt;"></a>Extract&lt;T, U&gt;</h3><p>与<code>Exclude&lt;T, U&gt;</code>互补。获取 T 类型中所有能赋值给 U 的类型，没有返回 never。</p><h3 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType<T></h3><p>获取 T 类型(函数)对应的返回值类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> &#123; <span class="hljs-comment">/*..*/</span> &#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">FooType</span> = <span class="hljs-title class_">ReturnType</span>&lt;foo&gt;;  <span class="hljs-comment">// string | number</span><br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>（1）<a href="https://juejin.cn/post/6926794697553739784">TypeScript 高级用法</a><br>（2）<a href="https://juejin.cn/post/6981728323051192357#heading-0">一篇够用的 TypeScript 总结</a><br>（3）<a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html">TypeScript 文档</a></p>]]></content>
    
    
    <categories>
      
      <category>前端技术体系</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch查询语句使用</title>
    <link href="/unkown404.github.io/2022/03/14/esUseage/"/>
    <url>/unkown404.github.io/2022/03/14/esUseage/</url>
    
    <content type="html"><![CDATA[<p>es 中的查询请求有两种方式，一种是简易版的查询，另外一种是使用 JSON 完整的请求体，叫做结构化查询（DSL）。DSL 的查询方式是 POST 过去一个 json，由于 post 的请求是 json 格式的，所以存在很多灵活性，也有很多形式。笔者出于使用 nodejs 技术调用 es 查询的需求，因此主要搜集的资料是关于 DSL 的。</p><p>本文并不是查询方法的全列举，而是针对自己实际使用的几种方法进行比较辨析。如果日后尝试使用其他方法，也会在这里添加补充说明。</p><div class="note note-info">            <p>使用 DSL 查询语法时，由于使用 json 字符串时存在特殊符号例如<code>*,/,\</code>等影响解析，因此需要使用两个反斜杠<code>\\</code>进行转义</p>          </div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">calcQueryString</span>=(<span class="hljs-params">keyword:<span class="hljs-built_in">string</span></span>)=&gt;&#123;<br>    <span class="hljs-keyword">return</span> keyword.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/([-\/\\^$*+?.()|[\]&#123;&#125;])/g</span>, <span class="hljs-string">&#x27;\\$1&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="全文查询"><a href="#全文查询" class="headerlink" title="全文查询"></a>全文查询</h2><h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p>不需要完整的卢塞恩语法支持。在查询语句里任何一个词项与分词匹配都会返回该文档。如果要查询所有关键词的文档，可以使用 and 操作符连接。结果里关键词但次序无法保证。</p><p>查询结构示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;match&quot;: &#123;<br>        &quot;<span class="hljs-attribute">content</span>&quot; : <span class="hljs-string">&quot;小白的文件整理箱&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该查询语句可能根据分词规则分为“小白”、“白的”、“文”、“整理箱”等多种关键词，只要有匹配的字词就会被搜出来，例如“文无定法”、“文小白”等都有可能</p><h3 id="match-phrase"><a href="#match-phrase" class="headerlink" title="match_phrase"></a>match_phrase</h3><p>在执行短语匹配查询时，查询结果会满足两个条件：1）必须匹配短语中的所有分词 2）保证各个分词的相对位置不变。</p><p>以 match 的查询语句为例，查询结果不会出现“文小白”，但有可能出现“小白菜的 zip 文件垃圾整理行李箱”</p><h3 id="multi-match"><a href="#multi-match" class="headerlink" title="multi_match"></a>multi_match</h3><p>match 语法的升级，可用于多个字段。也可以用指数符指定多个字段的权重</p><p>查询结构示例：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;multi_match&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;query&quot;</span> : <span class="hljs-string">&quot;小白的文件整理箱&quot;</span>,<br>        <span class="hljs-string">&quot;fields&quot;</span>:[<span class="hljs-string">&quot;title^3&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="query-string"><a href="#query-string" class="headerlink" title="query_string"></a>query_string</h3><p>常见写法：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;query_string&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;query&quot;</span>: <span class="hljs-string">&quot;(new york city) OR (big apple)&quot;</span>,<br>      <span class="hljs-string">&quot;fields&quot;</span>: [<span class="hljs-string">&quot;content&quot;</span>]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>支持运算符 AND 和 OR，括号内的查询语句作为整个查询。<br>支持 wildcard 语法。</p><h2 id="词项查询"><a href="#词项查询" class="headerlink" title="词项查询"></a>词项查询</h2><h3 id="term"><a href="#term" class="headerlink" title="term"></a>term</h3><p>term 是代表完全匹配，返回的文件必须包含完整的关键词。</p><h3 id="terms"><a href="#terms" class="headerlink" title="terms"></a>terms</h3><p>term 的升级版，可以查询多个字词。例如查询 content 字段包含“小白”和“文件整理箱”的文档。</p><p>查询结构示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;terms&quot;: &#123;<br>        &quot;<span class="hljs-attribute">content</span>&quot; : [<span class="hljs-string">&quot;小白&quot;</span>,<span class="hljs-string">&quot;文件整理箱&quot;</span>]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="prefix"><a href="#prefix" class="headerlink" title="prefix"></a>prefix</h3><p>查询某个字段以固定前缀开始的文档。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;prefix&quot;: &#123;<br>        &quot;<span class="hljs-attribute">content</span>&quot; : <span class="hljs-string">&quot;小白&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该查询语句会返回“小白”、“小白菜”等所有以“小白”开头的content文档。</p><h3 id="wildcard"><a href="#wildcard" class="headerlink" title="wildcard"></a>wildcard</h3><p>支持通配符搜索，可以使用?替换单个字符，用*替换零个或多个字符。通配符的查询效率较低不是很推荐。</p><h3 id="regexp"><a href="#regexp" class="headerlink" title="regexp"></a>regexp</h3><p>可以支持更为复杂的匹配模式。<em>（个人体验感觉不佳，用于带转义字段的查询时往往查不到，不知道什么原因；不如js的正则好用）</em></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;regexp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;postcode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;W[0-9].+&quot;</span> <br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="查询语句text字段和keyword字段的区别"><a href="#查询语句text字段和keyword字段的区别" class="headerlink" title="查询语句text字段和keyword字段的区别"></a>查询语句text字段和keyword字段的区别</h2><p>ElasticSearch 5.0以后，String字段被拆分成两种新的数据类型: text用于全文搜索，会分词,而keyword用于关键词搜索，不进行分词。对于字符串类型的字段，ES默认会再生成一个keyword字段用于精确索引。</p><p>简单理解就是text字段会被分词，而keyword字段是要求不分词完整地查找全字段。</p><p>keyword的查询语句如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;term&quot;: &#123;<br>        &quot;<span class="hljs-attribute">content</span><span class="hljs-selector-class">.keyword</span>&quot; : <span class="hljs-string">&quot;小白&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="查询字段时-term、match、match-phrase、query-string-的区别"><a href="#查询字段时-term、match、match-phrase、query-string-的区别" class="headerlink" title="查询字段时 term、match、match_phrase、query_string 的区别"></a>查询字段时 term、match、match_phrase、query_string 的区别</h2><h3 id="1-1-term"><a href="#1-1-term" class="headerlink" title="1.1 term"></a>1.1 term</h3><p>1）term 查询 keyword 字段。</p><p>term 不会分词。而 keyword 字段也不分词。需要完全匹配才可。</p><p>2）term 查询 text 字段</p><p>因为 text 字段会分词，而 term 不分词，所以 term 查询的条件必须是 text 字段分词后的某一个。</p><p>eg. brown big box 作为 text 字段会被分为[ brown, big, box ]的词组，当 term 的查询内容为 brown 时可返回该词条<br>当 term 的查询内容为 brown big 的时候则不会返回</p><h3 id="1-2-match"><a href="#1-2-match" class="headerlink" title="1.2 match"></a>1.2 match</h3><p>1）match 查询 keyword 字段</p><p>match 会被分词，而 keyword 不会被分词，match 的需要跟 keyword 的完全匹配可以。</p><p>其他的不完全匹配的都是失败的。</p><p>2）match 查询 text 字段</p><p>match 分词，text 也分词，只要 match 的分词结果和 text 的分词结果有相同的就匹配。</p><p>eg. brown big box 的词条，当 term 的查询内容为 fox 时也可返回该词条，因为存在“ox“这一相同内容</p><h3 id="1-3-match-phrase"><a href="#1-3-match-phrase" class="headerlink" title="1.3.match_phrase"></a>1.3.match_phrase</h3><p>1）match_phrase 匹配 keyword 字段。</p><p>这个同上必须跟 keyword 一致才可以。</p><p>2）match_phrase 匹配 text 字段。</p><p>match_phrase 是分词的，text 也是分词的。match_phrase 的分词结果必须在 text 字段分词中都包含，而且顺序必须相同，而且必须都是连续的。</p><p><em>（与 match 匹配 text 情况相比就多了顺序相同一个条件）</em></p><h3 id="1-4-query-string"><a href="#1-4-query-string" class="headerlink" title="1.4.query_string"></a>1.4.query_string</h3><p>1）query_string 查询 keyword 类型的字段。</p><p>网上有说法无法查询。但根据实际经验做长字符串的查询是可行的，可能是 Lucene 语法使用不当的问题。  </p><p>query_string 查询 keyword 字段如果只是使用了局部字段查询的话需要在前后加“*”。</p><p>2）query_string 查询 text 类型的字段。</p><p>和 match_phrase 区别的是，不需要连续，顺序还可以调换。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>（1）<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html">Elasticsearch Guide</a><br>（2）《从Lucene到ElasticSearch：全文检索实战》<br>（3）<a href="https://www.cnblogs.com/duanxz/p/3508338.html">ES之五：关于Elasticsearch查找相关的问题汇总（match、match_phrase、query_string和term）</a><br>（4）<a href="https://www.cnblogs.com/yjf512/p/4897294.html">elasticsearch 查询（match和term）</a></p>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo搭建博客</title>
    <link href="/unkown404.github.io/2022/03/14/hexoBlog/"/>
    <url>/unkown404.github.io/2022/03/14/hexoBlog/</url>
    
    <content type="html"><![CDATA[<h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2><p>1）<a href="https://nodejs.org/zh-cn/">node.js</a><br>2) <a href="https://git-scm.com/">git</a></p><h2 id="本地建站流程"><a href="#本地建站流程" class="headerlink" title="本地建站流程"></a>本地建站流程</h2><p>1.在<a href="https://gitee.com/">Gitee</a>注册登录账号，点击右上角“+”按钮创建新的仓库。仓库名可随意设置。但注意初始化时不要加文件。<br><img src="/unkown404.github.io/img/gitee-init.png"></p><div class="note note-info">            <p>根据网上大多数博客的说法仓库名应该设置为用户名，否则 hexo 打包的 css 路径会找不到。但是实际操作中并没有遇到这样的问题推测有两个可能性。<br>1）这个问题只出现在 GitHub Page 开设的流程。<br>2）配置更新了，现在新版 hexo 的打包确保了相对路径的可查找性。</p>          </div> <p>2.将空仓库拉到本地，安装 hexo，安装指令如下：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install hexo-<span class="hljs-keyword">cli</span> -g<br><br></code></pre></td></tr></table></figure><p>3.使用指令<code>hexo init</code>初始化 hexo，注意如果仓库的文件夹不为空的话，初始化就会失败，可以考虑新建一个文件夹，在新文件夹的位置启动初始化指令。<br><em>（推荐将初始化生成的文件夹都放在仓库的另一个分支，master 分支保留给 hexo 打包博客文件）</em><br>初始化后当前文件夹内部结构如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<br>├── _config.yml <span class="hljs-regexp">//</span>网站的配置文件，可配置大部分参数<br>├── package.json<br>├── scaffolds  <span class="hljs-regexp">//</span>模版文件夹<br>├── source  <span class="hljs-regexp">//</span>资源文件夹，用户添加资源的位置<br>|   ├── _drafts  <span class="hljs-regexp">//</span>草稿<br>|   └── _posts   <span class="hljs-regexp">//</span>博文<br>└── themes  <span class="hljs-regexp">//</span>主题文件夹。Hexo 会根据主题来生成静态页面。<br></code></pre></td></tr></table></figure><p>4.初始化完成以后 package.json 新增了几个指令，包括</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hexo generate&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;clean&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hexo clean&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;deploy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hexo deploy&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;server&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hexo server&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>新增的 hexo 指令的意义是：</p><blockquote><p>hexo clean —— 清空已有 hexo 网站文件<br>hexo generate(or g) —— 依据网页文本与新的 CSS 样式生成新网站文件<br>hexo server(or s) —— 启动本地服务器，可以在 localhost:4000 查看网站修改效果<br>按上述顺序执行就可以在 localhost:4000 看到默认版式下的页面了。一般默认的是一个 landscape 主题。</p></blockquote><p>到此为止一个简单的博客就在本地建好了。我们可以通过调整 themes 文件夹的主题、修改_config.yml 文件来使自己的博客更加个性化。</p><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>hexo 有自己的<a href="https://hexo.io/themes/">主题网站</a>，可以选择自己感兴趣的主题点击进入其 github 主页进行下载，解压后添加到 themes 文件夹下。</p><p>虽然 hexo 的主题丰富，很容易找到合意的个性主题。但是第一次使用时最好找一个比较常用的模版，这样说明文档比较丰富、遇到问题网上搜索时也很容易找到答案 😭</p><p>个人比较推荐并以后打算尝试的模版包括<a href="https://github.com/theme-next/hexo-theme-next">Next</a> (大家都喜欢应该是有理由的吧)、<a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a> (文档看着真齐全)。</p><p>当前使用的主题是<a href="https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak">tranquilpeak</a>，看着比较美观。后续以该主题为例讲解配置修改。</p><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p>1）GitHub 网站上以 zip 方式下载<br>2）将解压后的文件夹命名为 tranquilpeak 添加到博客的 themes 文件夹下<br>3）打开博客仓库的终端进入到 tranquilpeak 文件夹位置执行<code>npm install &amp;&amp; npm run prod</code><br>4）调整博客仓库主文件夹下的<code>theme: tranquilpeak</code><br>5）使用指令 hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 即可看到新样式</p><h3 id="tranquilpeak-相关配置"><a href="#tranquilpeak-相关配置" class="headerlink" title="tranquilpeak 相关配置"></a>tranquilpeak 相关配置</h3><p>tranquilpeak 主题文件夹下也有_config.yml 配置文件，在我下载的当前版本 4.1.3 里，作者把配置分为了“Sidebar Configuration”、“Header configuration”、“Author“、“Customization”、“Comment systems”、“Integrated services”和“Sharing options”。<br><strong>Sidebar Configuration</strong>：提供了侧边栏的菜单配置，可以根据自己的需求增减项目、调整链接</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">sidebar:</span>                   <br><span class="hljs-symbol">         menu:</span>                 <br><span class="hljs-symbol">             home:</span>             <br><span class="hljs-symbol">                title:</span> Home    <span class="hljs-meta"># 链接标题</span><br><span class="hljs-symbol">                url:</span> /         <span class="hljs-meta"># 链接URL</span><br><span class="hljs-symbol">                icon:</span> home     <span class="hljs-meta"># Font Awesome 图标名,https:<span class="hljs-comment">//fontawesome.com/icons?d=gallery&amp;m=free 上可以找到合适的图标</span></span><br></code></pre></td></tr></table></figure><p><strong>Header configuration</strong>：用于编辑头部右上角链接<br><strong>Author</strong>：编辑作者信息，包括以下几个部分。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">author:</span><br><span class="hljs-symbol">    email:</span> <br><span class="hljs-symbol">    location:</span> <br><span class="hljs-symbol">    picture:</span> <br><span class="hljs-symbol">    twitter:</span><br><span class="hljs-symbol">    google_plus:</span><br><span class="hljs-symbol">    google_plus_business:</span><br></code></pre></td></tr></table></figure><p>其中location和picture的填写内容会显示在关于（作者）的页面上。而作者的其他信息例如座右铭、工作等则是在博客总文件夹下的语言选项选定以后，在<code>tranquilpeak\languages\</code>下寻找对应语言的模版，修改作者相关的信息。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">author:</span><br>    <span class="hljs-meta"># 你的个人简介 (支持 Markdown 和 HTML 语法)</span><br><span class="hljs-symbol">    bio:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-meta"># 你的工作简介</span><br><span class="hljs-symbol">    job:</span> <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p><strong>Customization</strong>：有关于侧边栏的展示方法（sidebar_behavior）、文章列表缩略图位置（thumbnail_image_position）、封面图（cover_image）等配置。</p><p>“Comment systems”、“Integrated services”和“Sharing options”等配置暂时没有用到，以后再研究。</p><h2 id="书写博文"><a href="#书写博文" class="headerlink" title="书写博文"></a>书写博文</h2><p>1）可在终端执行如下指令完成页面新建</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">hexo <span class="hljs-keyword">new</span> [layout] &lt;<span class="hljs-built_in">title</span>&gt;<br></code></pre></td></tr></table></figure><p>layout变量可以有三种选择：post、page 和 draft。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 post 相同，都将储存到 source&#x2F;_posts 文件夹。</p><table><thead><tr><th align="center">layout选项</th><th align="center">生成文件路径</th></tr></thead><tbody><tr><td align="center">post</td><td align="center">source&#x2F;_posts</td></tr><tr><td align="center">page</td><td align="center">source</td></tr><tr><td align="center">draft</td><td align="center">source&#x2F;_drafts</td></tr></tbody></table><p>title是文章的名称，执行完指令后会在layout对应的路径下生成<code>&lt;title&gt;.md</code>文件。如果工程文件夹下的_config.yml 文件里<code>post_asset_folder</code>这一选项置为true的话则还会生成一个title的文件夹，可以存放引用资源。</p><p>2）调整文章内容<br>生成的文件头部通常会包含以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <br><span class="hljs-attr">date:</span> <br><span class="hljs-attr">tags:</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>如果是草稿则没有自动生成的date变量，执行语句<code>hexo publish draft  &lt;title&gt;</code>、移动到source&#x2F;_posts 文件夹时应该会出现。<br>根据自己的需要，可以在文件头部增加内容。以tranquilpeak为例，该样式支持categories、thumbnailImage、excerpt等配置。配置categories可以在分类页面看到自己这篇文章的归类情况；配置thumbnailImage时会在文章列表增加缩略图，但本地是看不到效果的，只有打包上传到gitee后才可以；配置excerpt时首页文章列表不会展示全文而只会展示摘要。<br>tranquilpeak模版还支持两个标签语法：<code>&lt;!-- more --&gt;</code>和&#96;&#96;。前者是将标志之前的内容将会自动生成首页的概览，后者则是自动生成文章目录。<br>具体的内容书写可以参考markdown语法。</p><h2 id="推送到gitee"><a href="#推送到gitee" class="headerlink" title="推送到gitee"></a>推送到gitee</h2><p>1）首先需要安装推送工具hexo-deployer-git。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>2）在博客工程文件夹下的_config.yml找到URL和deploy的配置。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># URL</span><br><span class="hljs-comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><br>url: https:<span class="hljs-regexp">//u</span>nknown-four-hundred-and-four.gitee.io/unknown_404<br><br>...<br><br>deploy:<br>  type: git<br>  repository: https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/unknown-four-hundred-and-four/u</span>nknown_404.git<br>  branch: master<br></code></pre></td></tr></table></figure><p>这里URL需要改成静态资源最后部署的域名，按照配置文件的说明，应该是<code>https://&#123;username&#125;.github.io/&#123;project&#125;</code>的格式，username是GitHub用户名，在GitHub上仓库名和用户名是相同，但在gitee上可以不一样，所以要注意实际上需要填入的是仓库名。project对应当前博客的工程名。<br>deploy选项里repository对应博客仓库的git地址，branch可根据需要修改，部署到page时注意一致性即可。<br>3）文件生成成功后执行<code>hexo deploy</code>指令，将文件推到远程仓库的master分支上。<br><img src="/unkown404.github.io/img/gitee-master.png"></p><h2 id="gitee-page服务启动"><a href="#gitee-page服务启动" class="headerlink" title="gitee page服务启动"></a>gitee page服务启动</h2><p>1）在gitee仓库首页选择“服务-Gitee Page”<br><img src="/unkown404.github.io/img/gitee-page.png"></p><p>2）如果没有实名认证的话开启Page服务需要验证，还需要绑定手机号。<br>3）进入到Gitee Pages 服务页面，选择部署分支，注意和工程文件夹下的_config.yml的deploy配置一致，如果选择了强制使用https，则工程文件夹下_config.yml的url配置也必须是https。<br><img src="/unkown404.github.io/img/gitee-start.png"></p><h2 id="其他客户端拉取代码的注意事项"><a href="#其他客户端拉取代码的注意事项" class="headerlink" title="其他客户端拉取代码的注意事项"></a>其他客户端拉取代码的注意事项</h2><p>本博客使用的主题tranquilpeak其资源assets是被列入忽略文件夹的内容，因此拉下来的代码不会包括这部分资源，如果直接启动无法正常看到页面样式。需要使用者在拉取代码以后进入主题的文件夹下按要求操作<code>npm install &amp;&amp; npm run prod</code>才可在本地看到正常的样式。如果之前将头像等资源放在assets文件夹下的话也需要在新生成的assets文件夹下重新加入。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>（1）<a href="https://cungudafa.blog.csdn.net/article/details/104260494?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~LandingCtr~Rate-1.queryctrv4&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~LandingCtr~Rate-1.queryctrv4&utm_relevant_index=1">基于Gitee+Hexo搭建个人博客</a><br>（2）<a href="https://hexo.io/zh-cn/docs/writing">Hexo中文文档</a><br>（3）<a href="https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak/blob/master/DOCUMENTATION.md">tranquilpeak配置</a></p>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>markdown笔记</title>
    <link href="/unkown404.github.io/2022/03/13/markdown%E7%AC%94%E8%AE%B0/"/>
    <url>/unkown404.github.io/2022/03/13/markdown%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。<br>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。<br>Markdown 编写的文档后缀为 .md, .markdown。</p></blockquote><h2 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h2><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h3><p>使用 # 号可表示 1-6 级标题，一级标题对应一个 <code>#</code>号，二级标题对应两个 <code>#</code> 号，以此类推。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean"># 这是一级标题<br>## 这是二级标题<br>### 这是三级标题<br>#### 这是四级标题<br>##### 这是五级标题<br>###### 这是六级标题<br></code></pre></td></tr></table></figure><p>效果：</p><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><h3 id="2-文字"><a href="#2-文字" class="headerlink" title="2.文字"></a>2.文字</h3><p>Markdown支持文字加粗、斜体、下划线、删除线等。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">*斜体文本*</span><br><span class="hljs-emphasis">_斜体文本_</span><br><span class="hljs-strong">**粗体文本**</span><br><span class="hljs-emphasis">__粗体文本__</span><br><span class="hljs-strong">***粗斜体文本**</span>*<br><span class="hljs-emphasis">___粗斜体文本__</span>_<br>&lt;u&gt;带下划线文本&lt;/u&gt;  <br>~~删除线文本~~<br>创建脚注格式类似这样 [^RUNOOB]。<br><br>[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！<br></code></pre></td></tr></table></figure><p>效果：<br><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><em><strong>粗斜体文本</strong></em><br><em><strong>粗斜体文本</strong></em><br><u>带下划线文本</u><br><del>删除线文本</del><br>创建脚注格式类似这样 [^RUNOOB]。</p><p>[^RUNOOB]: 菜鸟教程 – 学的不仅是技术，更是梦想！！！</p><h3 id="3-段落"><a href="#3-段落" class="headerlink" title="3.段落"></a>3.段落</h3><p><strong>分割线</strong>：三个或者三个以上的 - 或者 * 都可以。显示效果是一样的。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">---</span><br><span class="hljs-section">----</span><br><span class="hljs-bullet">***</span><br><span class="hljs-bullet"></span><span class="hljs-strong">*****</span><br></code></pre></td></tr></table></figure><h2 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h2><hr><hr><hr><p><strong>换行</strong>：使用两个以上空格加上回车，或者在段落后面使用一个空行来表示重新开始一个段落。</p><h3 id="4-链接与图片"><a href="#4-链接与图片" class="headerlink" title="4.链接与图片"></a>4.链接与图片</h3><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">1</span>）[超链接名](超链接地址 <span class="hljs-string">&quot;超链接title（optional）&quot;</span>)<br><span class="hljs-number">2</span>）&lt;<span class="hljs-keyword">https</span>://www.runoob.com&gt;直接使用链接地址<br><span class="hljs-number">3</span>）&lt;<span class="hljs-keyword">a</span> href=<span class="hljs-string">&quot;https://www.runoob.com&quot;</span> target=<span class="hljs-string">&quot;_blank&quot;</span>&gt;菜鸟教程&lt;/<span class="hljs-keyword">a</span>&gt;支持在新页面打开<br></code></pre></td></tr></table></figure><p>效果：<br><a href="https://www.runoob.com/">菜鸟教程</a><br><a href="https://www.runoob.com/">https://www.runoob.com</a><br><a href="https://www.runoob.com" target="_blank">菜鸟教程</a>  </p><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p>示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">格式：![alt 属性文本](图片地址 <span class="hljs-string">&quot;可选标题&quot;</span>)<br><br>![RUNOOB 图标](http:<span class="hljs-regexp">//</span>static.runoob.com<span class="hljs-regexp">/images/</span>runoob-logo.png <span class="hljs-string">&quot;RUNOOB&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标" title="RUNOOB"></p><h3 id="5-区块与代码"><a href="#5-区块与代码" class="headerlink" title="5.区块与代码"></a>5.区块与代码</h3><h4 id="区块："><a href="#区块：" class="headerlink" title="区块："></a>区块：</h4><p>区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号<br><em>区块嵌套</em> ：一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><p>单行代码：代码之间分别用一个反引号包起来<br>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p><h3 id="6-列表"><a href="#6-列表" class="headerlink" title="6.列表"></a>6.列表</h3><h4 id="无序列表："><a href="#无序列表：" class="headerlink" title="无序列表："></a>无序列表：</h4><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 列表内容<br><span class="hljs-bullet">+</span> 列表内容<br><span class="hljs-bullet">*</span> 列表内容<br><br>注意：- + <span class="hljs-emphasis">* 跟内容之间都要有一个空格</span><br></code></pre></td></tr></table></figure><p>效果：  </p><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ul><li>列表内容  <h4 id="有序列表："><a href="#有序列表：" class="headerlink" title="有序列表："></a>有序列表：</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 列表内容<br><span class="hljs-bullet">2.</span> 列表内容<br><span class="hljs-bullet">3.</span> 列表内容<br><br>注意：序号跟内容之间要有空格<br></code></pre></td></tr></table></figure>效果：</li></ul><ol><li>列表内容  </li><li>列表内容  </li><li>列表内容</li></ol><p><em>列表嵌套</em>：上一级和下一级之间敲三个空格即可</p><h3 id="7-表格"><a href="#7-表格" class="headerlink" title="7.表格"></a>7.表格</h3><p><code>|</code>来分隔不同的单元格，使用 <code>-</code>来分隔表头和其他行。</p><h4 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h4><p>我们可以设置表格的对齐方式：</p><ul><li>-: 设置内容和标题栏居右对齐。</li><li>:- 设置内容和标题栏居左对齐。</li><li>:-: 设置内容和标题栏居中对齐。<br>示例：<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> 左对齐 </span>|<span class="hljs-string"> 右对齐 </span>|<span class="hljs-string"> 居中对齐 </span>|<br>|<span class="hljs-string"> :-----</span>|<span class="hljs-string"> ----: </span>|<span class="hljs-string"> :----: </span>|<br>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<br>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table></li></ul><h2 id="Markdown效果预览"><a href="#Markdown效果预览" class="headerlink" title="Markdown效果预览"></a>Markdown效果预览</h2><p>VsCode：快捷键command+shift+v</p><h2 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h2><ol><li><a href="https://www.runoob.com/markdown/md-table.html">菜鸟教程</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
