<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>HeadlessUI组件库</title>
    <link href="/unknown404.github.io/2025/07/01/headlessui/"/>
    <url>/unknown404.github.io/2025/07/01/headlessui/</url>
    
    <content type="html"><![CDATA[<p>最近开发新项目的时候遇到了一些问题：由于设计绘制的左侧菜单过于个性化，在使用 antd 的 Menu 组件时不得不做了大量调整：包括强行改写 antd 内部 css 样式、每次菜单发生特殊的交互操作时都更新 Menu 的 items 属性的赋值变量。由此产生思考：是否可以使用更基础的功能组件来实现需求、不需要强行复写组件内部的预定样式。</p><span id="more"></span><h2 id="Headless-UI"><a href="#Headless-UI" class="headerlink" title="Headless UI"></a>Headless UI</h2><p>全称是 Headless User Interface （无头用户界面），是一种前端开发的方法论（亦或者是一种设计模式），其核心思想是将 用户界面（UI）的逻辑 和 交互行为 与 视觉表现（CSS 样式） 分离开来。</p><h2 id="无头组件库"><a href="#无头组件库" class="headerlink" title="无头组件库"></a>无头组件库</h2><p>和传统的 UI 组件库（如 Ant Design、Element UI）不同，无头组件库是“只提供逻辑、不提供样式”的组件库。它帮你处理好交互逻辑（比如弹窗开关、键盘控制、焦点管理等），但不渲染任何具体的 HTML &#x2F; CSS —— 样式、DOM 结构都由你自己决定。<br>目前比较有名的无头组件库有以下几个：</p><h3 id="Headless-UI-1"><a href="#Headless-UI-1" class="headerlink" title="Headless UI"></a>Headless UI</h3><p>作者：Tailwind Labs（也就是 Tailwind CSS 的官方团队）<br>支持框架：React、Vue<br>特点：</p><ul><li>完全无样式、可组合</li><li>支持无障碍（ARIA）和键盘导航</li><li>官方推荐搭配 Tailwind 使用，但可任意定制</li></ul><h3 id="Radix-UI"><a href="#Radix-UI" class="headerlink" title="Radix UI"></a>Radix UI</h3><p>支持框架：React<br>特点：</p><ul><li>完善的无障碍支持（ARIA）</li><li>稳定、灵活，且结构清晰</li><li>组件有独立的分包可以安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install @radix-ui/react-dialog<br>npm install @radix-ui/react-dropdown-menu<br>npm install @radix-ui/react-tooltip<br></code></pre></td></tr></table></figure><h3 id="shadcn-x2F-ui"><a href="#shadcn-x2F-ui" class="headerlink" title="shadcn&#x2F;ui"></a>shadcn&#x2F;ui</h3><p>支持框架：React<br>特点：</p><ul><li>基于 Tailwind CSS 和 Radix UI</li><li>不通过 npm 安装，而是直接将组件源代码复制粘贴到项目中,用户可根据自己的需求去修改和扩展代码<br>eg.执行指令<code>npx shadcn@latest add button</code>后，会直接将组件 Button 的代码加到用户的项目里</li><li>使用class-variance-authority，组件有了 variant 的功能</li></ul><h3 id="Ark-UI"><a href="#Ark-UI" class="headerlink" title="Ark UI"></a>Ark UI</h3><p>作者：Chakra 团队<br>支持框架：React、Vue、Solid<br>特点：</p><ul><li>利用 Zag. js 为多个 JavaScript 框架提供支持。</li><li>支持 Tailwind 样式，也可以结合 data-*和设置 className 来定制样式</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;<span class="hljs-title class_">Accordion</span>.<span class="hljs-property">Root</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Accordion.Item</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;AccordionItem border-b border-gray-300 data-[state=open]:bg-gray-100&quot;</span>&gt;</span></span><br><span class="language-xml">    &#123;/* … */&#125;</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">Accordion.Item</span>&gt;</span></span><br>&lt;/<span class="hljs-title class_">Accordion</span>.<span class="hljs-property">Root</span>&gt;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.AccordionItem</span> &#123;<br>  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#e5e5e5</span>;<br><br>  &amp;<span class="hljs-selector-attr">[data-state=<span class="hljs-string">&quot;open&quot;</span>]</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f5f5f5</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="个人迷思：关于-Menu-组件"><a href="#个人迷思：关于-Menu-组件" class="headerlink" title="个人迷思：关于 Menu 组件"></a>个人迷思：关于 Menu 组件</h2><p>因为我是出于 Antd 的 Menu 改造太过复杂所以才希望找个无头 Menu 组件来简化代码，然而事实上在阅读了这些组件的说明文档后，我发现它们的 Menu 组件都是属于下拉菜单 Dropdown，而不是 Antd 的导航菜单栏。可能是因为 Antd 的这种 Menu 组件封装比较重，而无头组件一般比较原子化，如果真要实现 Menu 组件的话，一般来说用 Collapse&#x2F;Disclosure+Button 等实现</p>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>headless ui</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSE接入web、小程序</title>
    <link href="/unknown404.github.io/2025/05/21/sse/"/>
    <url>/unknown404.github.io/2025/05/21/sse/</url>
    
    <content type="html"><![CDATA[<p>最近调用智能体的方式做出了调整，变更为 SSE 方式。</p><h2 id="什么是-SSE"><a href="#什么是-SSE" class="headerlink" title="什么是 SSE"></a>什么是 SSE</h2><p>SSE（Server-Sent Events）是一种浏览器原生支持的服务端向客户端推送数据的技术，非常适合用于实现流式响应。整个响应流程如下：</p><ol><li>客户端通过发送一个普通的 HTTP 请求建立连接。</li><li>服务端返回一个 Content-Type: text&#x2F;event-stream 的响应。</li><li>后续服务端可以不断往这个连接中推送数据流（保持连接不断）。</li><li>客户端通过监听事件流不断接收数据。</li></ol><h2 id="浏览器实现-SSE"><a href="#浏览器实现-SSE" class="headerlink" title="浏览器实现 SSE"></a>浏览器实现 SSE</h2><p>虽然浏览器提供了原生 API： EventSource，可以通过以下代码来接收服务器数据，但是它不支持发起 POST 请求，如果考虑发送数据以及处理请求一些状态，最好还是用 xhr 或者 fetch</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> eventSource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventSource</span>(<span class="hljs-string">&quot;http://localhost:3000&quot;</span>);<br><br>eventSource.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;收到消息:&quot;</span>, event.<span class="hljs-property">data</span>);<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;messages&quot;</span>).<span class="hljs-property">innerHTML</span> += <span class="hljs-string">`&lt;p&gt;<span class="hljs-subst">$&#123;event.data&#125;</span>&lt;/p&gt;`</span>;<br>&#125;);<br><br>eventSource.<span class="hljs-property">onopen</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;连接已打开&quot;</span>);<br>eventSource.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;连接中断，将自动重连&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用 fetch 时数据处理流程如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">TextDecoder</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;text-encoding-shim&quot;</span>;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://xxx.com/getData&quot;</span>);<br>    <span class="hljs-keyword">const</span> isStream =<br>      response.<span class="hljs-property">headers</span>?.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;Content-Type&quot;</span>) == <span class="hljs-string">&quot;text/event-stream&quot;</span>;<br>    <span class="hljs-keyword">if</span> (isStream) &#123;<br>      <span class="hljs-keyword">const</span> reader = response.<span class="hljs-property">body</span>.<span class="hljs-title function_">getReader</span>();<br>      <span class="hljs-keyword">const</span> decoder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDecoder</span>();<br>      <span class="hljs-keyword">let</span> buffer = <span class="hljs-string">&quot;&quot;</span>;<br>      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">const</span> &#123; done, value &#125; = <span class="hljs-keyword">await</span> reader.<span class="hljs-title function_">read</span>();<br>        <span class="hljs-keyword">if</span> (done) &#123;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>        buffer += decoder.<span class="hljs-title function_">decode</span>(value, &#123;<br>          <span class="hljs-attr">stream</span>: <span class="hljs-literal">true</span>,<br>        &#125;);<br>        <span class="hljs-keyword">const</span> lines = buffer.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        buffer = lines.<span class="hljs-title function_">pop</span>() || <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> line <span class="hljs-keyword">of</span> lines) &#123;<br>          <span class="hljs-keyword">if</span> (line.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&quot;data:&quot;</span>)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-keyword">const</span> jsonData = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(line.<span class="hljs-title function_">substring</span>(<span class="hljs-number">5</span>).<span class="hljs-title function_">trim</span>());<br>              <span class="hljs-title function_">processNewData</span>(jsonData);<br>            &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>              <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Error parsing SSE data:&quot;</span>, e);<br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Error:&quot;</span>, error);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>处理流程包括以下几个步骤：</p><ol><li>读取返回头 Content-Type，确认是 sse 数据</li><li>新建文本解码器（Uint8Array -&gt; 字符串），循环读取返回内容，直到标志位 done 指示结束</li><li>根据与后端商议的规则按行（\n）拆分数据，并保留最后一行不完整内容（如果存在）继续拼接。</li><li>提取 data: 后的内容，尝试 JSON.parse() 并传给 processNewData() 做进一步处理</li></ol><h3 id="SSE-格式参考"><a href="#SSE-格式参考" class="headerlink" title="SSE 格式参考"></a>SSE 格式参考</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs md">event:message<br>data:&#123;&quot;id&quot;:&quot;chatcmpl-Bp4ua73uKkcPSoa8QXdkNC1v12HOO&quot;,&quot;model&quot;:&quot;gpt-4o-mini-2024-07-18&quot;,&quot;object&quot;:&quot;chat.completion&quot;,&quot;choices&quot;:[&#123;&quot;index&quot;:0,&quot;delta&quot;:&#123;&quot;content&quot;:&quot;<span class="hljs-strong">**&quot;&#125;&#125;],&quot;created&quot;:1751513308,&quot;system<span class="hljs-emphasis">_fingerprint&quot;:&quot;fp_</span>efad92c60b&quot;&#125;</span><br><span class="hljs-strong"></span><br><span class="hljs-strong">event:message</span><br><span class="hljs-strong">data:&#123;&quot;id&quot;:&quot;chatcmpl-Bp4ua73uKkcPSoa8QXdkNC1v12HOO&quot;,&quot;model&quot;:&quot;gpt-4o-mini-2024-07-18&quot;,&quot;object&quot;:&quot;chat.completion&quot;,&quot;choices&quot;:[&#123;&quot;index&quot;:0,&quot;delta&quot;:&#123;&quot;content&quot;:&quot;视频&quot;&#125;&#125;],&quot;created&quot;:1751513308,&quot;system<span class="hljs-emphasis">_fingerprint&quot;:&quot;fp_</span>efad92c60b&quot;&#125;</span><br></code></pre></td></tr></table></figure><h2 id="小程序实现-SSE"><a href="#小程序实现-SSE" class="headerlink" title="小程序实现 SSE"></a>小程序实现 SSE</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> requestTask = wx.<span class="hljs-title function_">request</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">`https://xxx.com/getData`</span>,<br>    <span class="hljs-attr">enableChunked</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 开启分块接收</span><br>    <span class="hljs-title function_">success</span>(<span class="hljs-params">res</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Request succeeded&quot;</span>, res);<br>    &#125;,<br>    <span class="hljs-title function_">fail</span>(<span class="hljs-params">err</span>) &#123;<br>      <span class="hljs-keyword">if</span> (err?.<span class="hljs-property">errMsg</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;abort&quot;</span>)) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 手动停止的话，则不再进入catch</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Request failed:&quot;</span>, err);<br>      <span class="hljs-title function_">onError</span>(err);<br>    &#125;,<br>  &#125;);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">chunkFn</span> = (<span class="hljs-params">chunk</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (store.<span class="hljs-property">state</span>.<span class="hljs-property">root</span>.<span class="hljs-property">isStop</span>) &#123;<br>      requestTask?.<span class="hljs-title function_">abort</span>();<br>      requestTask?.<span class="hljs-title function_">offChunkReceived</span>(chunkFn);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> uint8Array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(chunk.<span class="hljs-property">data</span>); <span class="hljs-comment">// 将二进制数据转换为 Uint8Array</span><br><br>    <span class="hljs-keyword">const</span> text = decoder.<span class="hljs-title function_">decode</span>(uint8Array, &#123;<br>      <span class="hljs-attr">stream</span>: <span class="hljs-literal">true</span>,<br>    &#125;); <span class="hljs-comment">// 解码为字符串</span><br>    buffer += text; <span class="hljs-comment">// 将新数据追加到缓存区</span><br>    <span class="hljs-comment">// 按行分割数据</span><br>    <span class="hljs-keyword">const</span> lines = buffer.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    buffer = lines.<span class="hljs-title function_">pop</span>() || <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 保留未处理完的数据</span><br><br>    <span class="hljs-keyword">let</span> jsonBuffer = &#123;&#125;;<br>    <span class="hljs-keyword">if</span> (buffer) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        jsonBuffer = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(buffer);<br>      &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;error&quot;</span>, error);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> line <span class="hljs-keyword">of</span> lines) &#123;<br>      <span class="hljs-keyword">if</span> (line.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&quot;data:&quot;</span>)) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">const</span> jsonData = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(line.<span class="hljs-title function_">substring</span>(<span class="hljs-number">5</span>).<span class="hljs-title function_">trim</span>());<br>          <span class="hljs-title function_">processNewData</span>(jsonData);<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Error parsing SSE data:&quot;</span>, e);<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;;<br>  <span class="hljs-comment">// 监听分块数据</span><br>  requestTask.<span class="hljs-title function_">onChunkReceived</span>(chunkFn);<br>  <span class="hljs-keyword">return</span> requestTask;<br>&#125;<br></code></pre></td></tr></table></figure><p>小程序的处理流程和浏览器类似，需要的注意的有几点：</p><ol><li>enableChunked 需要设置为 true，onChunkReceived 设置数据处理，这样就可以分块处理数据</li><li>chunk 数据是二进制，需要用 Uint8Array 处理</li><li>微信小程序 requestTask.abort 不知道为什么放在同步代码不容易生效，需要放回调里</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/7502268562096160768">现在公司的 AI 部门的前端面试这么离谱吗？</a><br>（2）<a href="https://juejin.cn/post/7493579575848271887">uniapp 在微信小程序中实现 SSE 流式响应</a><br>（3）<a href="https://aicoding.juejin.cn/post/7521792361309372416">从SSE到打字机——AI场景下前端的实现逻辑与实践</a></p>]]></content>
    
    
    <categories>
      
      <category>工作技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小程序</tag>
      
      <tag>WEB API</tag>
      
      <tag>sse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React状态管理最新小结</title>
    <link href="/unknown404.github.io/2025/04/30/stateManagement/"/>
    <url>/unknown404.github.io/2025/04/30/stateManagement/</url>
    
    <content type="html"><![CDATA[<p>最近突然要从头搭一个 React 项目，构建自己项目的状态管理。对于平常用 umi+dva 一把梭的来说还真不太确定怎么搭会比较好。再加上随着时间变化，当初的新工具也成了老东西不再迭代，像 dva 就痛失了官方网站域名（hhh）。再加上调整一些 mobx 相关的开源项目踩了坑，所以还是决定要来梳理一番。</p><h2 id="mobx-mobx-state-tree"><a href="#mobx-mobx-state-tree" class="headerlink" title="mobx + mobx state tree"></a>mobx + mobx state tree</h2><p>mobx 是一个非常典型的响应式状态管理工具，即数据可变。它存在着几个比较关键的概念：</p><ul><li>observable，包裹普通的 JavaScript 数据结构，将其转换为响应式数据，任何依赖它的地方都会在数据变化时自动更新</li><li>action，用来修改状态的函数；如果涉及到异步动作，需要 then 内部的回调函数用 runInAction 或者 action.bound 包裹，或者直接用 flow 语法</li><li>reaction，追踪 observable 并在监听数据变化时触发效果函数；when 和 autorun 类似</li></ul><p>以下是 mobx 给出的示例。如果要获取和设置基本的状态值，可以将 store 作为 props 传入组件、利用 mobx-react 进行 store 连接</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; observable, computed, action &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">TodoModel</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./TodoModel&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TodoListModel</span> &#123;<br>  @observable todos = [];<br><br>  @computed<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">unfinishedTodoCount</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">todos</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> !todo.<span class="hljs-property">finished</span>).<span class="hljs-property">length</span>;<br>  &#125;<br><br>  @action<br>  <span class="hljs-title function_">addTodo</span>(<span class="hljs-params">title</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">todos</span>.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TodoModel</span>(title));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>它的特点是：</p><ul><li>事件触发 action 的执行，通过 action 来修改 state</li><li>state 更新后，computed Values 自动会根据依赖重新计算属性值</li><li>state 更新后会触发 reactions，来响应这次状态变化的一些操作</li></ul><p>mobx 虽然上手简单，但风格自由，如果没有统一团队的代码风格，可能会在 store 中看到各种各样的代码。因此也常用 mobx state tree 结合进行规范约束。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; types &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-state-tree&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">CounterModel</span> = types<br>  .<span class="hljs-title function_">model</span>(<span class="hljs-string">&quot;Counter&quot;</span>, &#123;<br>    <span class="hljs-attr">count</span>: types.<span class="hljs-property">number</span>,<br>  &#125;)<br>  .<span class="hljs-title function_">actions</span>(<span class="hljs-function">(<span class="hljs-params">self</span>) =&gt;</span> (&#123;<br>    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>      self.<span class="hljs-property">count</span> += <span class="hljs-number">1</span>;<br>    &#125;,<br>  &#125;));<br><br><span class="hljs-keyword">const</span> counter = <span class="hljs-title class_">CounterModel</span>.<span class="hljs-title function_">create</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;);<br></code></pre></td></tr></table></figure><p>mobx state tree 特点：</p><ul><li>必须定义模型结构</li><li>状态只能通过 actions 修改</li><li>支持 .snapshot()、.applySnapshot()、中间件拦截等高级特性</li></ul><p><strong>注意点</strong>：组件中使用的 mobx 变量是 observable 对象，直接传入 antd 组件是有可能出现错误的，需要用 toJS 转为 js 结构数据。</p><h2 id="Zustand"><a href="#Zustand" class="headerlink" title="Zustand"></a>Zustand</h2><p>一个轻量级的状态管理库，不需要像 Redux 那样定义复杂的 Action、Reducer、Store 组合等模板代码，但仍具有单向数据流的特点。主要特点有：</p><ul><li>极简 API：仅需掌握 create、set、get 三个核心方法：create 函数创建 store；set 函数用于修改状态；get 函数用于获取 store 内部的状态</li><li>灵活扩展：支持中间件生态</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// store定义</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> usePageStore = <span class="hljs-title function_">create</span>(<span class="hljs-function">(<span class="hljs-params">set</span>) =&gt;</span> (&#123;<br>  <span class="hljs-attr">state</span>: &#123;<br>    <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">false</span>,<br>  &#125;,<br>  <span class="hljs-attr">fetchData</span>: <span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-title function_">set</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> (&#123; <span class="hljs-attr">state</span>: &#123; ...state.<span class="hljs-property">state</span>, <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">true</span> &#125; &#125;));<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">const</span> &#123; data &#125; = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getData</span>(&#123;<br>        <span class="hljs-attr">request_id</span>: <span class="hljs-string">&quot;12335&quot;</span>,<br>        <span class="hljs-attr">input</span>: <span class="hljs-string">&quot;qwdqwd&quot;</span>,<br>      &#125;);<br>      <span class="hljs-title function_">set</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> (&#123;<br>        <span class="hljs-attr">state</span>: &#123; ...state.<span class="hljs-property">state</span>, <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">false</span>, ...data &#125;,<br>      &#125;));<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      <span class="hljs-title function_">set</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> (&#123; <span class="hljs-attr">state</span>: &#123; ...state.<span class="hljs-property">state</span>, <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">false</span> &#125; &#125;));<br>    &#125;<br>  &#125;,<br>&#125;));<br><span class="hljs-comment">// 组件使用</span><br><span class="hljs-keyword">const</span> &#123; state, fetchData &#125; = <span class="hljs-title function_">usePageStore</span>();<br></code></pre></td></tr></table></figure><h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><p>具有以下特点：</p><ul><li>单一数据源。 redux 的 store 只有一个，所有的状态都放在 store 中，所有的 state 共同组成了一个树形结构。</li><li>不可变数据。state 是不可变的， 在 redux 中修改 state 的方式是 dispatch 一个 action，根据 action 的 payload 返回一个新的 state。</li><li>纯函数修改。 redux 通过 reducer 函数来修改状态，它接受前一次的 state 和 action，返回新的 state，只要传入相同的 state 和 action，一定会返回相同的结果。</li></ul><h3 id="异步数据处理"><a href="#异步数据处理" class="headerlink" title="异步数据处理"></a>异步数据处理</h3><p>redux 没有规定如何处理异步数据流，通常是使用类似 redux-thunk、redux-saga 这些中间件来支持处理异步。以 redux-saga 为例，该中间件更适合中大型项目。redux-saga 提供了一些功能函数例如：put 用于触发 action；takeEvery 用于处理异步响应的规则，该函数表示每次触发 INCREMENT_ASYNC 动作时都执行 incrementAsync 函数；与之相对的 takeLatest 则是在短时间多次触发动作时，执行最后一次的触发</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// store/couter/saga.js</span><br><span class="hljs-keyword">import</span> &#123; put, takeEvery, delay &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux-saga/effects&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-variable constant_">INCREMENT_ASYNC</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./types&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; increment &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./action&quot;</span>;<br><br><span class="hljs-keyword">function</span>* <span class="hljs-title function_">incrementAsync</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-title function_">delay</span>(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 延迟1秒</span><br>  <span class="hljs-keyword">yield</span> <span class="hljs-title function_">put</span>(<span class="hljs-title function_">increment</span>());<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span>* <span class="hljs-title function_">counterSaga</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-title function_">takeEvery</span>(<span class="hljs-variable constant_">INCREMENT_ASYNC</span>, incrementAsync);<br>&#125;<br><span class="hljs-comment">// store/index.js</span><br><span class="hljs-keyword">import</span> &#123; createStore, combineReducers, applyMiddleware &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux&quot;</span>;<br><span class="hljs-keyword">import</span> createSagaMiddleware <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux-saga&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; counterReducer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./counter/reducer.ts&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; counterSaga &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./counter/saga.ts&quot;</span>;<br><span class="hljs-comment">// 创建 root reducer</span><br><span class="hljs-keyword">const</span> rootReducer = <span class="hljs-title function_">combineReducers</span>(&#123;<br>  <span class="hljs-attr">counter</span>: counterReducer,<br>&#125;);<br><span class="hljs-comment">// 创建 store</span><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(rootReducer, <span class="hljs-title function_">applyMiddleware</span>(sagaMiddleware));<br><br><span class="hljs-comment">// 运行 saga</span><br>sagaMiddleware.<span class="hljs-title function_">run</span>(counterSaga);<br></code></pre></td></tr></table></figure><h3 id="Redux-Toolkit"><a href="#Redux-Toolkit" class="headerlink" title="Redux Toolkit"></a>Redux Toolkit</h3><p>Redux 存在非常多的模版语法，使用起来十分不方便。Redux Toolkit（简称 RTK）是 Redux 官方推荐的现代 Redux 开发方式，它简化了 Redux 的使用，避免样板代码（boilerplate），并内置了如异步处理、不可变状态等常见工具。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// store/counter/counterSlice.js</span><br><span class="hljs-keyword">import</span> &#123; createSlice,createAsyncThunk &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@reduxjs/toolkit&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> incrementAsync = <span class="hljs-title function_">createAsyncThunk</span>(<span class="hljs-string">&#x27;counter/fetchCount&#x27;</span>,<span class="hljs-keyword">async</span> (<span class="hljs-attr">amount</span>: number) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchCount</span>(amount);<br>  <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>;<br>&#125;);<br><br><br><span class="hljs-keyword">const</span> counterSlice = <span class="hljs-title function_">createSlice</span>(&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;counter&#x27;</span>,<br>  <span class="hljs-attr">initialState</span>: &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">0</span> &#125;,<br>  <span class="hljs-attr">reducers</span>: &#123;<br>    <span class="hljs-attr">increment</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> &#123; state.<span class="hljs-property">value</span> += <span class="hljs-number">1</span> &#125;,<br>    <span class="hljs-attr">decrement</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> &#123; state.<span class="hljs-property">value</span> -= <span class="hljs-number">1</span> &#125;,<br>    <span class="hljs-attr">addByAmount</span>: <span class="hljs-function">(<span class="hljs-params">state, action</span>) =&gt;</span> &#123;<br>      state.<span class="hljs-property">value</span> += action.<span class="hljs-property">payload</span><br>    &#125;,<br>    <span class="hljs-attr">extraReducers</span>: <span class="hljs-function"><span class="hljs-params">builder</span> =&gt;</span> &#123;<br>    builder<br>      .<span class="hljs-title function_">addCase</span>(incrementAsync.<span class="hljs-property">pending</span>, <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> &#123; state.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;loading&#x27;</span> &#125;)<br>      .<span class="hljs-title function_">addCase</span>(incrementAsync.<span class="hljs-property">fulfilled</span>, <span class="hljs-function">(<span class="hljs-params">state, action</span>) =&gt;</span> &#123;<br>        state.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;succeeded&#x27;</span><br>        state.<span class="hljs-property">value</span> = action.<span class="hljs-property">payload</span><br>      &#125;)<br>      .<span class="hljs-title function_">addCase</span>(incrementAsync.<span class="hljs-property">rejected</span>, <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> &#123; state.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;failed&#x27;</span> &#125;);<br>  &#125;<br>  &#125;<br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> &#123; increment, decrement, addByAmount &#125; = counterSlice.<span class="hljs-property">actions</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> counterSlice.<span class="hljs-property">reducer</span>;<br><br><span class="hljs-comment">// store/index.js</span><br><span class="hljs-keyword">import</span> &#123; configureStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@reduxjs/toolkit&#x27;</span>;<br><span class="hljs-keyword">import</span> counterReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../counter/counterSlice&#x27;</span>;<br><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">configureStore</span>(&#123;<br>  <span class="hljs-attr">reducer</span>: &#123;<br>    <span class="hljs-attr">counter</span>: counterReducer,<br>  &#125;<br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;<br></code></pre></td></tr></table></figure><p>如上代码所示 RTK 使用 createSlice 创建 slice 并导出 reducer，并挂载到 configureStore() 的 reducer 对象上。最后将创建的 store 通过 provider 在入口文件中加载到全局即可。异步请求需要利用函数 createAsyncThunk，定义一个异步的 thunk action，该 action 可以处理异步逻辑并在请求开始、成功或失败时分发相应的 action。方法触发的时候会有三种状态：pending（进行中）、fulfilled（成功）、rejected（失败）。写好的 thunk action 可以通过 extraReducers 挂载在 slice。<br>在组件内部如果需要查看 store 的值、调用 store 的方法，可以用 react-redux 的 useSelector, useDispatch</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function">(<span class="hljs-params">state: RootState</span>) =&gt;</span> state.<span class="hljs-property">counter</span>.<span class="hljs-property">value</span>);<br>  <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useDispatch</span>();<br>  <span class="hljs-keyword">const</span> [loading, setLoading] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;getData&quot;</span> &#125;);<br>  &#125;, []);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &quot;INCREMENT_ASYNC&quot; &#125;)&#125;&gt;</span><br><span class="language-xml">        count is &#123;count&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>特性</th><th>Redux</th><th>MobX</th><th>Zustand</th></tr></thead><tbody><tr><td>响应式机制</td><td>手动更新、不可变数据</td><td>自动追踪、响应式</td><td>hooks + 代理自动响应</td></tr><tr><td>代码复杂度</td><td>高（需 action、reducer）</td><td>中（较灵活）</td><td>低（直接修改状态）</td></tr><tr><td>学习曲线</td><td>较陡峭</td><td>较缓和</td><td>极低</td></tr><tr><td>性能优化</td><td>需手动配置（如 memo、selector）</td><td>自动响应依赖</td><td>自动依赖追踪，轻量渲染</td></tr><tr><td>状态结构</td><td>单一 store，全局</td><td>多 store，可嵌套</td><td>支持多 store，按需组合</td></tr><tr><td>中间件&#x2F;插件</td><td>强大生态，Redux DevTools、Saga、Thunk 等</td><td>较少但够用</td><td>支持 DevTools，支持中间件扩展</td></tr><tr><td>使用场景</td><td>大型项目、多人协作、可预测状态流</td><td>复杂业务逻辑、响应式建模</td><td>中小项目、快速开发、现代 React 项目</td></tr><tr><td>主流程度</td><td><strong>历史最广泛使用</strong></td><td>一线企业较多采用</td><td><strong>近年来非常流行，逐渐普及</strong></td></tr></tbody></table><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/7138789672095842335">React 状态管理？看这一篇就够了</a></p>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>状态管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>amis初探</title>
    <link href="/unknown404.github.io/2025/03/12/amis/"/>
    <url>/unknown404.github.io/2025/03/12/amis/</url>
    
    <content type="html"><![CDATA[<p>公司要求用低代码来协助产品搭建一些简单的产品，通过一段时间有限的调研，选择了这个开源项目，开启了一段噩梦。<br>接下来是吐槽时间。</p><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>现在 ai 盛行，老板希望能快速搭建一些 ai 产品推广。考虑对产品经理的友好性，需要选择一款合适的低代码开源项目。<br>但不搜不知道，一搜发现低代码平台还真是多啊，真是让人头疼。而且低代码其实还分前端、后端、应用各种类型的搭建<br>以下是各平台的不完整测评，就目前的体验来说是这样</p><h3 id="appsmith"><a href="#appsmith" class="headerlink" title="appsmith"></a>appsmith</h3><p>似乎是创建应用的，个人感觉比较适合 B 端的数据展示和处理。支持写 js 代码，但我还是没办法快速弄清如何让一个按钮触发弹窗显示（是的这是我个人评判是否好用的标准）。而且似乎也导不出代码或者 json</p><h3 id="华为-tinyEngine"><a href="#华为-tinyEngine" class="headerlink" title="华为 tinyEngine"></a>华为 tinyEngine</h3><p>不可思议的体验，我完全不能理解，提供的 demo 预览什么也看不到，我企图修改时模块总会莫名其妙消失，当我去组件树试图寻找时，点击某节点整个面板又自动滚到顶部了。。。完全感觉不到可用的可能，不知道这个 demo 是不是个死的。导出的话是整个 Vue 项目，有着清晰的结构</p><h3 id="阿里-LowCodeEngine"><a href="#阿里-LowCodeEngine" class="headerlink" title="阿里 LowCodeEngine"></a>阿里 LowCodeEngine</h3><p>文档十分不友好，内容少而不精准，在试图制作弹窗 demo 时发现使用<code>$</code>引用 dom 来控制弹窗开启和隐藏出了问题，然而这是官方文档提供的内容。极度依赖 React，交互没有 React 知识不好实现。估计得训练一下产品经理。</p><h3 id="百度-amis"><a href="#百度-amis" class="headerlink" title="百度 amis"></a>百度 amis</h3><p>倒是对前端知识的门槛要求降低了，如果只是纯展示页面估计还不错。可惜一涉及到交互同样是噩梦。说明文档写的很差，提供的 demo 也全部是 json 配置，可视化配置表格找不到配置对应的位置。导出只能是页面的 json，页面通过引用 amis 的 sdk 对 json 做处理</p><p>经过了这番并不全面而详尽的尝试后，我实在没兴趣继续了。。。</p><h2 id="低代码原理"><a href="#低代码原理" class="headerlink" title="低代码原理"></a>低代码原理</h2><p>低代码（Low-Code）平台的实现原理主要围绕 可视化开发、模型驱动架构、组件化、代码生成 等关键技术。它们通过拖拽式 UI、流程编排、数据绑定等方式，让开发者快速构建应用，而无需手写大量代码。详细解说原理前须先介绍平台的搭建特点：一般的低代码编辑器主要分为三个部分：页面左侧是物料区，也就是页面常用的组件，与 antd 库有几分类似，但不是所有都是有实体的组件，也有的物料是某种逻辑的抽离，例如在 amis 中的 service 组件就是；页面中间是画布，使用者可将左侧组件拖拽到画布中心构建页面结构；右侧则是配置区，针对页面中使用的组件做特点的逻辑配置和样式调整。<br><img src="/unknown404.github.io/img/amis/amis.jpg"></p><p>低代码实现的几个关键环节主要有这些：</p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>所谓协议，个人更感觉像是约定的规范，约定物料开发的规则、页面搭建的规则之类的。例如绝大多数低代码都是将组件涉及的样式、交互逻辑抽离成一个 json 配置，通过设定几个固定的属性来控制。这样当低代码的 SDK 解析到组件的 json 时可以将其转换为对应的代码逻辑。。。这种感觉。<br>例如：当在页面添加了一个按钮后、左侧的配置 schema 新增了一个新 json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;button&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;按钮&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;onEvent&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;click&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;actions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;u:7f7930162cae&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>对应添加到页面的代码就是：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Button</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;amis&quot;</span>;<br> <span class="hljs-comment">// ...existing code...</span><br> <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">page</span>=(<span class="hljs-params">props</span>)=&gt;&#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="hljs-comment">// ...existing code...</span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&#123;props.label&#125;/</span>&gt;</span></span><br>  )<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h3><p>个人更通俗的理解就是符合协议、可读取配置 json 完善逻辑的封装组件、组件对应的配置表单以及定制好的行为。在 amis 中就对应了这么几个文件夹：</p><ul><li>renderer：渲染组件</li><li>plugin：组件的配置项设计</li><li>action：定制行为<br>一般的低代码平台会提供通用的物料。但是如果涉及到 C 端可能需要考虑更多个性化的内容：例如埋点，图片上传等，这些都是与公司自身的服务相挂钩的，都是需要自己开发扩展的</li></ul><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>渲染方式主要有两个大类：</p><ul><li>出码渲染</li><li>运行时渲染<br>常见的低代码渲染都是运行时渲染，只有少数对性能要求较高的产品才会使用出码渲染的方式。</li></ul><h4 id="出码渲染"><a href="#出码渲染" class="headerlink" title="出码渲染"></a>出码渲染</h4><p>出码渲染是将 schema 转化为 Vue 源码、React 源码或者其他语言的源码。</p><h4 id="运行时渲染"><a href="#运行时渲染" class="headerlink" title="运行时渲染"></a>运行时渲染</h4><p>页面 schema 渲染成页面都是在浏览器中完成的，不存在预编译的过程。amis 就属于这种渲染。</p><h2 id="低代码适用场景"><a href="#低代码适用场景" class="headerlink" title="低代码适用场景"></a>低代码适用场景</h2><p>个人理解是偏向于纯展示、低交互的页面，例如运营活动、B 端的表单，有复杂逻辑的页面就很难实现了。以下为几个代表</p><ul><li>海报，纯展示</li><li>H5 运营活动页，页面一次性，交互简单</li><li>中后台页面，表单页面，逻辑 curd 都在后端，前端不具备复杂逻辑</li></ul><p>如果真涉及到稍复杂的 C 端页面，用起来就比较痛苦了：产品只知道她的展示逻辑，不理解要实现这些逻辑需要经历哪些环节，只希望需要配置的内容越少越简洁；开发知道如何用代码实现，但必须完全代入低代码的思维、理解平台开发者的设计逻辑、沿着他的思路去抽离逻辑。而且万一配置出错了，不具有前端经验的人很难 debug，即使是前端在报错信息不全的情况下也很难快速定位问题点。综上所述，我很难想象谁需要这个。</p><h2 id="amis-使用注意事项"><a href="#amis-使用注意事项" class="headerlink" title="amis 使用注意事项"></a>amis 使用注意事项</h2><h3 id="SDK-使用说明"><a href="#SDK-使用说明" class="headerlink" title="SDK 使用说明"></a>SDK 使用说明</h3><p>虽然说明文档给出了 SDK 引入及自定义组件定义的说明，但实验时发现运行有问题，主要有以下几点：<br><strong>使用 import 方式导入 sdk.js 文件报错</strong><br>当前最新版的 sdk.js 文件依赖文件 rest.js，所以引入时需要将两个文件同时引入。如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;amis/sdk/sdk.js&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;amis/sdk/rest.js&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;amis/sdk/sdk.css&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;amis/sdk/helper.css&quot;</span>;<br></code></pre></td></tr></table></figure><p><strong>自定义组件渲染失败</strong><br>amis 在 SDK 引入自定义组件的说明里存在错误，估计是由于架构变更没有及时更新的缘故，现在 Renderer 属于 amis-core，所以正确的引入逻辑是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ...existing code...</span><br><span class="hljs-keyword">const</span> scoped = <span class="hljs-title function_">amisRequire</span>(<span class="hljs-string">&quot;amis/embed&quot;</span>);<br><span class="hljs-keyword">const</span> &#123; normalizeLink, <span class="hljs-title class_">Renderer</span> &#125; = <span class="hljs-title function_">amisRequire</span>(<span class="hljs-string">&quot;amis-core&quot;</span>);<br><span class="hljs-comment">// 自定义组件，props 中可以拿到配置中的所有参数，比如 props.label 是 &#x27;Name&#x27;</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">React</span> = <span class="hljs-title function_">amisRequire</span>(<span class="hljs-string">&quot;react&quot;</span>);<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">CustomComponent</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">let</span> dom = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 从这里开始写自定义代码，dom.current 就是新创建的 dom 节点</span><br>    <span class="hljs-comment">// 可以基于这个 dom 节点对接任意 JavaScript 框架，比如 jQuery/Vue 等</span><br>    dom.<span class="hljs-property">current</span>.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;custom&quot;</span>;<br>    <span class="hljs-comment">// 而 props 中能拿到这个</span><br>  &#125;);<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>, &#123;<br>    <span class="hljs-attr">ref</span>: dom,<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">//注册自定义组件，请参考后续对工作原理的介绍</span><br><span class="hljs-title class_">Renderer</span>(&#123;<br>  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/(^|\/)my-custom-renderer/</span>,<br>&#125;)(<span class="hljs-title class_">CustomComponent</span>);<br></code></pre></td></tr></table></figure><p>自定义组件注册完成后，使用时则是配置以下 json：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;my-custom-renderer&quot;</span> <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>hover 样式被 sdk 组件 hover 样式覆盖</strong><br>sdk 自动为渲染内容的容器元素添加了 amis-scope 的 class，同时将 css 文件的元素选择器全部添加了 amis-scope 的父元素，而在编辑器配置的 hover 属性没有自动附加 amis-scope 父元素，所以自定义的 hover 样式优先级反而劣于默认样式。只有手动写 hover 样式并加！important 才能实现</p><h3 id="amis-editor启动说明"><a href="#amis-editor启动说明" class="headerlink" title="amis-editor启动说明"></a>amis-editor启动说明</h3><p>虽然本地启动amis-editor-demo并不困难，但是到了部署一步却出了意外，因为amis依赖包里有个子依赖是个github仓库，所以docker镜像文件需要安装github镜像包，文件内容也就变成了：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs dockerFile"><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">20</span>-alpine<br><br><span class="hljs-keyword">ARG</span> DIR=/opt/apps/static<br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$DIR</span> /opt/logs/nginx /var/run/nginx</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> <span class="hljs-variable">$DIR</span></span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apk update &amp;&amp; apk add --no-cache nginx curl</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apk add --no-cache git</span><br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . <span class="hljs-variable">$DIR</span></span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> npm config <span class="hljs-built_in">set</span> registry https://registry.npmmirror.com &amp;&amp; npm install --legacy-peer-deps&amp;&amp; npm run release:<span class="hljs-built_in">test</span></span><br><br><span class="hljs-comment"># 创建目标目录 $DIR/static，如果目录不存在则创建</span><br><span class="hljs-comment"># 将 build 目录下的所有文件和子目录递归复制到 $DIR/static/ 目录下</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$DIR</span>/static &amp;&amp; <span class="hljs-built_in">cp</span> -r dist/* <span class="hljs-variable">$DIR</span>/static/</span><br><br><span class="hljs-comment"># COPY ./nginx.conf $DIR/nginx.conf</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> Dockerfile/start.sh /usr/local/bin/</span><br><span class="hljs-comment"># 启动 Nginx</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;sh&quot;</span>, <span class="hljs-string">&quot;/usr/local/bin/start.sh&quot;</span>]</span><br></code></pre></td></tr></table></figure><h3 id="数据域与展示组件问题"><a href="#数据域与展示组件问题" class="headerlink" title="数据域与展示组件问题"></a>数据域与展示组件问题</h3><p>amis 在解决组件数据绑定和数据传递方面提出了数据域和数据链结构，简单来说，有以下要点：</p><ul><li>组件的 data 属性值是数据域的一种形式</li><li>顶级节点数据域，也就是 page 节点的 data 属性</li><li>不是所有组件都有数据域这一特点，主要是表单类；展示组件如文本、富文本没有该属性</li><li>数据链的规则是：当前组件在遇到获取变量的场景（例如模板渲染、展示表单数据、渲染列表等等）时，首先会先尝试在当前组件的数据域中寻找变量，没有找到变量时，则向上寻找，直到顶级节点</li></ul><p>因此当出现异步请求后需要更新页面内容的情况，如果涉及的组件是展示类的，行为‘变量赋值‘是无法直接赋值给组件的，唯一的办法就是展示组件配置时绑定父层或顶层数据域变量，让行为‘变量赋值‘去改变绑定的变量</p><h3 id="数据表达式"><a href="#数据表达式" class="headerlink" title="数据表达式"></a>数据表达式</h3><p>在前端编程中，通过单击按钮控制侧边栏的显隐是通过绑定的 click 函数，让显示状态赋值为当前状态的取反值。然而在 amis 中，由于配置是用 json 存储，所以 visible 变量初始赋值为 false 其实是字符串的 false，取反后变量为 false，所以第一次触发点击事件被该状态控制的组件不会显示。visible 变量初始赋值空字符串可以解决问题。</p><h2 id="amis-的扩展"><a href="#amis-的扩展" class="headerlink" title="amis 的扩展"></a>amis 的扩展</h2><p>针对 C 端丰富多彩的需求，扩展是很难避免的，尤其是当产品缺乏开发知识时。以下是关于如何扩展的说明。</p><h3 id="plugin-扩展"><a href="#plugin-扩展" class="headerlink" title="plugin 扩展"></a>plugin 扩展</h3><p>amis 提供了关于 plugin 的定义，以下是基本定义，在编写自定义组件的配置表单 plugin 时也可以参考；amis 包里的 plugin 插件则是对这个定义的进一步封装为了 BasePlugin 这个基类。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 插件的 interface 定义</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PluginInterface</span><br>  <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">BasicRendererInfo</span>&gt;,<br>    <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">BasicSubRenderInfo</span>&gt;,<br>    <span class="hljs-title class_">PluginEventListener</span> &#123;<br>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">manager</span>: <span class="hljs-title class_">EditorManager</span>;<br><br>  order?: <span class="hljs-built_in">number</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 插件作用场景</span><br><span class="hljs-comment">   */</span><br>  scene?: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;;<br><br>  <span class="hljs-comment">// 是否可绑定数据，一般容器类型就没有</span><br>  withDataSource?: <span class="hljs-built_in">boolean</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 渲染器的名字，关联后不用自己实现 getRendererInfo 了。</span><br><span class="hljs-comment">   */</span><br>  rendererName?: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 默认的配置面板信息</span><br><span class="hljs-comment">   */</span><br>  panelIcon?: <span class="hljs-built_in">string</span>;<br>  panelTitle?: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 新增属性，用于判断是否出现在组件面板中，默认为false，为ture则不展示</span><br><span class="hljs-comment">   */</span><br>  disabledRendererPlugin?: <span class="hljs-built_in">boolean</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@deprecated</span> 用 panelBody</span><br><span class="hljs-comment">   */</span><br>  panelControls?: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">any</span>&gt;;<br>  panelBody?: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">any</span>&gt;;<br>  panelDefinitions?: <span class="hljs-built_in">any</span>;<br>  panelApi?: <span class="hljs-built_in">any</span>;<br>  panelSubmitOnChange?: <span class="hljs-built_in">boolean</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 隐藏右侧面板表单项Tab</span><br><span class="hljs-comment">   * <span class="hljs-doctag">TODO:</span> 正式上线后要干掉这个属性</span><br><span class="hljs-comment">   */</span><br>  notRenderFormZone?: <span class="hljs-built_in">boolean</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * 事件定义集合</span><br><span class="hljs-comment">   */</span><br>  events?: <span class="hljs-title class_">RendererPluginEvent</span>[] | (<span class="hljs-function">(<span class="hljs-params">schema: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-title class_">RendererPluginEvent</span>[]);<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * 专有动作定义集合</span><br><span class="hljs-comment">   */</span><br>  actions?: <span class="hljs-title class_">RendererPluginAction</span>[];<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 右侧面板是否需要两端对齐布局</span><br><span class="hljs-comment">   */</span><br>  panelJustify?: <span class="hljs-built_in">boolean</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * panelBodyAsyncCreator设置后异步加载层的配置项</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">async</span>?: <span class="hljs-title class_">AsyncLayerOptions</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 拖拽模式</span><br><span class="hljs-comment">   */</span><br>  dragMode?: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 有数据域的容器，可以为子组件提供读取的字段绑定页面</span><br><span class="hljs-comment">   */</span><br>  getAvailableContextFields?: <span class="hljs-function">(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-comment">// 提供数据域的容器节点</span></span></span><br><span class="hljs-params"><span class="hljs-function">    scopeNode: EditorNodeType,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-comment">// 数据域的应用节点</span></span></span><br><span class="hljs-params"><span class="hljs-function">    target: EditorNodeType,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-comment">// 节点所属的容器region</span></span></span><br><span class="hljs-params"><span class="hljs-function">    region?: EditorNodeType</span></span><br><span class="hljs-params"><span class="hljs-function">  </span>) =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">SchemaCollection</span> | <span class="hljs-built_in">void</span>&gt;;<br><br>  <span class="hljs-comment">/** 配置面板表单的 pipeOut function */</span><br>  panelFormPipeOut?: <span class="hljs-function">(<span class="hljs-params">value: <span class="hljs-built_in">any</span>, oldValue: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">any</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@deprecated</span> 用 panelBodyCreator</span><br><span class="hljs-comment">   */</span><br>  panelControlsCreator?: <span class="hljs-function">(<span class="hljs-params">context: BaseEventContext</span>) =&gt;</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">any</span>&gt;;<br>  panelBodyCreator?: <span class="hljs-function">(<span class="hljs-params">context: BaseEventContext</span>) =&gt;</span> <span class="hljs-title class_">SchemaCollection</span>;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 配置面板内容区的异步加载方法，设置后优先级大于panelBodyCreator</span><br><span class="hljs-comment">   */</span><br>  panelBodyAsyncCreator?: <span class="hljs-function">(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">    context: BaseEventContext</span></span><br><span class="hljs-params"><span class="hljs-function">  </span>) =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">SchemaCollection</span>&gt;;<br><br>  popOverBody?: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">any</span>&gt;;<br>  popOverBodyCreator?: <span class="hljs-function">(<span class="hljs-params">context: BaseEventContext</span>) =&gt;</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">any</span>&gt;;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 返回渲染器信息。不是每个插件都需要。</span><br><span class="hljs-comment">   */</span><br>  getRendererInfo?: <span class="hljs-function">(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">    context: RendererInfoResolveEventContext</span></span><br><span class="hljs-params"><span class="hljs-function">  </span>) =&gt;</span> <span class="hljs-title class_">BasicRendererInfo</span> | <span class="hljs-built_in">void</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 生成节点的 JSON Schema 的 uri 地址。</span><br><span class="hljs-comment">   */</span><br>  buildJSONSchema?: <span class="hljs-function">(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">    context: RendererJSONSchemaResolveEventContext</span></span><br><span class="hljs-params"><span class="hljs-function">  </span>) =&gt;</span> <span class="hljs-built_in">void</span> | <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 构建右上角功能按钮集合</span><br><span class="hljs-comment">   */</span><br>  buildEditorToolbar?: <span class="hljs-function">(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">    context: BaseEventContext,</span></span><br><span class="hljs-params"><span class="hljs-function">    toolbars: <span class="hljs-built_in">Array</span>&lt;BasicToolbarItem&gt;</span></span><br><span class="hljs-params"><span class="hljs-function">  </span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 构建右键菜单项</span><br><span class="hljs-comment">   */</span><br>  buildEditorContextMenu?: <span class="hljs-function">(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">    context: ContextMenuEventContext,</span></span><br><span class="hljs-params"><span class="hljs-function">    menus: <span class="hljs-built_in">Array</span>&lt;ContextMenuItem&gt;</span></span><br><span class="hljs-params"><span class="hljs-function">  </span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 构建编辑器面板。</span><br><span class="hljs-comment">   */</span><br>  buildEditorPanel?: <span class="hljs-function">(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">    context: BuildPanelEventContext,</span></span><br><span class="hljs-params"><span class="hljs-function">    panels: <span class="hljs-built_in">Array</span>&lt;BasicPanelItem&gt;</span></span><br><span class="hljs-params"><span class="hljs-function">  </span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 构建子渲染器信息集合。</span><br><span class="hljs-comment">   */</span><br>  buildSubRenderers?: <span class="hljs-function">(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">    context: RendererEventContext,</span></span><br><span class="hljs-params"><span class="hljs-function">    subRenderers: <span class="hljs-built_in">Array</span>&lt;SubRendererInfo&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">    renderers: <span class="hljs-built_in">Array</span>&lt;RendererConfig&gt;</span></span><br><span class="hljs-params"><span class="hljs-function">  </span>) =&gt;</span><br>    | <span class="hljs-title class_">BasicSubRenderInfo</span><br>    | <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">BasicSubRenderInfo</span>&gt;<br>    | <span class="hljs-built_in">void</span><br>    | <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">BasicSubRenderInfo</span> | <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">BasicSubRenderInfo</span>&gt; | <span class="hljs-built_in">void</span>&gt;;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 更新NPM自定义组件分类和排序[异步方法]</span><br><span class="hljs-comment">   * 备注：目前主要在npm自定义组件的分类和排序更新中使用</span><br><span class="hljs-comment">   */</span><br>  asyncUpdateCustomSubRenderersInfo?: <span class="hljs-function">(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">    context: RendererEventContext,</span></span><br><span class="hljs-params"><span class="hljs-function">    subRenderers: <span class="hljs-built_in">Array</span>&lt;SubRendererInfo&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">    renderers: <span class="hljs-built_in">Array</span>&lt;RendererConfig&gt;</span></span><br><span class="hljs-params"><span class="hljs-function">  </span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br><br>  markDom?: <span class="hljs-function">(<span class="hljs-params">dom: HTMLElement | <span class="hljs-built_in">Array</span>&lt;HTMLElement&gt;, props: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 获取上下文数据结构</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> node 当前容器节点</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> region 所属容器节点</span><br><span class="hljs-comment">   */</span><br>  buildDataSchemas?: <span class="hljs-function">(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">    node: EditorNodeType,</span></span><br><span class="hljs-params"><span class="hljs-function">    region?: EditorNodeType,</span></span><br><span class="hljs-params"><span class="hljs-function">    trigger?: EditorNodeType,</span></span><br><span class="hljs-params"><span class="hljs-function">    parent?: EditorNodeType</span></span><br><span class="hljs-params"><span class="hljs-function">  </span>) =&gt;</span> <span class="hljs-built_in">any</span> | <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">any</span>&gt;;<br><br>  rendererBeforeDispatchEvent?: <span class="hljs-function">(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">    node: EditorNodeType,</span></span><br><span class="hljs-params"><span class="hljs-function">    e: <span class="hljs-built_in">any</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    data: <span class="hljs-built_in">any</span></span></span><br><span class="hljs-params"><span class="hljs-function">  </span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 给 schema 打补丁，纠正一下 schema 配置。</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> <span class="hljs-variable">schema</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> <span class="hljs-variable">renderer</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> <span class="hljs-variable">props</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@returns</span></span><br><span class="hljs-comment">   */</span><br>  patchSchema?: <span class="hljs-function">(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">    schema: Schema,</span></span><br><span class="hljs-params"><span class="hljs-function">    renderer: RendererConfig,</span></span><br><span class="hljs-params"><span class="hljs-function">    props?: <span class="hljs-built_in">any</span></span></span><br><span class="hljs-params"><span class="hljs-function">  </span>) =&gt;</span> <span class="hljs-title class_">Schema</span> | <span class="hljs-built_in">void</span>;<br><br>  dispose?: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 组件 ref 回调，mount 和 unmount 的时候都会调用</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> <span class="hljs-variable">ref</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@returns</span></span><br><span class="hljs-comment">   */</span><br>  componentRef?: <span class="hljs-function">(<span class="hljs-params">node: EditorNodeType, ref: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BasePlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PluginInterface</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">readonly</span> manager: EditorManager</span>) &#123;&#125;<br><br>  <span class="hljs-keyword">static</span> scene = [<span class="hljs-string">&quot;global&quot;</span>];<br><br>  name?: <span class="hljs-built_in">string</span>;<br>  rendererName?: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 如果配置里面有 rendererName 自动返回渲染器信息。</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> <span class="hljs-variable">renderer</span></span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">getRendererInfo</span>(&#123;<br>    renderer,<br>    schema,<br>  &#125;: <span class="hljs-title class_">RendererInfoResolveEventContext</span>): <span class="hljs-title class_">BasicRendererInfo</span> | <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">plugin</span>: <span class="hljs-title class_">PluginInterface</span> = <span class="hljs-variable language_">this</span>;<br><br>    <span class="hljs-keyword">if</span> (<br>      schema.<span class="hljs-property">$$id</span> &amp;&amp;<br>      plugin.<span class="hljs-property">name</span> &amp;&amp;<br>      plugin.<span class="hljs-property">rendererName</span> &amp;&amp;<br>      plugin.<span class="hljs-property">rendererName</span> === renderer.<span class="hljs-property">name</span> <span class="hljs-comment">// renderer.name 会从 renderer.type 中取值</span><br>    ) &#123;<br>      <span class="hljs-keyword">let</span> curPluginName = plugin.<span class="hljs-property">name</span>;<br>      <span class="hljs-keyword">if</span> (schema?.<span class="hljs-property">isFreeContainer</span>) &#123;<br>        curPluginName = <span class="hljs-string">&quot;自由容器&quot;</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (schema?.<span class="hljs-property">isSorptionContainer</span>) &#123;<br>        curPluginName = <span class="hljs-string">&quot;吸附容器&quot;</span>;<br>      &#125;<br>      <span class="hljs-comment">// 复制部分信息出去</span><br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">name</span>: curPluginName,<br>        <span class="hljs-attr">regions</span>: plugin.<span class="hljs-property">regions</span>,<br>        <span class="hljs-attr">inlineEditableElements</span>: plugin.<span class="hljs-property">inlineEditableElements</span>,<br>        <span class="hljs-attr">patchContainers</span>: plugin.<span class="hljs-property">patchContainers</span>,<br>        <span class="hljs-attr">vRendererConfig</span>: plugin.<span class="hljs-property">vRendererConfig</span>,<br>        <span class="hljs-attr">wrapperProps</span>: plugin.<span class="hljs-property">wrapperProps</span>,<br>        <span class="hljs-attr">wrapperResolve</span>: plugin.<span class="hljs-property">wrapperResolve</span>,<br>        <span class="hljs-attr">filterProps</span>: plugin.<span class="hljs-property">filterProps</span>,<br>        <span class="hljs-attr">$schema</span>: plugin.<span class="hljs-property">$schema</span>,<br>        <span class="hljs-attr">renderRenderer</span>: plugin.<span class="hljs-property">renderRenderer</span>,<br>        <span class="hljs-attr">multifactor</span>: plugin.<span class="hljs-property">multifactor</span>,<br>        <span class="hljs-attr">scaffoldForm</span>: plugin.<span class="hljs-property">scaffoldForm</span>,<br>        <span class="hljs-attr">disabledRendererPlugin</span>: plugin.<span class="hljs-property">disabledRendererPlugin</span>,<br>        <span class="hljs-attr">isBaseComponent</span>: plugin.<span class="hljs-property">isBaseComponent</span>,<br>        <span class="hljs-attr">isListComponent</span>: plugin.<span class="hljs-property">isListComponent</span>,<br>        <span class="hljs-attr">rendererName</span>: plugin.<span class="hljs-property">rendererName</span>,<br>        <span class="hljs-attr">memberImmutable</span>: plugin.<span class="hljs-property">memberImmutable</span>,<br>        <span class="hljs-attr">getSubEditorVariable</span>: plugin.<span class="hljs-property">getSubEditorVariable</span>,<br>      &#125;;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 配置了 panelControls 自动生成配置面板</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> <span class="hljs-variable">context</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> <span class="hljs-variable">panels</span></span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">buildEditorPanel</span>(<span class="hljs-params"></span><br><span class="hljs-params">    context: BuildPanelEventContext,</span><br><span class="hljs-params">    panels: <span class="hljs-built_in">Array</span>&lt;BasicPanelItem&gt;</span><br><span class="hljs-params">  </span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">plugin</span>: <span class="hljs-title class_">PluginInterface</span> = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">const</span> store = <span class="hljs-variable language_">this</span>.<span class="hljs-property">manager</span>.<span class="hljs-property">store</span>;<br><br>    <span class="hljs-comment">// 没有选中元素 或者 多选时不处理</span><br>    <span class="hljs-keyword">if</span> (!store.<span class="hljs-property">activeId</span> || context.<span class="hljs-property">selections</span>.<span class="hljs-property">length</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<br>      !context.<span class="hljs-property">info</span>.<span class="hljs-property">hostId</span> &amp;&amp;<br>      (plugin.<span class="hljs-property">panelControls</span> ||<br>        plugin.<span class="hljs-property">panelControlsCreator</span> ||<br>        plugin.<span class="hljs-property">panelBody</span> ||<br>        plugin.<span class="hljs-property">panelBodyCreator</span> ||<br>        plugin.<span class="hljs-property">panelBodyAsyncCreator</span>) &amp;&amp;<br>      context.<span class="hljs-property">info</span>.<span class="hljs-property">plugin</span> === <span class="hljs-variable language_">this</span><br>    ) &#123;<br>      <span class="hljs-keyword">const</span> enableAsync = !!(<br>        plugin.<span class="hljs-property">panelBodyAsyncCreator</span> &amp;&amp;<br>        <span class="hljs-keyword">typeof</span> plugin.<span class="hljs-property">panelBodyAsyncCreator</span> === <span class="hljs-string">&quot;function&quot;</span><br>      );<br>      <span class="hljs-keyword">const</span> body = plugin.<span class="hljs-property">panelBodyAsyncCreator</span><br>        ? plugin.<span class="hljs-title function_">panelBodyAsyncCreator</span>(context)<br>        : plugin.<span class="hljs-property">panelBodyCreator</span><br>        ? plugin.<span class="hljs-title function_">panelBodyCreator</span>(context)<br>        : plugin.<span class="hljs-property">panelBody</span>!;<br><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">manager</span>.<span class="hljs-title function_">trigger</span>(<span class="hljs-string">&quot;after-build-panel-body&quot;</span>, &#123;<br>        context,<br>        <span class="hljs-attr">data</span>: body,<br>        plugin,<br>      &#125;);<br><br>      <span class="hljs-keyword">const</span> baseProps = &#123;<br>        <span class="hljs-attr">definitions</span>: plugin.<span class="hljs-property">panelDefinitions</span>,<br>        <span class="hljs-attr">submitOnChange</span>: plugin.<span class="hljs-property">panelSubmitOnChange</span>,<br>        <span class="hljs-attr">api</span>: plugin.<span class="hljs-property">panelApi</span>,<br>        <span class="hljs-attr">controls</span>: plugin.<span class="hljs-property">panelControlsCreator</span><br>          ? plugin.<span class="hljs-title function_">panelControlsCreator</span>(context)<br>          : plugin.<span class="hljs-property">panelControls</span>!,<br>        <span class="hljs-attr">justify</span>: plugin.<span class="hljs-property">panelJustify</span>,<br>        <span class="hljs-attr">panelById</span>: store.<span class="hljs-property">activeId</span>,<br>        <span class="hljs-attr">pipeOut</span>: plugin.<span class="hljs-property">panelFormPipeOut</span>?.<span class="hljs-property">bind</span>?.(plugin),<br>      &#125;;<br><br>      panels.<span class="hljs-title function_">push</span>(&#123;<br>        <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;config&quot;</span>,<br>        <span class="hljs-attr">icon</span>: plugin.<span class="hljs-property">panelIcon</span> || plugin.<span class="hljs-property">icon</span> || <span class="hljs-string">&quot;fa fa-cog&quot;</span>,<br>        <span class="hljs-attr">pluginIcon</span>: plugin.<span class="hljs-property">pluginIcon</span>,<br>        <span class="hljs-attr">title</span>: plugin.<span class="hljs-property">panelTitle</span> || <span class="hljs-string">&quot;设置&quot;</span>,<br>        <span class="hljs-attr">render</span>: enableAsync<br>          ? <span class="hljs-title function_">makeAsyncLayer</span>(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>              <span class="hljs-keyword">const</span> panelBody = <span class="hljs-keyword">await</span> (body <span class="hljs-keyword">as</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">SchemaCollection</span>&gt;);<br><br>              <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">manager</span>.<span class="hljs-title function_">makeSchemaFormRender</span>(&#123;<br>                ...baseProps,<br>                <span class="hljs-attr">body</span>: panelBody,<br>              &#125;);<br>            &#125;, <span class="hljs-title function_">omit</span>(plugin.<span class="hljs-property">async</span>, <span class="hljs-string">&quot;enable&quot;</span>))<br>          : <span class="hljs-variable language_">this</span>.<span class="hljs-property">manager</span>.<span class="hljs-title function_">makeSchemaFormRender</span>(&#123;<br>              ...baseProps,<br>              <span class="hljs-attr">body</span>: body <span class="hljs-keyword">as</span> <span class="hljs-title class_">SchemaCollection</span>,<br>            &#125;),<br>      &#125;);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<br>      context.<span class="hljs-property">info</span>.<span class="hljs-property">plugin</span> === <span class="hljs-variable language_">this</span> &amp;&amp;<br>      context.<span class="hljs-property">info</span>.<span class="hljs-property">hostId</span> &amp;&amp;<br>      (plugin.<span class="hljs-property">vRendererConfig</span>?.<span class="hljs-property">panelControls</span> ||<br>        plugin.<span class="hljs-property">vRendererConfig</span>?.<span class="hljs-property">panelControlsCreator</span> ||<br>        plugin.<span class="hljs-property">vRendererConfig</span>?.<span class="hljs-property">panelBody</span> ||<br>        plugin.<span class="hljs-property">vRendererConfig</span>?.<span class="hljs-property">panelBodyCreator</span>)<br>    ) &#123;<br>      panels.<span class="hljs-title function_">push</span>(&#123;<br>        <span class="hljs-attr">key</span>: context.<span class="hljs-property">info</span>.<span class="hljs-property">multifactor</span> ? <span class="hljs-string">&quot;vconfig&quot;</span> : <span class="hljs-string">&quot;config&quot;</span>,<br>        <span class="hljs-attr">icon</span>: plugin.<span class="hljs-property">vRendererConfig</span>.<span class="hljs-property">panelIcon</span> || <span class="hljs-string">&quot;fa fa-cog&quot;</span>,<br>        <span class="hljs-attr">title</span>: plugin.<span class="hljs-property">vRendererConfig</span>.<span class="hljs-property">panelTitle</span> || <span class="hljs-string">&quot;设置&quot;</span>,<br>        <span class="hljs-attr">render</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">manager</span>.<span class="hljs-title function_">makeSchemaFormRender</span>(&#123;<br>          <span class="hljs-attr">submitOnChange</span>: plugin.<span class="hljs-property">panelSubmitOnChange</span>,<br>          <span class="hljs-attr">api</span>: plugin.<span class="hljs-property">panelApi</span>,<br>          <span class="hljs-attr">definitions</span>: plugin.<span class="hljs-property">vRendererConfig</span>.<span class="hljs-property">panelDefinitions</span>,<br>          <span class="hljs-attr">controls</span>: plugin.<span class="hljs-property">vRendererConfig</span>.<span class="hljs-property">panelControlsCreator</span><br>            ? plugin.<span class="hljs-property">vRendererConfig</span>.<span class="hljs-title function_">panelControlsCreator</span>(context)<br>            : plugin.<span class="hljs-property">vRendererConfig</span>.<span class="hljs-property">panelControls</span>!,<br>          <span class="hljs-attr">body</span>: plugin.<span class="hljs-property">vRendererConfig</span>.<span class="hljs-property">panelBodyCreator</span><br>            ? plugin.<span class="hljs-property">vRendererConfig</span>.<span class="hljs-title function_">panelBodyCreator</span>(context)<br>            : plugin.<span class="hljs-property">vRendererConfig</span>.<span class="hljs-property">panelBody</span>!,<br>          <span class="hljs-attr">justify</span>: plugin.<span class="hljs-property">vRendererConfig</span>.<span class="hljs-property">panelJustify</span>,<br>          <span class="hljs-attr">panelById</span>: store.<span class="hljs-property">activeId</span>,<br>        &#125;),<br>      &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果是个多重身份证</span><br>    <span class="hljs-keyword">if</span> (context.<span class="hljs-property">info</span>.<span class="hljs-property">plugin</span> === <span class="hljs-variable language_">this</span> &amp;&amp; context.<span class="hljs-property">info</span>.<span class="hljs-property">multifactor</span>) &#123;<br>      <span class="hljs-keyword">const</span> <span class="hljs-attr">sameIdChild</span>: <span class="hljs-title class_">EditorNodeType</span> = context.<span class="hljs-property">node</span>.<span class="hljs-property">sameIdChild</span>;<br><br>      <span class="hljs-keyword">if</span> (sameIdChild) &#123;<br>        <span class="hljs-keyword">const</span> subPanels = <span class="hljs-variable language_">this</span>.<span class="hljs-property">manager</span>.<span class="hljs-title function_">collectPanels</span>(sameIdChild, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>        subPanels.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">panel</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (panel.<span class="hljs-property">key</span> === <span class="hljs-string">&quot;config&quot;</span> || panel.<span class="hljs-property">key</span> === <span class="hljs-string">&quot;vconfig&quot;</span>) &#123;<br>            panels.<span class="hljs-title function_">push</span>(&#123;<br>              ...panel,<br>              <span class="hljs-attr">key</span>: <span class="hljs-string">`sub-<span class="hljs-subst">$&#123;panel.key&#125;</span>`</span>,<br>              <span class="hljs-attr">icon</span>: sameIdChild.<span class="hljs-property">info</span>?.<span class="hljs-property">plugin</span>?.<span class="hljs-property">icon</span> || panel.<span class="hljs-property">icon</span>,<br>            &#125;);<br>          &#125;<br>        &#125;);<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 默认什么组件都加入的子组件里面，子类里面可以复写这个改变行为。</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> <span class="hljs-variable">context</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> <span class="hljs-variable">subRenderers</span></span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">buildSubRenderers</span>(<br>    <span class="hljs-attr">context</span>: <span class="hljs-title class_">RendererEventContext</span>,<br>    <span class="hljs-attr">subRenderers</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">SubRendererInfo</span>&gt;,<br>    <span class="hljs-attr">renderers</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">RendererConfig</span>&gt;<br>  ): <span class="hljs-title class_">BasicSubRenderInfo</span> | <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">BasicSubRenderInfo</span>&gt; | <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">plugin</span>: <span class="hljs-title class_">PluginInterface</span> = <span class="hljs-variable language_">this</span>;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(plugin.<span class="hljs-property">scaffolds</span>)) &#123;<br>      <span class="hljs-keyword">return</span> plugin.<span class="hljs-property">scaffolds</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">scaffold</span>) =&gt;</span> (&#123;<br>        <span class="hljs-attr">name</span>: (scaffold.<span class="hljs-property">name</span> ?? plugin.<span class="hljs-property">name</span>)!,<br>        <span class="hljs-attr">icon</span>: scaffold.<span class="hljs-property">icon</span> ?? plugin.<span class="hljs-property">icon</span>,<br>        <span class="hljs-attr">pluginIcon</span>: plugin.<span class="hljs-property">pluginIcon</span>,<br>        <span class="hljs-attr">description</span>: scaffold.<span class="hljs-property">description</span> ?? plugin.<span class="hljs-property">description</span>,<br>        <span class="hljs-attr">previewSchema</span>: scaffold.<span class="hljs-property">previewSchema</span> ?? plugin.<span class="hljs-property">previewSchema</span>,<br>        <span class="hljs-attr">tags</span>: scaffold.<span class="hljs-property">tags</span> ?? plugin.<span class="hljs-property">tags</span>,<br>        <span class="hljs-attr">docLink</span>: scaffold.<span class="hljs-property">docLink</span> ?? plugin.<span class="hljs-property">docLink</span>,<br>        <span class="hljs-attr">type</span>: scaffold.<span class="hljs-property">type</span> ?? plugin.<span class="hljs-property">type</span>,<br>        <span class="hljs-attr">scaffold</span>: scaffold.<span class="hljs-property">scaffold</span> ?? plugin.<span class="hljs-property">scaffold</span>,<br>        <span class="hljs-attr">scaffoldForm</span>: plugin.<span class="hljs-property">scaffoldForm</span>,<br>        <span class="hljs-attr">disabledRendererPlugin</span>: plugin.<span class="hljs-property">disabledRendererPlugin</span>,<br>        <span class="hljs-attr">isBaseComponent</span>: plugin.<span class="hljs-property">isBaseComponent</span>,<br>        <span class="hljs-attr">rendererName</span>: plugin.<span class="hljs-property">rendererName</span>,<br>      &#125;));<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (plugin.<span class="hljs-property">name</span> &amp;&amp; plugin.<span class="hljs-property">description</span>) &#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">searchKeywords</span>: plugin.<span class="hljs-property">searchKeywords</span>,<br>        <span class="hljs-attr">name</span>: plugin.<span class="hljs-property">name</span>,<br>        <span class="hljs-attr">icon</span>: plugin.<span class="hljs-property">icon</span>,<br>        <span class="hljs-attr">description</span>: plugin.<span class="hljs-property">description</span>,<br>        <span class="hljs-attr">previewSchema</span>: plugin.<span class="hljs-property">previewSchema</span>,<br>        <span class="hljs-attr">tags</span>: plugin.<span class="hljs-property">tags</span>,<br>        <span class="hljs-attr">docLink</span>: plugin.<span class="hljs-property">docLink</span>,<br>        <span class="hljs-attr">type</span>: plugin.<span class="hljs-property">type</span>,<br>        <span class="hljs-attr">scaffold</span>: plugin.<span class="hljs-property">scaffold</span>,<br>        <span class="hljs-attr">scaffoldForm</span>: plugin.<span class="hljs-property">scaffoldForm</span>,<br>        <span class="hljs-attr">disabledRendererPlugin</span>: plugin.<span class="hljs-property">disabledRendererPlugin</span>,<br>        <span class="hljs-attr">isBaseComponent</span>: plugin.<span class="hljs-property">isBaseComponent</span>,<br>        <span class="hljs-attr">pluginIcon</span>: plugin.<span class="hljs-property">pluginIcon</span>,<br>        <span class="hljs-attr">rendererName</span>: plugin.<span class="hljs-property">rendererName</span>,<br>      &#125;;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">renderPlaceholder</span>(<span class="hljs-params">text: <span class="hljs-built_in">string</span>, key?: <span class="hljs-built_in">any</span>, style?: <span class="hljs-built_in">any</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>, &#123;<br>      key,<br>      <span class="hljs-attr">className</span>: <span class="hljs-string">&quot;wrapper-sm b-a b-light m-b-sm&quot;</span>,<br>      <span class="hljs-attr">style</span>: style,<br>      <span class="hljs-attr">children</span>: <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;span&quot;</span>, &#123;<br>        <span class="hljs-attr">className</span>: <span class="hljs-string">&quot;text-muted&quot;</span>,<br>        <span class="hljs-attr">children</span>: text,<br>      &#125;),<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">getPlugin</span>(<span class="hljs-params">rendererNameOrKlass: <span class="hljs-built_in">string</span> | <span class="hljs-keyword">typeof</span> BasePlugin</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">find</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">manager</span>.<span class="hljs-property">plugins</span>, <span class="hljs-function">(<span class="hljs-params">plugin</span>) =&gt;</span><br>      <span class="hljs-keyword">typeof</span> rendererNameOrKlass === <span class="hljs-string">&quot;string&quot;</span><br>        ? plugin.<span class="hljs-property">rendererName</span> === rendererNameOrKlass<br>        : plugin <span class="hljs-keyword">instanceof</span> rendererNameOrKlass<br>    );<br>  &#125;<br><br>  <span class="hljs-title function_">buildDataSchemas</span>(<span class="hljs-params"></span><br><span class="hljs-params">    node: EditorNodeType,</span><br><span class="hljs-params">    region?: EditorNodeType,</span><br><span class="hljs-params">    trigger?: EditorNodeType,</span><br><span class="hljs-params">    parent?: EditorNodeType</span><br><span class="hljs-params">  </span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;string&quot;</span>,<br>      <span class="hljs-attr">rawType</span>: <span class="hljs-variable constant_">RAW_TYPE_MAP</span>[node.<span class="hljs-property">schema</span>.<span class="hljs-property">type</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">SchemaType</span>] || <span class="hljs-string">&quot;string&quot;</span>,<br>      <span class="hljs-attr">title</span>:<br>        <span class="hljs-keyword">typeof</span> node.<span class="hljs-property">schema</span>.<span class="hljs-property">label</span> === <span class="hljs-string">&quot;string&quot;</span><br>          ? node.<span class="hljs-property">schema</span>.<span class="hljs-property">label</span><br>          : node.<span class="hljs-property">schema</span>.<span class="hljs-property">name</span>,<br>      <span class="hljs-attr">originalValue</span>: node.<span class="hljs-property">schema</span>.<span class="hljs-property">value</span>, <span class="hljs-comment">// 记录原始值，循环引用检测需要</span><br>    &#125; <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">getKeyAndName</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">key</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">rendererName</span>,<br>      <span class="hljs-attr">name</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>,<br>    &#125;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有几个比较重要的属性必须命名：</p><ul><li>rendererName：关联的渲染组件名，与渲染器的名称一致配置结果才会赋值给渲染器的 props</li><li>name：组件名称（即组件面板显示的 Title）</li><li>tags：决定会在编辑器左侧组件面板哪个 tab 下面显示的</li><li>scaffold：拖入组件里面时的初始数据</li><li>panelTitle：右侧面板名称</li><li>panelControls、panelBodyCreator：右侧面板内容展示配置，符合 amis 的 json 渲染页面规则</li></ul><p>如果是设置自定义组件的 plugin，按照上面的属性编写即可，而如果是希望在已有的组件上增加一些配置，可以通过直接继承原有 plugin 进行改写，例如如果希望 service 组件可以增加一个模式，在该模式下直接填写一些请求相关参数，则可以采用继承原有的 ServicePlugin、改写目标属性，例如下写法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomServicePlugin</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">ServicePlugin</span> &#123;<br>  <span class="hljs-comment">// 需要显式声明静态属性</span><br>  <span class="hljs-keyword">static</span> id = <span class="hljs-string">&quot;ServicePlugin&quot;</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">manager: EditorManager</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(manager); <span class="hljs-comment">// 这会调用父类构造函数，初始化 dsManager</span><br>    <span class="hljs-comment">// 如果需要，可以在这里添加自定义初始化逻辑</span><br>  &#125;<br><br>  <span class="hljs-comment">// 覆写方法</span><br>  panelBodyCreator = <span class="hljs-function">(<span class="hljs-params">context: BaseEventContext</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> dsManager = <span class="hljs-variable language_">this</span>.<span class="hljs-property">dsManager</span>;<br>    <span class="hljs-comment">/** 数据源控件 */</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">generateDSControls</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-keyword">const</span> dsTypeSelector = dsManager.<span class="hljs-title function_">getDSSelectorSchema</span>(<br>        &#123;<br>          <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;select&quot;</span>,<br>          <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;horizontal&quot;</span>,<br>          <span class="hljs-attr">horizontal</span>: &#123;<br>            <span class="hljs-attr">justify</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">left</span>: <span class="hljs-string">&quot;col-sm-4&quot;</span>,<br>          &#125;,<br>          <span class="hljs-attr">onChange</span>: <span class="hljs-function">(<span class="hljs-params">value: <span class="hljs-built_in">any</span>, oldValue: <span class="hljs-built_in">any</span>, model: <span class="hljs-built_in">any</span>, form: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (value !== oldValue) &#123;<br>              <span class="hljs-keyword">const</span> data = form.<span class="hljs-property">data</span>;<br>              <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">if</span> (<br>                  key?.<span class="hljs-title function_">toLowerCase</span>()?.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&quot;fields&quot;</span>) ||<br>                  key?.<span class="hljs-title function_">toLowerCase</span>().<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&quot;api&quot;</span>)<br>                ) &#123;<br>                  form.<span class="hljs-title function_">deleteValueByName</span>(key);<br>                &#125;<br>              &#125;);<br>              form.<span class="hljs-title function_">deleteValueByName</span>(<span class="hljs-string">&quot;__fields&quot;</span>);<br>              form.<span class="hljs-title function_">deleteValueByName</span>(<span class="hljs-string">&quot;__relations&quot;</span>);<br>              form.<span class="hljs-title function_">setValueByName</span>(<span class="hljs-string">&quot;api&quot;</span>, <span class="hljs-literal">undefined</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> value;<br>          &#125;,<br>        &#125;,<br>        &#123; <span class="hljs-attr">schema</span>: context?.<span class="hljs-property">schema</span>, <span class="hljs-attr">sourceKey</span>: <span class="hljs-string">&quot;api&quot;</span> &#125;<br>      );<br>      <span class="hljs-comment">/** 默认数据源类型 */</span><br>      <span class="hljs-keyword">const</span> defaultDsType = dsTypeSelector.<span class="hljs-property">value</span>;<br>      <span class="hljs-keyword">const</span> dsSettings = dsManager.<span class="hljs-title function_">buildCollectionFromBuilders</span>(<br>        <span class="hljs-function">(<span class="hljs-params">builder, builderKey</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;container&quot;</span>,<br>            <span class="hljs-attr">visibleOn</span>: <span class="hljs-string">`data.dsType == null ? &#x27;<span class="hljs-subst">$&#123;builderKey&#125;</span>&#x27; === &#x27;<span class="hljs-subst">$&#123;</span></span><br><span class="hljs-subst"><span class="hljs-string">              defaultDsType || ApiDSBuilderKey</span></span><br><span class="hljs-subst"><span class="hljs-string">            &#125;</span>&#x27; : data.dsType === &#x27;<span class="hljs-subst">$&#123;builderKey&#125;</span>&#x27;`</span>,<br>            <span class="hljs-attr">body</span>: <span class="hljs-title function_">flattenDeep</span>([<br>              builder.<span class="hljs-title function_">makeSourceSettingForm</span>(&#123;<br>                <span class="hljs-attr">feat</span>: <span class="hljs-string">&quot;View&quot;</span>,<br>                <span class="hljs-attr">renderer</span>: <span class="hljs-string">&quot;service&quot;</span>,<br>                <span class="hljs-attr">inScaffold</span>: <span class="hljs-literal">false</span>,<br>                <span class="hljs-attr">sourceSettings</span>: &#123;<br>                  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;api&quot;</span>,<br>                  <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;接口配置&quot;</span>,<br>                  <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;horizontal&quot;</span>,<br>                  ...(builderKey === <span class="hljs-string">&quot;api&quot;</span> || builderKey === <span class="hljs-string">&quot;apicenter&quot;</span><br>                    ? &#123;<br>                        <span class="hljs-attr">horizontalConfig</span>: &#123;<br>                          <span class="hljs-attr">labelAlign</span>: <span class="hljs-string">&quot;left&quot;</span>,<br>                          <span class="hljs-attr">horizontal</span>: &#123;<br>                            <span class="hljs-attr">justify</span>: <span class="hljs-literal">true</span>,<br>                            <span class="hljs-attr">left</span>: <span class="hljs-number">4</span>,<br>                          &#125;,<br>                        &#125;,<br>                      &#125;<br>                    : &#123;&#125;),<br><br>                  <span class="hljs-attr">useFieldManager</span>: builderKey === <span class="hljs-title class_">ModelDSBuilderKey</span>,<br>                &#125;,<br>              &#125;),<br>            ]),<br>          &#125;;<br>        &#125;<br>      );<br>      dsSettings[<span class="hljs-number">0</span>].<span class="hljs-property">body</span>[<span class="hljs-number">0</span>].<span class="hljs-property">value</span> = <span class="hljs-string">`\$&#123;</span><br><span class="hljs-string">    isDIFY ? &#123;</span><br><span class="hljs-string">      url: &#x27;http://dify.com/adaptor/workflows/run&#x27;,</span><br><span class="hljs-string">      method: &#x27;post&#x27;,</span><br><span class="hljs-string">      requestAdaptor:</span><br><span class="hljs-string">        &#x27;function getUUID() &#123;\n  function generateRand(len = 7) &#123;\n    const rands =\n      &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;\n    return Array.from(Array(len))\n      .map(() =&gt; rands[parseInt((Math.random() * rands.length).toString())])\n      .join(&quot;&quot;);\n  &#125;\n\n  return new Date().getTime() + generateRand(7);\n&#125;\napi.data.request_id = getUUID()\nreturn api&#x27;,</span><br><span class="hljs-string">      adaptor: &#x27;&#x27;</span><br><span class="hljs-string">    &#125; : &#123;</span><br><span class="hljs-string">      </span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">  &#125;`</span>;<br>      <span class="hljs-keyword">return</span> [dsTypeSelector, ...dsSettings];<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">getSchemaTpl</span>(<span class="hljs-string">&quot;tabs&quot;</span>, [<br>      &#123;<br>        <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;属性&quot;</span>,<br>        <span class="hljs-attr">className</span>: <span class="hljs-string">&quot;p-none&quot;</span>,<br>        <span class="hljs-attr">body</span>: [<br>          <span class="hljs-title function_">getSchemaTpl</span>(<span class="hljs-string">&quot;collapseGroup&quot;</span>, [<br>            &#123;<br>              <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;基本&quot;</span>,<br>              <span class="hljs-attr">body</span>: [<br>                <span class="hljs-title function_">getSchemaTpl</span>(<span class="hljs-string">&quot;layout:originPosition&quot;</span>, &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;left-top&quot;</span> &#125;),<br>                <span class="hljs-title function_">getSchemaTpl</span>(<span class="hljs-string">&quot;switch&quot;</span>, &#123;<br>                  <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;是否使用dify&quot;</span>,<br>                  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;isDIFY&quot;</span>,<br>                  <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span>,<br>                &#125;),<br>                ...<span class="hljs-title function_">generateDSControls</span>(),<br>              ],<br>            &#125;,<br>          ]),<br>        ],<br>      &#125;,<br>      <span class="hljs-comment">// ...existing code...</span><br>    ]);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 id 需要注明，因为 ServicePlugin 的 id 是静态变量不会被继承。这里因为要改写的方法 panelBodyCreator 使用了 dsManager，所以要在构造函数调用父类构造函数。这里首先增加了一个 isDIFY 的配置，用于控制是否要填入一个默认的 API 配置。原代码的 dsTypeSelector 是用于设置数据来源的配置、即 dsType；dsSettings 用于配置 api 的 json 内容，所以可以等 dsSettings 返回后再做 api 配置修改。<br>以上修改逻辑较为粗糙，适用于配置嵌套比较浅的组件 plugin，如果是嵌套比较深的例如 Container 的背景图片上传配置，则由于配置很难全部透传到 input-image 组件内部，所以修改无效。<br>完成 plugin 编写后，如果是自定义组件的 plugin，直接用 registerEditorPlugin 全局注册组件即可；如果是扩展已有组件，需要用<code>unRegisterEditorPlugin(id:string)</code>注销掉原组件，再全局注册新的即可</p><h3 id="自定义组件扩展"><a href="#自定义组件扩展" class="headerlink" title="自定义组件扩展"></a>自定义组件扩展</h3><p>自定义组件扩展需要注意两件事：</p><ol><li>需要在编辑器添加自定义组件的 plugin 和 renderer</li><li>需要在 SDK 添加自定义组件的 renderer</li></ol><p>plugin 的开发在上一节已经叙述，过程是一致的。而 renderer 的开发简单来说是将 plugin 配置的变量作为 props 的入参，和默认参数结合，最终将数据渲染进组件进行展示。由于 amis 开发依赖 react，所以 renderer 利用 react 开发最为有利，如果要使用 Vue 开发，就需要利用 amis-widget 的包装函数进行一层转换，而且还是转 React。。。</p><p>我个人在开发时就遇到了问题：在 nuxt 3 项目引入 renderer 文件时整个页面都阻塞无法展示，不确定是不是因为 nuxt 3 对 react 有什么排斥的</p><h3 id="action-扩展"><a href="#action-扩展" class="headerlink" title="action 扩展"></a>action 扩展</h3><p>关于如何开发 action 的内容较少，只能根据源码内容进行推测。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> interface <span class="hljs-title class_">RendererAction</span> &#123;<br>  <span class="hljs-comment">// 运行这个 Action，每个类型的 Action 都只有一个实例，run 函数是个可重入的函数</span><br>  <span class="hljs-attr">run</span>: <span class="hljs-function">(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">    action: ListenerAction,</span></span><br><span class="hljs-params"><span class="hljs-function">    renderer: ListenerContext,</span></span><br><span class="hljs-params"><span class="hljs-function">    event: RendererEvent&lt;any&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">    mergeData?: any <span class="hljs-comment">// 有些Action内部需要通过上下文数据处理专有逻辑，这里的数据是事件数据+渲染器数据</span></span></span><br><span class="hljs-params"><span class="hljs-function">  </span>) =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">RendererEvent</span>&lt;any&gt; | <span class="hljs-keyword">void</span>&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>action 的基本结构如上所示，action 传入内容应该为 json 配置内容；renderer 不太明确，似乎是获取组件渲染内部的方法，通过 renderer.props 访问；event 应该是获取外部配置的一些函数，在编辑器的 demo 和 sdk 的 embed 都配置了一些函数，如请求 fetcher、跳转 jumpTo 等，在这个函数里可以通过 event.context.env 来访问到。<br>amis 提供了函数<code>registerAction(type: string, action: RendererAction)</code>当使用时就成功注册了一种行为动作，调用时使用形如<code>actionType: &#39;ajax&#39;</code>的格式就可以实现。</p><p>如果要在编辑器动作配置弹窗里出现配置的内容，则需要使用<code>registerActionPanel(actionType: string,actionPanel?: ActionPanel)</code>函数，其中 actionType 对应于注册动作的 type 内容，actionPanel 则大致包含如下内容：</p><ul><li>label：功能说明，对应于动作配置弹窗左侧菜单选项名</li><li>tag：所属大类，对应于动作配置弹窗左侧菜单选项集合名</li><li>description：对应动作说明</li><li>supportComponents：支持的组件类型</li><li>schema：动作对应的 json</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://mp.weixin.qq.com/s/yqYey76qLGYPfDtpGkVFfA">低代码渲染那些事</a></p>]]></content>
    
    
    <categories>
      
      <category>工作技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>低代码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nuxt3项目实践踩坑</title>
    <link href="/unknown404.github.io/2024/12/08/nuxt3/"/>
    <url>/unknown404.github.io/2024/12/08/nuxt3/</url>
    
    <content type="html"><![CDATA[<p>最近因产品需求，需要搭建一个支持 ssr 渲染的项目。在搭建 Nuxt3 项目的过程中，出现了很多问题，在此集中记录一下。</p><span id="more"></span><p>之所以选 Nuxt3 是考虑团队技术栈和 Vue 2 停止维护的事实决定的，本以为会多少兼容一下 Nuxt 2、Vue 2 的语法，事实证明太天真了。</p><h2 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h2><p>项目需求：<br>Nodejs &gt;&#x3D; 18<br>执行指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx nuxi@latest init &lt;project-name&gt;<br></code></pre></td></tr></table></figure><p>执行完成后进入<code>&lt;project-name&gt;</code>目录下，执行指令 <code>npm run dev</code>即可访问 <a href="http://localhost:3000/">http://localhost:3000</a></p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>初始化的 Nuxt 项目目录结构如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Nuxt3<br>├── assets                    <span class="hljs-meta"># 工程化处理的静态资源</span><br>├── components                <span class="hljs-meta"># 项目组件</span><br>├── composables               <span class="hljs-meta"># 响应式共享状态</span><br>├── layouts                   <span class="hljs-meta"># 布局组件</span><br>├── middleware                <span class="hljs-meta"># 路由中间件</span><br>├── pages                     <span class="hljs-meta"># 页面视图</span><br>├── plugins                   <span class="hljs-meta"># 项目公共插件</span><br>├── <span class="hljs-keyword">public</span>                    <span class="hljs-meta"># 不需要工程化处理的静态资源</span><br>├── store                     <span class="hljs-meta"># 状态管理</span><br>├── utils                     <span class="hljs-meta"># 静态工具函数</span><br>├── app.vue                   <span class="hljs-meta"># 入口页面</span><br>├── .gitignore                    <span class="hljs-meta"># git仓库提交忽略配置</span><br>├── nuxt.config.ts                <span class="hljs-meta"># Vite 构建配置入口</span><br>├── package.json                  <span class="hljs-meta"># 项目包管理文件</span><br>├── pnpm-<span class="hljs-keyword">lock</span>.yaml                <span class="hljs-meta"># pnpm包版本管理锁定</span><br>└── README.md                     <span class="hljs-meta"># 项目说明</span><br></code></pre></td></tr></table></figure><p>一般情况下我们认为项目开发内容（如页面、组件等）统一放在 src 文件夹内方便管理，因此需要修改 nuxt.config.ts 的配置为</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">NuxtConfig</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;nuxt/config&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineNuxtConfig</span>(&#123;<br>++  <span class="hljs-attr">srcDir</span>: <span class="hljs-string">&#x27;src/&#x27;</span>,<br>&#125; <span class="hljs-keyword">as</span> <span class="hljs-title class_">NuxtConfig</span>);<br></code></pre></td></tr></table></figure><p>同时将 app.vue、pages、server 文件等移到 src 目录下，变更为以下目录结构</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs 1c">-<span class="hljs-string">| /</span><br>---<span class="hljs-string">| node_modules/</span><br>---<span class="hljs-string">| nuxt.config.js</span><br>---<span class="hljs-string">| package.json</span><br>---<span class="hljs-string">| src/</span><br>------<span class="hljs-string">| assets/</span><br>------<span class="hljs-string">| components/</span><br>------<span class="hljs-string">| layouts/</span><br>------<span class="hljs-string">| middleware/</span><br>------<span class="hljs-string">| pages/</span><br>------<span class="hljs-string">| plugins/</span><br>------<span class="hljs-string">| public/</span><br>------<span class="hljs-string">| store/</span><br>------<span class="hljs-string">| server/</span><br>------<span class="hljs-string">| app.config.ts</span><br>------<span class="hljs-string">| app.vue</span><br>------<span class="hljs-string">| error.vue</span><br></code></pre></td></tr></table></figure><h4 id="重要目录介绍"><a href="#重要目录介绍" class="headerlink" title="重要目录介绍"></a>重要目录介绍</h4><h5 id="pages"><a href="#pages" class="headerlink" title="pages"></a>pages</h5><p>页面目录。Nuxt 提供了一个基于文件的路由，使用 Vue Router 在底层创建路由。<code>pages/index.vue</code> 文件将映射到应用程序的 <code>/ </code>路由。如果要设置动态路由，可用带方括号的文件名或文件夹表示，双方括号表示参数是可选的</p><h5 id="components"><a href="#components" class="headerlink" title="components"></a>components</h5><p>组件目录，放置全部的组件，Nuxt 项目会自动导入注册目录下的组件<br>如果您在嵌套目录中有一个组件，例如：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">| components/</span><br>--<span class="hljs-string">| base/</span><br>----<span class="hljs-string">| foo/</span><br>------<span class="hljs-string">| Button.vue</span><br></code></pre></td></tr></table></figure><p>那么组件的名称将基于其自身的路径目录和文件名，成为 BaseFooButton。如果希望仅根据组件名称而不是路径自动导入组件，则需要使用扩展形式的配置对象将 pathPrefix 选项设置为 false</p><h5 id="app-vue"><a href="#app-vue" class="headerlink" title="app.vue"></a>app.vue</h5><p>根视图组件，可以在组件中定义全局的样式和行为，并且在应用程序的整个生命周期内始终存在，可以说 app.vue 是 Nuxt.js 3 应用程序的视图层的入口文件。</p><h3 id="常用工具配置"><a href="#常用工具配置" class="headerlink" title="常用工具配置"></a>常用工具配置</h3><p>nuxt 自身提供了很多适配的模块，可优先在<a href="https://www.nuxt.com.cn/modules">官网</a>上进行查找，阅读安装指南</p><h4 id="pinia"><a href="#pinia" class="headerlink" title="pinia"></a>pinia</h4><p>Nuxt 3 不支持 Vuex，推荐 pinia，在插件市场提供了 pinia 的安装。<br>安装指令：<code>npm i pinia @pinia/nuxt</code><br>配置调整：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineNuxtConfig</span>(&#123;<br>  <span class="hljs-attr">modules</span>: [<span class="hljs-string">&quot;@pinia/nuxt&quot;</span>],<br>&#125;);<br></code></pre></td></tr></table></figure><p>对于选项式文件，如果要引入 pinia 内部的方法和 data 时应使用 setup 函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> baseStore = <span class="hljs-title function_">useBaseStore</span>();<br>    <span class="hljs-keyword">return</span> &#123; baseStore &#125;;<br>&#125;,<br></code></pre></td></tr></table></figure><h4 id="element-ui"><a href="#element-ui" class="headerlink" title="element ui"></a>element ui</h4><p>Nuxt 3 支持 element plus，和之前的 element ui 略有差异，但基本语法一致<br>安装指令：<code>npm i element-plus @element-plus/nuxt -D</code><br>配置调整：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineNuxtConfig</span>(&#123;<br>  <span class="hljs-attr">modules</span>: [<span class="hljs-string">&quot;@element-plus/nuxt&quot;</span>],<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="postcss-px-to-viewport-8-plugin"><a href="#postcss-px-to-viewport-8-plugin" class="headerlink" title="postcss-px-to-viewport-8-plugin"></a>postcss-px-to-viewport-8-plugin</h4><p>如果页面包括 wap 页面，需要引入 postcss-px-to-viewport-8-plugin 插件，实现页面样式与屏幕适配。该插件可以将代码中的 px 自动转换为 vw 单位。<br>安装指令：<code>npm i postcss-px-to-viewport-8-plugin --save-dev</code><br>配置调整：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineNuxtConfig</span>(&#123;<br>  <span class="hljs-attr">postcss</span>: &#123;<br>    <span class="hljs-attr">plugins</span>: &#123;<br>      <span class="hljs-string">&quot;postcss-px-to-viewport-8-plugin&quot;</span>: &#123;<br>        <span class="hljs-attr">unitToConvert</span>: <span class="hljs-string">&quot;px&quot;</span>, <span class="hljs-comment">// 要转化的单位</span><br>        <span class="hljs-attr">viewportWidth</span>: <span class="hljs-number">375</span>, <span class="hljs-comment">// UI设计稿的宽度</span><br>        <span class="hljs-attr">unitPrecision</span>: <span class="hljs-number">6</span>, <span class="hljs-comment">// 转换后的精度，即小数点位数</span><br>        <span class="hljs-attr">propList</span>: [<span class="hljs-string">&quot;*&quot;</span>], <span class="hljs-comment">// 指定转换的css属性的单位，*代表全部css属性的单位都进行转换</span><br>        <span class="hljs-attr">viewportUnit</span>: <span class="hljs-string">&quot;vw&quot;</span>, <span class="hljs-comment">// 指定需要转换成的视窗单位，默认vw</span><br>        <span class="hljs-attr">fontViewportUnit</span>: <span class="hljs-string">&quot;vw&quot;</span>, <span class="hljs-comment">// 指定字体需要转换成的视窗单位，默认vw</span><br>        <span class="hljs-attr">minPixelValue</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">// 默认值1，小于或等于1px则不进行转换</span><br>        <span class="hljs-attr">mediaQuery</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否在媒体查询的css代码中也进行转换，默认false</span><br>        <span class="hljs-attr">replace</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否转换后直接更换属性值</span><br>        <span class="hljs-attr">exclude</span>: [<span class="hljs-regexp">/node_modules/</span>, <span class="hljs-regexp">/src\/pages\/pc/</span>, <span class="hljs-regexp">/src\/components\/pc/</span>], <span class="hljs-comment">// 设置忽略文件，用正则做目录名匹配</span><br>      &#125;,<br>    &#125;,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>插件的配置规则与之前写过的 postcss-px-to-viewport 一致，只是 postcss-px-to-viewport 已废弃了。</p><h3 id="工程化配置"><a href="#工程化配置" class="headerlink" title="工程化配置"></a>工程化配置</h3><h4 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h4><p>安装指令：<code>npx nuxi module add eslint</code><br>指令会自动将模块添加到 nuxt.config.ts 中<br>配置调整：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineNuxtConfig</span>(&#123;<br>  <span class="hljs-attr">modules</span>: [<span class="hljs-string">&quot;@nuxt/eslint&quot;</span>],<br>&#125;);<br></code></pre></td></tr></table></figure><p>eslint 规则的修改放到根目录的 eslint.config.mjs 中（基本上就是提交时看哪个校验规则不顺眼，就把插件规则关掉或者从错误降级为 warn）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> withNuxt <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./.nuxt/eslint.config.mjs&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">withNuxt</span>(<br>  <span class="hljs-comment">// Your custom configs here</span><br>  &#123;<br>    <span class="hljs-attr">rules</span>: &#123;<br>      <span class="hljs-string">&quot;no-empty&quot;</span>: <span class="hljs-string">&quot;off&quot;</span>,<br>      <span class="hljs-string">&quot;@typescript-eslint/no-this-alias&quot;</span>: <span class="hljs-string">&quot;off&quot;</span>,<br>      <span class="hljs-string">&quot;@typescript-eslint/no-unused-expressions&quot;</span>: <span class="hljs-string">&quot;warn&quot;</span>,<br>    &#125;,<br>  &#125;<br>);<br></code></pre></td></tr></table></figure><h4 id="husky"><a href="#husky" class="headerlink" title="husky"></a>husky</h4><p>为保证代码格式一致、避免多人提交时因本地代码规则不同出现大量的样式变动修改，影响 review；同时有效防止错误的代码提交到远程，需要用 husky 对提交进行检查。<br>安装指令：<code>npm i husky prettier lint-staged --save-dev</code><br>prettier 是规范代码样式的模块，确保团队的代码使用统一相同的格式。lint-staged 是一个基于 Node.js 的库,它可以对 Git 仓库中的暂存区(staged)代码进行线性检测,从而确保代码质量。<br>接下来的操作包括：</p><ol><li>向 package.json 的 scripts 中添加命令：<code>&quot;lint&quot;: &quot;lint-staged&quot;,</code>同时在 package.json 添加 lint-staged 配置：</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;lint-staged&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;*.&#123;js,vue&#125;&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;eslint --fix&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;*.&#123;css,less,html,json,vue&#125;&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;prettier --write&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>这样会对提交的 js、vue 代码做 eslint 检查，对 css,less,html,json,vue 做代码样式检查 2. 运行指令<code>npx husky install</code>会在项目根目录下生成一个 .husky&#x2F; 文件夹，用于存放 Git 钩子。找到 pre-commit 文件，添加指令：npm run lint。或者在 package.json 中增加配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;husky&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;hooks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;pre-commit&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;lint-staged&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="项目开发"><a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h2><h3 id="host-别名访问"><a href="#host-别名访问" class="headerlink" title="host 别名访问"></a>host 别名访问</h3><p>Nuxt 默认启动时会将开发服务器绑定到 localhost（即 127.0.0.1），这意味着它只允许来自本地主机的访问。如果需要通过其他主机名或 IP 地址访问，必须明确设置绑定的 host。需要修改 nuxt.config.ts 配置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">port</span>: <span class="hljs-number">3000</span>,<br>    <span class="hljs-attr">host</span>: <span class="hljs-string">&quot;0.0.0.0&quot;</span>,<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="环境区分"><a href="#环境区分" class="headerlink" title="环境区分"></a>环境区分</h3><p>nuxt 3 无法和 nuxt 2 一样设置 cross-env、服务端和客户端都可以从 process.env 中获取环境变量。只能在 nuxt.config.ts 设置 runtimeConfig，使用 API useRuntimeConfig 获取设置的环境变量；以前静态获取环境变量、导出请求域名的方式无法实现。<br>示例：<br>在运行项目的指令中设置形如：<code>&quot;dev:prod&quot;: &quot;cross-env CODE_ENV=prod nuxt dev&quot;</code>的指令，确定了运行环境变量 CODE_ENV<br>项目的 utils 目录下的方法会全局注册，可以在目录下增加一个方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getEnv</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> config = <span class="hljs-title function_">useRuntimeConfig</span>();<br>  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CODE_ENV</span> = config.<span class="hljs-property">public</span>.<span class="hljs-property">CODE_ENV</span> || <span class="hljs-string">&quot;prod&quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">CODE_ENV</span>;<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> getEnv;<br></code></pre></td></tr></table></figure><p>在使用组合式 API 写法时可以直接用 getEnv 方法获取运行环境。选项式文件就只能用 setup 生命周期获取了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> env = <span class="hljs-title function_">getEnv</span>();<br>    <span class="hljs-keyword">return</span> &#123; env &#125;;<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="错误页面"><a href="#错误页面" class="headerlink" title="错误页面"></a>错误页面</h3><p>与 app.vue 同级增加一个 error.vue，当项目找不到目标页面、或者页面出现错误就会跳转到该文件的页面</p><h3 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h3><p>如果项目里包含有 pc 和 wap 的页面，可以在项目内部进行重定向（当然对部署域名做 ng 配置也是可以的）<br>重定向的方法是在中间件文件夹 middleware 下添加一个全局中间件 xxx.global.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineNuxtRouteMiddleware</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-keyword">from</span>, to</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// skip middleware on client side entirely</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">client</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">const</span> userAgent = <span class="hljs-title function_">useRequestHeaders</span>()[<span class="hljs-string">&quot;user-agent&quot;</span>] || <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">isMobile</span> = (<span class="hljs-params">ua</span>) =&gt; &#123;<br>    ua = ua.<span class="hljs-title function_">toLowerCase</span>();<br>    <span class="hljs-keyword">return</span> !!(<br>      ua.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/AppleWebKit.*Mobile.*/</span>) || <span class="hljs-regexp">/iphone|ipad|ipod|android/</span>.<span class="hljs-title function_">test</span>(ua)<br>    );<br>  &#125;;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isMobile</span>(userAgent) &amp;&amp; to.<span class="hljs-property">path</span>.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&quot;/pc/&quot;</span>)) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">from</span>.<span class="hljs-property">fullPath</span> === to.<span class="hljs-property">fullPath</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;/pc/&quot;</span>, <span class="hljs-string">&quot;/wap/&quot;</span>)) &#123;<br>      <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 避免重定向回来的死循环</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">navigateTo</span>(to.<span class="hljs-property">fullPath</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;/pc/&quot;</span>, <span class="hljs-string">&quot;/wap/&quot;</span>));<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isMobile</span>(userAgent) &amp;&amp; to.<span class="hljs-property">path</span>.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&quot;/wap/&quot;</span>)) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">from</span>.<span class="hljs-property">fullPath</span> === to.<span class="hljs-property">fullPath</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;/wap/&quot;</span>, <span class="hljs-string">&quot;/pc/&quot;</span>)) &#123;<br>      <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 避免重定向回来的死循环</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">navigateTo</span>(to.<span class="hljs-property">fullPath</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;/wap/&quot;</span>, <span class="hljs-string">&quot;/pc/&quot;</span>));<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>需要注意的点是重定向的条件判断没有针对所有可能性做返回，vue router 检验逻辑会认为有隐患；因此需要对所有可能性做条件处理</p><h3 id="server-端接口书写"><a href="#server-端接口书写" class="headerlink" title="server 端接口书写"></a>server 端接口书写</h3><p>接口命名两种方式：<br>1）server&#x2F;api 文件夹下命名文件，在此文件夹下的文件都会被 nuxt 扫描并自动加载<br>2）server&#x2F;routes 下命名文件，在此文件夹下的文件接口访问路径名为&#x2F;[文件名]<br>其他书写方式不会形成对外可访问的接口</p><h4 id="接口跨域处理"><a href="#接口跨域处理" class="headerlink" title="接口跨域处理"></a>接口跨域处理</h4><p>浏览器在发送跨域请求时，会先发送一个 OPTIONS 请求（预检请求）来检查服务器是否允许跨域。所以要针对 options 请求作正确的返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;<br>  defineEventHandler,<br>  createError,<br>  readBody,<br>  setResponseHeaders,<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;h3&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineEventHandler</span>(<span class="hljs-keyword">async</span> (event) =&gt; &#123;<br>  <span class="hljs-comment">// 设置 CORS 头</span><br>  <span class="hljs-title function_">setResponseHeaders</span>(event, &#123;<br>    <span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>: <span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-comment">// 允许所有来源</span><br>    <span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span>: <span class="hljs-string">&quot;GET, POST, PUT, DELETE, OPTIONS&quot;</span>, <span class="hljs-comment">// 允许的 HTTP 方法</span><br>    <span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span>: <span class="hljs-string">&quot;Content-Type, Authorization&quot;</span>, <span class="hljs-comment">// 允许的请求头</span><br>  &#125;);<br><br>  <span class="hljs-comment">// 如果是预检请求（OPTIONS），直接返回</span><br>  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">node</span>.<span class="hljs-property">req</span>.<span class="hljs-property">method</span> === <span class="hljs-string">&quot;OPTIONS&quot;</span>) &#123;<br>    event.<span class="hljs-property">node</span>.<span class="hljs-property">res</span>.<span class="hljs-property">statusCode</span> = <span class="hljs-number">204</span>; <span class="hljs-comment">// No Content</span><br>    event.<span class="hljs-property">node</span>.<span class="hljs-property">res</span>.<span class="hljs-title function_">end</span>();<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 处理实际的 POST 请求</span><br>  <span class="hljs-keyword">const</span> body = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readBody</span>(event).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;);<br>  <span class="hljs-keyword">const</span> &#123; routeName &#125; = body;<br>  <span class="hljs-keyword">const</span> target = schemaList.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.<span class="hljs-property">path</span> === routeName);<br>  <span class="hljs-keyword">if</span> (target) &#123;<br>    <span class="hljs-keyword">return</span> &#123; ...target &#125;;<br>  &#125;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-title function_">createError</span>(&#123;<br>    <span class="hljs-attr">status</span>: <span class="hljs-number">400</span>,<br>    <span class="hljs-attr">statusMessage</span>: <span class="hljs-string">&quot;Bad Request&quot;</span>,<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Invalid route&quot;</span>,<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><h3 id="镜像打包"><a href="#镜像打包" class="headerlink" title="镜像打包"></a>镜像打包</h3><p>因为对 docker 镜像文件编写不熟，所以就不分阶段写了，实现还是可以比较简单的：<br>1）选择合适版本的 node 源<br>2）添加文件夹&#x2F;opt&#x2F;project、设置文件夹为工作目录<br>3）选择 npm 源（如果项目使用了私有源）执行指令 npm install 安装依赖<br>4）执行指令 npm run build:test 打包<br>5）设置必要的环境变量<br>6）暴露容器端口 3000（nuxt 默认端口）<br>7）启动服务器</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dockerFile"><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">20</span>-alpine<br><br><span class="hljs-keyword">ADD</span><span class="language-bash"> . /opt/project</span><br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /opt/project</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> npm config <span class="hljs-built_in">set</span> registry  http://verdaccio.privacy.com/ &amp;&amp; npm install</span><br><span class="hljs-comment"># 不缓存安装包</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apk add --no-cache curl</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> npm run build:<span class="hljs-built_in">test</span></span><br><br><span class="hljs-keyword">ENV</span> NODE_ENV production<br><span class="hljs-comment"># 暴露容器端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">3000</span><br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;node&quot;</span>,<span class="hljs-string">&quot;./.output/server/index.mjs&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>因为打包完后 nuxt 的入口文件为.output&#x2F;server&#x2F;index.mjs，直接用 node 指令运行就能看到结果。<br>之后使用容器服务、拉取打包好的镜像即可。</p><p>一般部署到这里就结束了，然而如果项目通过 ng 配置、放在一个和其他项目共用的域名下可能会有问题，因为打包后.output&#x2F;public 文件夹下存有静态文件，项目访问这些文件时会通过域名+文件夹的路径访问，可能会出现因域名 ng 配置规则无法命中导致静态资源请求 404。如果要解决这个问题，需要将 public 文件夹下的内容上传至 cdn，同时将 nuxt.config.ts 添加配置：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">app: &#123;<br>    cdnURL: <span class="hljs-built_in">getPublicPath</span>(),<br>&#125;<br></code></pre></td></tr></table></figure><p>镜像打包文件增加一行上传 cdn 指令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs dockerFile"><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">20</span>-alpine<br><br><span class="hljs-keyword">ADD</span><span class="language-bash"> . /opt/project</span><br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /opt/project</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> npm config <span class="hljs-built_in">set</span> registry  http://verdaccio.privacy.com/ &amp;&amp; npm install</span><br><span class="hljs-comment"># 不缓存安装包</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apk add --no-cache curl</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> npm run build:<span class="hljs-built_in">test</span></span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> npm run upload:<span class="hljs-built_in">test</span></span><br><br><span class="hljs-keyword">ENV</span> NODE_ENV production<br><span class="hljs-comment"># 暴露容器端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">3000</span><br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;node&quot;</span>,<span class="hljs-string">&quot;./.output/server/index.mjs&quot;</span>]</span><br></code></pre></td></tr></table></figure><h3 id="日志服务"><a href="#日志服务" class="headerlink" title="日志服务"></a>日志服务</h3><p>为了偷懒不研究 pm2 的用法，使用了 nuxt3-winston-log，是官方推荐的插件。配置可参考 <a href="https://www.npmjs.com/package/nuxt3-winston-log">npm 说明</a><br>nuxt3-winston-log 会收集代码中所有的 console 打印语句，日志内容可通过登录容器服务器，在项目根目录的 logs 文件夹下查看 info 和 error 的打印情况</p><h2 id="附录：踩坑记录"><a href="#附录：踩坑记录" class="headerlink" title="附录：踩坑记录"></a>附录：踩坑记录</h2><ol><li>选项式文件有概率无法实现 ssr<br>原因不明，debug 时能看到请求在后端已经发出，但 html 文件里没有请求渲染的结果；最后只能借 ai 转成组合式了</li><li>服务端判断 iPad 有问题<br>原来的判断方法<code>UA.match(/(iPad)/) || (UA.match(/(Macintosh)/) &amp;&amp; navigator.maxTouchPoints &gt;= 1)</code>前一个判断条件太宽泛，容易命中，后一个依赖浏览器。目前没想到好办法，因此服务端渲染的页面无法适配 iPad</li><li>element-plus 样式改写不生效<br>原因：Vue 2 语法&#x2F;deep&#x2F;无法生效，element-plus 和 element-ui 在一些组件的 class 命名方式也有所改变，需要注意<br>解决方法：全局将&#x2F;deep&#x2F;替换为::v-deep，虽然这个语法也不是 Vue 3 的标准语法，但生效了，所以就这么无赖的写了</li><li>element-plus 不支持 i 标签 class 引入 icon 方式。<br>解决方法：如下代码</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;el-icon<br>      v-<span class="hljs-keyword">if</span>=<span class="hljs-string">&quot;isLogin &amp;&amp; userInfo&quot;</span><br>      <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;el-icon-switch-button logout-icon&quot;</span><br>      @click.<span class="hljs-property">stop</span>=<span class="hljs-string">&quot;handleLogout&quot;</span><br>   &gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ElIconSwitchButton</span>/&gt;</span></span><br>&lt;/el-icon&gt;<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://juejin.cn/post/7379521155285843980">Nuxt3 项目工程化、环境变量、SEO 配置</a></li><li><a href="https://juejin.cn/post/7236635191379509308?searchId=202412031133081B66D928AF3CC959C84B">超完整的 Nuxt3 踩坑实录，那真是泰裤辣！</a></li><li><a href="https://juejin.cn/post/7224435010072346683?searchId=20241215213456642157F15B260AB6947E">nuxt3 项目打包部署上线</a></li><li><a href="https://juejin.cn/post/7197214505347137592">使用 Docker 部署 Nuxt 3 的专家技术</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>工作技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nuxt</tag>
      
      <tag>ssr</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>electron初步调研</title>
    <link href="/unknown404.github.io/2024/11/20/electron/"/>
    <url>/unknown404.github.io/2024/11/20/electron/</url>
    
    <content type="html"><![CDATA[<p>最近需要开发桌面端，需要研究 electron。这里只打算研究最基础的开发。</p><span id="more"></span><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>是的，electron 事实上连安装本身都是个问题。在换了几个源以后发现只能求助于万能的网络，根据网上的建议，更换了几个 npm 相关的配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm config <span class="hljs-built_in">set</span> registry https://registry.npmmirror.com<br>npm config <span class="hljs-built_in">set</span> electron_mirror https://cdn.npmmirror.com/binaries/electron/<br>npm config <span class="hljs-built_in">set</span> electron_builder_binaries_mirror https://npmmirror.com/mirrors/electron-builder-binaries/<br></code></pre></td></tr></table></figure><p>第一个指令是更换了最新的淘宝 npm 源，说不定以后还会变。<br>然后就是执行指令<code>npm i electron -D</code>，经过漫长的等待终于成功了。</p><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>目前 Electron 打包方法分为两大类：</p><ul><li>社区提供的 Electron Builder</li><li>官方提供的 Electron Packager 和 Electron Forge<br>两方都声称自己已经提供了完整的功能。不过从网上的技术博文来看，还是 Electron Builder 用的更多一些，它的配置简单，涉及的插件少，更适合新手。</li></ul><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol><li>安装指令<code>npm i electron-builder -D</code></li><li>在 package.json 配置安装包相关参数</li><li>在 package.json 配置打包指令<code>electron-builder -mw</code>指令可以同时打包 mac 和 windows 安装包，如果当前环境是 mac，该指令可以正确执行。但 windows 环境下打不出 mac 包</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;icon&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1024.png&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;publish&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;provider&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;generic&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://xxx.upload.com/&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;directories&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;output&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;electron_dist&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;nsis&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;build/installer.nsh&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;oneClick&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;allowToChangeInstallationDirectory&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;createDesktopShortcut&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;createStartMenuShortcut&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;shortcutName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;test&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;win&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;nsis&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;arch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-string">&quot;x64&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;ia32&quot;</span><br>          <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;mac&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;dmg&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;arch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-string">&quot;x64&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;universal&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;arm64&quot;</span><br>          <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>这里对常用的配置做一下记录</p><h4 id="一般配置"><a href="#一般配置" class="headerlink" title="一般配置"></a>一般配置</h4><p>直接放在 build 配置下</p><ul><li><strong>productName</strong> ：项目名 这也是生成的 exe 文件的前缀名</li><li><strong>icon</strong> ：图标路径 要求至少 512*512</li><li><strong>directories</strong> ：输出文件夹</li></ul><h4 id="windows-配置"><a href="#windows-配置" class="headerlink" title="windows 配置"></a>windows 配置</h4><p>如果要打包 windows 可安装的 exe 文件，需要做 win 配置。鉴于 windows 目前常用的安装程序为 nsis，所以设置打包格式为 nsis，兼容 32 位和 64 位系统<br>nsis 如果不做任何配置，项目会一键安装到 c 盘，没有用户操作的余地，感觉不太好，所以对配置做了如下更改</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;nsis&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;build/installer.nsh&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//包含的自定义nsis脚本</span><br>      <span class="hljs-attr">&quot;oneClick&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//是否一键安装</span><br>      <span class="hljs-attr">&quot;allowToChangeInstallationDirectory&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//允许修改安装目录</span><br>      <span class="hljs-attr">&quot;createDesktopShortcut&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//创建桌面图标</span><br>      <span class="hljs-attr">&quot;createStartMenuShortcut&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//创建开始菜单图标</span><br>      <span class="hljs-attr">&quot;shortcutName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;test&quot;</span><span class="hljs-comment">//图标名称</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>nsis 配置里 include 和 scripts 的区别？</p><ul><li>include：在 nsis 已有的脚本上合并作者自己的自定义安装配置修改，文件路径下的内容应该不包含 nsis 完整的流程</li><li>scripts：用脚本语言对 nsis 安装过程完全自定义</li></ul><p>目前我的实力不足，没把握对全过程进行改写，所以只改写了如下内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sh">!macro preInit<br>    SetRegView 64<br>    ReadRegStr <span class="hljs-variable">$0</span> HKLM <span class="hljs-string">&quot;Software\Microsoft\Windows\CurrentVersion\Uninstall\&#123;GUID&#125;&quot;</span> <span class="hljs-string">&quot;UninstallString&quot;</span><br>    <span class="hljs-variable">$&#123;If&#125;</span> <span class="hljs-variable">$0</span> == <span class="hljs-string">&#x27;&#x27;</span><br>        WriteRegStr HKLM <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;INSTALL_REGISTRY_KEY&#125;</span>&quot;</span> InstallLocation <span class="hljs-string">&quot;C:\Program Files (x86)\myAPP-electron&quot;</span><br>    <span class="hljs-variable">$&#123;Endif&#125;</span><br>    SetRegView 32<br>    ReadRegStr <span class="hljs-variable">$0</span> HKLM <span class="hljs-string">&quot;Software\Microsoft\Windows\CurrentVersion\Uninstall\&#123;GUID&#125;&quot;</span> <span class="hljs-string">&quot;UninstallString&quot;</span><br>    <span class="hljs-variable">$&#123;If&#125;</span> <span class="hljs-variable">$0</span> == <span class="hljs-string">&#x27;&#x27;</span><br>        WriteRegStr HKLM <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;INSTALL_REGISTRY_KEY&#125;</span>&quot;</span> InstallLocation <span class="hljs-string">&quot;C:\Program Files (x86)\myAPP-electron&quot;</span><br>    <span class="hljs-variable">$&#123;Endif&#125;</span><br>!macroend<br><br>!macro customInit<br>  MessageBox MB_OK <span class="hljs-string">&quot;欢迎使用 xxx 安装程序！&quot;</span><br>!macroend<br></code></pre></td></tr></table></figure><p>只是按网上的说法，针对允许修改目录的操作对应修改注册表</p><h4 id="mac-配置"><a href="#mac-配置" class="headerlink" title="mac 配置"></a>mac 配置</h4><p>相比之下 mac 配置比较简单，常见安装包是 dmg，旧系统 universal，新系统 arm64</p><h2 id="自动更新"><a href="#自动更新" class="headerlink" title="自动更新"></a>自动更新</h2><p>自动更新的方法目前调研起来有这么几种：</p><ol><li>找台服务器，上传、版本更新、下载、执行安装都自己写，大概像<a href="https://juejin.cn/post/7428154064720412710">这篇文章</a>一样。<br>好处是不受 autoUpdater 限制，但是这个流程感觉还挺麻烦的</li><li>使用 electron 内部的 autoUpdater<br>但是看起来 windows 的安装只能使用 Squirrel.Windows，好像有点类似一键安装，所以也不支持换文件夹，感觉不友好，再加上<a href="https://segmentfault.com/a/1190000007616641?utm_source=sf-similar-article">技术太老</a></li><li>electron-updater，网上常见的解决方案</li></ol><p>但是 electron-updater 的使用方法也有多种：</p><ul><li>github release：需要是公开的，不知道能不能允许在 github 上开一个专门 release 的仓库，而且就现在 github 连接不稳的情况能不能顺利下载呢？有这些问题</li><li>http server：如果按<a href="https://juejin.cn/post/7302724955700264999?searchId=20241129105329614CF8B9472F2A1AD84D">这篇</a> 的意思只要提供的地址能找到 yml 和 exe 文件就可以下载更新了，那么放在 cdn 上应该也可以吧</li><li>私有 gitlab：看起来要写 gitlab ci 文件，嗯感觉有点麻烦</li></ul><p>如果要检查更新相关的信息打印情况，可以打开终端，执行指令<code>open ~/Library/Logs/&lt;app name&gt;/main.log</code><br>根据官方示例<a href="https://github.com/iffy/electron-updater-example/blob/master/main.js#L117C1-L119C4">https://github.com/iffy/electron-updater-example/blob/master/main.js#L117C1-L119C4</a> 应该用 checkForUpdatesAndNotify 就能实现了，但实际上只监听到了可更新资源没有任何操作。。。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://www.cnblogs.com/bokemoqi/p/18389113">解决 Electron 安装失败问题的实用指南</a><br>（2）<a href="https://juejin.cn/post/7250085815430430781">详解 Electron 打包</a><br>（3）<a href="https://juejin.cn/post/7140962767275556901?searchId=2024112617310837464B7109099AA135BE">【Electron】electron-builder 打包基础配置介绍</a></p>]]></content>
    
    
    <categories>
      
      <category>工作技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>electron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>npm发包流程</title>
    <link href="/unknown404.github.io/2024/11/14/npmPackage/"/>
    <url>/unknown404.github.io/2024/11/14/npmPackage/</url>
    
    <content type="html"><![CDATA[<p>总结一下自己第一次 npm 发包经历，以免忘记了。</p><span id="more"></span><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ol><li><p>新建一个文件夹，在文件夹内部使用指令 <code>npm init -y</code> 来快速生成一个带有默认值的 package.json。</p></li><li><p>使用指令安装 ts-loader、typescript、webpack、webpack-cli，其中 ts-loader 是 Webpack 的 TypeScript 加载器，在打包配置中处理以 ts 结尾的文件</p></li></ol><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol><li>ts 配置：在项目根目录下创建 tsconfig.json 文件，常见配置为以下内容</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;outDir&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./dist&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;declaration&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;declarationDir&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./dist/types&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;module&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ESNext&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ES5&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;moduleResolution&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Node&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;strict&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;src/**/*&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;exclude&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;node_modules&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;dist&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>webpack 配置：在项目根目录创建 webpack.config.js 文件，配置 Webpack</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><span class="hljs-keyword">const</span> &#123; library &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;webpack&quot;</span>);<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">alias</span>: &#123;<br>      <span class="hljs-string">&quot;@&quot;</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;../src&quot;</span>),<br>    &#125;,<br>    <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&quot;.js&quot;</span>, <span class="hljs-string">&quot;.ts&quot;</span>, <span class="hljs-string">&quot;.jsx&quot;</span>, <span class="hljs-string">&quot;.tsx&quot;</span>, <span class="hljs-string">&quot;.json&quot;</span>], <span class="hljs-comment">// 添加必要的文件扩展名</span><br>  &#125;,<br>  <span class="hljs-comment">// entry: 指定入口文件</span><br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&quot;./src/index.ts&quot;</span>,<br>  <span class="hljs-comment">// 入口文件指定完成之后对文件进行打包，把文件输出到指定的位置  【指定打包文件所在的目录】</span><br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-comment">// 指定打包文件的目录     __dirname,是一个成员，用来动态获取当前文件模块所属的绝对路径</span><br>    <span class="hljs-comment">//  所以说path:path.resolve(__dirname,&quot;dist&quot;)就是在打包之后的文件夹上拼接了一个文件夹，在打包时，直接生成。</span><br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;dist&quot;</span>),<br>    <span class="hljs-comment">// 打包后文件的文件名</span><br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;bundle.js&quot;</span>,<br>    <span class="hljs-attr">globalObject</span>: <span class="hljs-string">&quot;this&quot;</span>,<br>    <span class="hljs-attr">library</span>: <span class="hljs-string">&quot;newsSDK&quot;</span>,<br>    <span class="hljs-attr">libraryTarget</span>: <span class="hljs-string">&quot;umd&quot;</span>,<br>    <span class="hljs-attr">clean</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  <span class="hljs-comment">// 指定webpack打包时要使用的模块</span><br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-comment">// 指定要加载的规则</span><br>    <span class="hljs-attr">rules</span>: [<br>      <span class="hljs-comment">// 用ts-loader 处理以ts结尾的文件</span><br>      &#123;<br>        <span class="hljs-comment">// test 指定的是规则生效的文件</span><br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.ts$/</span>, <span class="hljs-comment">// 表示去【匹配所有以ts结尾的文件</span><br>        <span class="hljs-comment">// ts要使用的loader</span><br>        <span class="hljs-attr">use</span>: <span class="hljs-string">&quot;ts-loader&quot;</span>,<br>        <span class="hljs-comment">// 要排除的文件</span><br>        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node-modules/</span>,<br>      &#125;,<br>    ],<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>设置说明：</p><ul><li>resolve.extensions：支持解析的扩展名，如果不写 ts 实例中的入口文件路径无法识别</li><li>output.globalObject：设置为 ‘this’ 来确保在不同环境（例如 Node.js 和浏览器）下正确获取全局对象，避免直接使用 window。</li><li>output.library：指定模块作为全局变量的名称。在上面的示例中当直接在浏览器中引入时，该库会以 newsSDK 这个全局变量提供访问。</li><li>output.libraryTarget：设置 library 的暴露方式，常见选项包括：<br>‘var’：将库作为一个变量（变量名由 output.library 设置）放入全局对象上，在浏览器端使用时需要先加载该模块并引用相关变量。<br>‘window’：当库加载完成，入口起点的返回值将分配给 window 对象。<br>‘assign’：将库返回值分配给一个没使用 var 申明的变量中，如果这个变量没有在引入作用域中提前申明过，那么将会挂载在全局作用域中。<br>‘this’：将库的返回值分配给 this 对象的由 output.library 指定的属性。其中 this 的意义由用户决定。<br>‘global’：将库的返回值分配给全局对象的由 output.library 指定的属性。<br>‘commonjs’：以 CommonJS 模块定义方式导出，使这些模块可以在 Node.js 中被引用。<br>‘commonjs2’：和 commonjs 类似，但是会通过 module.exports 导出所有内容，适用于多个 CommonJS require 对同一个库进行重复调用的情况。<br>‘amd’：以 AMD 模块定义方式导出，使这些模块可以在 AMD 环境中被引用。<br>‘umd’：这是一种可以将你的库能够在所有的模块定义下都可运行的方式（并且导出的完全不是模块）。它将在 CommonJS、AMD 环境下运行，或将模块导出到全局下的变量。<br>具体在什么环境下使用可参见<a href="https://zhuanlan.zhihu.com/p/108216236">这篇文章</a></li></ul><p>除了示例中列举出来的配置，还有一些和打包相关的配置，例如：</p><ul><li>externals：指定哪些模块不需要被打包进最终的输出文件中，而是直接在外部环境中引用。这对于依赖于第三方库的项目尤其有用，通常用于避免重复打包体积较大的库，从而减少输出文件的大小。</li></ul><ol start="3"><li>devServer 配置</li></ol><p>对打包的结果进行文件引入测试时可以使用 webpack-dev-server，使用方法：<br>1）指令<code>npm install webpack-dev-server --save-dev</code>导入 webpack-dev-server 模块<br>2）在 webpack.config.js 中进行基本配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">devServer:</span> &#123;<br>    <span class="hljs-attr">static:</span> <span class="hljs-string">path.join(__dirname</span>, <span class="hljs-string">&quot;./examples&quot;</span><span class="hljs-string">)</span>,<br>    <span class="hljs-attr">compress:</span> <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">port:</span> <span class="hljs-number">9000</span>,<br>&#125;<span class="hljs-string">,</span><br></code></pre></td></tr></table></figure><p>3）指令<code>webpack serve --config webpack.config.js</code>启动服务</p><h2 id="模块编写"><a href="#模块编写" class="headerlink" title="模块编写"></a>模块编写</h2><p>需要注意的点是如果使用 export default 后，在 UMD 模式下需访问 .default 才是默认导出的内容</p><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>执行 webpack 打包指令<code>webpack</code>默认按 webpack.config.js 文件配置打包，如果存在多个 webpack 配置文件，可以用指令如<code>webpack --config build/webpack.config.dev.js</code>指定打包配置。示例中没有指定打包的 mode 可以用指令<code>webpack --mode development</code>指定。</p><h2 id="发包"><a href="#发包" class="headerlink" title="发包"></a>发包</h2><p>如果还没有登录 npm 账户，可以使用以下命令登录：npm login。（注意如果是在内网发布的包 npm 源要切到内部的 npm 源）<br>然后，在项目根目录下运行以下命令发布包：npm publish。<br>后续更新包时应该注意的点有：1）用户下载的包是用的 package.json 的 main 文件路径，所以更新代码后要重新打包更新 main 路径下的文件；2）包的版本号应该同步更新；3）考虑浏览器直接引入文件的情况，可以写一个 dist 文件上传静态资源到 cdn 方法<br>综上，可以设置一个复合指令<code>npm run release:patch</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;build:dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --mode development&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;build:prod&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --mode production&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;server&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack serve --config webpack.config.js --mode development&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;release:patch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;npm run build:prod &amp;&amp; npm version patch &amp;&amp; npm publish &amp;&amp; node publishCDN.mjs&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工作技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>npm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AGI基础概念总结</title>
    <link href="/unknown404.github.io/2024/09/11/agiStart/"/>
    <url>/unknown404.github.io/2024/09/11/agiStart/</url>
    
    <content type="html"><![CDATA[<p>自 chatgpt 面世以来，ai 相关的产品层出不穷，如何用好 ai、让它更好的为自己服务也是一大新课题。</p><span id="more"></span><h2 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h2><h3 id="什么是-Agent（代理-x2F-智能体）"><a href="#什么是-Agent（代理-x2F-智能体）" class="headerlink" title="什么是 Agent（代理&#x2F;智能体）"></a>什么是 Agent（代理&#x2F;智能体）</h3><p>Agent，可以翻译为代理或者智能体。在 AGI 领域，则指的是一个通过传感器&#x2F;计算器感知其环境、做出决策并相应地响应的主体。</p><h3 id="Agent-发展史"><a href="#Agent-发展史" class="headerlink" title="Agent 发展史"></a>Agent 发展史</h3><p>简单来说 Agent 不是现在才有的概念，早期的 Agent 依赖于制定的类似 ifelse 语句进行决策，后来基于强化学习的 Agent 的代表性产品——AlphaGo 出名后，人们将精力放在深度学习以及出现后深度神经网络来训练 Agent 学习复杂的策略。</p><p>而近年来，大型语言模型（LLM）非常火热，潜力巨大。因此，一个新的研究领域已经出现，使用 LLM 作为 Agent 的核心控制器。</p><h3 id="基于-LLM-的-Agent-的架构"><a href="#基于-LLM-的-Agent-的架构" class="headerlink" title="基于 LLM 的 Agent 的架构"></a>基于 LLM 的 Agent 的架构</h3><p>大致可以拆分为大模型、规划、记忆与工具使用四个组件部分。</p><h4 id="大模型"><a href="#大模型" class="headerlink" title="大模型"></a>大模型</h4><p>LLM 是 Agent 的核心组件，基于 GPT-3、GPT-4 或类似的大型语言模型。LLM 负责处理自然语言理解（NLU）和自然语言生成（NLG），与用户进行对话，回答问题，生成文本等。</p><h4 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h4><p>LLM 具备逻辑推理能力，但对于复杂的问题难以给出正确的答案，因为用户使用的 prompt（提示语）不合适，导致大模型直接给出了关联度高的字词。一项复杂的任务往往涉及许多步骤。AI Agent 需要首先拆解这些步骤，进行多步推理。<br>当下普遍的技术模式包括思维链和思维树。</p><h4 id="记忆"><a href="#记忆" class="headerlink" title="记忆"></a>记忆</h4><p>记忆模块负责存储信息，包括过去的交互、学习到的知识，甚至是临时的任务信息。<br>在 LLM 中，记忆模块仿照了人类的记忆模式：短期记忆指 transformer 架构限制的上下文窗口内的输入信息；长期记忆类似于外部向量存储</p><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p>AI Agent 与大模型的一大区别在于能够使用外部工具拓展模型能力。LLM 本身虽然强大，但也会有局限。因此，Agent 通常会与外部工具和 API 进行集成。插件系统允许 Agent 调用各种外部服务，如数据库查询、调用 Web API，甚至是与物理设备交互（如 IoT 设备）。<br>以 openAI 的 chatgpt 为例，其训练数据只截止到了 2021 年底，对于更新一些的知识内容它无法直接做出回答。后来 openAI 发布了 FunctionCall 模式，大概就是写一份规则，让 chatgpt 知道什么时候去调用外部工具。</p><h3 id="Agent-应用"><a href="#Agent-应用" class="headerlink" title="Agent 应用"></a>Agent 应用</h3><p>目前各大企业都提供了制作 agent 的平台，比较有名的有字节的 coze、钉钉的 AI 助理、Dify 等，主要可以分为以下几类</p><h4 id="AI-插件"><a href="#AI-插件" class="headerlink" title="AI+插件"></a>AI+插件</h4><p>特点：提供为模型写人设（即 prompt）的功能，可替换模型、添加插件、数据库，以及配置好后的对话调试</p><h4 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h4><p>特点：可以设置节点，处理一些复杂的任务：例如实现跳转和循环、根据多次输入的内容进行作答的场景；对不同类问题的回答有不同的输出格式要求的场景</p><h2 id="prompt"><a href="#prompt" class="headerlink" title="prompt"></a>prompt</h2><h3 id="什么是-prompt（提示词）？"><a href="#什么是-prompt（提示词）？" class="headerlink" title="什么是 prompt（提示词）？"></a>什么是 prompt（提示词）？</h3><p>提示词在人工智能领域是一种特定的输入，用于激发 AI 系统进行特定的思考或行为。它们可以是问题、指令或描述，旨在引导 AI 理解用户的意图并作出相应的反应。提示词的设计需要考虑到 AI 的理解和生成能力，确保它们能够激发出期望的输出</p><h2 id="MCP"><a href="#MCP" class="headerlink" title="MCP"></a>MCP</h2><p>MCP（模型上下文协议）是由 Anthropic 公司提出的一种新技术，通过标准化接口，确保 AI 模型（如 Claude）与外部工具、数据源之间可以无缝协作，解决了传统数据孤岛带来的限制，提升了 AI 模型的性能与响应的准确性。</p><h3 id="MCP-结构"><a href="#MCP-结构" class="headerlink" title="MCP 结构"></a>MCP 结构</h3><p>MCP Server：提供特定功能的服务器。<br>MCP Client：通过 MCP 协议与服务器进行通讯的客户端。<br>数据源：包括文件、数据库记录、API 响应等。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/7359119142786154546">全面讲解基于大型语言模型的智能 Agent：发展历程、架构与基于 Langchain 的实现 demo</a><br>（2）<a href="https://agijuejin.feishu.cn/wiki/F1jPwKffhiXedTkp26bcFuQInQb">十种 agent 工具，多种思路</a><br>（3）<a href="https://mp.weixin.qq.com/s/IKxC-bkC_6znhn9aHeVwBw">让 AI 写出靠谱代码：一套提示词模板设计实践</a></p>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AGI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vite小记</title>
    <link href="/unknown404.github.io/2024/09/02/vite/"/>
    <url>/unknown404.github.io/2024/09/02/vite/</url>
    
    <content type="html"><![CDATA[<p>记录一点 vite 的小知识</p><span id="more"></span><h2 id="什么是-vite"><a href="#什么是-vite" class="headerlink" title="什么是 vite"></a>什么是 vite</h2><p>一个新型前端构建工具，构建速度快于 webpack</p><h2 id="概念区分：vite、webpack、vue-cli、create-vue"><a href="#概念区分：vite、webpack、vue-cli、create-vue" class="headerlink" title="概念区分：vite、webpack、vue-cli、create-vue"></a>概念区分：vite、webpack、vue-cli、create-vue</h2><p>vue-cli、create-vue 都属于脚手架，作用是创建项目，选择性安装需要的插件，指定统一的风格，生成示例代码。区别在于：vue-cli 用于创建 vue2 的项目，使用 webpack 创建；create-vue 是 Vue3 的专用脚手架，使用 vite 创建。</p><p>webpack 属于打包代码：代码写好之后，为了更好的使用，需要打包处理一下。配置文件的 output 就是预期处理的结果</p><p>vite 属于构建项目：建立项目的运行环境，需要手动安装插件。打包代码只是构建项目的一环</p><h2 id="vite-特点"><a href="#vite-特点" class="headerlink" title="vite 特点"></a>vite 特点</h2><ul><li>开发环境：使用 esbuild 打包代码，基于 原生 ES 模块 提供了 丰富的内建功能，如速度快到惊人的 模块热更新（HMR）</li><li>生产环境：使用 Rollup 打包代码，可预配置，最终输出用于生产环境的高度优化过的静态资源</li><li>插件生态：通过其 插件 API 和 JavaScript API 进行扩展，并提供完整的类型支持。例如支持 React、TypeScript</li></ul><h3 id="vite-快速启动原因"><a href="#vite-快速启动原因" class="headerlink" title="vite 快速启动原因"></a>vite 快速启动原因</h3><ol><li>预构建：vite 会对 package.json 中的 dependencies 部分先进行构建，然后把构建后的文件换存在 node_modules&#x2F;.vite 文件夹中，当启动项目时，直接请求该缓存内容。</li><li>esbuild：vite 利用了目前大部分浏览器都支持 es 模块化语法的特性，直接引入需要的 es 模块代码；es 模块具有动态引入的特点，实现了按需加载，因此页面的加载速度就提升了。</li><li>热更新打包：不会像webpack一样更改了单个文件就重新打包后再传给server，而是监听到模块变化后让浏览器重新请求该模块</li></ol><h3 id="vite的风险"><a href="#vite的风险" class="headerlink" title="vite的风险"></a>vite的风险</h3><ol><li>开发环境和线上环境的打包方式不一样，所以可能会出现线上版展示效果与开发版不一致的情况</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/7095603836072493086?searchId=20240902144719D7C75F0E69B15A07B83B">一篇文章说清 webpack、vite、vue-cli、create-vue 的区别</a></p>]]></content>
    
    
    <categories>
      
      <category>前端技术体系</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端打包工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Taro项目开发中的问题总结</title>
    <link href="/unknown404.github.io/2024/08/22/taroBug/"/>
    <url>/unknown404.github.io/2024/08/22/taroBug/</url>
    
    <content type="html"><![CDATA[<p>最近领导迷恋上了跨端开发，把以前的一个项目迁移成 Taro 了。中间踩了不少奇奇怪怪的坑，终于忍不住列出来吐槽了。</p><span id="more"></span><h2 id="1-样式设置为-scoped-无法生效"><a href="#1-样式设置为-scoped-无法生效" class="headerlink" title="1. 样式设置为 scoped 无法生效"></a>1. 样式设置为 scoped 无法生效</h2><p>这好像没什么解决方法，自己写 scss 的时候小心点吧</p><h2 id="2-Taro-redirectTo-url-“-x2F-pages-x2F-404-x2F-index”-小程序跳转正常，h5-端报-page-x2F-wap-x2F-error-notfound"><a href="#2-Taro-redirectTo-url-“-x2F-pages-x2F-404-x2F-index”-小程序跳转正常，h5-端报-page-x2F-wap-x2F-error-notfound" class="headerlink" title="2. Taro.redirectTo({ url: “&#x2F;pages&#x2F;404&#x2F;index” });小程序跳转正常，h5 端报 page &#x2F;wap&#x2F;error notfound"></a>2. Taro.redirectTo({ url: “&#x2F;pages&#x2F;404&#x2F;index” });小程序跳转正常，h5 端报 page &#x2F;wap&#x2F;error notfound</h2><p>原因：配置文件里配置了 customRoutes: { ‘&#x2F;pages&#x2F;404&#x2F;index’: ‘&#x2F;error’ }<br>解决方法：去除 customRoutes 配置，h5 的这个配置好像只是改了个 path 名字，并不能做为 route 使用。</p><h2 id="3-百度小程序-first-child-的样式写法失效"><a href="#3-百度小程序-first-child-的样式写法失效" class="headerlink" title="3. 百度小程序 :first-child 的样式写法失效"></a>3. 百度小程序 :first-child 的样式写法失效</h2><p>原因：编译百度小程序的时候子元素外面都套了一层 dom，所以 first-child 对不上了<br>解决方法：改用 :first-of-type 或者在 template 代码加 class 判断条件</p><h2 id="4-H5-下，button-在-active-状态下有默认的白色背景"><a href="#4-H5-下，button-在-active-状态下有默认的白色背景" class="headerlink" title="4. H5 下，button 在 active 状态下有默认的白色背景"></a>4. H5 下，button 在 active 状态下有默认的白色背景</h2><p>设置 <code>&amp;:active &#123; background: none; &#125;</code> 关掉背景色</p><h2 id="5-mixins、extends-在-onShow、onHide-周期代码无法生效"><a href="#5-mixins、extends-在-onShow、onHide-周期代码无法生效" class="headerlink" title="5. mixins、extends 在 onShow、onHide 周期代码无法生效"></a>5. mixins、extends 在 onShow、onHide 周期代码无法生效</h2><p>原因：页面已经书写了 onShow 和 onHide 的代码，Taro 的代码扩展效果只限于 Vue 的几个生命周期<br>解决方法：手动在页面 onShow 和 onHide 添加目标逻辑</p><h2 id="6-eventCenter-监听-onShow-事件在-iOS-失效"><a href="#6-eventCenter-监听-onShow-事件在-iOS-失效" class="headerlink" title="6. eventCenter 监听 onShow 事件在 iOS 失效"></a>6. eventCenter 监听 onShow 事件在 iOS 失效</h2><p>原因：官方提供的监听示例代码为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; eventCenter, getCurrentInstance &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@tarojs/taro&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>    eventCenter.<span class="hljs-title function_">on</span>(<span class="hljs-title function_">getCurrentInstance</span>().<span class="hljs-property">router</span>.<span class="hljs-property">onShow</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;onShow&quot;</span>);<br>    &#125;);<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>实际 iOS 的 router 实例里没有 onShow，就算手动构造也仍然会在 iOS 部分页面监听失效</p><h2 id="7-抖音小程序-Button-唤起客服操作不生效"><a href="#7-抖音小程序-Button-唤起客服操作不生效" class="headerlink" title="7. 抖音小程序 Button 唤起客服操作不生效"></a>7. 抖音小程序 Button 唤起客服操作不生效</h2><p>原因：button 组件缺失 im 客服涉及的属性<br>解决方法：参考<a href="https://github.com/NervJS/taro/issues/14118">这个 issue</a>，使用插件@tarojs&#x2F;plugin-inject 这个插件，并在 config 文件里添加这个配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">plugins</span>: [<br>  [<br>    <span class="hljs-string">&quot;@tarojs/plugin-inject&quot;</span>,<br>    &#123;<br>      <span class="hljs-attr">components</span>: &#123;<br>        <span class="hljs-comment">// 给button组件添加自定义事件</span><br>        <span class="hljs-title class_">Button</span>: &#123;<br>          <span class="hljs-string">&quot;data-im-id&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>          <span class="hljs-attr">dataImId</span>: <span class="hljs-string">&quot;&quot;</span>,<br>          <span class="hljs-attr">dataImType</span>: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// im卡片类型</span><br>          <span class="hljs-string">&quot;data-im-type&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>          <span class="hljs-attr">dataGoodsId</span>: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 商品id</span><br>          <span class="hljs-string">&quot;data-goods-id&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>          <span class="hljs-attr">dataBizLine</span>: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 类型</span><br>          <span class="hljs-string">&quot;data-biz-line&quot;</span>: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 类型</span><br>          <span class="hljs-attr">dataOrderId</span>: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 订单id</span><br>          <span class="hljs-string">&quot;data-order-id&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>          <span class="hljs-attr">bindim</span>: <span class="hljs-string">&quot;&#x27;eh&#x27;&quot;</span>, <span class="hljs-comment">// 监听跳转IM的成功回调</span><br>          <span class="hljs-attr">bindIm</span>: <span class="hljs-string">&quot;&#x27;eh&#x27;&quot;</span>, <span class="hljs-comment">// 监听跳转IM的成功回调</span><br>          <span class="hljs-attr">binderror</span>: <span class="hljs-string">&quot;&#x27;eh&#x27;&quot;</span>, <span class="hljs-comment">// 监听跳转IM的失败回调</span><br>          <span class="hljs-attr">bindError</span>: <span class="hljs-string">&quot;&#x27;eh&quot;</span>, <span class="hljs-comment">// 监听跳转IM的失败回调</span><br>        &#125;,<br>      &#125;,<br>    &#125;,<br>  ],<br>];<br></code></pre></td></tr></table></figure><p>使用 Vue 组件书写时格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;button<br>  open-type=&quot;im&quot;<br>  dataImId=&quot;123456&quot;<br>  :onIm=&quot;imCallback&quot;<br>  :onError=&quot;onimError&quot;<br>&gt;<br>联系客服<br>&lt;/button&gt;<br></code></pre></td></tr></table></figure><p><strong>延伸</strong>：抖音小程序 textarea 无法监听键盘弹起，也是因为属性缺失（很神奇，input 组件对此进行了补充，但 textarea 却没有，截止目前 4.0.9 版本 <a href="https://github.com/NervJS/taro/pull/16098%EF%BC%89">https://github.com/NervJS/taro/pull/16098）</a><br>解决方法同上，如果不想改包的话：<br>在 config 文件里添加这个配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">plugins</span>: [<br>  [<br>    <span class="hljs-string">&quot;@tarojs/plugin-inject&quot;</span>,<br>    &#123;<br>      <span class="hljs-attr">components</span>: &#123;<br>        <span class="hljs-title class_">Textarea</span>: &#123;<br>          <span class="hljs-attr">bindkeyboardheightchange</span>: <span class="hljs-string">&quot;&#x27;eh&#x27;&quot;</span>,<br>          <span class="hljs-attr">bindKeyboardHeightChange</span>: <span class="hljs-string">&quot;&#x27;eh&#x27;&quot;</span>,<br>        &#125;,<br>      &#125;,<br>    &#125;,<br>  ],<br>];<br></code></pre></td></tr></table></figure><p>组件使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;textarea<br>  type=&quot;text&quot;<br>  v-model.trim=&quot;inputValue&quot;<br>  maxlength=&quot;-1&quot;<br>  class=&quot;textarea&quot;<br>  :cursor-spacing=&quot;12&quot;<br>  placeholder=&quot;请输入消息…&quot;<br>  placeholder-style=&quot;color: rgba(255,255,255,0.8);&quot;<br>  :auto-height=&quot;true&quot;<br>  :fixed=&quot;true&quot;<br>  :adjust-position=&quot;false&quot;<br>  @focus=&quot;inputFocusHandler&quot;<br>  @blur=&quot;inputBlurHandler&quot;<br>  @keyboardheightchange=&quot;keyboardHeightHandler&quot;<br>&gt;&lt;/textarea&gt;<br></code></pre></td></tr></table></figure><h2 id="8-h5-页面跳转使用-navigateTo、redirectTo-会失败"><a href="#8-h5-页面跳转使用-navigateTo、redirectTo-会失败" class="headerlink" title="8. h5 页面跳转使用 navigateTo、redirectTo 会失败"></a>8. h5 页面跳转使用 navigateTo、redirectTo 会失败</h2><p>原因：跳转目标带参数且用 customRoute 改写过路径<br>解决方法：？？？基本没有，当时官方说后续版本修复，但实际如果使用这些 API 跳转在 wap 上的效果是创建了一个页面而不是像 spa 的跳转，也就是说如果连续点击跳转、就会创建好几个相同的页面</p><h2 id="9-配置打包环境变量后运行代码报错"><a href="#9-配置打包环境变量后运行代码报错" class="headerlink" title="9. 配置打包环境变量后运行代码报错"></a>9. 配置打包环境变量后运行代码报错</h2><p>原因：环境变量名只设置了双引号，而实际运行时 Taro 会对变量名做解析，所以需要写成如下格式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">env</span>: &#123;<br>    <span class="hljs-attr">NODE_ENV</span>: <span class="hljs-string">&#x27;&quot;development&quot;&#x27;</span>, <span class="hljs-comment">// JSON.stringify(&#x27;development&#x27;)</span><br>    <span class="hljs-attr">TARO_APP_VERSION</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;process.env.TARO_ENV&#125;</span>_<span class="hljs-subst">$&#123;getTimeTag()&#125;</span>`</span>),<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个其实在<a href="https://docs.taro.zone/docs/next/config-detail#env">说明文档</a>里有反映出来，但这不合常规的设置居然一点解释都没有，差评。。。</p><h2 id="10-H5-的-TextArea-设置-autoHeight-为-true-时在数据清空时-TextArea-高度仍然是清空前的高度"><a href="#10-H5-的-TextArea-设置-autoHeight-为-true-时在数据清空时-TextArea-高度仍然是清空前的高度" class="headerlink" title="10. H5 的 TextArea 设置 autoHeight 为 true 时在数据清空时 TextArea 高度仍然是清空前的高度"></a>10. H5 的 TextArea 设置 autoHeight 为 true 时在数据清空时 TextArea 高度仍然是清空前的高度</h2><p>原因：原代码是在输入的时候调整高度，数据清除不触发 input 事件<br>解决方法：监听输入内容，当输入内容为空时手动设置高度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">watch</span>: &#123;<br>    <span class="hljs-title function_">inputValue</span>(<span class="hljs-params">_new</span>) &#123;<br>      <span class="hljs-keyword">if</span> (!_new || _new.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">isH5</span>) &#123;<br>          <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<br>            <span class="hljs-string">&#x27;.textarea .taro-textarea.auto-height&#x27;</span>,<br>          ).<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-string">&#x27;21px&#x27;</span>;<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">isH5</span>) &#123;<br>          <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<br>            <span class="hljs-string">&#x27;.textarea .taro-textarea.auto-height&#x27;</span>,<br>          ).<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-string">&#x27;auto&#x27;</span>;<br>        &#125;<br>      &#125;<br>    &#125;,<br>  &#125;,<br></code></pre></td></tr></table></figure><h2 id="11-onNetworkStatusChange-API-没生效"><a href="#11-onNetworkStatusChange-API-没生效" class="headerlink" title="11. onNetworkStatusChange API 没生效"></a>11. onNetworkStatusChange API 没生效</h2><p>原因：<br>1）其实不是 Taro 的问题，根据<a href="https://blog.51cto.com/u_16175487/6665743">这篇文章</a>，onNetworkStatusChange 方法是通过监听设备的网络状态来判断网络是否可用。在真实的移动设备上，网络状态的变化是由设备的网络模块来控制，并且设备会及时通知应用程序。但是，在自己电脑上测试时，我们通常会使用模拟器或者浏览器来模拟移动设备的环境，这就导致了一些问题，例如模拟器或者浏览器本身没有真实的网络模块，它们无法真实地模拟设备的网络状态变化。<br>2）onNetworkStatusChange 设置的位置不对，最好的是在页面的 onShow，app 的 onShow 也可以</p><h2 id="12-h5-的图片上传请求一直报-500"><a href="#12-h5-的图片上传请求一直报-500" class="headerlink" title="12. h5 的图片上传请求一直报 500"></a>12. h5 的图片上传请求一直报 500</h2><p>原因：似乎是浏览器本身的问题，图片上传的请求头部是<code>&#39;Content-Type&#39;: &#39;multipart/form-data&#39;</code>，但不能在接口中设置这个请求头（axios 例外），Content-Type 需要让浏览器自己识别添加。所以不要使用 Taro.uploadFile，而应该使用 request 函数，大概配置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Taro</span>.<span class="hljs-title function_">request</span>(&#123;<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;imgDomain&#125;</span>/image/upload`</span>,<br>  <span class="hljs-attr">header</span>: &#123;<br>    <span class="hljs-attr">authorization</span>: <span class="hljs-title class_">Taro</span>.<span class="hljs-title function_">getStorageSync</span>(<span class="hljs-string">&quot;access_token&quot;</span>),<br>    <span class="hljs-attr">requestId</span>: <span class="hljs-title function_">getRequestId</span>(),<br>  &#125;,<br>  <span class="hljs-attr">data</span>: file,<br>  <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="13-小程序-requestTask-abort-不生效"><a href="#13-小程序-requestTask-abort-不生效" class="headerlink" title="13. 小程序 requestTask.abort()不生效"></a>13. 小程序 requestTask.abort()不生效</h2><p>原因：不明。看网上说法这个函数是在请求未发出时实现的，无法像 axios 一样直接阻止请求连接？？</p>]]></content>
    
    
    <categories>
      
      <category>踩坑经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Taro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>页面效果实现整理</title>
    <link href="/unknown404.github.io/2024/08/13/pageStyle/"/>
    <url>/unknown404.github.io/2024/08/13/pageStyle/</url>
    
    <content type="html"><![CDATA[<p>随手记一下一些页面效果实现小技巧</p><span id="more"></span><h2 id="打字机效果"><a href="#打字机效果" class="headerlink" title="打字机效果"></a>打字机效果</h2><p>单行文字的实现：主要是靠函数定时调用自身来实现每个文字的显示都存在时间间隔</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> text = <span class="hljs-string">&quot;Welcome to the Typing Effect!&quot;</span>;<br><span class="hljs-keyword">const</span> speed = <span class="hljs-number">100</span>; <span class="hljs-comment">// 打字速度（毫秒）</span><br><br><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">typeWriter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (i &lt; text.<span class="hljs-property">length</span>) &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;typewriter&quot;</span>).<span class="hljs-property">innerHTML</span> += text.<span class="hljs-title function_">charAt</span>(i);<br>    i++;<br>    <span class="hljs-built_in">setTimeout</span>(typeWriter, speed);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 开始打字效果</span><br><span class="hljs-title function_">typeWriter</span>();<br></code></pre></td></tr></table></figure><p>标题轮播打字效果实现：实现点包括打字的定时显示和标题的循环替换，打字的定时显示可以用 for 循环加 await、用定时器控制 Promise 状态完成的时间，等待 Promise 结束后，进入下一次循环，处理下一个字符直到标题字符完成；标题的循环替换也是靠函数定时调用自身来实现，注意在调用自身之前需要考虑标题数组循环到最后一个时的边界条件、以及需要重置展示标题的变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> currentItemIndex = <span class="hljs-number">0</span>,<br>  timer = <span class="hljs-literal">null</span>,<br>  titles = [<span class="hljs-string">&quot;test1&quot;</span>, <span class="hljs-string">&quot;test2&quot;</span>],<br>  currentItem = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">showNextItem</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (currentItemIndex &gt;= titleInfo.<span class="hljs-property">length</span>) currentItemIndex = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 在打印下一项之前重置 currentItem</span><br>  currentItem = <span class="hljs-string">&quot;&quot;</span>;<br><br>  <span class="hljs-comment">// 开始打印下一项</span><br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">typeNextItem</span>();<br><br>  currentItemIndex++;<br>  timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">showNextItem</span>();<br>  &#125;, speed);<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">typeNextItem</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> currentLine = titles[currentItemIndex];<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span>闪烁问题及报错问题解决</span><br>  <span class="hljs-keyword">if</span> (currentLine?.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> charIndex = <span class="hljs-number">0</span>; charIndex &lt; currentLine.<span class="hljs-property">length</span>; charIndex++) &#123;<br>    <span class="hljs-keyword">const</span> currentChar = currentLine[charIndex];<br>    currentItem += currentChar;<br><br>    <span class="hljs-comment">// 使用 Promise 等待打字速度</span><br>    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, typingSpeed));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="浏览器刷新或者关闭时弹的提示弹窗"><a href="#浏览器刷新或者关闭时弹的提示弹窗" class="headerlink" title="浏览器刷新或者关闭时弹的提示弹窗"></a>浏览器刷新或者关闭时弹的提示弹窗</h2><p>当用户尝试刷新、关闭或离开当前页面时，可以使用 beforeunload 事件来触发一个提示弹窗。这种弹窗通常用于警告用户他们可能会丢失未保存的数据，例如在编辑表单或文档时。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;beforeunload&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-comment">// 检查用户是否有未保存的更改或其他需要提醒的条件</span><br>  <span class="hljs-keyword">const</span> shouldWarn = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 假设条件成立</span><br><br>  <span class="hljs-keyword">if</span> (shouldWarn) &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>(); <span class="hljs-comment">// 标准的阻止行为</span><br>    e.<span class="hljs-property">returnValue</span> = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 必须设置为非空值才能触发默认对话框</span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="组件扫光效果"><a href="#组件扫光效果" class="headerlink" title="组件扫光效果"></a>组件扫光效果</h2><p>CSS 扫光动画的原理很简单，就是一条斜向上 45deg 的线性渐变长方形从左到右的、无限循环的位移动画。需要我们创建一个伪元素，然后通过改变伪元素的位移来实现扫光动画了。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@keyframes</span> sweep &#123;<br>  <span class="hljs-number">0%</span> &#123;<br>    <span class="hljs-attribute">visibility</span>: visible;<br>    <span class="hljs-attribute">left</span>: -<span class="hljs-number">100%</span>;<br>  &#125;<br>  <span class="hljs-number">100%</span> &#123;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">visibility</span>: hidden;<br>  &#125;<br>&#125;<br><span class="hljs-selector-class">.sheen-area</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>  &amp;<span class="hljs-selector-pseudo">::after</span> &#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">10%</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">180%</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">70%</span>;<br>    <span class="hljs-attribute">background</span>: linear-gradient(<br>      to bottom,<br>      rgba(<span class="hljs-number">229</span>, <span class="hljs-number">172</span>, <span class="hljs-number">142</span>, <span class="hljs-number">0</span>),<br>      rgba(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0.5</span>) <span class="hljs-number">50%</span>,<br>      rgba(<span class="hljs-number">229</span>, <span class="hljs-number">172</span>, <span class="hljs-number">142</span>, <span class="hljs-number">0</span>)<br>    );<br>    <span class="hljs-attribute">transform</span>: rotate(<span class="hljs-number">60deg</span>);<br>    <span class="hljs-attribute">animation</span>: sweep <span class="hljs-number">1.4s</span> ease-in infinite;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面这段代码里 sheen-area 是容器，设置 overflow: hidden;隐藏扫光超出容器的部分，伪元素作为扫光条执行从左到右的动画。也可以像<a href="https://segmentfault.com/a/1190000045122864">这篇文章</a>一样设计动画</p>]]></content>
    
    
    <categories>
      
      <category>工作技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>JavaScript</tag>
      
      <tag>canvas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工具随记</title>
    <link href="/unknown404.github.io/2024/08/01/toolInfo/"/>
    <url>/unknown404.github.io/2024/08/01/toolInfo/</url>
    
    <content type="html"><![CDATA[<p>随手记一下一些工具小技巧</p><span id="more"></span><h2 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h2><p>（一）接口数据 mock<br>Chrome 117 优化了本地覆盖功能，因此可以在没有访问权限的情况下，通过 Network 面板轻松模拟远程资源的响应头和网页内容。</p><p>要覆盖网页内容，需要打开 Network 面板，右键点击一个请求，然后选择“Override content”。在 DevTools 中会自动定位到 Sources 标签下请求的文件位置，修改后保存刷新即可 mock 成功。</p><p>如果要取消覆盖内容，仍然是 Sources 标签下操作：要暂时禁用覆盖，取消选中 Enable Local Overrides 复选框；要取消全部覆盖，则点击 Enable Local Overrides 选项右侧的 Clear 图标找到修改的文件位置；若取消单个覆盖，则是将修改的文件选中后右键点击，在菜单中选中删除</p><p>（二）手机 ua 模拟</p><h2 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h2><p>（一） 将 Postman 请求转换为 cURL</p><ol><li>打开 Postman 并选择你要转换的请求。</li><li>点击右上角的“Code”按钮（有时显示为 &lt;&#x2F;&gt; 图标）。</li><li>在弹出的窗口中选择“cURL”。</li><li>复制生成的 cURL 命令，可以将其粘贴到终端或命令行中执行。</li></ol><p>（二）读取 cURL 格式的请求</p><ol><li>打开 Postman。</li><li>点击左上角的“Import”按钮。</li><li>选择“Raw text”选项。</li><li>粘贴你的 cURL 命令，然后点击“Continue”。</li><li>点击“Import”按钮，Postman 会自动解析并导入该请求</li></ol><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>（一）定位组件代码<br>npm 安装 click-to-react-component，在 main.tsx 引入：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom/client&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.tsx&#x27;</span><br><span class="hljs-comment">// @ts-ignore</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ClickToComponent</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;click-to-react-component&#x27;</span>;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)!).<span class="hljs-title function_">render</span>(<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">ClickToComponent</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>)<br></code></pre></td></tr></table></figure><p>按住 option + 单击，就会直接打开它的对应的组件的源码；按住 option + 右键单击，可以看到它的所有父级组件</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/7374631918111178790">React 项目里，如何快速定位你的组件源码？</a></p>]]></content>
    
    
    <categories>
      
      <category>工作技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postman</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tailwind</title>
    <link href="/unknown404.github.io/2024/07/08/tailwind/"/>
    <url>/unknown404.github.io/2024/07/08/tailwind/</url>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/7387611028988002314">https://juejin.cn/post/7387611028988002314</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CI/CD初识</title>
    <link href="/unknown404.github.io/2024/04/11/CICD/"/>
    <url>/unknown404.github.io/2024/04/11/CICD/</url>
    
    <content type="html"><![CDATA[<h2 id="CI-x2F-CD-简介"><a href="#CI-x2F-CD-简介" class="headerlink" title="CI&#x2F;CD 简介"></a>CI&#x2F;CD 简介</h2><p>CI 代表持续集成（Continuous Integration），在持续集成中，开发人员通常会将其代码提交到共享存储库，并且在每次提交后，会自动触发一系列的构建、测试和验证流程。</p><p>CD 代表持续交付（Continuous Delivery）和持续部署（Continuous Deployment）。持续交付是指自动化地将软件构建、测试和部署到预生产环境的过程，使得软件可以随时准备好进行发布。而持续部署更进一步，是指将软件构建、测试和部署的过程完全自动化，包括将新代码直接部署到生产环境，以便快速交付新功能和修复 bug。</p><h2 id="常见-CI-x2F-CD-工具"><a href="#常见-CI-x2F-CD-工具" class="headerlink" title="常见 CI&#x2F;CD 工具"></a>常见 CI&#x2F;CD 工具</h2><h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h3><p>该软件提供了一个易于使用的 Web 界面，可以帮助开发团队快速、高效地构建、测试和交付软件。它与各种版本控制系统（如 Git、Subversion）和构建工具（如 Maven、Gradle）无缝集成，可以轻松地配置和管理项目的构建过程。</p><h3 id="gitlab"><a href="#gitlab" class="headerlink" title="gitlab"></a>gitlab</h3><h4 id="gitlab-runner-启动"><a href="#gitlab-runner-启动" class="headerlink" title="gitlab runner 启动"></a>gitlab runner 启动</h4><p>gitlab runner 是一个开源项目，用于运行流水线任务并将结果发送回 GitLab。本质就是一个服务器。</p><p>gitlab-runner 的三种类型：</p><ul><li>共享 Runner（Shared Runner），所有项目可以使用。</li><li>群组 Runner（Group Runner），特定群组里的所有项目和子群组。</li><li>特定 Runner（Specific Runner），用于独立的项目。</li></ul><h5 id="gitlab-runner-安装"><a href="#gitlab-runner-安装" class="headerlink" title="gitlab runner 安装"></a>gitlab runner 安装</h5><p>可以在任意一台 server 安装。首先添加 GitLab 官方源</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -L https:<span class="hljs-regexp">//</span>packages.gitlab.com<span class="hljs-regexp">/install/</span>repositories<span class="hljs-regexp">/runner/gi</span>tlab-ci-multi-runner/script.rpm.sh | sudo bash<br><br>sudo yum install gitlab-ci-multi-runner<br></code></pre></td></tr></table></figure><h5 id="gitlab-runner-注册"><a href="#gitlab-runner-注册" class="headerlink" title="gitlab runner 注册"></a>gitlab runner 注册</h5><p>安装完 gitlab-renner 并成功运行后，我们此时需要将 gitlab 和 gitlab-runner 之间产生关联，所以我们需要注册 runner 到 gitlab</p><p>点击 gitlab 仓库的 setting，选择 CI&#x2F;CD 的选项，runner 一栏可以看到注册 runner 需要的 url 和 token。在执行下列指令时需要把 url 和 token 的参数换成自己 gitlab 仓库的</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">gitlab-runner register \<br><span class="hljs-params">--non-interactive</span> \<br><span class="hljs-params">--executor</span> <span class="hljs-string">&quot;docker&quot;</span> \<br><span class="hljs-params">--docker-image</span> alpine<span class="hljs-function">:latest</span> \<br><span class="hljs-params">--url</span> <span class="hljs-string">&quot;http://gitlab.xxxx.com:9880/&quot;</span> \<br><span class="hljs-params">--registration-token</span> <span class="hljs-string">&quot;i-WPBnBbQtiQDYndpQkc&quot;</span> \<br><span class="hljs-params">--description</span> <span class="hljs-string">&quot;my first nine-runner&quot;</span> \<br><span class="hljs-params">--tag-list</span> <span class="hljs-string">&quot;nine-runner&quot;</span> \<br><span class="hljs-params">--run-untagged</span> \<br><span class="hljs-params">--locked=</span><span class="hljs-string">&quot;false&quot;</span><br></code></pre></td></tr></table></figure><p>成功注册的话我们就可以在 gitlab 的 runner 一栏看到它的基本信息</p><h4 id="gitlab-ci-yml"><a href="#gitlab-ci-yml" class="headerlink" title=".gitlab-ci.yml"></a>.gitlab-ci.yml</h4><p>位于项目代码仓库的根目录下的配置文件，该文件中可以指定代码扫描、构建、测试、部署等几个步骤的一系列的命令或者脚本。<br>以前端项目举例，配置文件最基础的情况也需包括以下几步</p><ul><li>npm install 安装依赖</li><li>npm run build 打包项目</li><li>将生成的 dist 文件打包目录部署</li></ul><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">stages</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">build</span><br><br><span class="hljs-attribute">build</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">stage</span><span class="hljs-punctuation">:</span> <span class="hljs-string">build</span><br>  <span class="hljs-attribute">only</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">test</span><br>  <span class="hljs-attribute">cache</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">key</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cache&quot;</span><br>    <span class="hljs-attribute">paths</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">node_modules/</span><br>  <span class="hljs-attribute">script</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">npm install</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">node publish</span><br>  <span class="hljs-attribute">tags</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">front-end</span><br></code></pre></td></tr></table></figure><p>以上面这个代码为例，这里设置了流水线的阶段只有 build，而任务名 build 就是会在该阶段执行的任务，代码会先后执行指令<code>npm install</code> 和<code>node publish</code>。<br>但实际 devops 设计中，可能不会把构建部署任务放在该文件内，一是为例防止开发人员随便乱改这个文件，二是篇幅过长看着很乱，不易于统一更新维护。</p><p>所以有些 devops 会利用模板拆分优化.gitlab-ci.yml。这时候开发代码根目录下的 .gitlab-ci.yml 文件如下：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sml">variables:<br>  <span class="hljs-type">BUILD_TYPE</span>: <span class="hljs-type">JAVA</span><br><br><span class="hljs-keyword">include</span>:<br>  - project: <span class="hljs-symbol">&#x27;Group1</span>/gitlab-ci-template&#x27;<br>    <span class="hljs-built_in">ref</span>: <span class="hljs-symbol">&#x27;master&#x27;</span><br>    file: <span class="hljs-symbol">&#x27;src</span>/.gitlab-ci-template.yml&#x27;<br></code></pre></td></tr></table></figure><p>我们模板仓库在 Group1 这个组下的 gitlab-ci-template 目录，其中包含一个 src 目录，src 目录下包含一个 .gitlab-ci-template.yml 文件，里面就包含流水线任务配置。<br>这样就可以有效解决上述问题。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://www.infoq.cn/article/WHt0wFMDRrBU-dtkh1Xp/">如何从零开始搭建 CI&#x2F;CD 流水线</a><br>（2）<a href="https://docs.gitlab.com/ee/ci/yaml/#includeproject">gitlab document</a><br>（3）<a href="https://zhuanlan.zhihu.com/p/453140826">Gitlab CI&#x2F;CD 浅谈模板拆分</a><br>（4）<a href="https://cloud.tencent.com/developer/article/1925580">GitLabCI 模板库的流水线优化实践</a><br>（5）<a href="https://juejin.cn/post/7137143919418015751?searchId=20240407153905A10825B44CD86F030868#heading-20">面向个人开发者应该打造的 CICD 部署系统</a></p>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CI/CD</tag>
      
      <tag>运维小知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>腾讯云服务基础操作记录</title>
    <link href="/unknown404.github.io/2024/02/22/k8s/"/>
    <url>/unknown404.github.io/2024/02/22/k8s/</url>
    
    <content type="html"><![CDATA[<p>最近因为项目迁移老要操作腾讯云服务，所以写个总结的文章，梳理一下涉及的知识和操作。说真的前端部署真的应该考虑这些吗？</p><span id="more"></span><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h3><p>Kubernetes（简称 K8s）是一个开源的容器编排平台，用于自动化部署、扩展和管理容器化应用程序。<br>Kubernetes 集群的两种管理角色：Master 和 Node。</p><h4 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h4><p><img src="/unknown404.github.io/img/k8s/structure.jpg"></p><h5 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h5><p>集群的控制节点，每个 Kubernetes 集群需要有一个 master 节点来负责整个集群的管理和控制。包括以下结构</p><ul><li>Kubernetes API Server(kube-apiserver):提供了 HTTP Rest 接口的关键服务进程，是 Kubernetes 里所有资源的增，删，改，查等操作的唯一入口，也是集群控制的入口进程。</li><li>Kubernetes Controller Manager （kube-controller-manager）:Kubernetes 里所有资源对象的自动化控制中心，可以理解为资源对象的“大总管”</li><li>Kubernetes Schedule（kube-scheduler）:负责资源调度（Pod 调度）的进程，相当于公交公司的“调度室”。</li><li>etcd 服务：保存 Kubernetes 里所有资源对象的数据。</li></ul><h5 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h5><p>Kubernetes 集群中真正业务工作负载节点。当某个 Node 宕机后，其上的工作负载会被 Master 自动转移到其他节点上去。</p><ul><li>kubelet:负责 pod 对应的容器的创建，启停等任务。同时与 Master 节点密切协助，实现集群管理的基本功能。</li><li>kube-proxy:实现 Kubernetes service 的通信与负载均衡机制的重要组件。</li><li>Docker Engine（docker）：Docker 引擎，负责本机的容器创建和管理工作。</li></ul><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><ul><li>DNS：Kubernetes 提供了内建的 DNS 服务，用于解析服务名称到 Pod IP 地址，实现服务之间的通信。</li><li>Ingress Controller：可选组件，用于管理集群的入口流量，实现 HTTP 和 HTTPS 等应用层协议的路由和负载均衡。</li><li>Dashboard：可选的 Web UI，用于管理和监控 Kubernetes 集群。</li></ul><h4 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h4><h5 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h5><p>一组紧密关联的容器集合，它们共享 IPC 和 Network namespace，是 Kubernetes 调度的基本单位。在 VMware 的世界中，调度的原子单位是虚拟机（VM）；在 Docker 的 世界中，调度的原⼦单位是容器；⽽在 Kubernetes 的世界中，调度的原子单位是 Pod。每一个 pod 都有一个特殊的被称为“根容器”的 Pause 容器对应的镜像属于 Kubernetes 平台的一部分，除了 Pause 容器，每个 Pod 还包括一个或多个紧密相关的用户业务容器。</p><p>通过与 Master 节点的交互，Pod 可以被创建、调度到适合的节点上运行；而在 Node 节点上，kubelet 负责管理 Pod 的生命周期，而 kube-proxy 则负责处理 Pod 的网络通信。</p><h5 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h5><p>Pod 控制器是 Pod 启动的一种模版，用来保证在 K8S 里启动的 Pod 应始终按照用户的预期运行（副本数、生命周期、健康状态检查等）。之前主要是 Replication Controller 与 Replica Set 来实现，1.2 版本后官方更推荐用 Deployment。</p><p>Deployment 属于无状态应用部署（不会在本地存储持久化数据 ，多个 pod 间是没有关系的）。Deployment 的作用是管理和控制 Pod 和 ReplicaSet，管控它们运行在用户期望的状态中。除 Pod 管理之外，还提供了如扩缩容管理、一键回滚、不停机更新以及版本控制及其他特性。</p><h5 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h5><p>Pod 是非常重要的，但是可能随时会出现故障并销毁。如果通过 Deployment 或者 DaemonSet 对 Pod 进行管理，出现故障的 Pod 会自动被替换。但替换后的新 Pod 会拥有完全不同的 IP 地址。</p><p>Service 就是用来解决这个问题的核心概念，它并不是我们常说的“服务”的含义，而更像是网关层，可以看作一组提供相同服务的 Pod 的对外访问接口、流量均衡器。</p><h5 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h5><p>一个 Label 是一个 key&#x3D;value 的键值对。其中 key 与 value 由用户自己定义。Label 可以附加到各个资源对象上，例如 Node，Pod，Service，RC 等，一个资源对象可以定义任意数量的 Label，同一个 Label 也可以被添加到任意数量的资源对象上去，Label 通常在资源对象定义时确定，也可以在对象创建后动态添加或者删除。</p><p>当给某个资源对象定义一个 Label，就相当于给它打了一个标签，然后可以通过“Label Selector”（标签选择器）查询和筛选拥有某些 Label 的资源对象</p><p>Label Selector 可以用于以下场景：</p><ul><li>kube-controller 进程通过资源对象 RC 上定义的 Label Selector 来筛选要监控的 Pod 副本的数量，从而实现 Pod 副本的数量始终符合预期设定的全自动控制流程。</li><li>kube-proxy 进程通过 Service 的 Label Selector 来选择对应的 Pod，自动建立起每个 Service 到对应 Pod 的请求转发路由表，从而实现 Service 的智能负载均衡机制。</li><li>通过对某些 Node 定义特定的 Label，并且在 Pod 定义文件中使用 NodeSelector 这种标签调度策略，kube-scheduler 进程可以实现‘定向调度’的特性。</li></ul><h3 id="腾讯云-TKE-容器服务"><a href="#腾讯云-TKE-容器服务" class="headerlink" title="腾讯云 TKE 容器服务"></a>腾讯云 TKE 容器服务</h3><p>腾讯云容器服务（Tencent Kubernetes Engine, TKE）基于原生 kubernetes 提供以容器为核心的、高度可扩展的高性能容器管理服务。可以帮助用户轻松地在云上部署、管理和扩展容器化应用程序（大概吧）。</p><p>目前腾讯云列出的可配置的 k8s 属性如下表格所示<br><img src="/unknown404.github.io/img/k8s/k8sObj.jpg"></p><h3 id="腾讯云容器镜像服务"><a href="#腾讯云容器镜像服务" class="headerlink" title="腾讯云容器镜像服务"></a>腾讯云容器镜像服务</h3><p>一种容器镜像云端托管服务。该服务支持 Docker 镜像和 Helm Chart 的存储与分发，以及镜像的安全扫描。它为企业级客户提供了细颗粒度的访问权限管理和网络访问控制，支持镜像的全球同步及触发器，以满足客户拓展全球业务及使用容器 CI&#x2F;CD 工作流的需求。此外，TCR 还支持具有上千节点的大规模容器集群并发拉取 GB 级大镜像，保障业务的极速部署。</p><p>通过使用容器镜像服务，客户无需自建并维护镜像托管服务，即可在云端享受安全高效的镜像托管和分发服务。同时，该服务可以与腾讯云的容器服务 TKE 结合使用，为客户提供顺畅的容器上云体验。</p><h2 id="项目部署迁移操作"><a href="#项目部署迁移操作" class="headerlink" title="项目部署迁移操作"></a>项目部署迁移操作</h2><h3 id="镜像仓库迁移"><a href="#镜像仓库迁移" class="headerlink" title="镜像仓库迁移"></a>镜像仓库迁移</h3><p>公司里每个组都是有自己的命名空间的，所以项目迁移时需要在自己小组的命名空间下新建镜像仓库<br><img src="https://qcloudimg.tencent-cloud.cn/image/document/b95228adfa9046858ad971882c800fe6.png"><br>在部署工具里更新镜像仓库地址，打包镜像</p><h3 id="容器迁移"><a href="#容器迁移" class="headerlink" title="容器迁移"></a>容器迁移</h3><p>进入容器服务页面、选择 Deployment 菜单。在自己小组所属的命名空间下创建新的 deployment。由于部署脚手架利用了 Label 特性，所以表单的 label 一栏要增加项目的 appcode<br><img src="/unknown404.github.io/img/k8s/deployment.jpg"><br>容器一栏容器名可以和 deployment 保持一致；镜像选择自己小组的命名空间下新建的镜像仓库，刚新建好的镜像仓库没有版本，需要提前打包镜像推送到仓库；cpu&#x2F;内存限制可以分环境考虑：</p><ul><li>测试环境 cpu 限制 0.25 核，内存 256</li><li>正式环境 cpu 设置 0.25-0.5，内存 256-512</li></ul><p>核心思想就是测试环境能跑就行，正式环境需要有一定的扩展性。后面实例设置也是如此。<br><img src="/unknown404.github.io/img/k8s/container.jpg"><br>实例数量：等同于 replicas，直接指定 pod 实例数量。测试环境可以手动限制为 1 个，正式环境选择自动调节，实例范围 2-5，触发自动调节策略根据实际情况可以设置多个，例如满足 cpu 使用率高于 50%、内存利用率高于 50%中的一个触发<br><img src="/unknown404.github.io/img/k8s/pod.jpg"><br>镜像访问凭证：针对镜像仓库设置的，在 pod 中指定仓库密钥，默认都配置了 qcloudregistrykey 和 tencenthubkey，如果这个 key 设置错误将导致从镜像仓库拉取私有镜像失败（一般来说之前的人已经设过了，可以看看下拉列表；不确定的时候可以删除这一栏、估计也能跑的原因是腾讯云主账号权限高吧）</p><h3 id="服务迁移"><a href="#服务迁移" class="headerlink" title="服务迁移"></a>服务迁移</h3><p><img src="/unknown404.github.io/img/k8s/service.jpg"><br>服务器访问方式中，仅在集群内访问即设置 ClusterIP 的选项，服务只会在集群内部被访问，一般正式环境使用该配置（因为正式环境代码会部署到两个集群，应该是为了防止单一集群挂掉整个网站不可访问的情况吧）；内网 LB 访问即使用 ip+port 的形式可以访问到</p><p>容器端口：项目启动时的端口，一般如果是 ssr 项目就是指令启动时的端口，如果是 nginx 项目在没大改配置的条件下是 80<br>服务端口：自己随便设的端口，最后服务在集群外可通过负载均衡域名或 IP+服务端口访问服务</p><h3 id="测试服务运行效果"><a href="#测试服务运行效果" class="headerlink" title="测试服务运行效果"></a>测试服务运行效果</h3><p>点击新建的负载，查看 pod 的运行情况，如果没有正常运行，点击 tab “修正历史”查看原因。<br>服务设置为“仅在集群内访问”时，可以通过远程登录 pod 进行测试：点击 tab“Pod 管理“，选择一个 pod 点击远程登录，进入 cmd 界面后执行<code>curl &lt;Kubernetes Service 的域名&gt;:&lt;服务端口&gt;</code>，看返回是否是打包项目的内容<br><img src="https://qcloudimg.tencent-cloud.cn/image/document/4b2622c6b32d982dd29c6b25eb847e10.png"></p><p>服务设置为“内网 LB 访问”时，可以直接在浏览器地址栏输入<code>&lt;负载均衡IP&gt;:&lt;服务端口&gt;</code>看打开的页面是否是打包项目的内容。负载均衡 IP 在点击新建的 Service 名称的“详情”tab 里可以看到</p><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p><strong>Kubernetes Service 的域名</strong>：在 Kubernetes 中，每个 Service 都有一个唯一的域名，该域名遵循以下格式：<code>&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local</code>。其中：</p><ul><li><service-name> 是 Service 的名称。</li><li><namespace> 是 Service 所属的命名空间（Namespace）。</li><li>svc.cluster.local 是 Kubernetes 集群中所有 Service 的域名后缀。</li></ul><p>Kubernetes Service 的域名会映射到该 Service 的 ClusterIP 地址上。当你创建一个 Service 时，Kubernetes 会为该 Service 分配一个 ClusterIP 地址，并为该 Service 自动生成一个域名，其格式为 <code>&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local</code>。这个域名会自动解析到该 Service 的 ClusterIP 地址。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://zhuanlan.zhihu.com/p/618249568">kubernetes 入门看这篇就够了</a><br>（2）<a href="https://blog.csdn.net/wang_dian1/article/details/132045116">【云原生】K8S 超详细概述</a><br>（3）<a href="https://cloud.tencent.com/developer/article/1412208">在 TKE 集群中新建工作负载</a><br>（4）<a href="https://cloud.tencent.com/document/product/457/45598">tke 容器服务</a></p>]]></content>
    
    
    <categories>
      
      <category>备忘录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>前端部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>h5使用canvas绘制海报</title>
    <link href="/unknown404.github.io/2024/02/05/h5poster/"/>
    <url>/unknown404.github.io/2024/02/05/h5poster/</url>
    
    <content type="html"><![CDATA[<p>最近开发 canvas 绘制时发现自己有点忘了绘制规则了，所以贴一下代码做个备份。</p><span id="more"></span><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> bg = <span class="hljs-string">&quot;xxx.png&quot;</span>;<br><span class="hljs-keyword">var</span> qrcode = <span class="hljs-string">&quot;xxxx.png&quot;</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: 海报生成函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; sourceItem 「imgUrl：头图；text（array）；title；」</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; rect 海报宽高值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">*</span>&#125; base64图片</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">drawPoster</span>(<span class="hljs-params"></span><br><span class="hljs-params">  sourceItem,</span><br><span class="hljs-params">  rect = &#123; width: <span class="hljs-number">375</span>, height: <span class="hljs-number">667</span> &#125;</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; imgUrl, text, title, type &#125; = sourceItem;<br>  <span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;canvas&quot;</span>);<br>  <span class="hljs-keyword">var</span> dpr = <span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span> || <span class="hljs-number">1</span>;<br>  canvas.<span class="hljs-property">width</span> = rect.<span class="hljs-property">width</span> * dpr;<br>  canvas.<span class="hljs-property">height</span> = rect.<span class="hljs-property">height</span> * dpr;<br>  <span class="hljs-keyword">const</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&quot;2d&quot;</span>);<br>  ctx.<span class="hljs-title function_">clearRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, canvas.<span class="hljs-property">width</span>, canvas.<span class="hljs-property">height</span>);<br>  <span class="hljs-comment">// 绘制背景图</span><br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">drawPic</span>(ctx, dpr, bg);<br>  <span class="hljs-comment">// 绘制ai图</span><br>  ctx.<span class="hljs-title function_">save</span>();<br>  <span class="hljs-title function_">drawArcFrame</span>(ctx, <span class="hljs-number">64</span> * dpr, <span class="hljs-number">64</span> * dpr, <span class="hljs-number">246</span> * dpr, <span class="hljs-number">376</span> * dpr, <span class="hljs-number">16</span> * dpr);<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">drawPic</span>(<br>    ctx,<br>    dpr,<br>    imgUrl,<br>    &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">64</span> * dpr, <span class="hljs-attr">y</span>: <span class="hljs-number">64</span> * dpr &#125;,<br>    &#123; <span class="hljs-attr">width</span>: <span class="hljs-number">246</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">376</span> &#125;<br>  );<br>  ctx.<span class="hljs-title function_">restore</span>();<br>  <span class="hljs-comment">// 绘制qrcode</span><br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">drawPic</span>(<br>    ctx,<br>    dpr,<br>    qrcode,<br>    &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">239</span> * dpr, <span class="hljs-attr">y</span>: <span class="hljs-number">369</span> * dpr &#125;,<br>    &#123; <span class="hljs-attr">width</span>: <span class="hljs-number">68</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">68</span> &#125;<br>  );<br>  <span class="hljs-comment">// 绘制文字</span><br>  <span class="hljs-keyword">const</span> lineHeight = <span class="hljs-number">25</span> * dpr;<br>  <span class="hljs-keyword">var</span> startY = <span class="hljs-number">467</span> * dpr + lineHeight,<br>    startX = <span class="hljs-number">0</span>;<br>  ctx.<span class="hljs-property">textAlign</span> = <span class="hljs-string">&quot;center&quot;</span>;<br>  <span class="hljs-comment">// 预处理，对每行文字进行折行逻辑处理</span><br>  <span class="hljs-keyword">let</span> lineCount = <span class="hljs-number">4</span>;<br>  <span class="hljs-keyword">let</span> row = [];<br>  ctx.<span class="hljs-property">font</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-number">17</span> * dpr&#125;</span>px PingFangSC, PingFang SC`</span>; <span class="hljs-comment">// 设置字体样式和大小</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; text.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> line = text[i];<br>    <span class="hljs-keyword">let</span> tempText = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> wordIndex = <span class="hljs-number">0</span>; wordIndex &lt; line.<span class="hljs-property">length</span>; wordIndex++) &#123;<br>      <span class="hljs-keyword">if</span> (ctx.<span class="hljs-title function_">measureText</span>(tempText).<span class="hljs-property">width</span> &lt; <span class="hljs-number">200</span> * dpr) &#123;<br>        tempText += line[wordIndex];<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        wordIndex--;<br>        row.<span class="hljs-title function_">push</span>(tempText);<br>        tempText = <span class="hljs-string">&quot;&quot;</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (tempText) row.<span class="hljs-title function_">push</span>(tempText);<br>  &#125;<br>  <span class="hljs-keyword">let</span> totalLineCount = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(row.<span class="hljs-property">length</span>, lineCount);<br>  <span class="hljs-keyword">if</span> (title) &#123;<br>    startX = canvas.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>;<br>    totalLineCount++;<br>    startY = <span class="hljs-number">539</span> * dpr - (lineHeight * totalLineCount) / <span class="hljs-number">2</span> + lineHeight / <span class="hljs-number">2</span>;<br>    <span class="hljs-title function_">drawText</span>(<br>      ctx,<br>      dpr,<br>      title,<br>      &#123; <span class="hljs-attr">x</span>: startX, <span class="hljs-attr">y</span>: startY &#125;,<br>      <span class="hljs-number">17</span>,<br>      <span class="hljs-string">&quot;normal&quot;</span>,<br>      <span class="hljs-string">&quot;#AD2700&quot;</span><br>    );<br>    startY += lineHeight;<br>    totalLineCount--;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    startY = <span class="hljs-number">539</span> * dpr - (lineHeight * totalLineCount) / <span class="hljs-number">2</span> + lineHeight / <span class="hljs-number">2</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(row.<span class="hljs-property">length</span>, lineCount); i++) &#123;<br>    startX = canvas.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>;<br>    <span class="hljs-title function_">drawText</span>(ctx, dpr, row[i], &#123; <span class="hljs-attr">x</span>: startX, <span class="hljs-attr">y</span>: startY &#125;, <span class="hljs-number">17</span>, <span class="hljs-string">&quot;bold&quot;</span>, <span class="hljs-string">&quot;#AD2700&quot;</span>);<br>    startY += lineHeight;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> imageURL = canvas.<span class="hljs-title function_">toDataURL</span>(<span class="hljs-string">&quot;image/png&quot;</span>); <span class="hljs-comment">// 将Canvas转换为PNG格式的图片URL</span><br>  <span class="hljs-keyword">return</span> imageURL;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">drawText</span>(<span class="hljs-params"></span><br><span class="hljs-params">  ctx,</span><br><span class="hljs-params">  dpr = <span class="hljs-number">2</span>,</span><br><span class="hljs-params">  text,</span><br><span class="hljs-params">  position = &#123; x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span> &#125;,</span><br><span class="hljs-params">  fontSize = <span class="hljs-number">30</span>,</span><br><span class="hljs-params">  fontWeight = <span class="hljs-string">&quot;normal&quot;</span>,</span><br><span class="hljs-params">  color = <span class="hljs-string">&quot;red&quot;</span></span><br><span class="hljs-params"></span>) &#123;<br>  ctx.<span class="hljs-property">fillStyle</span> = color;<br>  ctx.<span class="hljs-property">font</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;fontWeight&#125;</span> <span class="hljs-subst">$&#123;fontSize * dpr&#125;</span>px PingFangSC, PingFang SC`</span>; <span class="hljs-comment">// 设置字体样式和大小</span><br>  ctx.<span class="hljs-title function_">fillText</span>(text, position.<span class="hljs-property">x</span>, position.<span class="hljs-property">y</span>); <span class="hljs-comment">// 设置文字位置和内容</span><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">drawPic</span>(<span class="hljs-params"></span><br><span class="hljs-params">  ctx,</span><br><span class="hljs-params">  dpr = <span class="hljs-number">2</span>,</span><br><span class="hljs-params">  imgUrl,</span><br><span class="hljs-params">  position = &#123; x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span> &#125;,</span><br><span class="hljs-params">  rect = &#123; width: <span class="hljs-number">375</span>, height: <span class="hljs-number">667</span> &#125;</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> image = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();<br>    image.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;crossOrigin&quot;</span>, <span class="hljs-string">&quot;anonymous&quot;</span>);<br>    image.<span class="hljs-property">src</span> = imgUrl;<br>    image.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      ctx.<span class="hljs-title function_">drawImage</span>(<br>        image,<br>        position.<span class="hljs-property">x</span>,<br>        position.<span class="hljs-property">y</span>,<br>        rect.<span class="hljs-property">width</span> * dpr,<br>        rect.<span class="hljs-property">height</span> * dpr<br>      );<br>      <span class="hljs-title function_">resolve</span>();<br>    &#125;;<br>  &#125;);<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">drawArcFrame</span>(<span class="hljs-params">ctx, x, y, w, h, r</span>) &#123;<br>  ctx.<span class="hljs-title function_">beginPath</span>();<br>  <span class="hljs-comment">// 因为边缘描边存在锯齿，最好指定使用 transparent 填充</span><br>  ctx.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&quot;transparent&quot;</span>;<br>  <span class="hljs-comment">// 左上角</span><br>  ctx.<span class="hljs-title function_">arc</span>(x + r, y + r, r, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">1.5</span>);<br><br>  <span class="hljs-comment">// border-top</span><br>  ctx.<span class="hljs-title function_">moveTo</span>(x + r, y);<br>  ctx.<span class="hljs-title function_">lineTo</span>(x + w - r, y);<br>  ctx.<span class="hljs-title function_">lineTo</span>(x + w, y + r);<br>  <span class="hljs-comment">// 右上角</span><br>  ctx.<span class="hljs-title function_">arc</span>(x + w - r, y + r, r, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">1.5</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>);<br><br>  <span class="hljs-comment">// border-right</span><br>  ctx.<span class="hljs-title function_">lineTo</span>(x + w, y + h - r);<br>  ctx.<span class="hljs-title function_">lineTo</span>(x + w - r, y + h);<br>  <span class="hljs-comment">// 右下角</span><br>  ctx.<span class="hljs-title function_">arc</span>(x + w - r, y + h - r, r, <span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">0.5</span>);<br><br>  <span class="hljs-comment">// border-bottom</span><br>  ctx.<span class="hljs-title function_">lineTo</span>(x + r, y + h);<br>  ctx.<span class="hljs-title function_">lineTo</span>(x, y + h - r);<br>  <span class="hljs-comment">// 左下角</span><br>  ctx.<span class="hljs-title function_">arc</span>(x + r, y + h - r, r, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">0.5</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>);<br><br>  <span class="hljs-comment">// border-left</span><br>  ctx.<span class="hljs-title function_">lineTo</span>(x, y + r);<br>  ctx.<span class="hljs-title function_">lineTo</span>(x + r, y);<br><br>  <span class="hljs-comment">// 这里是使用 fill 还是 stroke都可以，二选一即可，但是需要与上面对应</span><br>  ctx.<span class="hljs-title function_">fill</span>();<br>  <span class="hljs-comment">// ctx.stroke()</span><br>  ctx.<span class="hljs-title function_">closePath</span>();<br>  <span class="hljs-comment">// 剪切</span><br>  ctx.<span class="hljs-title function_">clip</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>注意点：</p><ul><li>绘制图片属于异步操作，只能等图片加载完才能绘制，如果存在显示于图片之上的文字，必须要让文字的绘制在图片回调函数执行之后发生，不能同步执行</li><li>绘制圆角时，需使用函数 ctx.save()保存之前的绘制内容；圆角的实现本质是对画板进行了剪切、再填充绘制内容实现的，绘制完成后用 ctx.restore()将画板剩余部分恢复</li><li>文字绘制时起始坐标默认是文字的左下而不是左上</li></ul>]]></content>
    
    
    <categories>
      
      <category>备忘录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>canvas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>babel初识</title>
    <link href="/unknown404.github.io/2024/02/04/babel/"/>
    <url>/unknown404.github.io/2024/02/04/babel/</url>
    
    <content type="html"><![CDATA[<p>了解一下 babel 相关配置</p><span id="more"></span><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>babel 最初是用于 es6 转 es5，确保各端浏览器能支持代码逻辑的运行。但现在 babel 作为转译器，还可以实现其他的功能</p><h2 id="babel-作用"><a href="#babel-作用" class="headerlink" title="babel 作用"></a>babel 作用</h2><h3 id="转译-es、typescript、flow-等到目标环境支持的-js"><a href="#转译-es、typescript、flow-等到目标环境支持的-js" class="headerlink" title="转译 es、typescript、flow 等到目标环境支持的 js"></a>转译 es、typescript、flow 等到目标环境支持的 js</h3><p>这个是最常用的功能，用来把代码中的 es 的新的语法、typescript 和 flow 的语法转成基于目标环境支持的语法的实现。并且还可以把目标环境不支持的 api 进行 polyfill。</p><p>babel7 提供了 @babel&#x2F;preset-env 的包，可以指定目标 env 来按需转换，转换更加的精准，产物更小。</p><h3 id="一些特定用途的转换"><a href="#一些特定用途的转换" class="headerlink" title="一些特定用途的转换"></a>一些特定用途的转换</h3><p>比如函数插桩（函数中自动插入一些代码，例如埋点代码）、自动国际化等。</p><h3 id="代码的静态分析"><a href="#代码的静态分析" class="headerlink" title="代码的静态分析"></a>代码的静态分析</h3><p>对代码进行 parse 之后，会生成 AST，通过 AST 能够理解代码结构，除了转换 AST 再打印成目标代码之外，也同样可以用于分析代码的信息，进行一些静态检查。例如：</p><ul><li>linter 工具就是分析 AST 的结构，对代码规范进行检查。</li><li>api 文档自动生成工具，可以提取源码中的注释，然后生成文档。</li><li>…</li></ul><h2 id="babel-配置的方式"><a href="#babel-配置的方式" class="headerlink" title="babel 配置的方式"></a>babel 配置的方式</h2><ul><li>babel.config.json：在项目的根目录（package.json 文件所在的目录）下</li><li>.babelrc.json：在项目的根目录（package.json 文件所在的目录）下</li><li>@babel&#x2F;cli</li></ul><p>三种配置方式的权重排序（由小到大） babel.config.json &lt; .babelrc &lt; programmatic options from @babel&#x2F;cli</p><h2 id="常用-babel-配置"><a href="#常用-babel-配置" class="headerlink" title="常用 babel 配置"></a>常用 babel 配置</h2><p>babel 中插件可配置两个属性——presets 和 plugins，应用顺序是：先 plugin 再 preset，plugin 从左到右，preset 从右到左。</p><h3 id="presets"><a href="#presets" class="headerlink" title="presets"></a>presets</h3><p>一般情况下一个插件用来解决一个语法转译问题，例如@babel&#x2F;plugin-transform-arrow-functions 可以用于箭头函数转为一般函数，@babel&#x2F;plugin-transform-destructuring 则用于将 es6 的解构语法进行转译。而 presets 可以理解为官方预置的 es 的新的语法、typescript 和 flow 的语法转译为目标环境支持语法的插件的集合，省去了我们一个个引入插件的麻烦。<br>babel 官方目前提供的预设包括：</p><ul><li>@babel&#x2F;preset-env (转译 es 6+语法)</li><li>@babel&#x2F;preset-typescript （转译 ts 语法）</li><li>@babel&#x2F;preset-react （转译 react 语法）</li><li>@babel&#x2F;preset-flow （转译 flow 语法）</li></ul><h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><p>常用的插件有：</p><h4 id="babel-x2F-plugin-transform-runtime"><a href="#babel-x2F-plugin-transform-runtime" class="headerlink" title="@babel&#x2F;plugin-transform-runtime"></a>@babel&#x2F;plugin-transform-runtime</h4><p>转译 class 语法时 babel 注入了一些辅助函数的声明，以便语法转换后使用。但如果多个文件都使用了 class 语法，转译时这些辅助函数都会在转换文件里定义，尽管函数功能是相同的<br>plugin-transform-runtime 则是可以将 helper 和 polyfill 都改为从一个统一的地方引入，并且引入的对象和全局变量是完全隔离的</p><h4 id="babel-x2F-plugin-proposal-decorators"><a href="#babel-x2F-plugin-proposal-decorators" class="headerlink" title="@babel&#x2F;plugin-proposal-decorators"></a>@babel&#x2F;plugin-proposal-decorators</h4><p>转译 js 装饰器语法</p><h4 id="babel-plugin-import"><a href="#babel-plugin-import" class="headerlink" title="babel-plugin-import"></a>babel-plugin-import</h4><p>模块化导入插件，可以实现按需引入依赖包模块<br>使用示例：<br>使用指令<code>npm install babel-plugin-import --save-dev</code>安装该依赖后对 babel 配置文件进行如下配置</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123;<br>  plugins: [<br>    [<span class="hljs-string">&quot;import&quot;</span>, &#123;<br>      <span class="hljs-string">&quot;libraryName&quot;</span>: <span class="hljs-string">&quot;antd&quot;</span>, <span class="hljs-regexp">//</span> 指定导入包的名称<br>      <span class="hljs-string">&quot;libraryDirectory&quot;</span>: <span class="hljs-string">&quot;lib&quot;</span>, <span class="hljs-regexp">//</span> 指定模块的存放目录<br>      style: <span class="hljs-string">&quot;css&quot;</span>, <span class="hljs-regexp">//</span> 导入 css 样式<br>    &#125;]<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>不过理论上新版的 antd 和 material-ui 中，默认已支持基于 ES modules 的 tree shaking 功能；而打包工具如：Webpack、Rollup 等在打包层面也支持了 <a href="https://juejin.cn/post/7298966922329554995?searchId=20240206112751FE48D0DEEA2D4405759C">tree shaking</a>，使得我们不需要额外配置 babel-plugin-import 也能实现按需引入</p><h2 id="babel-编译流程"><a href="#babel-编译流程" class="headerlink" title="babel 编译流程"></a>babel 编译流程</h2><p>整体编译流程主要分为三步：</p><ul><li>parse：通过 parser 把源码转成抽象语法树（AST）</li><li>transform：遍历 AST，调用各种 transform 插件对 AST 进行增删改</li><li>generate：把转换后的 AST 打印成目标代码，并生成 sourcemap</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/7049160361173319693?from=search-suggest">一文轻松掌握 babel</a><br>（2）<a href="https://zhuanlan.zhihu.com/p/394783228?utm_id=0">Babel 教程 11：@babel&#x2F;plugin-transform-runtime</a></p>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>babel</tag>
      
      <tag>前端编译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stylex</title>
    <link href="/unknown404.github.io/2024/01/25/stylex/"/>
    <url>/unknown404.github.io/2024/01/25/stylex/</url>
    
    <content type="html"><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>近日，Meta 开源了一款「CSS-in-JS 库」 —— StyleX。这个项目从提出到 Meta 内部使用到最终开源经历了大约 5 年的时间，据说这套解决方案让 facebook 首页样式文件体积减少了至少 80%。</p><h2 id="常见-css-方案"><a href="#常见-css-方案" class="headerlink" title="常见 css 方案"></a>常见 css 方案</h2><h3 id="BEM"><a href="#BEM" class="headerlink" title="BEM"></a>BEM</h3><p>BEM 是一种用于编写 CSS 类名的命名约定，它基于块（block）、元素（element）和修饰符（modifier）的概念。使用 BEM 命名约定，可以更清晰地表达 CSS 类之间的关系，并使代码更易于维护和扩展。<br>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card__header&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 块内的元素 --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card__body&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 块内的元素 --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card__footer card__footer--highlighted&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 块内的元素，并带有修饰符 --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在这个例子中，card 是一个块，它包含了 header、body 和 footer 这些元素。footer 元素还带有一个修饰符 highlighted，表示这个底部元素有一些突出显示的样式。</p><h3 id="CSS-Modules"><a href="#CSS-Modules" class="headerlink" title="CSS Modules"></a>CSS Modules</h3><p>CSS Modules 是一种将 CSS 文件与 JavaScript 模块分离的技术。通过使用 CSS Modules，可以将 CSS 类名限制在模块内部，从而避免全局命名冲突的问题。</p><p>示例：<br>在 webpack 中进行如下配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// webpack.config.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// 其他配置项</span><br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,<br>        <span class="hljs-attr">use</span>: [<span class="hljs-string">&quot;style-loader&quot;</span>, <span class="hljs-string">&quot;css-loader&quot;</span>],<br>      &#125;,<br>    ],<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>将 css 文件引入 js，样式表中的类名将被映射为一个对象，可以通过该对象访问局部化的类名，再在 jsx 或 html 中使用该类名。编译时会自动生成一个唯一的类名，避免全局命名冲突。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;<br>  <span class="hljs-attribute">overflow</span>: scroll;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#f5f7fa</span>;<br>  <span class="hljs-selector-class">.nav</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./styles.less&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">NavBar</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;antd-mobile&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyTask</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;styles.container&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">NavBar</span> <span class="hljs-attr">onBack</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;&#125;&#125; className=&#123;styles.nav&#125;&gt;</span><br><span class="language-xml">        我的任务</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">NavBar</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="原子-css"><a href="#原子-css" class="headerlink" title="原子 css"></a>原子 css</h3><p>原子 CSS 是一种将 CSS 属性分解为最基本的元素的技术。通过使用原子 CSS，可以将复杂的样式表分解为更小的、可重用和可维护的模块。目前这方面的实现有<a href="https://tailwindcss.com/">Tailwind CSS</a>、<a href="https://windicss.org/">Windi CSS</a>等<br>以 Tailwind CSS 为例，它提供了一组预定义的类名，每个类名都代表一个特定的样式属性。通过使用这些类名，可以轻松地创建具有不同样式和布局的组件。<br>示例：在 css 文件引入预设置的文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@tailwind</span> base;<br><span class="hljs-keyword">@tailwind</span> components;<br><span class="hljs-keyword">@tailwind</span> utilities;<br></code></pre></td></tr></table></figure><p>使用预设样式<br><img src="/unknown404.github.io/img/stylex/tailwind.jpg"></p><p>样式解释：</p><ul><li>max-w-7xl: 这个类设置了元素的宽度最大为 7XL 尺寸，其中 7XL 是 Tailwind CSS 的尺寸单位之一。7XL 通常对应于屏幕尺寸的非常大的屏幕。</li><li>mx-auto: 这个类设置元素的左右边距自动，使元素在水平方向上居中。</li><li>text-center: 这个类将文本内容居中对齐。</li><li>py-12: 这个类设置元素的上边距和下边距为 12 个尺寸单位。在 Tailwind CSS 中，py 是“padding-y”的缩写，表示元素的垂直内边距。</li><li>px-4: 这个类设置元素的左外边距和右外边距为 4 个尺寸单位。px 是“padding-x”的缩写，表示元素的水平内边距。</li><li>sm:px-6: 这个类是一个断点特定的类，它只在屏幕尺寸小于或等于小型设备时生效。在这种情况下，它将元素的水平内边距设置为 6 个尺寸单位。</li><li>lg:py-16: 这个类是一个断点特定的类，它只在屏幕尺寸大于或等于大型设备时生效。在这种情况下，它将元素的上边距和下边距设置为 16 个尺寸单位。</li><li>lg:px-8: 这个类也是一个断点特定的类，它只在屏幕尺寸大于或等于大型设备时生效。在这种情况下，它将元素的左外边距和右外边距设置为 8 个尺寸单位。</li></ul><h3 id="CSS-in-JS"><a href="#CSS-in-JS" class="headerlink" title="CSS-in-JS"></a>CSS-in-JS</h3><p>CSS 中的 JavaScript 是一种将 JavaScript 代码嵌入到 CSS 中的方式。通过这种方式，可以在 CSS 中使用 JavaScript 变量、函数和逻辑，以实现更灵活和动态的样式和布局。目前这方面实现的库有<a href="https://styled-components.com/docs/basics">style components</a>、<a href="https://emotion.sh/">Emotion</a>等</p><p>stylex 也属于 CSS-in-JS 库</p><h2 id="stylex-的基本用法"><a href="#stylex-的基本用法" class="headerlink" title="stylex 的基本用法"></a>stylex 的基本用法</h2><p>StyleX 的 API 很少，主要涉及两个常用方法：</p><ul><li>stylex.create，创建样式<br>代码示例如下，使用 stylex.create 函数创建了 4 个命名空间：header，logo，link，txtcenter</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> stylex <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@stylexjs/stylex&quot;</span>;<br><br><span class="hljs-keyword">const</span> styles = stylex.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-attr">header</span>: &#123;<br>    <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&quot;#282c34&quot;</span>,<br>    <span class="hljs-attr">minHeight</span>: <span class="hljs-string">&quot;100vh&quot;</span>,<br>    <span class="hljs-attr">display</span>: <span class="hljs-string">&quot;flex&quot;</span>,<br>    <span class="hljs-attr">flexDirection</span>: <span class="hljs-string">&quot;column&quot;</span>,<br>    <span class="hljs-attr">alignItems</span>: <span class="hljs-string">&quot;center&quot;</span>,<br>    <span class="hljs-attr">justifyContent</span>: <span class="hljs-string">&quot;center&quot;</span>,<br>    <span class="hljs-attr">fontSize</span>: <span class="hljs-string">&quot;calc(10px + 2vmin)&quot;</span>,<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;white&quot;</span>,<br>  &#125;,<br>  <span class="hljs-attr">logo</span>: &#123;<br>    <span class="hljs-attr">height</span>: <span class="hljs-string">&quot;40vmin&quot;</span>,<br>    <span class="hljs-attr">pointerEvents</span>: <span class="hljs-string">&quot;none&quot;</span>,<br>  &#125;,<br>  <span class="hljs-attr">link</span>: &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;#61dafb&quot;</span>,<br>  &#125;,<br>  <span class="hljs-attr">txtcenter</span>: &#123;<br>    <span class="hljs-attr">textAlign</span>: <span class="hljs-string">&quot;center&quot;</span>,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>stylex.props，定义 html 的 props，将 stylex.create 定义的样式应用到 html 上（如果定义的是静态样式，dom 上增加的属性为 class；如果定义的是动态样式，dom 上增加的属性为 style）<br>代码示例如下：</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> &#123;<span class="hljs-attr">...stylex.props</span>(<span class="hljs-attr">styles.txtcenter</span>)&#125;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">header</span> &#123;<span class="hljs-attr">...stylex.props</span>(<span class="hljs-attr">styles.header</span>)&#125;&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;logo&#125;</span> &#123;<span class="hljs-attr">...stylex.props</span>(<span class="hljs-attr">styles.logo</span>)&#125; <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;logo&quot;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">          Edit <span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>src/App.js<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span> and save to reload.</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">a</span></span></span><br><span class="hljs-tag"><span class="language-xml">          &#123;<span class="hljs-attr">...stylex.props</span>(<span class="hljs-attr">styles.link</span>)&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://reactjs.org&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;noopener noreferrer&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        &gt;</span></span><br><span class="language-xml">          Learn React</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>编译后运行的结果如图所示</p><p><img src="/unknown404.github.io/img/stylex/stylex.jpg"><br>可以看到命名空间的样式被拆成了多个类名</p><h2 id="stylex-优势"><a href="#stylex-优势" class="headerlink" title="stylex 优势"></a>stylex 优势</h2><h3 id="文件可扩展"><a href="#文件可扩展" class="headerlink" title="文件可扩展"></a>文件可扩展</h3><p>stylex 减少不必要的 CSS 规则和类名，从而减少最终输出的 CSS 文件大小；即使组件增加，css 大小也不会增加太多</p><p>假设样式设置为：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> logo <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./logo.svg&quot;</span>;<br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> stylex <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@stylexjs/stylex&quot;</span>;<br><br><span class="hljs-keyword">const</span> styles = stylex.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-attr">link</span>: &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;#61dafb&quot;</span>,<br>  &#125;,<br>  <span class="hljs-attr">txt</span>: &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;#61dafb&quot;</span>,<br>  &#125;,<br>&#125;);<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;logo&#125;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;logo&quot;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> &#123;<span class="hljs-attr">...stylex.props</span>(<span class="hljs-attr">styles.txt</span>)&#125;&gt;</span></span><br><span class="language-xml">          Edit <span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>src/App.js<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span> and save to reload.</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">a</span></span></span><br><span class="hljs-tag"><span class="language-xml">          &#123;<span class="hljs-attr">...stylex.props</span>(<span class="hljs-attr">styles.link</span>)&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://reactjs.org&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;noopener noreferrer&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        &gt;</span></span><br><span class="language-xml">          Learn React</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><p><img src="/unknown404.github.io/img/stylex/scaleable.jpg"></p><p>从编译结果可以看到即使命名空间不同，只要样式一致都会赋给相同的类名。这种原子类名的控制粒度确保了即使项目体积增大，样式表的体积也能控制在合理的范围内。</p><h3 id="样式效果可预测"><a href="#样式效果可预测" class="headerlink" title="样式效果可预测"></a>样式效果可预测</h3><p>没有特定的样式优先级问题，最后应用的样式将覆盖先前的样式。这使得样式的应用更加简单和一致。</p><p>假设存在如下 css 文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.blue</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br><span class="hljs-selector-class">.red</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p>以及如下 html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;red blue&quot;</span>&gt;</span>我是什么颜色？<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>最终显示的 p 标签是什么颜色的呢？实际上，样式取决于他们在样式表中定义的顺序，.red 的定义在.blue 后面，所以 p 应该是红色的。而如果 blue 和 red 分别在两个 css 文件里，则 p 标签的颜色取决于样式文件的加载顺序。</p><p>而在 stylex 中样式的优先级只需要考虑 styles.props 中的调用顺序，以最后一个为准。例如在下面的代码中 blue 在 red 后面，所以颜色为 blue</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> stylex <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;stylex&quot;</span>;<br><br><span class="hljs-comment">// 创建样式</span><br><span class="hljs-keyword">const</span> styles = stylex.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-attr">red</span>: &#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;red&quot;</span> &#125;,<br>  <span class="hljs-attr">blue</span>: &#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;blue&quot;</span> &#125;,<br>&#125;);<br><br><span class="hljs-comment">// 使用</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> &#123;<span class="hljs-attr">...styles.props</span>(<span class="hljs-attr">styles.red</span>, <span class="hljs-attr">styles.blue</span>)&#125;&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;<br></code></pre></td></tr></table></figure><h3 id="样式的类型安全"><a href="#样式的类型安全" class="headerlink" title="样式的类型安全"></a>样式的类型安全</h3><p>可以与 typescript 结合、定义类型声明限制自定义组件的样式传参。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> &#123;<span class="hljs-title class_">StyleXStyles</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@stylexjs/stylex&#x27;</span>;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Props</span> = &#123;<br>  <span class="hljs-comment">// ...</span><br>  style?: <span class="hljs-title class_">StyleXStyles</span>&lt;&#123;<br>    color?: <span class="hljs-built_in">string</span>;<br>    backgroundColor?: <span class="hljs-built_in">string</span>;<br>    borderColor?: <span class="hljs-built_in">string</span>;<br>    borderTopColor?: <span class="hljs-built_in">string</span>;<br>    borderEndColor?: <span class="hljs-built_in">string</span>;<br>    borderBottomColor?: <span class="hljs-built_in">string</span>;<br>    borderStartColor?: <span class="hljs-built_in">string</span>;<br>  &#125;&gt;;<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params">&#123;style, ...&#125;: Props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span></span></span><br><span class="hljs-tag"><span class="language-xml">      &#123;<span class="hljs-attr">...stylex.props</span>(<span class="hljs-attr">localStyles.foo</span>, <span class="hljs-attr">localStyles.bar</span>, <span class="hljs-attr">style</span>)&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">    &gt;</span></span><br><span class="language-xml">      &#123;/* ... */&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>例如在这段代码中限制了组件 MyComponent 的 style props 只能接受如下 stylex 样式</p><h2 id="stylex-缺点"><a href="#stylex-缺点" class="headerlink" title="stylex 缺点"></a>stylex 缺点</h2><ul><li>并不提供完整的 css 选择器功能，为了使应用可预测，一些伪类选择器可能并不支持，比如 .className &gt; _、.className ~ _、.className:hover &gt; div:first-child 等</li></ul><h2 id="stylex-适用范围"><a href="#stylex-适用范围" class="headerlink" title="stylex 适用范围"></a>stylex 适用范围</h2><ul><li>用 js 控制 ui 的框架项目如 react，angular 等，vue、svelte 使用的话需要额外的自定义配置</li><li>庞大且体积不断增加的项目</li><li>可复用组件项目</li></ul><h2 id="后续碎碎念"><a href="#后续碎碎念" class="headerlink" title="后续碎碎念"></a>后续碎碎念</h2><p>因为 stylex 提供的 demo 都太简陋了，所以自己尝试用 create-react-app 搭建了一个项目测试它的使用，结果发现居然没有修改打包配置的方法，要想实现还要安装 craco 脚手架，真是麻烦。。。node 版本还必须 16 以上才能运行正常，这个怎么没在文档里写啊。。。话说 create-react-app 这个框架这么封闭、复杂点的需求还要配router和redux、为什么这么多人还喜欢用啊不理解。。。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://stylexjs.com/docs/learn/">Introduction to StyleX</a><br>（2）<a href="https://mp.weixin.qq.com/s/ysFnkHSTSGBn1UIdapZGVg">你了解 JSX，那你了解 StyleX 么？</a></p>]]></content>
    
    
    <categories>
      
      <category>技术分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>监控告警设计</title>
    <link href="/unknown404.github.io/2024/01/17/errorAlert/"/>
    <url>/unknown404.github.io/2024/01/17/errorAlert/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>监控告警是当年接手的第一个 nodejs 需求，本来想在网上搜搜成熟的方案，然而可能是由于自己搜索能力太差了，没有找到合适的方案，于是自己就按照自己的想法写了一个监控告警的方案。现在回看当时的代码还是觉得有点稚嫩，只能说功能实现了，代码确实能跑。但是不是个稳健的代码自己心里一直没数，也不知道怎么写总结文档，所以一直拖到现在才想起来。可能是个糟糕的方案，但涉及的知识点还是值得记录的。</p><h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><ul><li>所有的项目采集到的前端错误都写入了专门的 es 了</li><li>提供 es 增删改查的能力及可视化展示的服务器是用 eggjs 框架搭建的</li><li>前端组有自己的一个 redis 库可供全部成员使用</li></ul><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>每个项目都可以配置多个告警规则（例如 “5min 内 js 报错次数超过 10 次”连续触发了 3 次、“30min 内资源错误影响用户数不超过 100 人”连续触发了 4 次）</li><li>告警规则命中时可以利用飞书机器人发送告警信息</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="告警规则校验"><a href="#告警规则校验" class="headerlink" title="告警规则校验"></a>告警规则校验</h3><p>要实现如 5min 内 js 报错次数超过 10 次的验证，首先需要统计每 5min 内 js 报错次数。考虑到可能会出现某一时间点报错数激增的情况，5min 的时间窗不应该重叠，重叠的话连续触发次数很容易达成。告警太频繁相当于没有作用，所以希望通过连续次数进行限制，确保告警上报的问题是持续存在的，是必须要检查修正的。分析需求后得出结论：</p><ul><li>为了检测连续触发次数，<strong>需要建立一个新表</strong>，用于存储每个项目每个告警规则的设置时间间隔内、设置的错误类型它的报错次数</li><li><strong>新表的数据写入依赖于定时任务</strong>，考虑到不同规则的时间间隔可能设置的不同，定时任务的执行间隔应该为设置时间间隔的最小公约数</li></ul><p>因为前端有现成的 redis 库，所以直接用它来存储每个告警规则的设置时间间隔内、设置的错误类型它的报错次数的数据。eggjs 连接 mongo 库需要 npm 安装模块 egg-mongoose（感谢上帝官方有做这种扩展）。在 config&#x2F;config.default.js 中配置 mongo 连接信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">appInfo</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">const</span> mongoose = &#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">`mongodb://<span class="hljs-subst">$&#123;ip&#125;</span>/`</span>, <span class="hljs-comment">//端口号可以省略</span><br>    <span class="hljs-attr">options</span>: &#123;<br>      <span class="hljs-attr">useNewUrlParser</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">auth</span>: &#123;<br>        <span class="hljs-attr">user</span>: <span class="hljs-string">&quot;username&quot;</span>,<br>        <span class="hljs-attr">password</span>: <span class="hljs-string">&quot;pwd&quot;</span>,<br>      &#125;,<br>    &#125;,<br>    <span class="hljs-attr">plugins</span>: [],<br>    <span class="hljs-attr">loadModel</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">app</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">agent</span>: <span class="hljs-literal">false</span>,<br>  &#125;;<br>  <span class="hljs-keyword">return</span> &#123;<br>    mongoose,<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>之后在 app&#x2F;model&#x2F;alarm.js 中定义新表的模型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 分钟错误日志数记录</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">app</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> mongoose = app.<span class="hljs-property">mongoose</span>;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title class_">Schema</span> = mongoose.<span class="hljs-property">Schema</span>;<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title class_">RecordsSchema</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>(&#123;<br>    <span class="hljs-attr">total</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,<br>    &#125;,<br>    <span class="hljs-attr">timestamp</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,<br>    &#125;,<br>    <span class="hljs-attr">interval</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,<br>    &#125;,<br>    <span class="hljs-attr">projectType</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<br>    &#125;,<br>    <span class="hljs-attr">errorType</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<br>    &#125;,<br>    <span class="hljs-attr">ruleType</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<br>    &#125;,<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&quot;Records&quot;</span>, <span class="hljs-title class_">RecordsSchema</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>之后在 app&#x2F;service&#x2F; 中编写 redis 增删改查功能时，可以直接用 ctx.model.Records 代表表格操作<br>egg-mongoose 提供的函数比较有限，这里只写一下用到的几种：</p><ul><li>insertMany：插入多项数据</li><li>find：查找数据，没有设置条件则查全部</li><li>remove：删除数据</li><li>deleteMany：删除特定条件数据</li></ul><p>eggjs 为约定式目录，所以直接在 app&#x2F;schedule 下新建一个文件夹，然后在该文件夹下新建一个 js 文件，命名为<code>checkAlarm.js</code>，在该文件中编写定时任务。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">schedule</span>: &#123;<br>    <span class="hljs-attr">interval</span>: <span class="hljs-string">&quot;1m&quot;</span>, <span class="hljs-comment">// 1 分钟间隔</span><br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;worker&quot;</span>, <span class="hljs-comment">// 指定的 worker 执行</span><br>  &#125;,<br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">task</span>(<span class="hljs-params">ctx</span>) &#123;<br>    <span class="hljs-comment">// 单个报错规则判定</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">queryErrorRecords</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">rule</span>) =&gt; &#123;<br>      <span class="hljs-keyword">const</span> projectType = rule.<span class="hljs-property">projectType</span>;<br>      <span class="hljs-keyword">const</span> type = rule.<span class="hljs-property">errorType</span>;<br><br>      <span class="hljs-keyword">let</span> endTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();<br>      <span class="hljs-comment">// 如果没有错误数日志，或当前时间与上一次日志记录的时间点大于规定间隔时，向es发起查询</span><br>      <span class="hljs-keyword">if</span> (<br>        record.<span class="hljs-property">length</span> == <span class="hljs-number">0</span> ||<br>        <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(<br>          (endTime - record[record.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>].<span class="hljs-property">timestamp</span>) / (<span class="hljs-number">60</span> * <span class="hljs-number">1000</span>)<br>        ) &gt;= rule.<span class="hljs-property">interval</span><br>      ) &#123;<br>        <span class="hljs-keyword">let</span> startTime = endTime - rule.<span class="hljs-property">interval</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;<br>        <span class="hljs-keyword">const</span> queryBody = &#123;<br>          <span class="hljs-attr">track_total_hits</span>: <span class="hljs-literal">true</span>,<br>          <span class="hljs-attr">query</span>: &#123;<br>            <span class="hljs-attr">bool</span>: &#123;<br>              <span class="hljs-attr">must</span>: [<br>                &#123;<br>                  <span class="hljs-attr">term</span>: &#123;<br>                    <span class="hljs-string">&quot;projectType.keyword&quot;</span>: projectType,<br>                  &#125;,<br>                &#125;,<br>                &#123;<br>                  <span class="hljs-attr">match</span>: &#123;<br>                    type,<br>                  &#125;,<br>                &#125;,<br>              ],<br>              <span class="hljs-attr">filter</span>: [<br>                &#123;<br>                  <span class="hljs-attr">range</span>: &#123;<br>                    <span class="hljs-attr">time</span>: &#123;<br>                      <span class="hljs-attr">gte</span>: startTime,<br>                      <span class="hljs-attr">lte</span>: endTime,<br>                    &#125;,<br>                  &#125;,<br>                &#125;,<br>              ],<br>            &#125;,<br>          &#125;,<br>          <span class="hljs-attr">sort</span>: [<br>            &#123;<br>              <span class="hljs-attr">time</span>: <span class="hljs-string">&quot;asc&quot;</span>,<br>            &#125;,<br>          ],<br>        &#125;;<br>        <span class="hljs-keyword">const</span> body = <span class="hljs-keyword">await</span> ctx.<span class="hljs-property">service</span>.<span class="hljs-property">esClient</span>.<span class="hljs-title function_">search</span>(queryBody);<br>        <span class="hljs-keyword">const</span> &#123;<br>          <span class="hljs-attr">hits</span>: &#123; hits, total &#125;,<br>        &#125; = body;<br>        <span class="hljs-comment">// 分警报类型处理报错</span><br>        newRecords.<span class="hljs-title function_">push</span>(&#123;<br>          <span class="hljs-attr">total</span>: total.<span class="hljs-property">value</span>,<br>          <span class="hljs-attr">timestamp</span>: endTime,<br>          <span class="hljs-attr">interval</span>: rule.<span class="hljs-property">interval</span>,<br>          <span class="hljs-attr">projectType</span>: projectType,<br>          <span class="hljs-attr">errorType</span>: type,<br>          <span class="hljs-attr">ruleType</span>: rule.<span class="hljs-property">ruleType</span>,<br>        &#125;);<br>      &#125;<br>    &#125;;<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;调用定时器回调&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    <span class="hljs-comment">// 获取报警规则</span><br>    <span class="hljs-keyword">let</span> &#123; data, env &#125; = <span class="hljs-keyword">await</span> ctx.<span class="hljs-property">service</span>.<span class="hljs-property">alertRule</span>.<span class="hljs-title function_">getWarning</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;current env:&quot;</span>, env);<br>    <span class="hljs-comment">// 数据格式调整</span><br>    <span class="hljs-keyword">let</span> rules = <span class="hljs-title function_">flattenRuleObj</span>(data);<br>    <span class="hljs-comment">// 获取和报警轮询相关的错误数日志</span><br>    <span class="hljs-keyword">let</span> records = <span class="hljs-keyword">await</span> ctx.<span class="hljs-property">service</span>.<span class="hljs-property">errorRecord</span>.<span class="hljs-title function_">getRecord</span>();<br>    <span class="hljs-keyword">let</span> newRecords = [];<br>    <span class="hljs-keyword">let</span> originalRecords = newRecords.<span class="hljs-title function_">slice</span>();<br><br>    <span class="hljs-keyword">if</span> (rules.<span class="hljs-property">length</span>) &#123;<br>      <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(<br>        rules.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">async</span> (rule, idx) =&gt; &#123;<br>          <span class="hljs-keyword">await</span> <span class="hljs-title function_">queryErrorRecords</span>(rule);<br>        &#125;)<br>      );<br><br>      <span class="hljs-comment">// 减少不必要的数据更改</span><br>      <span class="hljs-keyword">if</span> (newRecords.<span class="hljs-property">length</span> != originalRecords.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">await</span> ctx.<span class="hljs-property">service</span>.<span class="hljs-property">errorRecord</span>.<span class="hljs-title function_">storeRecord</span>(newRecords, env);<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> currentTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>    <span class="hljs-keyword">if</span> (currentTime.<span class="hljs-title function_">getHours</span>() == <span class="hljs-number">2</span> &amp;&amp; currentTime.<span class="hljs-title function_">getMinutes</span>() == <span class="hljs-number">10</span>) &#123;<br>      <span class="hljs-keyword">await</span> ctx.<span class="hljs-property">service</span>.<span class="hljs-property">errorRecord</span>.<span class="hljs-title function_">clearRecord</span>(<br>        currentTime.<span class="hljs-title function_">getTime</span>() - <span class="hljs-number">2</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>,<br>        env<br>      );<br>    &#125;<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>为简化方便展示，这里只展示了部分代码。定时任务启动后，首先查询报警规则，有报警规则设置时针对每一个报警规则进行数据处理（queryErrorRecords）：</p><ul><li>用 ctx.service.errorRecord.getRecord 获取当前报警规则下时间间隔的报错数统计结果</li><li>当前定时任务时间点与上一条记录时间点进行对比，如果大于等于设定的时间点，则向 es 进行时间间隔内特定错误的报错数查询，并将新的查询数与之前的时间间隔的报错数数据一起传给 mongo，更新表格</li><li>为防止表格数据越来越多，每天凌晨 2 点 10 分定时清除 2 点之前的数据</li></ul><p>关于为什么用 ctx.service.errorRecord.getRecord 做了全查，是因为告警规则有连续触发次数的设置，同时告警规则的时间间隔是可变动的，所以不好设置查询范围；另一方面要对所有的报警规则都做一次筛选查询感觉对请求接口压力比较大，做一次全查然后在 queryErrorRecords 做筛选处理感觉更合理。</p><h3 id="告警规则触发"><a href="#告警规则触发" class="headerlink" title="告警规则触发"></a>告警规则触发</h3><p>这里只以”5min 内 js 报错次数超过 10 次”连续触发了 3 次 的规则为例进行描述</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (relevantRecord.<span class="hljs-property">length</span> &gt;= rule.<span class="hljs-property">count</span> - <span class="hljs-number">1</span> &amp;&amp; total.<span class="hljs-property">value</span> &gt;= rule.<span class="hljs-property">limitValue</span>) &#123;<br>  <span class="hljs-comment">// 判断是否符合规则</span><br>  <span class="hljs-comment">// 判别规则1:警报设置连续次数是1时判断本次轮询报错数超过阈值</span><br>  <span class="hljs-comment">// 判别规则2:警报设置连续次数大于1时判断最近几条轮询报错数是否超过阈值</span><br>  <span class="hljs-comment">// 规则2情况下需要考虑关闭警报一段时间重新开启的情况，判断中应该对relevantRecord里的时间戳做检查</span><br>  <span class="hljs-keyword">const</span> timeRange = rule.<span class="hljs-property">count</span> * rule.<span class="hljs-property">interval</span>;<br>  <span class="hljs-keyword">const</span> isHitRule =<br>    (relevantRecord.<span class="hljs-property">length</span> == <span class="hljs-number">0</span> &amp;&amp; rule.<span class="hljs-property">count</span> == <span class="hljs-number">1</span>) ||<br>    relevantRecord<br>      .<span class="hljs-title function_">slice</span>(relevantRecord.<span class="hljs-property">length</span> - rule.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>, relevantRecord.<span class="hljs-property">length</span>)<br>      .<span class="hljs-title function_">every</span>(<br>        <span class="hljs-function">(<span class="hljs-params">item, i</span>) =&gt;</span><br>          item.<span class="hljs-property">total</span> &gt;= rule.<span class="hljs-property">limitValue</span> &amp;&amp;<br>          endTime - item.<span class="hljs-property">timestamp</span> &lt; (timeRange + <span class="hljs-number">1</span>) * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span><br>      );<br>  <span class="hljs-comment">// 符合规则且设置了webhook时发送警报</span><br>  <span class="hljs-keyword">if</span> (isHitRule &amp;&amp; rule.<span class="hljs-property">webhook</span>) &#123;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> ctx.<span class="hljs-property">service</span>.<span class="hljs-property">robot</span>.<span class="hljs-title function_">sendSettingMessage</span>(&#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;rich-text&quot;</span>,<br>      <span class="hljs-attr">webhook</span>: rule.<span class="hljs-property">webhook</span>,<br>      <span class="hljs-attr">msgBody</span>: &#123;<br>        <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;监控报警通知&quot;</span>,<br>        <span class="hljs-attr">firstLine</span>: <span class="hljs-string">`项目<span class="hljs-subst">$&#123;projectType&#125;</span>在<span class="hljs-subst">$&#123;</span></span><br><span class="hljs-subst"><span class="hljs-string">          rule.interval</span></span><br><span class="hljs-subst"><span class="hljs-string">        &#125;</span>min间隔，发生<span class="hljs-subst">$&#123;printErrorName(type)&#125;</span>，错误数超过阈值<span class="hljs-subst">$&#123;</span></span><br><span class="hljs-subst"><span class="hljs-string">          rule.limitValue</span></span><br><span class="hljs-subst"><span class="hljs-string">        &#125;</span>，连续<span class="hljs-subst">$&#123;rule.count&#125;</span>次`</span>,<br>        <span class="hljs-attr">secondLine</span>: <span class="hljs-string">&quot;请点击&quot;</span>,<br>        <span class="hljs-attr">link</span>: <span class="hljs-string">`http://<span class="hljs-subst">$&#123;MainDomain(env)&#125;</span>/#/list/<span class="hljs-subst">$&#123;type&#125;</span>`</span>,<br>      &#125;,<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 relevantRecord 就表示与告警规则相关的数据。当本次定时任务发现命中告警规则的时间间隔和错误数时，开始判断规则连续次数是否符合条件（连续次数为 1 直接可以告警）。用于判断的变量是 isHitRule，其逻辑如下：</p><ol><li>连续次数为 1，符合告警条件</li><li>连续次数大于 1，判断最近几条记录的错误数是否都大于阈值（需滤除关闭告警的时间段带来的误差）<br>飞书告警具体实现可以参考之前的文章</li></ol><h3 id="部署优化"><a href="#部署优化" class="headerlink" title="部署优化"></a>部署优化</h3><p>将该定时任务写好后部署到服务器上，发现有时候告警会连续报两次。经过排查后发现部署上的是一个服务器集群，共 6 个服务器，有两个执行的时间太过接近、所以当一个服务器还未传新的数据时另一个服务器也认为符合判定执行了查询、判断、告警，就导致了两次，其他时候的服务器由于读到了之前服务器推入的数据，因此不命中我的时间间隔判断条件<br>之前本来是希望参考<a href="https://blog.csdn.net/qq_24884955/article/details/82856230">这篇文章</a>设置一个服务器运行该定时任务，但是 hostname 的 hash 码太乱了，且每次上线都更新一次，没什么用</p><p>最终采用的是利用 redis 实现分布式锁的方法。分布式锁是一种在分布式系统中实现资源互斥访问机制。在多个进程或多台机器同时操作一些资源时，redis 生成一个限时的 key，使用 Redis 的 expire 特征，所以最终当用户需要释放资源时，释放 key。</p><p>事务锁的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBLock</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">ctx</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_uuid</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">uuid</span>(); <span class="hljs-comment">// 分布式节点的uuid</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">_uuid</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">Lock</span> = ctx.<span class="hljs-property">model</span>.<span class="hljs-property">Lock</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 基于时间戳生成的uuid</span><br>  <span class="hljs-title function_">uuid</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> d = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&quot;</span>.<span class="hljs-title function_">replace</span>(<br>      <span class="hljs-regexp">/[xy]/g</span>,<br>      <span class="hljs-keyword">function</span> (<span class="hljs-params">c</span>) &#123;<br>        <span class="hljs-keyword">var</span> r = (d + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">16</span>) % <span class="hljs-number">16</span> | <span class="hljs-number">0</span>;<br>        d = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(d / <span class="hljs-number">16</span>);<br>        <span class="hljs-keyword">return</span> (c === <span class="hljs-string">&quot;x&quot;</span> ? r : (r &amp; <span class="hljs-number">0x3</span>) | <span class="hljs-number">0x8</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>);<br>      &#125;<br>    );<br>  &#125;<br><br>  <span class="hljs-comment">// 获取一次锁</span><br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">acquire</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">Lock</span>.<span class="hljs-title function_">create</span>(&#123;<br>        <span class="hljs-attr">_id</span>: name,<br>        <span class="hljs-attr">acquirer</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">_uuid</span>,<br>        <span class="hljs-attr">acquiredAt</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),<br>        <span class="hljs-attr">updatedAt</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),<br>      &#125;);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;error:&quot;</span> + e);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 获取锁, 每5s重试一次</span><br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">lock</span>(<span class="hljs-params">name, retryInterval = <span class="hljs-number">5000</span></span>) &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">acquire</span>(name)) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sleep</span>(retryInterval);<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 解锁</span><br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">unlock</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;unlock&quot;</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">Lock</span>.<span class="hljs-title function_">deleteMany</span>(&#123; <span class="hljs-attr">_id</span>: name, <span class="hljs-attr">acquirer</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">_uuid</span> &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">// 续期</span><br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">renew</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">Lock</span>.<span class="hljs-title function_">updateOne</span>(<br>      &#123; <span class="hljs-attr">_id</span>: name, <span class="hljs-attr">acquirer</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">_uuid</span> &#125;,<br>      &#123;<br>        <span class="hljs-attr">updatedAt</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),<br>      &#125;<br>    );<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;renew&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 睡眠</span><br>  <span class="hljs-title function_">sleep</span>(<span class="hljs-params">ms</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, ms));<br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">DBLock</span>;<br></code></pre></td></tr></table></figure><p>事务锁主要涉及的操作：</p><ul><li>uuid：唯一标识符生成，是为了解决错误删除其他线程的锁的问题，线程在删除锁的时候，用自己的 uuid 与 Redis 中锁的 uuid 进行比较，如果是自己的锁就进行删除，不是则不删除</li><li>lock：循环获取锁数据，如果获取到则跳出循环，否则等待 5s 后重试。锁数据生成：利用 Redis 的 setNx 命令在 Redis 数据库中创建一个&lt;Key，Value&gt;记录，这条命令只有当 Redis 中没有这个 Key 的时候才执行成功，当已经有这个 Key 的时候会返回失败</li><li>unlock：删除锁数据</li><li>renew：更新锁数据，延长锁的过期时间；主要用于由于业务执行时间长，最终可能导致在业务执行过程中，自己的锁超时，然后锁自动释放了</li></ul><p>在定时任务里的使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">schedule</span>: &#123;<br>    <span class="hljs-attr">interval</span>: <span class="hljs-string">&quot;1m&quot;</span>, <span class="hljs-comment">// 1 分钟间隔</span><br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;worker&quot;</span>, <span class="hljs-comment">// 指定的 worker 执行</span><br>  &#125;,<br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">task</span>(<span class="hljs-params">ctx</span>) &#123;<br>    <span class="hljs-comment">// 。。。</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;调用定时器回调&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    <span class="hljs-comment">// 获取报警规则</span><br>    <span class="hljs-keyword">let</span> &#123; data, env &#125; = <span class="hljs-keyword">await</span> ctx.<span class="hljs-property">service</span>.<span class="hljs-property">alertRule</span>.<span class="hljs-title function_">getWarning</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;current env:&quot;</span>, env);<br>    <span class="hljs-comment">// 数据格式调整</span><br>    <span class="hljs-keyword">let</span> rules = <span class="hljs-title function_">flattenRuleObj</span>(data);<br>    <span class="hljs-comment">// 获取和报警轮询相关的错误数日志</span><br>    <span class="hljs-keyword">let</span> records = <span class="hljs-keyword">await</span> ctx.<span class="hljs-property">service</span>.<span class="hljs-property">errorRecord</span>.<span class="hljs-title function_">getRecord</span>();<br>    <span class="hljs-keyword">let</span> newRecords = [];<br>    <span class="hljs-keyword">let</span> originalRecords = newRecords.<span class="hljs-title function_">slice</span>();<br><br>    <span class="hljs-keyword">if</span> (rules.<span class="hljs-property">length</span>) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">await</span> dblock.<span class="hljs-title function_">lock</span>(<span class="hljs-string">&quot;send_errcount&quot;</span>);<br>        <span class="hljs-keyword">if</span> (rules.<span class="hljs-property">length</span>) &#123;<br>          <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(<br>            rules.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">async</span> (rule, idx) =&gt; &#123;<br>              <span class="hljs-keyword">await</span> <span class="hljs-title function_">queryErrorRecords</span>(rule);<br>            &#125;)<br>          );<br><br>          <span class="hljs-comment">// 减少不必要的数据更改</span><br>          <span class="hljs-keyword">if</span> (newRecords.<span class="hljs-property">length</span> != originalRecords.<span class="hljs-property">length</span>) &#123;<br>            <span class="hljs-keyword">await</span> ctx.<span class="hljs-property">service</span>.<span class="hljs-property">errorRecord</span>.<span class="hljs-title function_">storeRecord</span>(newRecords, env);<br>          &#125;<br>        &#125;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">await</span> dblock.<span class="hljs-title function_">unlock</span>(<span class="hljs-string">&quot;send_errcount&quot;</span>);<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> currentTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>    <span class="hljs-keyword">if</span> (currentTime.<span class="hljs-title function_">getHours</span>() == <span class="hljs-number">2</span> &amp;&amp; currentTime.<span class="hljs-title function_">getMinutes</span>() == <span class="hljs-number">10</span>) &#123;<br>      <span class="hljs-keyword">await</span> ctx.<span class="hljs-property">service</span>.<span class="hljs-property">errorRecord</span>.<span class="hljs-title function_">clearRecord</span>(<br>        currentTime.<span class="hljs-title function_">getTime</span>() - <span class="hljs-number">2</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>,<br>        env<br>      );<br>    &#125;<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>在告警规则校验和告警规则触发的操作的之前设置锁，所有操作结束后解锁。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://blog.csdn.net/qq_24884955/article/details/82856230">egg 服务器集群情况下的定时任务执行操作（2 种方式）</a><br>（2）<a href="https://juejin.cn/post/7239058077273620536?searchId=2024011811013604AA57490988668AB93E">图解 Redis 和 Zookeeper 分布式锁 | 京东云技术团队</a></p>]]></content>
    
    
    <categories>
      
      <category>工作技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端监控</tag>
      
      <tag>redis</tag>
      
      <tag>eggjs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react-query状态管理</title>
    <link href="/unknown404.github.io/2023/11/09/react-query/"/>
    <url>/unknown404.github.io/2023/11/09/react-query/</url>
    
    <content type="html"><![CDATA[<p>起因是在阅读<a href="https://github.com/alan2207/bulletproof-react">某 react 项目</a>时看到作者提出的项目状态管理的规则，觉得很有意思；对于平常使用 redux 一把梭的人来说，他说的这个技术方案太过陌生，所以想随手记一下。</p><span id="more"></span><h2 id="状态管理方针"><a href="#状态管理方针" class="headerlink" title="状态管理方针"></a>状态管理方针</h2><p>以下是项目作者提出的状态管理的简要概述</p><h3 id="组件状态"><a href="#组件状态" class="headerlink" title="组件状态"></a>组件状态</h3><p>对于只有当前组件才用的状态可以直接用 react 的钩子函数</p><ul><li>useState</li><li>useReducer</li></ul><h3 id="应用状态"><a href="#应用状态" class="headerlink" title="应用状态"></a>应用状态</h3><p>应用状态指在交互时发生值的改变、以控制应用的状态的这种变量，例如弹出弹窗、提示语、夜间模式等。可以使用以下方式管理</p><ul><li>context</li><li>redux<br>以及其他看起来功能很类似的库</li></ul><h3 id="表格状态"><a href="#表格状态" class="headerlink" title="表格状态"></a>表格状态</h3><p>填写表单时的数据管理，有专门的解决方案</p><ul><li>React Hook Form</li><li>Formik</li><li>React Final Form</li></ul><h3 id="服务端数据管理"><a href="#服务端数据管理" class="headerlink" title="服务端数据管理"></a>服务端数据管理</h3><p>从服务器请求得到的数据，有时需要存储起来方便后续修改等操作。可以使用以下方案</p><ul><li>react-query</li><li>swr</li><li>apollo client</li><li>urql</li></ul><p>本文这次只记录 react-query 的使用方法</p><h2 id="react-query"><a href="#react-query" class="headerlink" title="react-query"></a>react-query</h2><h3 id="使用场景举例"><a href="#使用场景举例" class="headerlink" title="使用场景举例"></a>使用场景举例</h3><p>一般来说，如果一个页面要展示请求内容，需要以下代码来实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [data, updateData] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">const</span> [isError, setError] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">const</span> [isLoading, setLoading] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-title function_">setError</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/user&#x27;</span>);<br>      <span class="hljs-title function_">updateData</span>(data);<br>    &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>      <span class="hljs-title function_">setError</span>(<span class="hljs-literal">true</span>);<br>    &#125;<br>    <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">false</span>);<br>  &#125;, [])<br><br>  <span class="hljs-comment">// 处理data</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到至少需要 3 个 state，存储数据的 data、请求加载态的 isLoading 和请求失败的 isError。如果页面涉及多个请求，这样的 state 设置还要重复好多次。<br>如果使用 react-query 实现，则代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><br><span class="hljs-keyword">import</span> &#123; useQuery &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-query&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123;data, isLoading, isError&#125; = <span class="hljs-title function_">useQuery</span>(<span class="hljs-string">&#x27;userData&#x27;</span>, <span class="hljs-function">() =&gt;</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/user&#x27;</span>));<br><br>  <span class="hljs-keyword">if</span> (isLoading) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>loading<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">      &#123;data.map(user =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;user.id&#125;</span>&gt;</span>&#123;user.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>)&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到可以省去中间态的 state 设置，除此之外 react-query 还可以实现这些功能：</p><ul><li>多个组件请求同一个 query 时只发出一个请求</li><li>缓存数据失效&#x2F;更新策略（判断缓存合适失效，失效后自动请求数据）</li><li>对失效数据垃圾清理</li></ul><p>如何实现将在接下来的使用介绍里展开</p><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p>根据 react-query v4 的说明文档，可以在 App.tsx 文件做如下配置</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">QueryClientProvider</span>, <span class="hljs-title class_">ReactQueryProviderConfig</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-query&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">queryConfig</span>: <span class="hljs-title class_">ReactQueryProviderConfig</span> = &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * refetchOnWindowFocus 窗口获得焦点时重新获取数据</span><br><span class="hljs-comment">   * staleTime 过多久重新获取服务端数据</span><br><span class="hljs-comment">   * cacheTime 数据缓存时间 默认是 5 * 60 * 1000 5分钟</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">queries</span>: &#123;<br>    <span class="hljs-attr">refetchOnWindowFocus</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">staleTime</span>: <span class="hljs-number">5</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>,<br>    <span class="hljs-attr">retry</span>: <span class="hljs-number">0</span><br>  &#125;,<br>&#125;;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">QueryClientProvider</span> <span class="hljs-attr">client</span>=<span class="hljs-string">&#123;new</span> <span class="hljs-attr">QueryClient</span>(&#123; <span class="hljs-attr">defaultOptions:</span> <span class="hljs-attr">queryConfig</span> &#125;)&#125;&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">QueryClientProvider</span>&gt;</span></span><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>  );<br><br></code></pre></td></tr></table></figure><p>QueryClient 是可以与缓存交互的实例，其他组件如果想要获取这个实例可以用 useQueryClient 函数实现。<br>QueryClient 实例可配置的参数包括：</p><div class="note note-info">            <p><strong>staleTime</strong> 重新获取数据的时间间隔 默认 0<br><strong>cacheTime</strong> 数据缓存时间<br><strong>retry</strong> 失败重试次数 默认 3 次<br><strong>refetchOnWindowFocus</strong> 窗口重新获得焦点时重新获取数据 默认 false<br><strong>refetchOnReconnect</strong> 网络重新链接<br><strong>refetchOnMount</strong> 实例重新挂载<br><strong>enabled</strong> 如果为“false”的化，“useQuery”不会触发</p>          </div><p>这些参数也可以在钩子函数里配置</p><p>react-query 常用的钩子函数有两个：useQuery 和 useMutation，用于应对常见的数据操作</p><h3 id="useQuery（数据查询）"><a href="#useQuery（数据查询）" class="headerlink" title="useQuery（数据查询）"></a>useQuery（数据查询）</h3><h4 id="书写规范"><a href="#书写规范" class="headerlink" title="书写规范"></a>书写规范</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useQuery &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-query&quot;</span>;<br><span class="hljs-comment">// v3写法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> info = <span class="hljs-title function_">useQuery</span>(<span class="hljs-string">&quot;todos&quot;</span>, fetchTodoList);<br>&#125;<br><span class="hljs-comment">// v4+写法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> info = <span class="hljs-title function_">useQuery</span>(&#123; <span class="hljs-attr">queryKey</span>: [<span class="hljs-string">&quot;todos&quot;</span>], <span class="hljs-attr">queryFn</span>: fetchTodoList &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="入参出参"><a href="#入参出参" class="headerlink" title="入参出参"></a>入参出参</h4><p>queryKey 可以都是字符串数组，也可以是 object 元素<br>queryFn 可以自动接收到 queryKey 的值，通常会返回 promise 值；如果考虑请求出错、返回 rejected 状态的情况的话，queryFn 的内部需要考虑做抛出错误的处理，以 fetch 请求为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">useQuery</span>(&#123;<br>  <span class="hljs-attr">queryKey</span>: [<span class="hljs-string">&quot;todos&quot;</span>, todoId],<br>  <span class="hljs-attr">queryFn</span>: <span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/todos/&quot;</span> + todoId);<br>    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Network response was not ok&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>当 queryKey 的内容发生变动时 queryFn 的内容就会自动执行<br>useQuery 返回的内容包括：</p><div class="note note-info">            <p><strong>isLoading</strong>：请求是否在加载数据<br><strong>isError</strong>：请求是否报错<br><strong>isFetching</strong>：是否有一个挂起的请求，适用于无限滚动<br><strong>data</strong>：请求返回数据</p>          </div><h3 id="useMutation（数据增删改）"><a href="#useMutation（数据增删改）" class="headerlink" title="useMutation（数据增删改）"></a>useMutation（数据增删改）</h3><p>该函数钩子通常用于有副作用的场景。</p><h4 id="书写规范-1"><a href="#书写规范-1" class="headerlink" title="书写规范"></a>书写规范</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useQuery &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-query&quot;</span>;<br><span class="hljs-comment">// v3写法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [mutate] = <span class="hljs-title function_">useMutation</span>(<span class="hljs-function">(<span class="hljs-params">newTodo</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/todos&quot;</span>, newTodo);<br>  &#125;);<br>&#125;<br><span class="hljs-comment">// v4+写法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> mutation = <span class="hljs-title function_">useMutation</span>(&#123;<br>    <span class="hljs-attr">mutationFn</span>: <span class="hljs-function">(<span class="hljs-params">newTodo</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/todos&quot;</span>, newTodo);<br>    &#125;,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="入参出参-1"><a href="#入参出参-1" class="headerlink" title="入参出参"></a>入参出参</h4><p>常用的入参包括：</p><div class="note note-info">            <p><strong>mutationFn</strong>：用于处理请求的函数，返回 promise 对象<br><strong>onMutate</strong>：请求触发、将要执行前触发的回调函数<br><strong>onError</strong>：请求失败时触发的回调函数<br><strong>onSuccess</strong>：请求失败时触发的回调函数<br><strong>onSettled</strong>：请求完成时触发的回调函数，不管成功与否；执行时机在 onSuccess 和 onError 之后</p>          </div><p>除此以外也可以配置请求操作相关的一些配置，例如重试、重试延迟等<br>返回的内容主要包括：</p><div class="note note-info">            <p><strong>mutate</strong>：在代码中运行突变的操作，接受的入参包括 mutationFn 的入参和 onSuccess、onError、onSettled<br><strong>isPending</strong>：请求是否在加载数据<br><strong>isError</strong>：请求是否报错</p>          </div><p>涉及增删改的操作可以使用乐观更新来减少等待加载的时间，让用户体验更好。所谓乐观更新、就是前端默认后端接口请求一定会成功、提前将修改结果展示出来。<br>以下面这段代码为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useDeleteDiscussion</span> = (<span class="hljs-params">&#123; config &#125;: UseDeleteDiscussionOptions = &#123;&#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> &#123; addNotification &#125; = <span class="hljs-title function_">useNotificationStore</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">useMutation</span>(&#123;<br>    <span class="hljs-attr">onMutate</span>: <span class="hljs-keyword">async</span> (deletedDiscussion) =&gt; &#123;<br>      <span class="hljs-keyword">await</span> queryClient.<span class="hljs-title function_">cancelQueries</span>(<span class="hljs-string">&#x27;discussions&#x27;</span>);<br><br>      <span class="hljs-keyword">const</span> previousDiscussions = queryClient.<span class="hljs-property">getQueryData</span>&lt;<span class="hljs-title class_">Discussion</span>[]&gt;(<span class="hljs-string">&#x27;discussions&#x27;</span>);<br><br>      queryClient.<span class="hljs-title function_">setQueryData</span>(<br>        <span class="hljs-string">&#x27;discussions&#x27;</span>,<br>        previousDiscussions?.<span class="hljs-title function_">filter</span>(<br>          <span class="hljs-function">(<span class="hljs-params">discussion</span>) =&gt;</span> discussion.<span class="hljs-property">id</span> !== deletedDiscussion.<span class="hljs-property">discussionId</span><br>        )<br>      );<br><br>      <span class="hljs-keyword">return</span> &#123; previousDiscussions &#125;;<br>    &#125;,<br>    <span class="hljs-attr">onError</span>: <span class="hljs-function">(<span class="hljs-params">_, __, context: any</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (context?.<span class="hljs-property">previousDiscussions</span>) &#123;<br>        queryClient.<span class="hljs-title function_">setQueryData</span>(<span class="hljs-string">&#x27;discussions&#x27;</span>, context.<span class="hljs-property">previousDiscussions</span>);<br>      &#125;<br>    &#125;,<br>    <span class="hljs-attr">onSuccess</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      queryClient.<span class="hljs-title function_">invalidateQueries</span>(<span class="hljs-string">&#x27;discussions&#x27;</span>);<br>      <span class="hljs-title function_">addNotification</span>(&#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;success&#x27;</span>,<br>        <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Discussion Deleted&#x27;</span>,<br>      &#125;);<br>    &#125;,<br>    ...config,<br>    <span class="hljs-attr">mutationFn</span>: <span class="hljs-function">(<span class="hljs-params">&#123; discussionId &#125;: &#123; discussionId: string &#125;</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> axios.<span class="hljs-title function_">delete</span>(<span class="hljs-string">`/discussions/<span class="hljs-subst">$&#123;discussionId&#125;</span>`</span>);<br>    &#125;<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><p>这段代码的大致逻辑是：</p><ul><li>删除请求触发onMutate回调，为了乐观更新首先取消已有的讨论的请求（应该是为了应对配置了更新策略的queryClient）；从缓存中取出已存储的讨论列表、滤除删除的目标讨论、利用setQueryData将结果存入缓存</li><li>删除请求成功时，用invalidateQueries清除缓存、重新拉取数据</li><li>删除请求失败时，缓存重新存入上一次缓存即未删除的内容，相当于回退</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>（1）<a href="https://juejin.cn/post/6882669076540456967">react-query</a><br>（2）<a href="https://juejin.cn/column/7105422212789714980">react-query手把手教程</a></p>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>状态管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>带缩略图的图片切换展示实现</title>
    <link href="/unknown404.github.io/2023/11/09/thumbSwipe/"/>
    <url>/unknown404.github.io/2023/11/09/thumbSwipe/</url>
    
    <content type="html"><![CDATA[<p>简单记录一下做需求时遇到的问题和思考</p><span id="more"></span><h2 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h2><ol><li>实现一个带缩略图的图片切换模块；大图片支持左右翻页查看，也支持点选小图查看。</li><li>缩略图图片数量较少时整体居中；图片较多时缩略图支持滚动。点击缩略图选中的小图处于正中</li><li>点击大图打开预览弹窗，预览可左右滑动查看图片，再次点击退出预览态</li><li>预览态图片展示原则：过长的图片，放大且从顶部开始展示，可向下滑动查看；短图居中展示</li></ol><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ol><li>因为需求涉及到很多图片切换展示，可使用已有的方案 swiper 组件，如果使用了 vue 框架则使用 vue-awesome-swiper、配合 swiper 以前使用。安装时注意版本问题，高版本的 swiper 只能使用 vue 3 版本的 vue-awesome-swiper 调用，如果要使用 vue2 语法，版本可参考：</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;swiper&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^5.4.5&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;vue-awesome-swiper&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.1.1&quot;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>带缩略图的图片轮播官网有给实现<a href="https://github.com/surmon-china/surmon-china.github.io/blob/vue2/projects/vue-awesome-swiper/examples/30-thumbs-gallery.vue">案例</a><br>大图的展示使用 swiper 组件没有疑问。但实现的缩略图在轮播条件下样式比较合理，不然首图居中时左侧出现大片空白感觉很奇怪；因此缩略图的实现放弃用 swiper，将父容器设置为溢出滚动，小图包裹在一个容器里，在不滚动的时候利用 flex 布局让小图整体的容器居中</p><ol start="2"><li>缩略图较多、需要滑动查看缩略图并点击时使选中的缩略图位于父容器中间的实现可以利用浏览器的 API：scrollIntoView。一般说来使用这个 API 时可能直接就使用默认的方法、没有考虑过传参， 但实际上该 API 提供了入参让我们可以改变滚动进视野的方式：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> alignToTop = <span class="hljs-built_in">boolean</span>;<br><span class="hljs-keyword">type</span> scrollIntoViewOptions = &#123;<br>  <span class="hljs-attr">behavior</span>: <span class="hljs-string">&quot;auto&quot;</span> | <span class="hljs-string">&quot;smooth&quot;</span>;<br>  <span class="hljs-attr">block</span>: <span class="hljs-string">&quot;start&quot;</span> | <span class="hljs-string">&quot;center&quot;</span> | <span class="hljs-string">&quot;end&quot;</span> | <span class="hljs-string">&quot;nearest&quot;</span>;<br>  <span class="hljs-attr">inline</span>: <span class="hljs-string">&quot;start&quot;</span> | <span class="hljs-string">&quot;center&quot;</span> | <span class="hljs-string">&quot;end&quot;</span> | <span class="hljs-string">&quot;nearest&quot;</span>;<br>&#125;;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Element</span> &#123;<br>  <span class="hljs-title function_">scrollIntoView</span>(arg?: alignToTop | scrollIntoViewOptions): <span class="hljs-built_in">void</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 block 就是决定竖直方向的对齐方式，inline 是决定左右方向的对齐方式，可以对这两个参数进行操作。</p><ol start="3"><li>图片列表加载时可能需要一些时间，偶尔可能会出现部分图片加载失败。为避免显示失败，需要增加过渡态展示，这里以变量imgLoaded控制，通过监听图片加载的load过程来改变imgLoaded的值，当所有图片加载结束时变更imgLoaded、展示图片。</li></ol><p>最后带缩略的图片展示模块的实现大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;img-list-container&quot;&gt;<br>    &lt;div class=&quot;img-list-wrap&quot; v-show=&quot;imgList &amp;&amp; imgList.length&quot;&gt;<br>      &lt;!-- swiper1 --&gt;<br>      &lt;swiper<br>        class=&quot;swiper gallery-top&quot;<br>        :options=&quot;swiperOptionTop&quot;<br>        ref=&quot;swiperTop&quot;<br>        @slideChange=&quot;onSlideChange&quot;<br>      &gt;<br>        &lt;swiper-slide<br>          class=&quot;img-slide&quot;<br>          v-for=&quot;(item, idx) in imgList&quot;<br>          :key=&quot;idx&quot;<br>        &gt;<br>          &lt;img<br>            :src=&quot;item.url&quot;<br>            class=&quot;img-content&quot;<br>            @click=&quot;showPreviewModal&quot;<br>            v-show=&quot;imgLoaded&quot;<br>            @load=&quot;bigPicLoad(item.url, idx)&quot;<br>            @error=&quot;(event) =&gt; bigPicLoadFail(item.url, idx, event)&quot;<br>          /&gt;<br>          &lt;img<br>            src=&quot;./loading.gif&quot;<br>            class=&quot;img-content_0 center&quot;<br>            v-show=&quot;!imgLoaded&quot;<br>          /&gt;<br>        &lt;/swiper-slide&gt;<br>      &lt;/swiper&gt;<br>      &lt;!-- Thumbs --&gt;<br>      &lt;div<br>        :class=&quot;[<br>          &#x27;gallery-thumbs&#x27;,<br>          imgList &amp;&amp; imgList.length &lt; 6 &amp;&amp; &#x27;no-scroll&#x27;,<br>        ]&quot;<br>        ref=&quot;swiperThumbs&quot;<br>      &gt;<br>        &lt;div<br>          :class=&quot;[&#x27;thumb-wrap&#x27;, imgList &amp;&amp; imgList.length &lt; 6 &amp;&amp; &#x27;no-scroll&#x27;]&quot;<br>        &gt;<br>          &lt;div<br>            :class=&quot;[&#x27;img-thumb&#x27;, idx === activeIndex &amp;&amp; &#x27;img-thumb-active&#x27;]&quot;<br>            v-for=&quot;(item, idx) in imgList&quot;<br>            :key=&quot;idx&quot;<br>            @click=&quot;(event) =&gt; changeActiveIdx(event, idx)&quot;<br>          &gt;<br>            &lt;img<br>              :src=&quot;item.url&quot;<br>              class=&quot;img-content&quot;<br>              v-show=&quot;smallImgLoaded&quot;<br>              @load=&quot;smallPicLoad(item.url, idx)&quot;<br>            /&gt;<br>            &lt;img<br>              src=&quot;./loading.gif&quot;<br>              class=&quot;img-content_0&quot;<br>              v-show=&quot;!smallImgLoaded&quot;<br>            /&gt;<br>          &lt;/div&gt;<br>        &lt;/div&gt;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br><br>    &lt;img-preview<br>      :currentIdx=&quot;activeIndex&quot;<br>      :imgList=&quot;imgList&quot;<br>      ref=&quot;previewModal&quot;<br>    /&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>import ImgPreview from &quot;@/wap/components/ImgPreview.vue&quot;;<br><br>import &#123; Swiper, SwiperSlide &#125; from &quot;vue-awesome-swiper&quot;;<br>import &quot;swiper/css/swiper.css&quot;;<br><br>export default &#123;<br>  name: &quot;swiper-thumbs-gallery&quot;,<br>  props: &#123;<br>    imgList: &#123;<br>      type: Array,<br>      default: [],<br>    &#125;,<br>  &#125;,<br>  components: &#123;<br>    Swiper,<br>    SwiperSlide,<br>    ImgPreview,<br>  &#125;,<br><br>  watch: &#123;<br>    imgList: &#123;<br>      deep: true,<br>      handler(newVal) &#123;<br>        this.activeIndex = 0;<br>        this.imgLoaded = false;<br>        this.smallImgLoaded = false;<br>        this.topCount = 0;<br>        this.thumbCount = 0;<br>        this.swiperTop.slideTo(this.activeIndex);<br>      &#125;,<br>    &#125;,<br>  &#125;,<br>  data() &#123;<br>    return &#123;<br>      swiperOptionTop: &#123;<br>        loop: false,<br>        loopedSlides: this.imgList.length,<br>        spaceBetween: 10,<br>      &#125;,<br>      swiperTop: null,<br>      swiperThumbs: null,<br>      activeIndex: 0,<br>      imgLoaded: false,<br>      smallImgLoaded: false,<br>      topCount: 0,<br>      thumbCount: 0,<br>    &#125;;<br>  &#125;,<br>  mounted() &#123;<br>    this.$nextTick(() =&gt; &#123;<br>      this.swiperTop = this.$refs.swiperTop.$swiper;<br>      this.swiperThumbs = this.$refs.swiperThumbs.$swiper;<br>    &#125;);<br>  &#125;,<br>  methods: &#123;<br>    bigPicLoad(url, idx) &#123;<br>      this.topCount++;<br>      if (this.topCount === this.imgList.length) &#123;<br>        this.imgLoaded = true;<br>      &#125;<br>    &#125;,<br>    bigPicLoadFail(url, idx, event) &#123;<br>      event.target.style =<br>        &quot;width:57px;height:43px;position: absolute;left: 50%;top: 50%;transform: translate(-50%, -50%);&quot;;<br>      this.imgList[idx].url = &quot;./fail.png&quot;;<br>      this.topCount++;<br>      if (this.topCount === this.imgList.length) &#123;<br>        this.imgLoaded = true;<br>      &#125;<br>    &#125;,<br>    smallPicLoad(url, idx) &#123;<br>      console.log(&quot;small loaded&quot;, url, idx, this.imgList.length);<br>      this.thumbCount++;<br>      if (this.thumbCount === this.imgList.length) &#123;<br>        this.smallImgLoaded = true;<br>      &#125;<br>    &#125;,<br>    onSlideChange() &#123;<br>      console.log(&quot;swiper&quot;, this.swiperTop.activeIndex);<br>      this.activeIndex = this.swiperTop.activeIndex;<br>    &#125;,<br>    changeActiveIdx(event, idx) &#123;<br>      this.activeIndex = idx;<br>      this.swiperTop.slideTo(this.activeIndex);<br>      event.target.scrollIntoView(&#123;<br>        block: &quot;nearest&quot;,<br>        inline: &quot;center&quot;,<br>      &#125;);<br>    &#125;,<br>    showPreviewModal() &#123;<br>      this.$refs[&quot;previewModal&quot;].show();<br>    &#125;,<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;less&quot; scoped&gt;<br>.swiper &#123;<br>  .swiper-slide &#123;<br>    background-size: cover;<br>    background-position: center;<br>  &#125;<br>&#125;<br><br>.gallery-top &#123;<br>  height: 387px;<br>  width: 100%;<br><br>  .img-content_0 &#123;<br>    width: 42px;<br>    height: 58px;<br>    padding-top: 149px;<br>    box-sizing: content-box;<br>    margin: auto;<br>  &#125;<br><br>  .img-content_-1 &#123;<br>    width: 57px;<br>    height: 57px;<br>    padding-top: 156px;<br>    box-sizing: content-box;<br>    margin: auto;<br>  &#125;<br><br>  .txt &#123;<br>    font-size: 14px;<br>    font-weight: 400;<br>    color: #ffffff;<br>    line-height: 20px;<br>    margin-top: 13px;<br>  &#125;<br><br>  .img-content &#123;<br>    width: 100%;<br>    height: 100%;<br>    object-fit: cover;<br>  &#125;<br><br>  .watermark &#123;<br>    position: absolute;<br>    right: 7px;<br>    bottom: 10px;<br>    width: 79px;<br>    height: 22px;<br>  &#125;<br>&#125;<br><br>.gallery-thumbs &#123;<br>  height: 62px;<br>  box-sizing: border-box;<br>  padding: 8px 0;<br>  overflow-x: scroll;<br>  overflow-y: hidden;<br><br>  &amp;::-webkit-scrollbar &#123;<br>    display: none;<br>    width: 0;<br>    height: 0;<br>  &#125;<br><br>  &amp;.no-scroll &#123;<br>    display: flex;<br>    justify-content: center;<br>  &#125;<br><br>  .thumb-wrap &#123;<br>    display: flex;<br>  &#125;<br><br>  .img-thumb &#123;<br>    display: inline-block;<br>    width: 46px;<br>    height: 46px;<br>    border-radius: 6px;<br>    overflow: hidden;<br>    margin-right: 8px;<br>    flex-shrink: 0;<br>    box-sizing: border-box;<br><br>    .img-content &#123;<br>      width: 100%;<br>      height: 100%;<br>      object-fit: cover;<br>    &#125;<br>  &#125;<br><br>  .img-thumb-active &#123;<br>    border: 2px solid #3269ff;<br>  &#125;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><ol start="3"><li>图片的预览实现起来本身并不复杂，还是利用 swiper 组件，但一些细节点需要注意：</li></ol><ul><li>高度自适应尽量不要用 fit-content 而是 auto，因为在 iOS 系统，部分机型不支持这个属性</li><li>需要监听从图片展示模块传输的当前图片的 index，操作预览模块的 swiper 跳到该 index 的位置</li><li>点击事件不要挂在 swiper 和 swiper-slide 组件上，否则无法生效</li><li>为防止滚动查看预览弹窗时后面页面滚动，需要改变body的样式</li></ul><p>最终预览模块的实现大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;preview-list-container&quot; v-show=&quot;modalVisible&quot;&gt;<br>    &lt;!-- swiper1 --&gt;<br>    &lt;swiper<br>      class=&quot;swiper gallery-top&quot;<br>      :options=&quot;swiperOptionTop&quot;<br>      ref=&quot;swiperTop&quot;<br>      @slideChange=&quot;onSlideChange&quot;<br>    &gt;<br>      &lt;swiper-slide class=&quot;img-slide&quot; v-for=&quot;(item, idx) in imgList&quot; :key=&quot;idx&quot;&gt;<br>        &lt;div class=&quot;img-container&quot; @click=&quot;hidden&quot;&gt;<br>          &lt;div class=&quot;img-wrap&quot;&gt;<br>            &lt;img :src=&quot;item.url&quot; class=&quot;img-content&quot; /&gt;<br>          &lt;/div&gt;<br>        &lt;/div&gt;<br>      &lt;/swiper-slide&gt;<br>    &lt;/swiper&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; Swiper, SwiperSlide &#125; from &quot;vue-awesome-swiper&quot;;<br>import &quot;swiper/css/swiper.css&quot;;<br><br>export default &#123;<br>  name: &quot;img-preview&quot;,<br>  props: &#123;<br>    imgList: &#123;<br>      type: Array,<br>      default: [],<br>    &#125;,<br>    currentIdx: &#123;<br>      type: Number,<br>      default: 0,<br>    &#125;,<br>  &#125;,<br>  components: &#123;<br>    Swiper,<br>    SwiperSlide,<br>  &#125;,<br>  watch: &#123;<br>    currentIdx: &#123;<br>      handler(newVal) &#123;<br>        this.activeIndex = newVal;<br>        this.swiperTop.slideTo(this.activeIndex);<br>      &#125;,<br>    &#125;,<br>  &#125;,<br>  data() &#123;<br>    return &#123;<br>      swiperOptionTop: &#123;<br>        loop: false,<br>        loopedSlides: this.imgList.length,<br>        spaceBetween: 10,<br>      &#125;,<br>      swiperTop: null,<br>      activeIndex: 0,<br>      modalVisible: false,<br>    &#125;;<br>  &#125;,<br>  created() &#123;<br>    this.activeIndex = this.currentIdx;<br>  &#125;,<br>  mounted() &#123;<br>    this.$nextTick(() =&gt; &#123;<br>      this.swiperTop = this.$refs.swiperTop.$swiper;<br>    &#125;);<br>  &#125;,<br>  methods: &#123;<br>    onSlideChange() &#123;<br>      this.activeIndex = this.swiperTop.activeIndex;<br>    &#125;,<br>    show() &#123;<br>      this.modalVisible = true;<br>      document.body.style.overflow = &quot;hidden&quot;;<br>    &#125;,<br>    hidden() &#123;<br>      this.modalVisible = false;<br>      document.body.style.overflow = &quot;&quot;;<br>    &#125;,<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;less&quot; scoped&gt;<br>.preview-list-container &#123;<br>  position: fixed;<br>  width: 100%;<br>  height: 100vh;<br>  left: 0;<br>  top: 0;<br>  background: #000;<br>  z-index: 2000;<br><br>  .img-wrap &#123;<br>    position: relative;<br>    width: 100%;<br>  &#125;<br><br>  .toolkit-container &#123;<br>    position: fixed;<br>    left: 0;<br>    bottom: 0;<br>    width: 100%;<br>    padding: 15px 24px 48px;<br>    background: rgba(0, 0, 0, 0.5);<br>    display: flex;<br>    justify-content: space-between;<br>    align-items: center;<br>    color: #fff;<br>    font-size: 16px;<br>    line-height: 22px;<br>    z-index: 999;<br><br>    .toolkit-wrap &#123;<br>      display: flex;<br><br>      .toolkit &#123;<br>        display: flex;<br>        align-items: center;<br>        margin-left: 32px;<br><br>        .icon &#123;<br>          width: 16px;<br>          height: 16px;<br>          object-fit: contain;<br>          margin-right: 4px;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br>.swiper &#123;<br>  .swiper-slide &#123;<br>    background-size: cover;<br>    background-position: center;<br>  &#125;<br><br>  &amp;.gallery-top &#123;<br>    width: 100%;<br>    height: 100vh;<br><br>    .img-container &#123;<br>      width: 100%;<br>      height: 100vh;<br>      display: flex;<br>      align-items: center;<br>      overflow-y: scroll;<br>    &#125;<br><br>    .watermark &#123;<br>      position: absolute;<br>      right: 7px;<br>      bottom: 10px;<br>      width: 79px;<br>      height: 22px;<br>    &#125;<br><br>    .img-content &#123;<br>      width: 100%;<br>      height: auto;<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://segmentfault.com/a/1190000041886147">详细介绍 scrollIntoView 方法</a></p>]]></content>
    
    
    <categories>
      
      <category>工作技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动端开发时的系统兼容性问题</title>
    <link href="/unknown404.github.io/2023/10/27/iosCompat/"/>
    <url>/unknown404.github.io/2023/10/27/iosCompat/</url>
    
    <content type="html"><![CDATA[<p>吐槽一下移动端开发时碰到的各种意想不到的兼容性问题。有系统的问题，例如 iOS 和安卓的区别；也有浏览器区别，不同商家的浏览器设计也是差别很大的</p><span id="more"></span><h1 id="浏览器篇"><a href="#浏览器篇" class="headerlink" title="浏览器篇"></a>浏览器篇</h1><h2 id="问题-1-ios-系统输入框-disabled-状态样式过浅"><a href="#问题-1-ios-系统输入框-disabled-状态样式过浅" class="headerlink" title="问题 1: ios 系统输入框 disabled 状态样式过浅"></a>问题 1: ios 系统输入框 disabled 状态样式过浅</h2><p>解决方法：增加 -webkit-text-fill-color 属性配置以及要调整 opacity。如下示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">textarea</span><span class="hljs-selector-pseudo">:disabled</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">1</span>);<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>  -webkit-text-fill-<span class="hljs-attribute">color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="问题-2-安卓移动端软键盘弹出时底部-fixed-定位被顶上去"><a href="#问题-2-安卓移动端软键盘弹出时底部-fixed-定位被顶上去" class="headerlink" title="问题 2:安卓移动端软键盘弹出时底部 fixed 定位被顶上去"></a>问题 2:安卓移动端软键盘弹出时底部 fixed 定位被顶上去</h2><p>原因是安卓系统和 ios 系统加载键盘的方式不同<br>解决方法：window.onresize 监听页面高度的变化，手动来控制吸底组件的显示和隐藏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;footer&quot; v-show=&quot;hideshow&quot;&gt;&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      docmHeight: &quot;&quot;, //第一次获取高度<br>      nowHeight: &quot;&quot;,<br>      hideshow: true,<br>      isResize: false,<br>    &#125;;<br>  &#125;,<br>  watch: &#123;<br>    // 如果 clientHeight 发生改变，这个函数就会运行<br>    nowHeight: function () &#123;<br>      if (this.docmHeight != this.nowHeight) &#123;<br>        this.hideshow = false;<br>      &#125; else &#123;<br>        this.hideshow = true;<br>      &#125;<br>    &#125;,<br>  &#125;,<br>  mounted() &#123;<br>    // 获取浏览器可视区域高度<br>    this.docmHeight = document.documentElement.clientHeight; // document.body.clientWidth;<br>    window.onresize = () =&gt; &#123;<br>      // 在窗口或框架被调整大小时触发<br>      return (() =&gt; &#123;<br>        this.nowHeight = document.documentElement.clientHeight;<br>        console.log(&quot;当前高度&quot;, this.nowHeight);<br>      &#125;)();<br>    &#125;;<br>  &#125;,<br>  methods: &#123;&#125;,<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><em>个人碎碎念：其实我觉得这个方法并不好，有的手机支持横屏，横屏时页面肯定会触发 resize 事件，然后底部组件消失了？毕竟 mounted 生命周期不会再次触发。之前自己想的是键盘弹起事件和 input 组件聚焦强关联，把隐藏底部组件的触发时机放在聚焦上。但此时遇到较真的产品就会认为页面滚动时应该让 input 失焦，但浏览器并不会实现这个效果，逻辑的实现又十分复杂。所以最好的解决方案就是换个设计吧。。。</em></p><h2 id="问题-3-针对整个屏幕竖直居中的图片在-ios-的-Safari-和-Chrome-浏览器不居中"><a href="#问题-3-针对整个屏幕竖直居中的图片在-ios-的-Safari-和-Chrome-浏览器不居中" class="headerlink" title="问题 3: 针对整个屏幕竖直居中的图片在 ios 的 Safari 和 Chrome 浏览器不居中"></a>问题 3: 针对整个屏幕竖直居中的图片在 ios 的 Safari 和 Chrome 浏览器不居中</h2><p>原因：书写样式时父元素的高度设置为 100vh，也就是屏幕高度，而 Safari 和 Chrome 都有工具栏，在工具栏显示的情况下看起来就不怎么竖直居中了。其实这是 100vh 的一个 bug，可以详见<a href="https://juejin.cn/post/7313979304513552435">这篇文章</a><br>解决方法：外层父元素高度设置为 100%，因为 position 的设置该元素已经脱离了原本文本流、基准变为视口，高度设置为 100%也不会出现撑不起高度的情况，会依照视口高度定值；虽然 document.documentElement.clientHeight 和 window.innerHeight 可获取可视高度，但 Safari 的工具栏是下滑时可隐藏的，所以需要反复监听高度进行调整也比较麻烦</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.modal-container</span> &#123;<br>  <span class="hljs-attribute">position</span>: fixed;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#000</span>;<br>  <span class="hljs-attribute">z-index</span>: <span class="hljs-number">2000</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="问题-4-小米浏览器夜间模式白色图片发黑"><a href="#问题-4-小米浏览器夜间模式白色图片发黑" class="headerlink" title="问题 4:小米浏览器夜间模式白色图片发黑"></a>问题 4:小米浏览器夜间模式白色图片发黑</h2><p>原因：好像是特定的浏览器版本，会在夜间模式对白色图片进行反色<br>反色原理接近<code>filter: invert(110%) hue-rotate(180deg)</code>，但实际操作时按这个方法反色回去发现透明部分也被反色了，所以可能 filter 的方法还缺少参数<br>解决方法：一个可能性比较高的解决方法是：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">prefers-color-scheme</span>: dark) &#123;<br>  <span class="hljs-selector-tag">img</span> &#123;<br>    <span class="hljs-attribute">filter</span>: none <span class="hljs-meta">!important</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样可以去除夜间模式的过滤器效果</p><h2 id="问题-5-使用-vue-lazyload-懒加载图片流时，安卓手机会出现某一页面的第一帧图片流呈加载态，只有滚动后才变为有图片的情况"><a href="#问题-5-使用-vue-lazyload-懒加载图片流时，安卓手机会出现某一页面的第一帧图片流呈加载态，只有滚动后才变为有图片的情况" class="headerlink" title="问题 5:使用 vue-lazyload 懒加载图片流时，安卓手机会出现某一页面的第一帧图片流呈加载态，只有滚动后才变为有图片的情况"></a>问题 5:使用 vue-lazyload 懒加载图片流时，安卓手机会出现某一页面的第一帧图片流呈加载态，只有滚动后才变为有图片的情况</h2><p>原因：不是很明了，可能与<a href="https://juejin.cn/post/7015142066145460231">这篇文章</a>说的有关系，iOS 会触发 resize 事件，android 不会。<br>解决方法：在页面加载或者激活的生命周期加一个滚动函数，滚 1px，触发加载</p><h2 id="问题-6-粘贴板功能在部分环境失效"><a href="#问题-6-粘贴板功能在部分环境失效" class="headerlink" title="问题 6:粘贴板功能在部分环境失效"></a>问题 6:粘贴板功能在部分环境失效</h2><p>原因：粘贴板使用的是 navigator.clipboard，该方法在 iOS 或比较先进的浏览器才会生效，而微信小程序安卓 webview 环境下使用用这个方法会报错<br>解决方法：增加 navigator.clipboard 的 api 使用检查和设备识别，如果不存在该 api 则使用 npm 包 copy-to-clipboard 的方法</p><h2 id="问题-7-安卓-qq-浏览器点击图片会自动放大"><a href="#问题-7-安卓-qq-浏览器点击图片会自动放大" class="headerlink" title="问题 7:安卓 qq 浏览器点击图片会自动放大"></a>问题 7:安卓 qq 浏览器点击图片会自动放大</h2><p>原因：qq 浏览器的自发行为（就跟他有时候会自动屏蔽 ad-wrap 的元素一样离谱）<br>解决方法：使用 css 样式 pointer-events: none;可以阻止浏览器默认行为，但是如果希望保留一些浏览器默认行为如长按保存就不能使用该样式</p><h2 id="问题-8-ios-的-safari-下拉页面时页面外区域是黑的"><a href="#问题-8-ios-的-safari-下拉页面时页面外区域是黑的" class="headerlink" title="问题 8:ios 的 safari 下拉页面时页面外区域是黑的"></a>问题 8:ios 的 safari 下拉页面时页面外区域是黑的</h2><p>原因：和 meta 上设置的 theme color 有关<br>解决方法：document.querySelector(‘meta[name&#x3D;”theme-color”]’).setAttribute(‘content’, bgColor || “#141416”)</p><h2 id="问题-9-ios-部分机型-border-radius-和-overflow：hidden-样式不生效"><a href="#问题-9-ios-部分机型-border-radius-和-overflow：hidden-样式不生效" class="headerlink" title="问题 9:ios 部分机型 border-radius 和 overflow：hidden 样式不生效"></a>问题 9:ios 部分机型 border-radius 和 overflow：hidden 样式不生效</h2><p>原因：根据<a href="https://juejin.cn/post/7372396174249459750">这篇文章</a>应该是因为 ios 手机会在 transform 的时候导致 border-radius 失效<br>解决方法：1.按照文章的改法、使用动画效果带 transform 的元素的上一级 div 元素的 css 加上语句<code>-webkit-transform:rotate(0deg);</code><br>；2.将圆角样式加到内容器而不是带 transform 样式的外容器</p><h2 id="问题-10-iPhone-16-部分条件判断效果与其他机型不一样"><a href="#问题-10-iPhone-16-部分条件判断效果与其他机型不一样" class="headerlink" title="问题 10: iPhone 16 部分条件判断效果与其他机型不一样"></a>问题 10: iPhone 16 部分条件判断效果与其他机型不一样</h2><p>原因：不明，网上几乎没有资料，表现上好像是不是很支持链式判断符，有可能会把接收到空数组变成其他？<br>解决方法：没有什么具体的方法，现在只能根据现象推测可能的问题。例如<code>extra?.list?.length? true : false</code>改成<code>Array.isArray(extra?.list) &amp;&amp; extra.list.length &gt; 0? true : false</code></p><h2 id="问题-11-ios-自动高度带滚动的-textarea-在输入需要转行时没有滚动到最新一行；安卓则是完全不会自动滚动到输入的最新行"><a href="#问题-11-ios-自动高度带滚动的-textarea-在输入需要转行时没有滚动到最新一行；安卓则是完全不会自动滚动到输入的最新行" class="headerlink" title="问题 11: ios 自动高度带滚动的 textarea 在输入需要转行时没有滚动到最新一行；安卓则是完全不会自动滚动到输入的最新行"></a>问题 11: ios 自动高度带滚动的 textarea 在输入需要转行时没有滚动到最新一行；安卓则是完全不会自动滚动到输入的最新行</h2><p>原因：ios 应该是监听了行数变化进行的滚动，而在中文输入法时存在一个输入到确认的时间，在这个时间内 ios 已经完成了行数监听的滚动；安卓没有这种监听<br>解决方法：监听输入内容而不是行数变化，设置滚动高度时应该在原本的 scrollHeight 上增加一些行高，以防此时 ios 的滚动高度不包括或低于输入内容高度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">watch</span>: &#123;<br>    <span class="hljs-title function_">inputValue</span>(<span class="hljs-params">_new</span>) &#123;<br>      <span class="hljs-keyword">const</span> target = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;textArea&#x27;</span>);<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">scrollHeight</span>, target.<span class="hljs-property">clientHeight</span>);<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        target.<span class="hljs-property">scrollTop</span> = target.<span class="hljs-property">scrollHeight</span> + <span class="hljs-number">42</span>;<br>      &#125;);<br>    &#125;,<br>  &#125;,<br></code></pre></td></tr></table></figure><h2 id="问题-12-部分模块在-uc-浏览器不显示"><a href="#问题-12-部分模块在-uc-浏览器不显示" class="headerlink" title="问题 12:部分模块在 uc 浏览器不显示"></a>问题 12:部分模块在 uc 浏览器不显示</h2><p><strong>原因</strong>：uc 浏览器内置样式文件，与自定义的样式文件存在覆盖关系。例如如果模块命名为 ad-wrap，则该模块会被强制隐藏。</p><h2 id="问题-13-使用-em-为单位的模块在-qq-浏览器上比例失效"><a href="#问题-13-使用-em-为单位的模块在-qq-浏览器上比例失效" class="headerlink" title="问题 13:使用 em 为单位的模块在 qq 浏览器上比例失效"></a>问题 13:使用 em 为单位的模块在 qq 浏览器上比例失效</h2><p><strong>原因</strong>：父元素的 font-size 的赋值问题。有的浏览器会存在最小 font-size，小于该阈值则设置无效。qq 浏览器下 font-size 最小 8px，所以父元素的 font-size 的设置不能小于 8px</p><p><del>如果不是老项目的旧样式太多太难改了还是尽可能的用 vw 吧</del></p><h2 id="问题-14-输入框使用-keydown-enter-时回车操作键盘不会隐藏、对展示搜索结果有影响"><a href="#问题-14-输入框使用-keydown-enter-时回车操作键盘不会隐藏、对展示搜索结果有影响" class="headerlink" title="问题 14:输入框使用@keydown.enter 时回车操作键盘不会隐藏、对展示搜索结果有影响"></a>问题 14:输入框使用@keydown.enter 时回车操作键盘不会隐藏、对展示搜索结果有影响</h2><p><strong>原因</strong>：不明<br><strong>解决方式</strong>：使用 ref 方法，改为监听 keyup 事件，如果监听到 event.keyCode &#x3D;&#x3D; 13 进行后续操作，同时在之前的回调函数中增加 this.$refs.searchInput.blur()手动失焦</p><h2 id="问题-15-手机熄屏后设置的定时器无法生效"><a href="#问题-15-手机熄屏后设置的定时器无法生效" class="headerlink" title="问题 15:手机熄屏后设置的定时器无法生效"></a>问题 15:手机熄屏后设置的定时器无法生效</h2><p>原因：根据<a href="https://blog.csdn.net/thirteen_king13/article/details/114077815">这篇文章</a>，这是系统固有特性<br>解决方法：监听事件 visibilitychange，锁屏就记录时间，再次显示时记录此时时间，与之前设置的时间间隔比较，超出则立即执行，没有则设置一个新时间间隔的定时器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;visibilitychange&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;visibilitychange&quot;</span>);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">winVisible</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">// hidden 为锁屏隐藏状态，visible为重新显示状态</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">visibilityState</span> === <span class="hljs-string">&quot;hidden&quot;</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">screenShutdownTime</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();<br>    <span class="hljs-built_in">clearTimeout</span>(showIntroTimer);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">visibilityState</span> === <span class="hljs-string">&quot;visible&quot;</span>) &#123;<br>    <span class="hljs-keyword">let</span> screenShowTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();<br>    <span class="hljs-keyword">const</span> diffTime = screenShowTime - <span class="hljs-variable language_">this</span>.<span class="hljs-property">screenShutdownTime</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">countTime</span> = <span class="hljs-built_in">parseInt</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">countTime</span>) - diffTime;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">countTime</span> &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 重新赋值，间隔后的新的定时器时间</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initTimer</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 已经超出范围，则默认秒数已经读完</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">countTime</span> = <span class="hljs-number">0</span>;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initTimer</span>();<br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="小程序篇"><a href="#小程序篇" class="headerlink" title="小程序篇"></a>小程序篇</h1><h2 id="问题-1-弹窗滚动穿透问题（即弹窗出现时页面还可以做滚动操作）"><a href="#问题-1-弹窗滚动穿透问题（即弹窗出现时页面还可以做滚动操作）" class="headerlink" title="问题 1: 弹窗滚动穿透问题（即弹窗出现时页面还可以做滚动操作）"></a>问题 1: 弹窗滚动穿透问题（即弹窗出现时页面还可以做滚动操作）</h2><p>解决方法：跟使用的技术及小程序平台有关，如果只有<a href="https://developers.weixin.qq.com/community/develop/doc/d615c9a8957a00225ae66b65a8c2bd01?highLine=%25E6%25BB%259A%25E5%258A%25A8%25E7%25A9%25BF%25E9%2580%258F">微信小程序</a>可以用官方提供的 page-meta，或者在弹窗上增加 catchtouchmove 属性；如果使用了跨端框架（例如<a href="https://taro-docs.jd.com/docs/vue-overall#taro-3-%E5%9C%A8%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AB%AF%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6">Taro</a>），可能这些属性不生效，只能通过改变页面样式如固定高度、溢出隐藏等来禁止页面的滚动</p>]]></content>
    
    
    <categories>
      
      <category>踩坑经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cover-view在webview上显示</title>
    <link href="/unknown404.github.io/2023/10/07/cover-view/"/>
    <url>/unknown404.github.io/2023/10/07/cover-view/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>根据微信小程序官方文档，webview 覆盖全组件，是不支持其他组件进行覆盖的。但有些需求希望在小程序的 webview 页增加浮动图标、提供引导作用。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>利用 webview 的 bindload 属性或者页面的onShow周期、在 webivew 加载完成后显示 cover-view 的内容，为保证 cover-view 能出现最好加上一点时延。<br>这只是一个临时解决方法，并不是官方提供的实现。所以在开发者工具上无法看出效果，只有真机才能看到，日后也有无法生效的可能。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://developers.weixin.qq.com/community/develop/doc/000a40ddcac42010f5ba0737c56800">cover-view能否覆盖webview?</a></p>]]></content>
    
    
    <categories>
      
      <category>工作技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自定义tabbar的实现</title>
    <link href="/unknown404.github.io/2023/09/21/tabBarMid/"/>
    <url>/unknown404.github.io/2023/09/21/tabBarMid/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>根据产品需求，要实现小程序的 tabbar 样式自定义、中间按钮凸起的效果</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li><p>pages.json文件和一般带tabbar的项目一样进行配置（不做配置的话切换页面顶部导航会出现回退键）</p></li><li><p>自定义tabbar中实现tab页面切换的逻辑：每个tab页都设置id值，切换页面时传入自定义tabbar组件的id值变化，改变tabbar的icon激活样式；在mounted周期隐藏默认的tabbar</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;view class=&quot;tab-container&quot;&gt;<br>        &lt;view class=&quot;tabbar-item&quot; v-for=&quot;(item, index) in tabBarList&quot; :class=&quot;[item.centerItem ? &#x27; center-item&#x27; : &#x27;&#x27;]&quot;<br>            @click=&quot;changeItem(item)&quot; :key=&quot;index&quot;&gt;<br>            &lt;view class=&quot;item-top&quot;&gt;<br>                &lt;image :src=&quot;currentItem == item.id ? item.selectIcon : item.icon&quot;&gt;&lt;/image&gt;<br>            &lt;/view&gt;<br>            &lt;view class=&quot;item-bottom&quot; :class=&quot;[currentItem == item.id ? &#x27;item-active&#x27; : &#x27;&#x27;]&quot;&gt;<br>                &lt;text&gt;&#123;&#123; item.text &#125;&#125;&lt;/text&gt;<br>            &lt;/view&gt;<br>        &lt;/view&gt;<br>    &lt;/view&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; tabBarList &#125; from &#x27;../utils/constants&#x27;<br>export default &#123;<br>    props: &#123;<br>        currentPageId: &#123;<br>            type: Number,<br>            default: 0<br>        &#125;<br>    &#125;,<br>    data() &#123;<br>        return &#123;<br>            currentItem: 0,<br>            tabBarList: tabBarList<br>        &#125;<br>    &#125;,<br>    methods: &#123;<br>        changeItem(item) &#123;<br>            uni.switchTab(&#123;<br>                url: item.path<br>            &#125;);<br>        &#125;<br><br>    &#125;,<br>    mounted() &#123;<br>        this.currentItem = this.currentPageId<br>        uni.hideTabBar();<br>    &#125;,<br><br>&#125;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;less&quot;&gt;<br>.tab-container &#123;<br>    position: fixed;<br>    bottom: 0;<br>    left: 0;<br>    width: 100%;<br>    height: 120rpx;<br>    padding: 10rpx 80rpx 0;<br>    display: flex;<br>    justify-content: space-between;<br>    box-sizing: border-box;<br>    border-top: 1rpx solid #999;<br>    background: #fff;<br><br>    .tabbar-item &#123;<br>        display: flex;<br>        flex-direction: column;<br>        justify-content: center;<br>        align-items: center;<br>        text-align: center;<br><br>        .item-top &#123;<br>            width: 64rpx;<br>            height: 64rpx;<br>            margin-bottom: 10rpx;<br><br>            image &#123;<br>                width: 100%;<br>                height: 100%;<br>                object-fit: contain;<br>            &#125;<br>        &#125;<br><br>        .item-bottom &#123;<br>            font-size: 20rpx;<br>            color: #999;<br>        &#125;<br><br>        &amp;.center-item &#123;<br>            position: absolute;<br>            top: -50rpx;<br>            left: calc(50% - 50rpx);<br>            background: #fff;<br>            width: 100rpx;<br>            border: 1px solid;<br>            border-radius: 10rpx;<br>            padding: 20rpx 0;<br>            box-sizing: border-box;<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure></li><li><p>将自定义的tabbar引入页面</p></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://blog.csdn.net/weixin_56650035/article/details/118027317">uniapp 自定义 tabbar，中间凸起</a></p>]]></content>
    
    
    <categories>
      
      <category>工作技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ios踩坑经历——页面在键盘弹出时上移</title>
    <link href="/unknown404.github.io/2023/09/18/iosScroll/"/>
    <url>/unknown404.github.io/2023/09/18/iosScroll/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>iOS 环境下当 input 组件聚焦、弹出键盘时，页面整体位置上移</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>这属于 iOS 系统的特殊操作，必然会出现。解决思路是键盘弹出时记录下当前滚动的位置，用 js 进行位置还原。但考虑执行时可能无法完全抵消 ios 的默认操作，实际展示可能会出现页面上移后迅速回位的奇怪效果，设置为在键盘隐藏时页面回归原位。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;container&quot;&gt;<br>    &lt;input ref=&quot;input&quot; /&gt;<br>    &lt;button @click=&quot;focusInput&quot; /&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      scrollTop: 0,<br>    &#125;;<br>  &#125;,<br><br>  mounted() &#123;<br>    var UA = navigator.userAgent.toLowerCase();<br>    if (<br>      UA.indexOf(&quot;iphone&quot;) &gt; -1 ||<br>      UA.indexOf(&quot;ipad&quot;) &gt; -1 ||<br>      UA.indexOf(&quot;ios&quot;) &gt; -1<br>    ) &#123;<br>      // 监听键盘收起操作<br>      document.body.addEventListener(&quot;focusout&quot;, this.pageRecover);<br>    &#125;<br>  &#125;,<br>  destroyed() &#123;<br>    var UA = navigator.userAgent.toLowerCase();<br>    if (<br>      UA.indexOf(&quot;iphone&quot;) &gt; -1 ||<br>      UA.indexOf(&quot;ipad&quot;) &gt; -1 ||<br>      UA.indexOf(&quot;ios&quot;) &gt; -1<br>    ) &#123;<br>      document.body.removeEventListener(&quot;focusout&quot;, this.pageRecover);<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    focusInput() &#123;<br>      // 触发键盘出现、页面上推<br>      this.$refs[&quot;input&quot;].focus();<br>      this.scrollTop = window.pageYOffset;<br>    &#125;,<br>    //软键盘收起的事件处理<br>    pageRecover() &#123;<br>      setTimeout(() =&gt; &#123;<br>        window.scrollTo(0, this.scrollTop);<br>      &#125;, 500);<br>    &#125;,<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/6844904083438977032">由 Vant Field 组件得到解决 IOS 输入框 键盘上推问题</a></p>]]></content>
    
    
    <categories>
      
      <category>踩坑经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode指令</title>
    <link href="/unknown404.github.io/2023/09/07/vscodeCmd/"/>
    <url>/unknown404.github.io/2023/09/07/vscodeCmd/</url>
    
    <content type="html"><![CDATA[<p>记录下几个提升效率的 vscode 指令，免得自己突然想不起来又专门查。</p><span id="more"></span><h2 id="打开-vscode-的-setting"><a href="#打开-vscode-的-setting" class="headerlink" title="打开 vscode 的 setting"></a>打开 vscode 的 setting</h2><p>方法一：找到 vscode 顶部菜单，点击首个 tab，按“preferences - setting”的顺序点开</p><p>方法二：IDE 界面的左下角的齿轮点开，选择菜单里的 setting</p><p>方法三：使用指令<code>Cmd + Shift + P</code>（mac）打开命令面板 Command Palette，输入 setting 后点击“Preference：Open User Settings (JSON) ”就会打开用户的设置 json</p><p>举例可以修改 editor.stickyScroll.enabled 属性的状态，让 ide 屏幕顶部显示你所在的函数&#x2F;类，这在阅读较长的代码时比较有用</p><h2 id="项目切换"><a href="#项目切换" class="headerlink" title="项目切换"></a>项目切换</h2><p>指令<code>control + R</code>，可在最近打开的几个项目间进行切换</p><h2 id="文档查找"><a href="#文档查找" class="headerlink" title="文档查找"></a>文档查找</h2><p>指令<code>Cmd + P</code>，搜索当前项目的文件名</p><h2 id="函数查找"><a href="#函数查找" class="headerlink" title="函数查找"></a>函数查找</h2><p>指令<code>Cmd + Shift + O</code>，搜索当前所在文件里的函数名</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/7270061728897204282">你一定要知道的 7 个 VS Code 技巧</a></p>]]></content>
    
    
    <categories>
      
      <category>备忘录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css文件px转rem操作</title>
    <link href="/unknown404.github.io/2023/08/28/postcss/"/>
    <url>/unknown404.github.io/2023/08/28/postcss/</url>
    
    <content type="html"><![CDATA[<p>前端尤其是移动端开发时，对屏幕适配换设计稿的要求比较高。常见的方法是将 px 转为 rem，主要有两种实现方式。</p><h3 id="使用-CSS-预处理器（如-Sass-或-Less）"><a href="#使用-CSS-预处理器（如-Sass-或-Less）" class="headerlink" title="使用 CSS 预处理器（如 Sass 或 Less）"></a>使用 CSS 预处理器（如 Sass 或 Less）</h3><p>通过编写变量和函数来实现</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs less">$base-<span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;<br><br><span class="hljs-variable">@function</span> px2rem($px) &#123;<br>  <span class="hljs-variable">@return</span> $px / $base-font-size * <span class="hljs-number">1rem</span>;<br>&#125;<br><br>.example &#123;<br>  <span class="hljs-attribute">font-size</span>: px2rem(<span class="hljs-number">24px</span>); <span class="hljs-comment">// 1.5rem</span><br>  <span class="hljs-attribute">width</span>: px2rem(<span class="hljs-number">200px</span>); <span class="hljs-comment">// 12.5rem</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用-postcss-插件"><a href="#使用-postcss-插件" class="headerlink" title="使用 postcss 插件"></a>使用 postcss 插件</h3><h4 id="关于-postcss"><a href="#关于-postcss" class="headerlink" title="关于 postcss"></a>关于 postcss</h4><p>PostCSS 是一个用于转换 CSS 的工具，可以通过插件来实现以下功能：</p><ul><li>自动补全浏览器前缀（autoprefixer）</li><li>优化 CSS： cssnano 可以进行压缩，purgecss 可以删除未使用的 CSS。</li></ul><p>常用的单位转换插件包括 postcss-pxtorem 和 postcss-plugin-px2rem。配置插件后，它会自动将 CSS 文件中的 px 单位转换为 rem。</p><p>如果想实现整个项目自动将 px 转为 rem，主要有两个步骤</p><h4 id="1-根元素挂载-font-size-样式"><a href="#1-根元素挂载-font-size-样式" class="headerlink" title="1.根元素挂载 font-size 样式"></a>1.根元素挂载 font-size 样式</h4><p>rem 单位是相对于根节点的字体大小的，所以需要设置根节点的字体大小。当窗口大小调整时，通过调整根节点的字体大小来实现自适应。</p><p>实现代码如下（一般来说设计稿都是 750 的宽度）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span> (<span class="hljs-params">designWidth, maxWidth</span>) &#123;<br>  <span class="hljs-keyword">var</span> doc = <span class="hljs-variable language_">document</span>,<br>    timer;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">refreshRem</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> width = doc.<span class="hljs-property">documentElement</span>.<span class="hljs-title function_">getBoundingClientRect</span>().<span class="hljs-property">width</span>;<br>    <span class="hljs-comment">// *** 一定程度的适配pc ***</span><br>    <span class="hljs-keyword">var</span> rem;<br>    <span class="hljs-keyword">if</span> (width &gt; maxWidth) &#123;<br>      rem = <span class="hljs-number">72</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      rem = (width * <span class="hljs-number">100</span>) / designWidth;<br>    &#125;<br>    <span class="hljs-comment">// *** 适配pc结束 ***</span><br>    doc.<span class="hljs-property">documentElement</span>.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = rem + <span class="hljs-string">&quot;px&quot;</span>;<br>  &#125;<br>  <span class="hljs-comment">// rem初始化开始</span><br>  <span class="hljs-title function_">refreshRem</span>();<br>  <span class="hljs-comment">// 改变窗口大小时重新设置 rem</span><br>  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<br>    <span class="hljs-string">&quot;resize&quot;</span>,<br>    <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timer); <span class="hljs-comment">//防止执行两次</span><br>      timer = <span class="hljs-built_in">setTimeout</span>(refreshRem, <span class="hljs-number">300</span>);<br>    &#125;,<br>    <span class="hljs-literal">false</span><br>  );<br>  <span class="hljs-comment">// 浏览器后退的时候重新计算</span><br>  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<br>    <span class="hljs-string">&quot;pageshow&quot;</span>,<br>    <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>      <span class="hljs-comment">// 页面从缓存加载时</span><br>      <span class="hljs-keyword">if</span> (e.<span class="hljs-property">persisted</span>) &#123;<br>        <span class="hljs-built_in">clearTimeout</span>(timer);<br>        timer = <span class="hljs-built_in">setTimeout</span>(refreshRem, <span class="hljs-number">300</span>);<br>      &#125;<br>    &#125;,<br>    <span class="hljs-literal">false</span><br>  );<br>&#125;)(<span class="hljs-number">750</span>, <span class="hljs-number">540</span>);<br></code></pre></td></tr></table></figure><p>将这段 js 引入到项目的入口文件 app.html 后，查看页面的 html 节点，是否有被自动添加 font-size。</p><h4 id="2-配置-postcss"><a href="#2-配置-postcss" class="headerlink" title="2.配置 postcss"></a>2.配置 postcss</h4><ol><li>安装 postcss-pxtorem</li><li>在项目根目录下创建一个名为 postcss.config.js 的文件，用于配置 PostCSS 插件。（如果像 nuxt 的项目已经安装了 postcss，可以直接在 nuxt.config.js 文件里配置</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">plugins</span>: &#123;<br>    <span class="hljs-string">&quot;postcss-pxtorem&quot;</span>: &#123;<br>      <span class="hljs-attr">rootValue</span>: <span class="hljs-number">50</span>,<br>      <span class="hljs-attr">propList</span>: [<span class="hljs-string">&quot;*&quot;</span>],<br>    &#125;,<br>    <span class="hljs-attr">autoprefixer</span>: &#123;&#125;,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="备注：viewpoint-适配方法"><a href="#备注：viewpoint-适配方法" class="headerlink" title="备注：viewpoint 适配方法"></a>备注：viewpoint 适配方法</h3><p>到这里 rem 适配方法已经结束了。现在更为流行的是使用 vw、vh 单位进行适配。但满屏的宽度为 100vw，与设计稿的 750 进行手动换算还是比较麻烦。所以仍需要一些适配操作。原理大体同 rem 类似，主要两种：</p><ol><li>使用 CSS 预处理器（如 Sass 或 Less）</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@windowWidth:</span> <span class="hljs-number">100vw</span>;<br><span class="hljs-selector-class">.rpxToVW</span>(<span class="hljs-variable">@name</span>,<span class="hljs-variable">@rpx</span>) &#123;<br>  <span class="hljs-comment">//传入不带单位的rpx数值，将rpx转为vw</span><br>  @&#123;name&#125;: <span class="hljs-selector-tag">unit</span>(<span class="hljs-variable">@rpx</span> / <span class="hljs-number">750</span> * <span class="hljs-variable">@windowWidth</span>, vw);<br>&#125;<br><span class="hljs-selector-class">.taskBlock</span> &#123;<br>  <span class="hljs-selector-class">.rpxToVW</span>(margin,<span class="hljs-number">20</span>);<br>  <span class="hljs-selector-class">.rpxToVW</span>(padding,<span class="hljs-number">30</span>);<br>  <span class="hljs-selector-class">.rpxToVW</span>(border-radius,<span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>postcss</li></ol><ul><li>安装 postcss-px-to-viewport</li><li>在根目录新建一个名为 postcss.config.js 的文件</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">plugins</span>: &#123;<br>    <span class="hljs-string">&quot;postcss-px-to-viewport&quot;</span>: &#123;<br>      <span class="hljs-attr">unitToConvert</span>: <span class="hljs-string">&quot;px&quot;</span>, <span class="hljs-comment">// 要转化的单位</span><br>      <span class="hljs-attr">viewportWidth</span>: <span class="hljs-number">375</span>, <span class="hljs-comment">// UI设计稿的宽度</span><br>      <span class="hljs-attr">unitPrecision</span>: <span class="hljs-number">6</span>, <span class="hljs-comment">// 转换后的精度，即小数点位数</span><br>      <span class="hljs-attr">propList</span>: [<span class="hljs-string">&quot;*&quot;</span>], <span class="hljs-comment">// 指定转换的css属性的单位，*代表全部css属性的单位都进行转换</span><br>      <span class="hljs-attr">viewportUnit</span>: <span class="hljs-string">&quot;vw&quot;</span>, <span class="hljs-comment">// 指定需要转换成的视窗单位，默认vw</span><br>      <span class="hljs-attr">fontViewportUnit</span>: <span class="hljs-string">&quot;vw&quot;</span>, <span class="hljs-comment">// 指定字体需要转换成的视窗单位，默认vw</span><br>      <span class="hljs-attr">selectorBlackList</span>: [<span class="hljs-string">&quot;wrap&quot;</span>], <span class="hljs-comment">// 指定不转换为视窗单位的类名，</span><br>      <span class="hljs-attr">minPixelValue</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">// 默认值1，小于或等于1px则不进行转换</span><br>      <span class="hljs-attr">mediaQuery</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否在媒体查询的css代码中也进行转换，默认false</span><br>      <span class="hljs-attr">replace</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否转换后直接更换属性值</span><br>      <span class="hljs-attr">exclude</span>: [<span class="hljs-regexp">/node_modules/</span>], <span class="hljs-comment">// 设置忽略文件，用正则做目录名匹配</span><br>    &#125;,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>备注： webpack 5 版本 postcss 配置书写方式有差别，从对象形式变为函数形式，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;postcss-px-to-viewport&quot;</span>)(&#123;<br>      <span class="hljs-attr">unitToConvert</span>: <span class="hljs-string">&quot;px&quot;</span>, <span class="hljs-comment">// 要转化的单位</span><br>      <span class="hljs-attr">viewportWidth</span>: <span class="hljs-number">375</span>, <span class="hljs-comment">// UI设计稿的宽度</span><br>      <span class="hljs-attr">unitPrecision</span>: <span class="hljs-number">6</span>, <span class="hljs-comment">// 转换后的精度，即小数点位数</span><br>      <span class="hljs-attr">propList</span>: [<span class="hljs-string">&quot;*&quot;</span>], <span class="hljs-comment">// 指定转换的css属性的单位，*代表全部css属性的单位都进行转换</span><br>      <span class="hljs-attr">viewportUnit</span>: <span class="hljs-string">&quot;vw&quot;</span>, <span class="hljs-comment">// 指定需要转换成的视窗单位，默认vw</span><br>      <span class="hljs-attr">fontViewportUnit</span>: <span class="hljs-string">&quot;vw&quot;</span>, <span class="hljs-comment">// 指定字体需要转换成的视窗单位，默认vw</span><br>      <span class="hljs-attr">minPixelValue</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">// 默认值1，小于或等于1px则不进行转换</span><br>      <span class="hljs-attr">mediaQuery</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否在媒体查询的css代码中也进行转换，默认false</span><br>      <span class="hljs-attr">replace</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否转换后直接更换属性值</span><br>      <span class="hljs-attr">selectorBlackList</span>: [<span class="hljs-string">&quot;wrap&quot;</span>], <span class="hljs-comment">// 指定不转换为视窗单位的类名</span><br>      <span class="hljs-attr">exclude</span>: [<span class="hljs-regexp">/node_modules/</span>, <span class="hljs-regexp">/src\/views/</span>, <span class="hljs-regexp">/src\/components/</span>, <span class="hljs-regexp">/src\/App/</span>], <span class="hljs-comment">// 设置忽略文件，用正则做目录名匹配</span><br>    &#125;),<br>    <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;autoprefixer&quot;</span>)(),<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://juejin.cn/post/6844903557930418189?searchId=202308281046059EA791D01FCE5880F623">Vue 项目自动转换 px 为 rem，高保真还原设计图</a></li><li><a href="https://juejin.cn/post/7061866685166256142?searchId=2023082811284766FD14F856BCD7817236">移动端适配解决方案(二)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>工作技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>postcss</tag>
      
      <tag>rem</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈WEB前端性能监控</title>
    <link href="/unknown404.github.io/2023/08/25/performanceMonitor/"/>
    <url>/unknown404.github.io/2023/08/25/performanceMonitor/</url>
    
    <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>前端页面性能对用户留存、用户直观体验有着重要影响。有调查显示，当页面加载时间超过 2 秒后，加载时间每增加一秒，就会有大量的用户流失，所以做好页面性能优化，无疑对网站来说是一个非常重要的步骤。</p><h2 id="二、前端性能评判指标"><a href="#二、前端性能评判指标" class="headerlink" title="二、前端性能评判指标"></a>二、前端性能评判指标</h2><p>对于 Web 开发人员来说，如何衡量一个 Web 页面的性能一直是一个难题。在这一方面，谷歌团队一直致力于提供各种质量信号的统一指南。</p><h3 id="2-1-核心-Web-指标"><a href="#2-1-核心-Web-指标" class="headerlink" title="2.1 核心 Web 指标"></a>2.1 核心 Web 指标</h3><p>核心 Web 指标旨在适用于所有网页，反映出以用户为中心的结果。该指标并不是固定不变的。2020 年谷歌团队从加载性能、交互性和视觉稳定性方面考虑提出了 3 个核心 Web 指标：最大内容绘制（LCP）、首次输入延迟（FID）、累积布局偏移（CLS）</p><p><img src="/unknown404.github.io/img/performanceMonitor/web_vital.png"></p><h4 id="2-1-1-最大内容绘制（Largest-Contentful-Paint-LCP）"><a href="#2-1-1-最大内容绘制（Largest-Contentful-Paint-LCP）" class="headerlink" title="2.1.1 最大内容绘制（Largest Contentful Paint, LCP）"></a>2.1.1 最大内容绘制（Largest Contentful Paint, LCP）</h4><p>定义：页面首次开始加载时可视区域内可见的最大图像或文本块完成渲染的相对时间。</p><p>LCP 考量的元素类型为：</p><ul><li><p><code>&lt;img&gt;</code>元素</p></li><li><p>内嵌在<code>&lt;svg&gt;</code>元素内的<code>&lt;image&gt;</code>元素</p></li><li><p><code>&lt;video&gt;</code>元素（使用封面图像）</p></li><li><p>通过 url()函数（而非使用 CSS 渐变）加载的带有背景图像的元素</p></li><li><p>包含文本节点或其他行内级文本元素子元素的块级元素。</p></li></ul><h4 id="2-1-2-首次输入延迟（First-Input-Delay-FID）"><a href="#2-1-2-首次输入延迟（First-Input-Delay-FID）" class="headerlink" title="2.1.2 首次输入延迟（First Input Delay, FID）"></a>2.1.2 首次输入延迟（First Input Delay, FID）</h4><p>定义：用户第一次与页面交互（例如当他们单击链接、点按按钮或使用由 JavaScript 驱动的自定义控件）直到浏览器对交互作出响应、并实际开始处理事件处理程序所经过的时间。</p><p>特点：</p><ul><li><p>需要在真实用户环境下测量</p></li><li><p>实际数据与预期可能会有差距较大的情况。真实环境下会出现几种可能性：</p></li></ul><p>a）并非所有用户都会在每次访问您的网站时进行交互。用户发出的交互可能与 FID 无关（如滚动和缩放之类的交互）-&gt; FID 没有值</p><p>b）一些用户的首次交互会处于不利的时间段内（当主线程长时间处于繁忙时）-&gt; FID 值较高</p><p>c）一些用户的首次交互会处于有利的时间段内（当主线程完全空闲时）-&gt; FID 值较低</p><p>由于 FID 值的预期差异，在查看 FID 上报数据时主要关注值的分布并注意较高的百分位数</p><h4 id="2-1-3-累积布局偏移（Cumulative-Layout-Shift-CLS）"><a href="#2-1-3-累积布局偏移（Cumulative-Layout-Shift-CLS）" class="headerlink" title="2.1.3 累积布局偏移（Cumulative Layout Shift, CLS）"></a>2.1.3 累积布局偏移（Cumulative Layout Shift, CLS）</h4><p>定义：整个页面生命周期内发生的所有单次布局偏移分数的总和。</p><p>计算方式：</p><p><em>布局偏移分数 &#x3D; 影响分数 * 距离分数</em></p><p><em>布局偏移分数得分范围 0-1，0 表示没有偏移，1 表示最大偏移</em></p><p><strong>影响分数</strong></p><p>影响分数测量 <em>不稳定元素</em> 对两帧之间的可视区域产生的影响。</p><p>前一帧 <em>和</em> 当前帧的所有 <em>不稳定元素</em> 的可见区域集合（占总可视区域的部分）就是当前帧的 <em>影响分数</em> 。</p><p><img src="/unknown404.github.io/img/performanceMonitor/cls.png"></p><p>在上图中，有一个元素在一帧中占据了一半的可视区域。接着，在下一帧中，元素下移了可视区域高度的 25%。红色虚线矩形框表示两帧中元素的可见区域集合，在本示例中，该集合占总可视区域的 75%，因此其 <em>影响分数</em> 为 0.75 。</p><p><strong>距离分数</strong></p><p>布局偏移分数计算公式的另一部分测量不稳定元素相对于可视区域位移的距离。 <em>距离分数</em> 指的是任何 <em>不稳定元素</em> 在一帧中位移的最大距离（水平或垂直）除以可视区域的最大尺寸维度（宽度或高度，以较大者为准）。</p><p>在刚才的示例中，最大的可视区域尺寸维度是高度，不稳定元素的位移距离为可视区域高度的 25%，因此 <em>距离分数</em> 为 0.25。</p><p>所以，在这个示例中， <em>影响分数</em> 是 0.75 ， <em>距离分数</em> 是 0.25 ，所以 <em>布局偏移分数</em> 是 0.75 * 0.25 &#x3D; 0.1875</p><h3 id="2-2-Web-指标"><a href="#2-2-Web-指标" class="headerlink" title="2.2 Web 指标"></a>2.2 Web 指标</h3><p>除了核心 Web 指标外，还有其他的指标也可用于加载、交互等性能评估</p><h4 id="2-2-1-文档加载相关指标"><a href="#2-2-1-文档加载相关指标" class="headerlink" title="2.2.1 文档加载相关指标"></a>2.2.1 文档加载相关指标</h4><h5 id="第一字节时间（Time-to-First-Byte，TTFB）"><a href="#第一字节时间（Time-to-First-Byte，TTFB）" class="headerlink" title="第一字节时间（Time to First Byte，TTFB）"></a>第一字节时间（Time to First Byte，TTFB）</h5><p>浏览器从请求页面开始到接收第一字节的时间，这个时间段内包括 DNS 查找、TCP 连接和发出请求直到响应的第一个字节到达为止的时延。<br><img src="/unknown404.github.io/img/performanceMonitor/performancetiming.png"></p><p><img src="/unknown404.github.io/img/performanceMonitor/ttfb.png"></p><h5 id="DOM-解析完成时间（DOMContentLoaded，DCL）"><a href="#DOM-解析完成时间（DOMContentLoaded，DCL）" class="headerlink" title="DOM 解析完成时间（DOMContentLoaded，DCL）"></a>DOM 解析完成时间（DOMContentLoaded，DCL）</h5><p>DomContentLoaded 事件触发的时间。当 **HTML 文档被完全加载和解析完成之后，DOMContentLoaded ** 事件被触发，而无需等待样式表、图像和子框架加载完成。早期网络性能的测量参量</p><h5 id="页面加载耗时（Load，L）"><a href="#页面加载耗时（Load，L）" class="headerlink" title="页面加载耗时（Load，L）"></a>页面加载耗时（Load，L）</h5><p>onLoad 事件触发的时间。页面所有资源都加载完毕后（比如图片，CSS），onLoad 事件才被触发。早期网络性能的测量参量</p><h4 id="2-2-2-内容呈现相关指标"><a href="#2-2-2-内容呈现相关指标" class="headerlink" title="2.2.2 内容呈现相关指标"></a>2.2.2 内容呈现相关指标</h4><h5 id="首次绘制（-First-Paint，FP）"><a href="#首次绘制（-First-Paint，FP）" class="headerlink" title="首次绘制（ First Paint，FP）"></a>首次绘制（ First Paint，FP）</h5><p>从开始加载到浏览器 <strong>首次绘制像素</strong> 到屏幕上的时间，也就是页面在屏幕上首次发生视觉变化的时间。但此变化可能是简单的背景色更新或不引人注意的内容，它并不表示页面内容完整性，可能会报告没有任何可见的内容被绘制的时间。</p><h5 id="首次内容绘制-（First-Contentful-Paint，FCP）"><a href="#首次内容绘制-（First-Contentful-Paint，FCP）" class="headerlink" title="首次内容绘制 （First Contentful Paint，FCP）"></a>首次内容绘制 （First Contentful Paint，FCP）</h5><p>浏览器 <strong>首次绘制来自 DOM 的内容</strong> 的时间，内容必须是文本、图片（包含背景图）、非白色的 canvas 或 SVG，也包括带有正在加载中的 Web 字体的文本。</p><p>这是用户第一次开始看到页面内容，但仅仅有内容，并不意味着它是有用的内容（例如 Header、导航栏等），也不意味着有用户要消费的内容。</p><p><strong>辨析：FCP 和 LCP 区别</strong></p><p>FCP：第一次看到的内容，不一定有用</p><p>LCP：最大内容，在页面加载过程中对应的元素是会发生变化的</p><p><img src="/unknown404.github.io/img/performanceMonitor/fcpvslcp.png"></p><h4 id="2-2-3-交互响应性相关指标"><a href="#2-2-3-交互响应性相关指标" class="headerlink" title="2.2.3 交互响应性相关指标"></a>2.2.3 交互响应性相关指标</h4><h5 id="可交互时间（Time-to-Interactive，TTI）"><a href="#可交互时间（Time-to-Interactive，TTI）" class="headerlink" title="可交互时间（Time to Interactive，TTI）"></a>可交互时间（Time to Interactive，TTI）</h5><p>表示网页第一次 <strong>完全达到可交互状态</strong> 的时间点，浏览器已经可以持续性的响应用户的输入。完全达到可交互状态的时间点是在最后一个长任务（Long Task）完成的时间, 并且在随后的 5 秒内网络和主线程是空闲的。</p><p><img src="/unknown404.github.io/img/performanceMonitor/tti.png"></p><h2 id="三、性能监控模式"><a href="#三、性能监控模式" class="headerlink" title="三、性能监控模式"></a>三、性能监控模式</h2><p>从技术方面来讲，前端性能监控主要分为两种方式，一种叫做合成监控（Synthetic Monitoring，SYN），另一种是真实用户监控（Real User Monitoring，RUM）。</p><p>合成监控：在一个模拟场景里，去提交一个需要做性能审计的页面，通过一系列的工具、规则去运行你的页面，提取一些性能指标，得出一个审计报告。</p><p>真实用户监控：在用户结束页面访问的时候，把此次访问产生的性能指标上传到日志服务器、进行数据的提取清洗加工，最后在监控平台上进行展示。</p><table><thead><tr><th align="center"></th><th align="center">合成监控</th><th align="center">真实用户监控</th></tr></thead><tbody><tr><td align="center">实现难度及成本</td><td align="center">较低</td><td align="center">较高</td></tr><tr><td align="center">采集数据丰富度</td><td align="center">丰富</td><td align="center">基础</td></tr><tr><td align="center">数据样本量</td><td align="center">较小</td><td align="center">较大</td></tr><tr><td align="center">是否有侵入性</td><td align="center">否</td><td align="center">是</td></tr></tbody></table><h3 id="3-1-合成监控"><a href="#3-1-合成监控" class="headerlink" title="3.1 合成监控"></a>3.1 合成监控</h3><p>常见工具： <strong>Lighthouse、PageSpeed、 WebPageTest</strong></p><h4 id="自研合成监控方案"><a href="#自研合成监控方案" class="headerlink" title="自研合成监控方案"></a>自研合成监控方案</h4><p>目前常见的合成监控的实现方案为在服务端通过 Puppeteer 访问检测页面，调用 Lighthouse 获取相应指标，计算目标得分并将结果保存在数据库，同时提供给前台页面进行可视化展示。</p><p><strong>Puppeteer</strong></p><p>一个 Node 库，它提供了一个高级 API 来通过 DevTools 协议控制 Chrome。利用 Puppeteer 可以生成一个 Browser 对象，Browser 可以拥有多个页面对象。</p><p><strong>Lighthouse</strong></p><p>Lighthouse 是 Google 开源的自动化工具，用于改进网络应用的质量。它可以作为一个 Chrome 扩展程序运行，或从命令行运行。只需要为 Lighthouse 提供一个要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告，从中看看可以采取哪些措施来改进应用。</p><p><img src="/unknown404.github.io/img/performanceMonitor/lighthouse.png"></p><p>Lighthouse 由这几部分组成</p><p>Driver（驱动）—— 通过 Chrome Debugging Protocol 和 Chrome 进行交互。</p><p>Gatherer（采集器）—— 决定在页面加载过程中采集哪些信息，将采集的信息输出为 Artifact。可自定义。</p><p>Audit（审查器）—— 将 Gatherer 采集的 Artifact 作为输入，审查器会对其测试，然后得出相应的测评结果。可自定义。</p><p>Report（报告）—— 将审查的结果通过指定的方式报告出来。</p><p>合成监控的大致流程为：建立连接-&gt; 收集数据-&gt; 评估结果-&gt; 生成报告-&gt; 数据存储</p><h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><p>利用 Puppeteer 启动一个无头浏览器，打开一个空白页面。利用 Page 对象的 goto 方法打开目标 URL。然后将 Puppeteer 移交给 Lighthouse，实现方式就是确保 Puppeteer 和 lighthouse 启动时使用同一个端口号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> browser = <span class="hljs-keyword">await</span> puppeteer.<span class="hljs-title function_">launch</span>(); <span class="hljs-comment">//生成browser实例</span><br><span class="hljs-keyword">const</span> page = <span class="hljs-keyword">await</span> browser.<span class="hljs-title function_">newPage</span>(); <span class="hljs-comment">//解析一个新的页面。</span><br><span class="hljs-keyword">await</span> page.<span class="hljs-title function_">goto</span>(url); <span class="hljs-comment">//跳转到 目标url</span><br><span class="hljs-keyword">const</span> options = &#123;<br>  <span class="hljs-attr">logLevel</span>: <span class="hljs-string">&quot;info&quot;</span>,<br>  <span class="hljs-attr">output</span>: <span class="hljs-string">&quot;html&quot;</span>,<br>  <span class="hljs-attr">port</span>: <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(browser.<span class="hljs-title function_">wsEndpoint</span>()).<span class="hljs-property">port</span>,<br>&#125;;<br><span class="hljs-keyword">const</span> runnerResult = <span class="hljs-keyword">await</span> <span class="hljs-title function_">lighthouse</span>(url, options);<br></code></pre></td></tr></table></figure><p>移交之后 Lighthouse 通过 Chrome DevTools Protocol 定义的主动指令与事件通知，就实现了操控 Chrome 浏览器，和感知页面加载过程中的各个事件。</p><h4 id="收集数据"><a href="#收集数据" class="headerlink" title="收集数据"></a>收集数据</h4><p>lighthouse 默认会调用 css-usage、js-usage、viewport-dimensions 等采集器获取数据，同时我们也可以自己设置采集器。所有的采集器继承同一父类 Gatherer，其内部结构为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Gatherer</span> &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">keyof LH.GathererArtifacts</span>&#125;</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>() &#123;<br>    <span class="hljs-comment">// @ts-expect-error - assume that class name has been added to LH.GathererArtifacts.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">constructor</span>.<span class="hljs-property">name</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 在页面导航前触发</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">LH.Gatherer.PassContext</span>&#125; <span class="hljs-variable">passContext</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">LH.Gatherer.PhaseResult</span>&#125;</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">beforePass</span>(<span class="hljs-params">passContext</span>) &#123;&#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 在页面加载完后</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">LH.Gatherer.PassContext</span>&#125; <span class="hljs-variable">passContext</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">LH.Gatherer.PhaseResult</span>&#125;</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">pass</span>(<span class="hljs-params">passContext</span>) &#123;&#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 在页面加载完毕，且gatherer全部执行完成</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">LH.Gatherer.PassContext</span>&#125; <span class="hljs-variable">passContext</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">LH.Gatherer.LoadData</span>&#125; <span class="hljs-variable">loadData</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">LH.Gatherer.PhaseResult</span>&#125;</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">afterPass</span>(<span class="hljs-params">passContext, loadData</span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中只需要重点关注 3 个钩子方法：beforePass、pass、afterPass，Artifact 取最后一次 Hook 输出的结果，e.g.当 afterPass 未吐出，则采用 pass 结果，以此类推。</p><p>以收集器 viewport-dimensions 为例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewportDimensions</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Gatherer</span> &#123;<br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">afterPass</span>(<span class="hljs-params">passContext</span>) &#123;<br>    <span class="hljs-keyword">const</span> driver = passContext.<span class="hljs-property">driver</span>;<br>    <span class="hljs-keyword">const</span> dimensions = <span class="hljs-keyword">await</span> driver.<span class="hljs-property">executionContext</span>.evaluate(<br>      <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>          <span class="hljs-attr">innerWidth</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>,<br>          <span class="hljs-attr">innerHeight</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>,<br>          <span class="hljs-attr">outerWidth</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">outerWidth</span>,<br>          <span class="hljs-attr">outerHeight</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">outerHeight</span>,<br>          <span class="hljs-attr">devicePixelRatio</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span>,<br>        &#125;;<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">args</span>: [],<br>        <span class="hljs-attr">useIsolation</span>: <span class="hljs-literal">true</span>,<br>      &#125;<br>    );<br><br>    <span class="hljs-keyword">const</span> allNumeric = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(dimensions).<span class="hljs-title function_">every</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-property">isFinite</span>);<br>    <span class="hljs-keyword">if</span> (!allNumeric) &#123;<br>      <span class="hljs-keyword">const</span> results = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(dimensions);<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<br>        <span class="hljs-string">`ViewportDimensions results were not numeric: <span class="hljs-subst">$&#123;results&#125;</span>`</span><br>      );<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dimensions;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所有 gatherers 运行完后，就会生成一个中间产物 artifacts，此后 Lighthouse 就可以断开与浏览器的连接，只使用 artifacts 进行后续的分析。</p><h4 id="评估结果"><a href="#评估结果" class="headerlink" title="评估结果"></a>评估结果</h4><p>审查器将 gather 传来的 artifacts 作为输入进行分数评估操作。和采集器一样，lighthouse 提供标准的审查器，我们可以在继承标准审查器的基础上写自己的审查器，在自己的审查器里，我们通常会用到两个方法：一个是 meta，一个是 audit。meta 方法返回一个对象，该对象包含了该审查器的信息，特别注意的是 requiredArtifacts 字段和 id 字段，requiredArtifacts 字段的值对应着相对应的采集器，id 对应着 config 文件中对应的 audits 数组的内容。audit 方法返回一个对象，内容为这次审查的最终结果，包括 score、details 等字段。</p><p>以利用收集器 viewport-dimensions 数据的审查器 content-width 为例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ContentWidth</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Audit</span> &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">LH.Audit.Meta</span>&#125;</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">get</span> <span class="hljs-title function_">meta</span>() &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;content-width&quot;</span>,<br>      <span class="hljs-comment">// 审查通过时的标题</span><br>      <span class="hljs-attr">title</span>: <span class="hljs-title function_">str_</span>(<span class="hljs-title class_">UIStrings</span>.<span class="hljs-property">title</span>),<br>      <span class="hljs-comment">// 审查失败时的标题</span><br>      <span class="hljs-attr">failureTitle</span>: <span class="hljs-title function_">str_</span>(<span class="hljs-title class_">UIStrings</span>.<span class="hljs-property">failureTitle</span>),<br>      <span class="hljs-comment">//标题下关于该指标的描述</span><br>      <span class="hljs-attr">description</span>: <span class="hljs-title function_">str_</span>(<span class="hljs-title class_">UIStrings</span>.<span class="hljs-property">description</span>),<br>      <span class="hljs-attr">requiredArtifacts</span>: [<span class="hljs-string">&quot;ViewportDimensions&quot;</span>],<br>    &#125;;<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">LH.Artifacts</span>&#125; <span class="hljs-variable">artifacts</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">LH.Audit.Context</span>&#125; <span class="hljs-variable">context</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">LH.Audit.Product</span>&#125;</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">audit</span>(<span class="hljs-params">artifacts, context</span>) &#123;<br>    <span class="hljs-keyword">const</span> viewportWidth = artifacts.<span class="hljs-property">ViewportDimensions</span>.<span class="hljs-property">innerWidth</span>;<br>    <span class="hljs-keyword">const</span> windowWidth = artifacts.<span class="hljs-property">ViewportDimensions</span>.<span class="hljs-property">outerWidth</span>;<br>    <span class="hljs-keyword">const</span> widthsMatch = viewportWidth === windowWidth;<br>    <span class="hljs-keyword">if</span> (context.<span class="hljs-property">settings</span>.<span class="hljs-property">formFactor</span> === <span class="hljs-string">&quot;desktop&quot;</span>) &#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">score</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">notApplicable</span>: <span class="hljs-literal">true</span>,<br>      &#125;;<br>    &#125;<br>    <span class="hljs-keyword">let</span> explanation;<br>    <span class="hljs-keyword">if</span> (!widthsMatch) &#123;<br>      explanation = <span class="hljs-title function_">str_</span>(<span class="hljs-title class_">UIStrings</span>.<span class="hljs-property">explanation</span>, &#123;<br>        <span class="hljs-attr">innerWidth</span>: artifacts.<span class="hljs-property">ViewportDimensions</span>.<span class="hljs-property">innerWidth</span>,<br>        <span class="hljs-attr">outerWidth</span>: artifacts.<span class="hljs-property">ViewportDimensions</span>.<span class="hljs-property">outerWidth</span>,<br>      &#125;);<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">score</span>: <span class="hljs-title class_">Number</span>(widthsMatch),<br>      explanation,<br>    &#125;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="生成报告"><a href="#生成报告" class="headerlink" title="生成报告"></a>生成报告</h4><p>审查器的分数结果并不是最终出现在报告的结果，报告是以测试类别 category 为统计结果，配置文件会定义每个测试类别所需的审计项及其分数所占的权重。以 performance 为例，其权重设置为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&#x27;performance&#x27;</span>: &#123;<br>    <span class="hljs-attr">title</span>: <span class="hljs-title function_">str_</span>(<span class="hljs-title class_">UIStrings</span>.<span class="hljs-property">performanceCategoryTitle</span>),<br>    <span class="hljs-attr">auditRefs</span>: [<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;first-contentful-paint&#x27;</span>, <span class="hljs-attr">weight</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">group</span>: <span class="hljs-string">&#x27;metrics&#x27;</span>&#125;,<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;interactive&#x27;</span>, <span class="hljs-attr">weight</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">group</span>: <span class="hljs-string">&#x27;metrics&#x27;</span>&#125;,<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;speed-index&#x27;</span>, <span class="hljs-attr">weight</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">group</span>: <span class="hljs-string">&#x27;metrics&#x27;</span>&#125;,<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;total-blocking-time&#x27;</span>, <span class="hljs-attr">weight</span>: <span class="hljs-number">30</span>, <span class="hljs-attr">group</span>: <span class="hljs-string">&#x27;metrics&#x27;</span>&#125;,<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;largest-contentful-paint&#x27;</span>, <span class="hljs-attr">weight</span>: <span class="hljs-number">25</span>, <span class="hljs-attr">group</span>: <span class="hljs-string">&#x27;metrics&#x27;</span>&#125;,<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;cumulative-layout-shift&#x27;</span>, <span class="hljs-attr">weight</span>: <span class="hljs-number">15</span>, <span class="hljs-attr">group</span>: <span class="hljs-string">&#x27;metrics&#x27;</span>&#125;,<br>    <span class="hljs-comment">// 省略</span><br>    ]<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>content-width 审查结果在报告中的展示：</p><p><img src="/unknown404.github.io/img/performanceMonitor/content_width.png"></p><h3 id="3-2-真实用户监控"><a href="#3-2-真实用户监控" class="headerlink" title="3.2 真实用户监控"></a>3.2 真实用户监控</h3><h4 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h4><p>数据的收集主要利用浏览器提供的 API，performance 提供了多种 API，不同的 API 之间可能会有重叠的部分。</p><h5 id="PerformanceTiming-数据收集"><a href="#PerformanceTiming-数据收集" class="headerlink" title="PerformanceTiming 数据收集"></a>PerformanceTiming 数据收集</h5><p>performance.getEntriesByType(“navigation”)：可返回从输入 url 到用户可以使用页面的全过程时间统计，单位均为毫秒。（该数据也可通过 new PerformanceObserver.observe(‘navigation’, entryHandler)获取）</p><p><img src="/unknown404.github.io/img/performanceMonitor/performancetiming.png"></p><p>TTFB：responseStart - requestStart</p><p>DCL：domContentLoadedEventEnd - fetchStart</p><p>L：loadEventStart - fetchStart</p><p>performance.getEntriesByType(‘paint’)：可返回 FP 和 FCP 两个时间点的值（该数据也可通过 new PerformanceObserver.observe(‘paint’, entryHandler)获取）</p><p><img src="/unknown404.github.io/img/performanceMonitor/example.png"></p><p><strong>PerformanceObserver API 相关的数据收集</strong></p><p><strong>LCP</strong></p><p>利用 PerformanceObserver API 可获取 LCP 相关的信息。由于页面转移到后台后，PerformanceObserver API 仍会继续分发 largest-contentful-paint 条目，所以这部分的数据不能做考虑。如果发生页面隐藏、输入事件(用户的交互行为可能会导致页面元素的可见性变化)则停止 PerformanceObserver 的性能监听，计算 LCP；由于最大内容可能随加载变化，所以选取最后一个作为本次页面加载的 lcp 的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getLCP</span> = (<span class="hljs-params">lcp</span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isPerformanceObserverSupported</span>()) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&quot;browser do not support performanceObserver&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> firstHiddenTime = <span class="hljs-title function_">getFirstHiddenTime</span>();<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">entryHandler</span> = (<span class="hljs-params">entry</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">startTime</span> &lt; firstHiddenTime.<span class="hljs-property">timeStamp</span>) &#123;<br>      lcp.<span class="hljs-property">value</span> = entry;<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">observe</span>(<span class="hljs-string">&quot;largest-contentful-paint&quot;</span>, entryHandler);<br>&#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">initLCP</span> = (<span class="hljs-params">store, report, immediately = <span class="hljs-literal">true</span></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> lcp = &#123; <span class="hljs-attr">value</span>: &#123;&#125;, <span class="hljs-attr">entries</span>: [] &#125;;<br>  <span class="hljs-keyword">const</span> po = <span class="hljs-title function_">getLCP</span>(lcp);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">stopListening</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (po) &#123;<br>      <span class="hljs-keyword">if</span> (po.<span class="hljs-property">takeRecords</span>) &#123;<br>        po.<span class="hljs-title function_">takeRecords</span>().<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">entry</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">const</span> firstHiddenTime = <span class="hljs-title function_">getFirstHiddenTime</span>();<br>          <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">startTime</span> &lt; firstHiddenTime.<span class="hljs-property">timeStamp</span>) &#123;<br>            lcp.<span class="hljs-property">value</span> = entry;<br>            lcp.<span class="hljs-property">entries</span>.<span class="hljs-title function_">push</span>(entry);<br>          &#125;<br>        &#125;);<br>      &#125;<br>      po.<span class="hljs-title function_">disconnect</span>();<br><br>      <span class="hljs-keyword">if</span> (!store.<span class="hljs-title function_">has</span>(metricsName.<span class="hljs-property">LCP</span>)) &#123;<br>        <span class="hljs-keyword">const</span> value = lcp.<span class="hljs-property">value</span>;<br>        <span class="hljs-keyword">const</span> metrics = &#123;<br>          <span class="hljs-attr">name</span>: metricsName.<span class="hljs-property">LCP</span>,<br>          <span class="hljs-attr">value</span>: <span class="hljs-title function_">roundByFour</span>(value.<span class="hljs-property">startTime</span>, <span class="hljs-number">2</span>),<br>          <span class="hljs-attr">entries</span>: value,<br>        &#125;;<br><br>        <span class="hljs-keyword">if</span> (immediately) &#123;<br>          <span class="hljs-title function_">report</span>(metrics);<br>        &#125;<br><br>        store.<span class="hljs-title function_">set</span>(metricsName.<span class="hljs-property">LCP</span>, metrics);<br>      &#125;<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-title function_">onHidden</span>(stopListening, <span class="hljs-literal">true</span>);<br>  [<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-string">&quot;keydown&quot;</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">addEventListener</span>(event, stopListening, &#123; <span class="hljs-attr">once</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">capture</span>: <span class="hljs-literal">true</span> &#125;);<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>FID</strong></p><p>和 LCP 的计算类似，需要忽视页面转移到后台后 PerformanceObserver API 继续分发的 first-input 条目。first-input 条目的延迟值是通过获取条目的 startTime 和 processingStart 时间戳之间的差值来测量的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getFID</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isPerformanceObserverSupported</span>()) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&quot;browser do not support performanceObserver&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> firstHiddenTime = <span class="hljs-title function_">getFirstHiddenTime</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">eventHandler</span> = (<span class="hljs-params">entry</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">startTime</span> &lt; firstHiddenTime.<span class="hljs-property">timeStamp</span>) &#123;<br>        <span class="hljs-keyword">if</span> (po) &#123;<br>          po.<span class="hljs-title function_">disconnect</span>();<br>        &#125;<br>        <span class="hljs-title function_">resolve</span>(entry);<br>      &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">const</span> po = <span class="hljs-title function_">observe</span>(<span class="hljs-string">&quot;first-input&quot;</span>, eventHandler);<br><br>    <span class="hljs-keyword">if</span> (po) &#123;<br>      <span class="hljs-title function_">onHidden</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (po?.<span class="hljs-property">takeRecords</span>) &#123;<br>          po.<span class="hljs-title function_">takeRecords</span>().<span class="hljs-title function_">map</span>(eventHandler);<br>        &#125;<br>        po.<span class="hljs-title function_">disconnect</span>();<br>      &#125;, <span class="hljs-literal">true</span>);<br>    &#125;<br>  &#125;);<br>&#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">initFID</span> = (<span class="hljs-params">store, report, immediately = <span class="hljs-literal">true</span></span>) =&gt; &#123;<br>  <span class="hljs-title function_">getFID</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">entry</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> metrics = &#123;<br>      <span class="hljs-attr">name</span>: metricsName.<span class="hljs-property">FID</span>,<br>      <span class="hljs-attr">value</span>: <span class="hljs-title function_">roundByFour</span>(entry.<span class="hljs-property">processingStart</span> - entry.<span class="hljs-property">startTime</span>, <span class="hljs-number">2</span>),<br>    &#125;;<br><br>    <span class="hljs-keyword">if</span> (immediately) &#123;<br>      <span class="hljs-title function_">report</span>(metrics);<br>    &#125;<br><br>    store.<span class="hljs-title function_">set</span>(metricsName.<span class="hljs-property">FID</span>, metrics);<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>CLS</strong></p><p>计算 CLS 时需注意布局偏移并不总是坏事，对用户交互（单击链接、点选按钮、在搜索框中键入信息等）进行响应的布局偏移是可以被使用者所接受的。PerformanceObserver 对用户输入 500 毫秒内发生的布局偏移会带有标志，方便在计算中排除这些偏移。</p><p>在 CLS 中，有一个叫 <strong>会话窗口</strong> 的术语：一个或多个快速连续发生的单次布局偏移，每次偏移相隔的时间少于 1 秒，且整个窗口的最大持续时长为 5 秒。计算会话窗口时取所有会话窗口中的最大值作为 CLS 的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getCLS</span> = (<span class="hljs-params">cls</span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isPerformanceObserverSupported</span>()) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&quot;browser do not support performanceObserver&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">entryHandler</span> = (<span class="hljs-params">entry</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (!entry.<span class="hljs-property">hadRecentInput</span>) &#123;<br>      cls.<span class="hljs-property">value</span> += entry.<span class="hljs-property">value</span>;<br>    &#125;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">observe</span>(<span class="hljs-string">&quot;layout-shift&quot;</span>, entryHandler);<br>&#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">initCLS</span> = (<span class="hljs-params">store, report, immediately = <span class="hljs-literal">true</span></span>) =&gt; &#123;<br>  <span class="hljs-keyword">let</span> sessionValue = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> sessionEntries = [];<br>  <span class="hljs-keyword">const</span> cls = &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">entries</span>: [] &#125;;<br><br>  <span class="hljs-keyword">const</span> po = <span class="hljs-title function_">getCLS</span>(cls);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">stopListening</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (po?.<span class="hljs-property">takeRecords</span>) &#123;<br>      po.<span class="hljs-title function_">takeRecords</span>().<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">entry</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (!entry.<span class="hljs-property">hadRecentInput</span>) &#123;<br>          <span class="hljs-keyword">const</span> firstSessionEntry = sessionEntries[<span class="hljs-number">0</span>];<br>          <span class="hljs-keyword">const</span> lastSessionEntry = sessionEntries[sessionEntries.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>          <span class="hljs-keyword">if</span> (<br>            sessionValue &amp;&amp;<br>            entry.<span class="hljs-property">startTime</span> - lastSessionEntry.<span class="hljs-property">startTime</span> &lt; <span class="hljs-number">1000</span> &amp;&amp;<br>            entry.<span class="hljs-property">startTime</span> - firstSessionEntry.<span class="hljs-property">startTime</span> &lt; <span class="hljs-number">5000</span><br>          ) &#123;<br>            sessionValue += entry.<span class="hljs-property">value</span>;<br>            sessionEntries.<span class="hljs-title function_">push</span>(entry);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            sessionValue = entry.<span class="hljs-property">value</span>;<br>            sessionEntries = [entry];<br>          &#125;<br>          <span class="hljs-keyword">if</span> (sessionValue &gt; metric.<span class="hljs-property">value</span>) &#123;<br>            cls.<span class="hljs-property">value</span> = sessionValue;<br>            cls.<span class="hljs-property">entries</span> = sessionEntries;<br>          &#125;<br>        &#125;<br>      &#125;);<br>    &#125;<br>    po?.<span class="hljs-title function_">disconnect</span>();<br><br>    <span class="hljs-keyword">const</span> metrics = &#123;<br>      <span class="hljs-attr">name</span>: metricsName.<span class="hljs-property">CLS</span>,<br>      <span class="hljs-attr">value</span>: <span class="hljs-title function_">roundByFour</span>(cls.<span class="hljs-property">value</span>),<br>      <span class="hljs-attr">entries</span>: cls.<span class="hljs-property">entries</span>,<br>    &#125;;<br><br>    <span class="hljs-keyword">if</span> (immediately) &#123;<br>      <span class="hljs-title function_">report</span>(metrics);<br>    &#125;<br><br>    store.<span class="hljs-title function_">set</span>(metricsName.<span class="hljs-property">CLS</span>, metrics);<br>  &#125;;<br><br>  <span class="hljs-title function_">onHidden</span>(stopListening, <span class="hljs-literal">true</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="数据上报"><a href="#数据上报" class="headerlink" title="数据上报"></a>数据上报</h4><p><strong>上报时机</strong>：可以选择拿到数据后立即上报，也可以等用户页面操作结束、关闭隐藏页面时上报</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">[beforeUnload, unload, onHidden].<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">fn</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> metrics = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getCurrentMetrics</span>();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(metrics).<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> &amp;&amp; !immediately) &#123;<br>      <span class="hljs-title function_">reporter</span>(metrics);<br>    &#125;<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>上报方式</strong></p><table><thead><tr><th align="center"></th><th align="center">img 请求</th><th align="center">fetch&#x2F;xhr</th><th align="center">navigator.sendBeacon()</th></tr></thead><tbody><tr><td align="center">优点</td><td align="center">兼容性</td><td align="center">兼容性</td><td align="center">不丢点不延迟加载</td></tr><tr><td align="center">缺点</td><td align="center">部分浏览器丢点；延时页面加载；get 长度限制</td><td align="center">fetch 丢点，同步 xhr 不丢点，延迟页面卸载</td><td align="center">兼容性</td></tr></tbody></table><p>丢点：页面卸载时正在上报的请求丢失</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://web.dev/vitals/">web vitals</a></li><li><a href="https://github.com/GoogleChrome/lighthouse">lighthouse</a></li><li><a href="https://juejin.cn/post/7017974567943536671">前端监控 SDK 的一些技术要点原理分析</a></li><li><a href="https://juejin.cn/post/6844903992380637198">Lighthouse 测试内幕</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端监控</tag>
      
      <tag>分享记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jsconfig的简要说明</title>
    <link href="/unknown404.github.io/2023/07/24/jsconfig/"/>
    <url>/unknown404.github.io/2023/07/24/jsconfig/</url>
    
    <content type="html"><![CDATA[<p>最近整理旧项目，遇到一些使用简化路径的引用模块，无法直接导向原文件，遂进行的简单研究。</p><span id="more"></span><h2 id="jsconfig-文件是什么"><a href="#jsconfig-文件是什么" class="headerlink" title="jsconfig 文件是什么"></a>jsconfig 文件是什么</h2><p>一个在 JavaScript 项目中的配置文件。它用于指定项目的 JavaScript 语言服务选项，让编辑器或 IDE（集成开发环境）了解项目的结构和语法，以便在编辑过程中提供更好的代码提示、补全和错误检查。</p><p>jsconfig.json 是 tsconfig.json 的子集。如果该项目为 ts 项目，应该使用 tsconfig.json</p><ul><li><strong>文件位置</strong>：JavaScript 项目的根目录下</li><li><strong>文件作用</strong>：</li></ul><ol><li>代码智能感知：通过 jsconfig.json，可以配置项目中的模块、库、路径，让编辑器能够正确地识别它们，提供智能感知和自动补全功能。</li><li>导入路径的简化：可以设置路径映射，让导入模块时的路径更加简洁。</li><li>错误检查：jsconfig.json 定义了项目的语法规范和特性，编辑器可以根据这些规则进行代码错误检查。</li><li>重构支持：可以支持一些重构功能，比如重命名变量、函数等。</li></ol><h2 id="jsconfig-文件的配置"><a href="#jsconfig-文件的配置" class="headerlink" title="jsconfig 文件的配置"></a>jsconfig 文件的配置</h2><p>一个用于智能感知的配置文件大致情况如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;es6&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;baseUrl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;.&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;paths&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;@/*&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;src/*&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;@com/*&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;./src/components/*&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;@api&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;./src/model/api.js&quot;</span><span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;src/**/*&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>compilerOptions: 编译选项，可以设置编译目标、模块解析、是否允许隐式的任意类型等。</li><li>baseUrl: 设置项目中的基本路径，这样在导入模块时，可以使用相对于基本路径的路径。</li><li>paths: 路径映射，用于简化导入模块时的路径，可以使用自定义的别名。</li><li>include: 设置需要包含的文件&#x2F;目录，通常是匹配模式，指定哪些文件应该被包含在项目中。</li><li>exclude: 设置需要排除的文件&#x2F;目录，通常是匹配模式，指定哪些文件不应该被包含在项目中。</li></ul><p>实际上 compilerOptions 包含的可配置属性众多，这里就不一一列举了。<br><strong>注意点</strong>：配好 jsconfig 文件后最好重新打开一下这个项目，否则可能不会立即生效。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://juejin.cn/post/7004748084374831117">你需要知道 jsconfig.json 都在这里啦</a></p>]]></content>
    
    
    <categories>
      
      <category>工作技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小程序踩坑经历--feed乱流</title>
    <link href="/unknown404.github.io/2023/06/30/feedFix/"/>
    <url>/unknown404.github.io/2023/06/30/feedFix/</url>
    
    <content type="html"><![CDATA[<p>记录维护项目时碰到的问题。</p><span id="more"></span><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>小程序的 feed 流内容带有关闭按钮，点击后该条目从 feed 流移除。但移除后后续条目的图片发生了错位。</p><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>根据 skype 给出的提示，主要有几个可能：</p><ol><li><p><a href="https://blog.csdn.net/u013633921/article/details/119922467">分页逻辑有问题，导致删除数据后，下一页的数据重复了上一页的数据</a>。可以尝试使用 last_id 来记录上一页最后一条数据的 id，然后根据这个 id 来获取下一页的数据，避免重复。</p></li><li><p><a href="https://blog.csdn.net/qq_41930094/article/details/106230395">删除操作没有正确更新页面的数据，导致页面显示的数据和数据库不一致</a>。可以使用 setData()方法来更新页面的数据，让页面重新渲染。</p></li><li><p><a href="https://blog.csdn.net/Bat_Reality/article/details/104721839">数组删除操作使用了 splice()方法，但是没有注意它会改变原始数组的长度和索引</a>。可以使用 filter()方法来删除数组中的元素，它不会改变原始数组，而是返回一个新的数组。</p></li></ol><p>虽然这些原因并不符合项目的实际情况，但也提供了思路：1）feed 数组在删除操作后的 js 更新逻辑可能有问题；2）渲染 feed 的模板结构可能有问题，导致删除的条目在模版上没对应</p><p>最后经过排查发现 feed 的模版代码中，key 值的设置不正确，导致模版在删除操作时再次渲染数据出错。至于为什么 key 值不对，则是项目的脚手架编译逻辑出现了问题，不在讨论范围。就是这样～</p>]]></content>
    
    
    <categories>
      
      <category>踩坑经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nodeJs网络框架简介</title>
    <link href="/unknown404.github.io/2023/05/04/BFF/"/>
    <url>/unknown404.github.io/2023/05/04/BFF/</url>
    
    <content type="html"><![CDATA[<p>想针对一直在使用的 nodeJs 框架做一个梳理归纳。</p><span id="more"></span><p>根据我的个人理解，目前常见的 nodeJS 框架可以分为基础框架和企业级框架。<br>所谓基础框架就是将 nodeJs 的 http 模块的方法进行了包装，提供了中间件、路由设置、模版渲染等方法。代表性的框架有 express、koa、fastify<br>而企业级框架则是在基础框架的基础上进一步架构，规定了代码组织复用的规则，集成了数据库、模板引擎的使用方案等，使后端的开发更加轻松，也更贴近业务需求。</p><h2 id="基础框架"><a href="#基础框架" class="headerlink" title="基础框架"></a>基础框架</h2><h3 id="express"><a href="#express" class="headerlink" title="express"></a>express</h3><p>express 是 2010 年提出的框架，目前与其他框架相比更加成熟和稳定，具有更广泛的社区支持和生态系统。<br>特点：</p><ul><li>请求处理对象：Node 的 req 和 res 对象</li><li>异步代码风格：依赖于回调函数和 Promise</li><li>中间件模式：通过调用 next 函数来链式传递</li><li>路由处理：express 框架已经集成，不需要额外引入插件</li></ul><h3 id="KOA"><a href="#KOA" class="headerlink" title="KOA"></a>KOA</h3><p>由 express 团队开发的，基于 ES6 新特性<br>特点：</p><ul><li>请求处理对象：Koa 框架自己封装的对象 ctx.request 和 ctx.response</li><li>异步代码风格：使用 async 和 await 语言的特性</li><li>中间件模式：洋葱模型，中间件可以直接返回 promise 对象</li><li>路由处理：需要中间件如 koa-route</li></ul><h3 id="fastify"><a href="#fastify" class="headerlink" title="fastify"></a>fastify</h3><p>号称是快速且低开销的 Web 框架。社区插件丰富，可扩展性强。内置 logger，可以用于代码分析调试。<br>特点：</p><ul><li>请求处理对象：Node 的 req 和 res 对象</li><li>异步代码风格：可使用 async 和 await 语言的特性，也可使用回调函数和 Promise 的书写方式</li><li>中间件模式：可以直接返回处理结果，也可以使用 next 回调函数来调用下一个中间件</li><li>路由处理：框架已经集成，不需要额外引入插件</li></ul><h2 id="企业级框架"><a href="#企业级框架" class="headerlink" title="企业级框架"></a>企业级框架</h2><h3 id="eggJs"><a href="#eggJs" class="headerlink" title="eggJs"></a>eggJs</h3><p>Egg.js 是一个基于 koa2 的开源框架。框架本身并没有集成如数据库、模板引擎、前端框架等功能，而是需要引入对应功能的插件（个人认为对于使用者来说这并不是一个非常好的选择，因为如果社区活跃度低，插件的丰富度和质量都会成为问题，最终只能自己花时间去开发）</p><h4 id="有明确的约定规范"><a href="#有明确的约定规范" class="headerlink" title="有明确的约定规范"></a>有明确的约定规范</h4><p>eggJs 的目录结构大致如下所示，这里相对说明文档做了简化</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stata">egg-project<br>├── package.json<br>├── <span class="hljs-keyword">app</span>.js (可选)<br>├── agent.js (可选)<br>├── <span class="hljs-keyword">app</span><br>|   ├── router.js<br>│   ├── controller<br>│   ├── service (可选)<br>│   ├── middleware (可选)<br>│   ├── schedule (可选)<br>│   ├── <span class="hljs-keyword">view</span> (可选)<br>│   └── extend (可选)<br>├── config<br>└── <span class="hljs-keyword">test</span><br></code></pre></td></tr></table></figure><p>目录文件的作用：</p><ul><li>app.js 和 agent.js 用于自定义启动时的初始化工作</li><li>app&#x2F;router.js 用于配置 URL 路由规则，将符合规则的路由请求发送给对应的目标控制器或模板</li><li>app&#x2F;controller&#x2F;** 用于解析用户请求传入的参数，处理后返回相应的结果</li><li>app&#x2F;service&#x2F;** 用于编写接口的业务逻辑，内容可以直接写在 controller 文件内部，但分离出来文件逻辑更清晰</li><li>app&#x2F;middleware&#x2F;** 用于编写中间件</li><li>app&#x2F;schedule&#x2F;** 用于定时任务</li><li>app&#x2F;view&#x2F;** 用于放置模板文件</li><li>app&#x2F;extend&#x2F;** 用于框架的扩展</li></ul><p>eggJs 约定了这些文件后，使用者只需要将实现的代码逻辑放在对应的文件夹下。在框架内部 egg-core 的 loader 会自动去读取对应文件夹下的文件，获取文件名、并将逻辑挂到指定的全局变量中。这里以 service 为例，在<a href="https://github.com/eggjs/egg-core/blob/2920f6eade07959d25f5c4f96b154d3fbae877db/lib/loader/mixin/service.js">egg-core 的代码中</a>读取了 app&#x2F;service 目录下的文件，将文件名称作为一个作为属性，挂载在 context 上下文上，然后将对应的 js 文件，暴露的方法赋值在这个属性上。例如 service 文件夹下有一个 alertRule 的 js 文件，内部有 getWarning 方法。在运行项目时 alertRule 就会挂在 ctx.service 下，在 controller 中就可以通过 ctx.service.alertRule.getWarning()调用 service 里的逻辑代码<br>更详细的内容可以参考<a href="https://juejin.cn/post/6844903716777099278">这篇文章</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-meta">&quot;use strict&quot;</span>;<br><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Load app/service</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@function</span> EggLoader#loadService</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Object</span>&#125; <span class="hljs-variable">opt</span> - LoaderOptions</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@since</span> 1.0.0</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">loadService</span>(<span class="hljs-params">opt</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">timing</span>.<span class="hljs-title function_">start</span>(<span class="hljs-string">&quot;Load Service&quot;</span>);<br>    <span class="hljs-comment">// 载入到 app.serviceClasses</span><br>    opt = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<br>      &#123;<br>        <span class="hljs-attr">call</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">caseStyle</span>: <span class="hljs-string">&quot;lower&quot;</span>,<br>        <span class="hljs-attr">fieldClass</span>: <span class="hljs-string">&quot;serviceClasses&quot;</span>,<br>        <span class="hljs-attr">directory</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getLoadUnits</span>().<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">unit</span>) =&gt;</span><br>          path.<span class="hljs-title function_">join</span>(unit.<span class="hljs-property">path</span>, <span class="hljs-string">&quot;app/service&quot;</span>)<br>        ),<br>      &#125;,<br>      opt<br>    );<br>    <span class="hljs-keyword">const</span> servicePaths = opt.<span class="hljs-property">directory</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">loadToContext</span>(servicePaths, <span class="hljs-string">&quot;service&quot;</span>, opt);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">timing</span>.<span class="hljs-title function_">end</span>(<span class="hljs-string">&quot;Load Service&quot;</span>);<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="插件机制"><a href="#插件机制" class="headerlink" title="插件机制"></a>插件机制</h4><p>模板引擎、数据库连接都需要下载对应的 plugin；插件的配置需要在 config 文件夹下进行声明</p><h4 id="多线程管理"><a href="#多线程管理" class="headerlink" title="多线程管理"></a>多线程管理</h4><p>eggJs 的进程模型如下</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">                +--------+          +-------+<br>                |<span class="hljs-string"> Master </span>|<span class="hljs-string">&lt;--------&gt;</span>|<span class="hljs-string"> Agent </span>|<br>                +--------+          +-------+<br>                ^   ^    ^<br>               /    |<span class="hljs-string">     \</span><br><span class="hljs-string">             /      </span>|<span class="hljs-string">       \</span><br><span class="hljs-string">           /        </span>|<span class="hljs-string">         \</span><br><span class="hljs-string">         v          v          v</span><br><span class="hljs-string">+----------+   +----------+   +----------+</span><br><span class="hljs-string"></span>|<span class="hljs-string"> Worker 1 </span>|<span class="hljs-string">   </span>|<span class="hljs-string"> Worker 2 </span>|<span class="hljs-string">   </span>|<span class="hljs-string"> Worker 3 </span>|<br>+----------+   +----------+   +----------+<br></code></pre></td></tr></table></figure><p>Master 作为主线程，启动 Agent 作为秘书进程协助 Worker 处理一些公共事务（日志之类），同时启动 Worker 进程执行真正的业务代码。</p><h3 id="nestJs"><a href="#nestJs" class="headerlink" title="nestJs"></a>nestJs</h3><p>nestJs 是基于 express 的开源框架，目录的结构据说和 Spring 有异曲同工之妙(但我没学过)。对 ts 的支持比较好。nestJs 的构建思路和 eggJs 几乎大相径庭。它具有以下特点</p><h4 id="去中心化路由"><a href="#去中心化路由" class="headerlink" title="去中心化路由"></a>去中心化路由</h4><p>nest 项目没有 router.js 文件，所有的路由通过装饰器与 Controller 绑定。</p><h4 id="依赖注入（DI-Dependency-Injection）思想"><a href="#依赖注入（DI-Dependency-Injection）思想" class="headerlink" title="依赖注入（DI, Dependency Injection）思想"></a>依赖注入（DI, Dependency Injection）思想</h4><p>依赖注入是控制反转（IOC，Inversion of Control）的一种应用形式。可以用于解决一个类依赖于另外一个类的情况。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> _pet<br><br>  constructor () &#123;<br>    <span class="hljs-built_in">this</span>._pet = <span class="hljs-keyword">new</span> <span class="hljs-type">Dog</span>()<br>  &#125;<br>&#125;<br><br>const xiaoming = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>()<br></code></pre></td></tr></table></figure><p>例如上面这段代码，存在着两个问题：</p><ul><li>Person 类固定依赖于 Dog 类，如果后续 Person 想要依赖于其他宠物类，是无法轻易修改的。</li><li>Dog 类有所变化，比如其属性颜色染成了黑色，Person 类也会直接受到影响。</li></ul><p>而如果将 Dog 的实例注入到 Person 类中，则 pet 属性不再强依赖 Dog 类。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-keyword">private</span> _pet<br><br>  constructor (pet) &#123;<br>    <span class="hljs-keyword">this</span>._pet = pet<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> doggy = <span class="hljs-keyword">new</span> Dog()<br><span class="hljs-keyword">const</span> xiaoming = <span class="hljs-keyword">new</span> Person(doggy) <span class="hljs-comment">// 将实例化的 dog 传入 person 类</span><br></code></pre></td></tr></table></figure><p>在 nestJs 框架中就承担了这样一个任务：一个容器来维护各个对象实例，当用户需要使用实例时，容器会自动将对象实例化给用户。<br>以初始化的 app 文件为例，在 app.controller.ts 中就是在构造器函数部分注入了 AppService 模块的实例 appService，controller 方法中就可以直接用 this.appService 访问 service 内部的方法，实例化的操作在框架内实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Controller</span>, <span class="hljs-title class_">Get</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/common&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">AppService</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./app.service&#x27;</span>;<br><br><span class="hljs-meta">@Controller</span>()<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppController</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> appService: AppService</span>) &#123;&#125;<br><br>  <span class="hljs-meta">@Get</span>()<br>  <span class="hljs-title function_">getHello</span>(): <span class="hljs-built_in">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">appService</span>.<span class="hljs-title function_">getHello</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="模块化思想"><a href="#模块化思想" class="headerlink" title="模块化思想"></a>模块化思想</h4><p>Nest.js 应用程序都是由一个或多个模块组成的。每个模块都是一个独立的、封闭的功能单元，负责处理某个具体的业务逻辑或功能。使用指令<code>nest g resource xxx</code>就会生成以 xxx 命名的文件夹，内部包括了 controller、service、module 的文件,同时在 app.module.ts 也进行了自动导入，模块加入 imports 中。具体文件结构如下所示</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">test<br>├── test<span class="hljs-selector-class">.controller</span><span class="hljs-selector-class">.ts</span><br>├── test<span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.ts</span><br>├── test<span class="hljs-selector-class">.controller</span><span class="hljs-selector-class">.spec</span><span class="hljs-selector-class">.ts</span><br>├── test<span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.spec</span><span class="hljs-selector-class">.ts</span><br>├── test<span class="hljs-selector-class">.module</span><span class="hljs-selector-class">.ts</span><br>└── dto<br>    ├── create-test<span class="hljs-selector-class">.dto</span><span class="hljs-selector-class">.ts</span><br>    └── update-test<span class="hljs-selector-class">.dto</span>.ts<br></code></pre></td></tr></table></figure><p>其中 test.controller.spec.ts 和 test.service.spec.ts 为测试文件。如果不想生成测试文件,可以在 nest-cli.json 中配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;generateOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>   <span class="hljs-attr">&quot;spec&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><br> <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>test.controller.ts 用于处理路由传来的数据<br>test.service.ts 用于写业务相关的逻辑<br>test.module.ts 相当于一个应用程序的根模块，可以看到它将 TestController 和 TestService 都通过@Module 进行了一个注入<br>@Module 主要包括以下属性：</p><ul><li>providers：由 Nest 注入器实例化的 provider，并且可以至少在整个模块中共享</li><li>controllers：在这个模块内定义的 controller</li><li>imports：可以注入 其他 module 或者 provider</li><li>exports：引入该模块时可以自动使用的 provider</li></ul><p>这里需要注明 provider 其实就是不仅仅是 Service 层，还包括：Sql 的 Dao 层、工具方法等提供</p><h4 id="面向切面编程（AOP，Aspect-Oriented-Programming）"><a href="#面向切面编程（AOP，Aspect-Oriented-Programming）" class="headerlink" title="面向切面编程（AOP，Aspect Oriented Programming）"></a>面向切面编程（AOP，Aspect Oriented Programming）</h4><p>当一个请求打过来时，一般会经过 Controller（控制器）、Service（服务）、Repository（数据库访问） 的链路。如果想在这个调用链路里加入日志记录、权限控制、异常处理等设置时，在调用 Controller 之前和之后加入一个执行通用逻辑的阶段，这个切面的逻辑编程就是 AOP。具体到 nest 中就是 Middleware、Guard、Pipe、Interceptor、ExceptionFilter 的实现<br>关于这些模块怎么使用，官方文档大致有写，这里只辨析一下 Middleware 和 Interceptor 区别</p><ul><li>Middleware：调用时机发生在路由处理前；书写方式和 express 的中间件相似，回调函数接收 req、res、next 参数</li><li>Interceptor：基于 AOP（面向切面编程）的概念实现的，它可以在请求处理管道的不同阶段中插入逻辑，例如在调用控制器方法之前或之后；Interceptor 内部实现了 intercept 函数，接收了 context 和 next 两个参数，context 是请求上下文，next 是调用链接的切面对象，执行 next.handle() 就会调用目标 Controller，不调用就不会执行</li></ul><h4 id="不特别依赖于平台"><a href="#不特别依赖于平台" class="headerlink" title="不特别依赖于平台"></a>不特别依赖于平台</h4><p>nest 虽然基于 express，但可以灵活的切换 http 框架和 socket 框架<br>它采用了适配器模式，express 或者别的平台比如 fastify 只要继承这个适配器的类，实现其中的抽象方法，就能接入到 Nest.js 里。在项目的 main.ts 中调整 NestFactory.create 的入参，增加 serverOrOptions 参数即可实现</p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>文末的碎碎念吧。其实个人感觉框架本身的使用并不是很难，一些日常开发照着开发文档抄基本上都能出来。但是对框架的架构去理解就感觉很难：规范内部的代码是怎么整合的？为什么要这么做？这些的理解就很难，如果不涉及深层的开发，读源码也觉得有点浪费时间，毕竟阅历及惯性思维等限制很难去快速理解开发者的思路，而如果没有做架构师、只是开发的话，这个时间的必要性感觉实在是。。。</p><p>现在记录下的内容说实话感觉还是很浅层次的内容，也许意义不是很大。但也许当我很久没开发 egg 项目再改写时，不会因为找不到 ctx 上的一些对象名感到疑惑（也许吧。。。）</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/7192528039945699386">浅谈 NestJS 设计思想（分层、IOC、AOP）</a><br>（2）<a href="https://juejin.cn/post/6844903716777099278">Egg.js 源码分析-项目启动</a><br>（3）<a href="https://juejin.cn/post/7070377945553977357">Nest.js 基于 Express 但也不是完全基于</a></p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>页面埋点基础概念</title>
    <link href="/unknown404.github.io/2023/04/25/eventTracking/"/>
    <url>/unknown404.github.io/2023/04/25/eventTracking/</url>
    
    <content type="html"><![CDATA[<p>所谓埋点可以理解为在应用中通过代码来采集上报一些信息，用于分析应用使用的状况，后续用来进一步优化产品或是提供运营的数据支撑。对于公司来说埋点的业务意义非常重要。</p><span id="more"></span><h2 id="常见的埋点方式"><a href="#常见的埋点方式" class="headerlink" title="常见的埋点方式"></a>常见的埋点方式</h2><p>埋点常用的技术方案有三种：代码侵入埋点、可视化埋点、无埋点。</p><h3 id="代码侵入埋点"><a href="#代码侵入埋点" class="headerlink" title="代码侵入埋点"></a>代码侵入埋点</h3><p>代码埋点就是在你需要统计数据的地方植入 N 行代码，统计用户的关键行为。</p><ul><li>优点：使用者控制精准，可以非常精确地选择什么时候发送数据；使用者可以比较方便地设置自定义属性、自定义事件，传递比较丰富的数据到服务端</li><li>缺点：每一个控件的埋点都需要添加相应的代码，工作量大，对业务代码的侵入性高；存在更新代价，每一次更新，都需要通过各个应用市场进行分发，而且有的用户还不一定更新，就会流失这部分客户的数据</li></ul><p>但综合来说代码埋点对于公司自研的角度是最容易实现的。</p><p>主流的埋点模型目前有两种：utm 埋点和 spm 埋点</p><h4 id="utm-埋点"><a href="#utm-埋点" class="headerlink" title="utm 埋点"></a>utm 埋点</h4><p>由 Google Analytics 提出，utm 是“Urchin Tracking Module”的简写，大意就是跟踪模块。主要的参数包括这些</p><table><thead><tr><th align="center">参数</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">utm_campaign</td><td align="center">推广活动名称</td></tr><tr><td align="center">utm_content</td><td align="center">推广活动内容</td></tr><tr><td align="center">utm_source</td><td align="center">推广活动来源，例如：baidu</td></tr><tr><td align="center">utm_medium</td><td align="center">推广活动媒介，例如：email</td></tr><tr><td align="center">utm_term</td><td align="center">推广活动关键词</td></tr></tbody></table><h4 id="spm-埋点"><a href="#spm-埋点" class="headerlink" title="spm 埋点"></a>spm 埋点</h4><p>由阿里提出，主要是用于追踪具体的站内位置。阿里的 SPM 位置编码由 A.B.C.D 四段构成, 各分段分别代表</p><ul><li>A:站点&#x2F;业务；</li><li>B:页面；</li><li>C:页面区块；</li><li>D:区块内点位。</li></ul><p>SPM 的基本功能个人认为包括这些：</p><p>跳转拼接：通过页面，区块，点位信息去拼接 spm 码，页面跳转时将 spm 添加到 url 的 query 参数。<br>埋点上报：通过解析 URL 提取参数，完善 pv 链的顺序，页面的 pv 上报时就能获取当前页面信息和上一个页面信息。</p><h3 id="可视化埋点"><a href="#可视化埋点" class="headerlink" title="可视化埋点"></a>可视化埋点</h3><p>可视化埋点的具体操作是：在可视化界面上打开项目地址，并圈选需要埋点的 DOM 元素，对选中的 DOM 元素添加自定义埋点事件；完成后可视化平台会根据保存的事件列表生成一个 JS 文件，需要将其埋入应用。<br>该方式的实现原理是：在进行事件设置的时候，“可视化埋点工具”会利用它部署在网站页面（或者 app）上的基础代码对网站（或 app）上所有的可交互事件元素进行解析，获取它们的 DOM path。</p><ul><li>优点：操作简单</li><li>缺点：上报的场景比较受限，跟事件操作强关联；埋点配置需要独立发布</li></ul><p>该方式实现的代表三方为 talkingData、Mixpanel</p><h3 id="无埋点"><a href="#无埋点" class="headerlink" title="无埋点"></a>无埋点</h3><p>无埋点也可以理解为全埋点，前端引入的 SDK 会自动劫持页面所有的事件、进行自主上报。</p><ul><li>优点：对业务代码的侵入量少，操作简单</li><li>缺点：会产生大量的上报请求，服务器的压力会比较大；如果没有合适的数据清洗规范，后台看到的数据就难以进行分析</li></ul><p>一般来说无埋点方案可能会直接使用现有的三方 SDK 如 GrowingIO、神策等。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/7151400818594283557">初识 SPM</a><br>（2）<a href="https://www.shangyexinzhi.com/article/4258360.html">流量追踪：如何通过URL进行数据采集？谷歌UTM参数及阿里SPM介绍</a><br>（3）<a href="http://www.imooc.com/article/27151">前端埋点的那些事</a></p>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>埋点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小程序踩坑经历--CDN域名替换</title>
    <link href="/unknown404.github.io/2023/04/15/appletCDN/"/>
    <url>/unknown404.github.io/2023/04/15/appletCDN/</url>
    
    <content type="html"><![CDATA[<p>记录项目迁移时碰到的问题。</p><span id="more"></span><h2 id="问题-1-关于-CDN-域名替换"><a href="#问题-1-关于-CDN-域名替换" class="headerlink" title="问题 1:关于 CDN 域名替换"></a>问题 1:关于 CDN 域名替换</h2><h3 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h3><p>替换了静态资源使用的域名后，是否需要在开发者平台上修改 request 合法域名或 downloadFile 合法域名？</p><h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p>需要根据代码情况来看：</p><ol><li>如果直接在 scss 文件引入 url 链接的情况，不需要进行配置。</li><li>使用 wx.downloadFile 相关 API 时需要配置 downloadFile 合法域名列表。需要注意的是使用 wx.getImageInfo 和 wx.loadFontFace 等 API 实际上也会向对应的域名发起请求，如果该域名不在小程序开发者平台的 downloadFile 合法域名列表中，就会出现跨域问题，从而导致请求失败。</li></ol><h2 id="问题-2-使用的特殊字体文件在-ios-和开发者工具上显示正常，安卓上无法显示"><a href="#问题-2-使用的特殊字体文件在-ios-和开发者工具上显示正常，安卓上无法显示" class="headerlink" title="问题 2:使用的特殊字体文件在 ios 和开发者工具上显示正常，安卓上无法显示"></a>问题 2:使用的特殊字体文件在 ios 和开发者工具上显示正常，安卓上无法显示</h2><h3 id="场景描述-1"><a href="#场景描述-1" class="headerlink" title="场景描述"></a>场景描述</h3><p>使用了如下代码来调用 icon 字体文件，域名链接可以正常访问，但会出现上述问题；且远程调试和真机调试平台都没有任何报错信息。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@font-face</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;icon2018&quot;</span>;<br>  <span class="hljs-attribute">src</span>: url(<span class="hljs-string">&quot;https://statics.xxx.com/iconfont.ttf?t=1539342297740&quot;</span>),<br>    <span class="hljs-comment">/* chrome, firefox, opera, Safari, Android, iOS 4.2+*/</span><br>      url(<span class="hljs-string">&quot;https://statics.xxx.com/iconfont.svg?t=1539342297740#icon2018&quot;</span>)<br>      format(<span class="hljs-string">&quot;svg&quot;</span>); <span class="hljs-comment">/* iOS 4.1- */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解决方式-1"><a href="#解决方式-1" class="headerlink" title="解决方式"></a>解决方式</h3><p>CDN 的 nginx 配置需要进行跨域处理</p><h2 id="问题-3-同路径页面跳转时，页面-data-没更新"><a href="#问题-3-同路径页面跳转时，页面-data-没更新" class="headerlink" title="问题 3:同路径页面跳转时，页面 data 没更新"></a>问题 3:同路径页面跳转时，页面 data 没更新</h2><h3 id="场景描述-2"><a href="#场景描述-2" class="headerlink" title="场景描述"></a>场景描述</h3><p>页面切换大概是这样一个过程 pageA -&gt; pageB?id&#x3D;1 -&gt; pageB?id&#x3D;2<br>当跳 pageB?id&#x3D;2 时，data 中的一个对象数据还保持为 pageB?id&#x3D;1 的数据</p><h3 id="解决方式-2"><a href="#解决方式-2" class="headerlink" title="解决方式"></a>解决方式</h3><p>目前无法分析具体原因，有可能是 mpvue 的框架问题，但这个问题不是稳定触发的，当跳转事件绑定的是@click.stop 的时候才发生。<br>当前保守的解决方式是在 onHide 或 onUnload 周期对 data 数据进行重置</p><h2 id="问题-4-小程序全局变量"><a href="#问题-4-小程序全局变量" class="headerlink" title="问题 4:小程序全局变量"></a>问题 4:小程序全局变量</h2><h3 id="场景描述-3"><a href="#场景描述-3" class="headerlink" title="场景描述"></a>场景描述</h3><p>不同小程序框架，全局变量设置的方式有细微的差别</p><h3 id="解决方式-3"><a href="#解决方式-3" class="headerlink" title="解决方式"></a>解决方式</h3><ol><li>uni-app、mpvue</li></ol><p>在 App.vue 中定义 globalData 的相关配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">globalData</span>: &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;text&#x27;</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>js 中操作 globalData 的方式如下： getApp().globalData.text &#x3D; ‘test’</p><p>在应用 onLaunch 时，getApp 对象还未获取，暂时可以使用 this.globalData 获取 globalData。</p><ol start="2"><li>taro</li></ol><p>虽然官方文档给出了<a href="https://docs.taro.zone/docs/come-from-miniapp#react">react 语法</a>的定义方法，然而设置的 taroGlobalData 只能维持初始化的值，而无法被改动。<br>想要解决这个问题，可以自己维护一个 globalData 对象，定义获取和修改该对象的方法。</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">const</span> globalData = &#123;&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setGlobalData</span> (<span class="hljs-params">key, val</span>) </span>&#123;<br>  globalData[key] = val<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getGlobalData</span> (<span class="hljs-params">key</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> globalData[key]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://leiem.cn/2022/01/21/46155/">小程序引用网络字体在安卓无效</a><br>（2）<a href="https://github.com/meituan-dianping/mpvue/issues/140">同一路由切换时，上一次的页面数据会保留</a><br>（3）<a href="https://www.cnblogs.com/juewuzhe/p/11097146.html">Taro – 定义全局变量</a></p>]]></content>
    
    
    <categories>
      
      <category>踩坑经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker基础知识</title>
    <link href="/unknown404.github.io/2023/03/24/docker/"/>
    <url>/unknown404.github.io/2023/03/24/docker/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么选择-docker-进行部署"><a href="#为什么选择-docker-进行部署" class="headerlink" title="为什么选择 docker 进行部署"></a>为什么选择 docker 进行部署</h2><p>个人理解有以下几点：</p><ol><li>docker 能提供一致性的运行环境。让程序在一致性的环境中运行：不管是开发环境、测试环境、还是生产环境；不管是开发时、构建时、还是运行时。</li><li>Kubernetes（又称 k8s）的容器集群管理系统因具有完备的集群管理能力（容器的高可用、负载均衡和故障恢复等）而广泛应用，为 docker 提供了自动化管理和编排的能力，让 docker 部署更容易被接受</li><li>标准化的服务程序封装技术-镜像，包含了程序以及程序对运行环境的依赖</li></ol><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>Client：客户端</li><li>Daemon：守护进程</li><li>Image：镜像，一个容器的模板，通过一个镜像可以创建多个容器</li><li>Container：容器，是镜像的运行实例</li><li>Repository：仓库，分为公开仓库（Public）和私有仓库（Private）两种形式。最大的公开仓库是 Docker Hub， 存放了数量庞大的镜像供用户下载。私有仓库是指用户在本地搭建的私有 Docker Registry。</li></ul><p>Client 通过命令行与 Daemon 交互。Daemon 通过 Image 镜像创建了一个容器去运行命令。</p><h2 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h2><p>Mac 电脑如果没有安装 homebrew，可以通过 <a href="https://www.docker.com/get-started/">Docker Desktop</a>下载 docker 后，双击安装即可。</p><p>安装完成后可以使用指令<code>docker -v</code>查看 docker 版本号，确认是否安装成功。</p><h2 id="docker-常见指令"><a href="#docker-常见指令" class="headerlink" title="docker 常见指令"></a>docker 常见指令</h2><h3 id="容器相关指令"><a href="#容器相关指令" class="headerlink" title="容器相关指令"></a>容器相关指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看运行中的容器</span><br><span class="hljs-comment"># 可以查看容器ID、基础镜像、容器名称、运行状态、端口映射等</span><br>docker ps<br><br><span class="hljs-comment"># 查看所有容器：包括停止的</span><br>docker ps -a<br><br><span class="hljs-comment"># 查看容器的信息</span><br><span class="hljs-comment"># 例如端口号的映射、目录挂载</span><br>docker inspect [images_name/images_id]<br><br><span class="hljs-comment"># 启动和停止容器</span><br>docker start/stop [container_name/container_id]<br><br><span class="hljs-comment">#  重启容器</span><br><span class="hljs-comment">#  使用场景实例：</span><br><span class="hljs-comment">#  在加入新的npm包依赖需要重新编译的时候使用重启运行编译</span><br><span class="hljs-comment">#  nginx容器的配置更新后需要重启生效</span><br>docker restart [container_name/container_id]<br><br><span class="hljs-comment"># 进入容器</span><br><span class="hljs-comment"># ps:有些容器没有bash,需要改成/bin/sh，例如mysql、mongodb的</span><br><span class="hljs-comment"># 退出容器输入exit 回车键</span><br>docker <span class="hljs-built_in">exec</span> -it [container_name/container_id] /bin/bash<br><br><span class="hljs-comment"># 删除容器</span><br><span class="hljs-comment"># 在容器停止的状态才能删</span><br>docker <span class="hljs-built_in">rm</span> [container_name/container_id]<br><br><span class="hljs-comment"># 容器主机文件拷</span><br><span class="hljs-comment"># 将容器文件拷贝到主机</span><br>docker <span class="hljs-built_in">cp</span> [container_id/container_name] : [文件目录] [主机目录]<br><br><span class="hljs-comment"># 将主机的目录拷贝到容器</span><br>docker <span class="hljs-built_in">cp</span> [主机目录] [container_id/container_name] : [文件目录]<br></code></pre></td></tr></table></figure><h3 id="镜像相关指令"><a href="#镜像相关指令" class="headerlink" title="镜像相关指令"></a>镜像相关指令</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 搜索镜像</span><br><span class="hljs-attribute">docker</span> search<span class="hljs-meta"> [images_name:tag]</span><br><br><span class="hljs-comment"># 下载镜像（：指定版本）</span><br><span class="hljs-attribute">docker</span> pull<span class="hljs-meta"> [images_name:tag]</span><br><br><span class="hljs-comment"># 查看本地下载的镜像</span><br><span class="hljs-attribute">docker</span> images<br><br><span class="hljs-comment"># 自己构建镜像</span><br><span class="hljs-comment"># 根据dockerfile的路径或者url构建镜像</span><br><span class="hljs-attribute">docker</span> build<span class="hljs-meta"> [OPTIONS] PATH|URL|-</span><br><span class="hljs-meta"></span><br><span class="hljs-meta"># 查看镜像的构建历史</span><br><span class="hljs-meta">docker history [images_name]</span><br><br><span class="hljs-comment"># 删除镜像</span><br><span class="hljs-comment"># 需要先删除以此镜像为基础的容器</span><br><span class="hljs-attribute">docker</span> rmi<span class="hljs-meta"> [images_name]</span><br><br><span class="hljs-comment"># 运行镜像</span><br><span class="hljs-comment">##</span><br><span class="hljs-attribute">docker</span> run<span class="hljs-meta"> [OPTIONS] [images_name] [COMMAND] [ARG...]</span><br></code></pre></td></tr></table></figure><h3 id="镜像迁移相关"><a href="#镜像迁移相关" class="headerlink" title="镜像迁移相关"></a>镜像迁移相关</h3><h4 id="docker-save-docker-load"><a href="#docker-save-docker-load" class="headerlink" title="docker save + docker load"></a>docker save + docker load</h4><p>docker save 命令用于将 Docker 镜像导出为一个 tar 归档文件，该文件包含了镜像的全部文件系统层，包括 Dockerfile 中定义的命令、环境变量等。导出的镜像可以使用 docker load 命令重新导入到 Docker 中，或者将其传输到其他 Docker 安装实例中。由于 docker save 导出的文件包含了完整的镜像层，因此可以用来备份或迁移整个镜像。</p><h4 id="docker-export-docker-import"><a href="#docker-export-docker-import" class="headerlink" title="docker export + docker import"></a>docker export + docker import</h4><p>docker export 命令用于将 Docker 容器的文件系统导出为一个 tar 归档文件，该文件不包含容器的元数据（比如容器的标签、端口号、环境变量等），仅包含容器中运行的应用程序和文件。导出的容器文件系统可以使用 docker import 命令导入为一个新的 Docker 镜像，或者在需要时手动将其中的文件复制到本地系统中。由于 docker export 不包含镜像的元数据，因此它通常用于容器的临时备份和文件传输。</p><p>总之，docker save 适用于备份、迁移整个 Docker 镜像，docker export 适用于容器的临时备份和文件传输。</p><h2 id="docker-镜像运行实践：Jenkins-安装"><a href="#docker-镜像运行实践：Jenkins-安装" class="headerlink" title="docker 镜像运行实践：Jenkins 安装"></a>docker 镜像运行实践：Jenkins 安装</h2><h3 id="Jenkins-简介"><a href="#Jenkins-简介" class="headerlink" title="Jenkins 简介"></a>Jenkins 简介</h3><p>Jenkins 是一款业界流行的开源持续集成工具，广泛用于项目开发，具有自动化构建、测试和部署等功能。前端自动化部署的重要工具。</p><h3 id="Jenkins-镜像获取"><a href="#Jenkins-镜像获取" class="headerlink" title="Jenkins 镜像获取"></a>Jenkins 镜像获取</h3><p>dockerHub 网站已经提供了对应的镜像<a href="https://hub.docker.com/r/jenkins/jenkins">jenkins</a>。个人理解 dockerHub 网站类似依赖包的一个集合网站 npmjs，而镜像则类似于依赖包。开发者可以从 dockerHub 下载需要的镜像，也可以把自己生成的镜像打包上传到网站。在运行类似 docker run 等指令时如果镜像不存在当前 docker 内就会去网站拉取同名镜像。<br>执行指令<code>docker pull jenkins/jenkins:lts-jdk11</code>就可以下载 Jenkins 的稳定镜像版本。</p><h3 id="Jenkins-容器创建"><a href="#Jenkins-容器创建" class="headerlink" title="Jenkins 容器创建"></a>Jenkins 容器创建</h3><p>执行如下指令，在 docker volume 会自动产生一个叫 jenkins_home 的空间，无论 docker 的容器是运行还是停止或删除 jenkins_home 都会存在；同时指令还做了端口的映射：将宿主机 8080 端口映射到容器 8080 端口，50000 端口是基于 JNLP 的 Jenkins 代理（slave）通过 TCP 与 Jenkins master 进行通信的端口。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -p <span class="hljs-number">8080</span>:<span class="hljs-number">8080</span> -p <span class="hljs-number">50000</span>:<span class="hljs-number">50000</span> --restart=<span class="hljs-literal">on</span>-failure -v jenkins_home:/var/jenkins_home jenkins/jenkins:lts-jdk11<br></code></pre></td></tr></table></figure><p>执行完后可以用指令 docker ps 查看容器运行情况。运行完成就可以在本地打开网址 <a href="http://localhost:8080/">http://localhost:8080</a> 即可访问。<br>正常运行时应该可以看到一个登录界面，需要输入管理员密码才可正常进入，该密码在命令行中可以看到。但有时可能会遇到”Please wait while Jenkins is getting ready to work”，需要重启 container 才能完成，原因不明。</p><h2 id="前端部署说明"><a href="#前端部署说明" class="headerlink" title="前端部署说明"></a>前端部署说明</h2><p>目前来说，前端部署的流程可以认为是将静态文件 html、css 和 js 上传到服务器的目录下，用户通过域名+路径进行访问；如果配置了 nginx，则增加了静态文件放在 nginx 文件夹下（例如&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;）、Nginx 启动做简单配置的操作。因为 docker 隔离性、安全性的特点，所以整个部署资源一般放在 docker 内。<br>实现步骤大致如下：</p><ol><li>连接服务器<br>使用指令 <code>ssh root@[IP]</code>来连接远程服务器，通常需要输入用户名和密码</li><li>安装 docker、拉取 nginx 的 docker 镜像</li><li>增加配置文件</li></ol><ul><li>1）增加 Dockerfile：在前端项目的根目录下创建 Dockerfile，添加如下内容</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">FROM nginx  <span class="hljs-regexp">//</span>该镜像是基于 nginx:latest 镜像而构建的<br>COPY dist<span class="hljs-regexp">/ /u</span>sr<span class="hljs-regexp">/share/</span>nginx<span class="hljs-regexp">/html/</span>  <span class="hljs-regexp">//</span>将项目根目录下 dist 文件夹下的所有文件复制到镜像中 <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html/ 目录下<br>COPY default.conf <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/conf.d/</span>default.conf  <span class="hljs-regexp">//</span>将 项目根目录下 default.conf 复制到 etc<span class="hljs-regexp">/nginx/</span>conf.d/default.conf，用本地的 default.conf 配置来替换 Nginx 镜像里的默认配置<br></code></pre></td></tr></table></figure><p><strong>备注：Dockerfile 常用指令</strong></p><ul><li><p>FROM：指定基础镜像，后续的指令将在该镜像上执行。</p></li><li><p>RUN：在镜像上执行 Linux 命令，并形成一个新的层。</p></li><li><p>CMD：指定启动镜像容器时的默认行为，一个 Dockerfile 中只能有一个 CMD 指令。</p></li><li><p>ENTRYPOINT：指定容器启动后执行的命令，可以覆盖 CMD 指令中的命令。</p></li><li><p>ENV：设置环境变量。</p></li><li><p>COPY：将文件系统中的文件复制到镜像中。</p></li><li><p>WORKDIR：设置工作目录。</p></li><li><p>EXPOSE：设置向外暴露的端口。</p></li><li><p>VOLUME：设置容器与外界映射的目录。</p></li><li><p>2）增加 nginx 的配置替换文件 default.conf。示例如下</p></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk">server &#123;<br>    listen       <span class="hljs-number">80</span>;<br>    server_name  localhost; <span class="hljs-comment"># 此处可修改为docker服务宿主机的ip/域名</span><br><br>    <span class="hljs-comment">#charset koi8-r;</span><br>    access_log  <span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/nginx/</span>host.access.log  main;<br>    error_log  <span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/nginx/</span>error.log  error;<br><br>    location / &#123;<br>        root   <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html;<br>        index  index.html index.htm;<br>    &#125;<br><br>    error_page   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /<span class="hljs-number">50</span>x.html;<br>    location = /<span class="hljs-number">50</span>x.html &#123;<br>        root   <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>使用指令<code>docker build -t vue-init .</code>构建镜像</li><li>使用指令<code>docker run -d -p 8136:80 --name vue-init-container vue-init</code>创建容器、运行。此时打开浏览器输入 服务器 ip&#x2F;域名 端口号:8136，就能看到前端页面了</li></ol><h3 id="多前端项目-ng-转发说明"><a href="#多前端项目-ng-转发说明" class="headerlink" title="多前端项目 ng 转发说明"></a>多前端项目 ng 转发说明</h3><p>多前端项目最好让所有构建好的项目全部在一个文件夹下，再将这个文件夹下内容全部拷贝到 html 文件夹下。由于不同路径对应不同项目，要求前端项目本身的路由basename包括转发的路径。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dockerFile"><span class="hljs-keyword">FROM</span> nginx<br><span class="hljs-comment"># 新增log文件夹</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> -p /opt/logs/nginx</span><br><br><span class="hljs-comment"># 复制 nginx 配置文件</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> nginx/nginx.conf /etc/nginx/nginx.conf</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> nginx/default.conf /etc/nginx/conf.d/default.conf</span><br><br><span class="hljs-comment"># 复制各个项目的 dist 目录</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> app/ /usr/share/nginx/html/</span><br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span><br><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;nginx&quot;</span>, <span class="hljs-string">&quot;-g&quot;</span>, <span class="hljs-string">&quot;daemon off;&quot;</span>]</span><br></code></pre></td></tr></table></figure><h3 id="SSR-项目部署说明"><a href="#SSR-项目部署说明" class="headerlink" title="SSR 项目部署说明"></a>SSR 项目部署说明</h3><p>如果是 SSR 项目，不需要配 ng，dockerfile 直接启动服务器就好。这里以 nuxt 为例：代码首先新建了个文件夹，然后以该文件夹为工作区域，执行安装依赖、打包生产包、启动服务器的操作。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dockerFile"><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">20</span>-alpine<br><br><span class="hljs-keyword">ADD</span><span class="language-bash"> . /opt/project</span><br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /opt/project</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> npm config <span class="hljs-built_in">set</span> registry  http://verdaccio.privacy.com/ &amp;&amp; npm install</span><br><span class="hljs-comment"># 不缓存安装包</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apk add --no-cache curl</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> npm run build:<span class="hljs-built_in">test</span></span><br><br><span class="hljs-keyword">ENV</span> NODE_ENV production<br><span class="hljs-comment"># 暴露容器端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">3000</span><br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;node&quot;</span>,<span class="hljs-string">&quot;./.output/server/index.mjs&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>在ng配置方面需要注意以下几点：</p><ul><li>让access log和error log都放到新建文件夹下，默认的var文件夹不知道为什么很难用sh指令访问。</li><li>为了防止每新增一个项目就要新增一个location配置，这里使用了正则表达式，提取出 项目名称 和 路径剩余部分。设置root，告诉ng从这个位置开始拼接文件路径，try_files 或 rewrite 的前置路径名</li><li>为了防止重定向的一些问题，需要注意以下配置：absolute_redirect off: 防止 Nginx 生成绝对路径的重定向；port_in_redirect off: 防止在重定向时改变端口号<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">http</span> &#123;<br>  <span class="hljs-attribute">log_format</span> main <span class="hljs-string">&#x27;<span class="hljs-variable">$remote_addr</span> <span class="hljs-variable">$remote_user</span> [<span class="hljs-variable">$time_local</span>] <span class="hljs-variable">$request_uri</span> &#x27;</span><br>                      <span class="hljs-string">&#x27;<span class="hljs-variable">$status</span> <span class="hljs-variable">$body_bytes_sent</span> &quot;<span class="hljs-variable">$http_referer</span>&quot; &#x27;</span><br>                      <span class="hljs-string">&#x27;&quot;<span class="hljs-variable">$http_user_agent</span>&quot; <span class="hljs-variable">$hostname</span> <span class="hljs-variable">$request_time</span> <span class="hljs-variable">$http_host</span>&#x27;</span>;<br>    <span class="hljs-attribute">access_log</span> /opt/logs/nginx/access.log main;<br>    <span class="hljs-attribute">error_log</span> /opt/logs/nginx/<span class="hljs-literal">error</span>.log;<br>    <span class="hljs-attribute">include</span> /etc/nginx/mime.types;<br>    <br>    <span class="hljs-attribute">sendfile</span> <span class="hljs-literal">on</span>;<br>    <span class="hljs-attribute">tcp_nopush</span> <span class="hljs-literal">on</span>;<br>    <span class="hljs-attribute">tcp_nodelay</span> <span class="hljs-literal">on</span>;<br>    <span class="hljs-attribute">keepalive_timeout</span> <span class="hljs-number">65</span>;<br>    <span class="hljs-attribute">types_hash_max_size</span> <span class="hljs-number">2048</span>;<br>    <span class="hljs-attribute">default_type</span> application/octet-stream;<br>    <br>    <span class="hljs-attribute">gzip</span> <span class="hljs-literal">on</span>;<br>    <span class="hljs-section">server</span> &#123;<br>      <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>      <span class="hljs-attribute">server_name</span>  localhost;<br>      <span class="hljs-comment"># 关闭自动添加斜杠</span><br>      <span class="hljs-attribute">absolute_redirect</span> <span class="hljs-literal">off</span>;<br>      <span class="hljs-attribute">port_in_redirect</span> <span class="hljs-literal">off</span>;<br><br>      <span class="hljs-section">location</span> <span class="hljs-regexp">~ ^/newsnap/([^/]+)(/.*)?$</span> &#123;<br>          <span class="hljs-attribute">set</span> <span class="hljs-variable">$proj</span> <span class="hljs-variable">$1</span>;<br>          <span class="hljs-attribute">set</span> <span class="hljs-variable">$rest</span> <span class="hljs-variable">$2</span>;<br>          <span class="hljs-attribute">root</span> /usr/share/nginx/html;<br><br>          <span class="hljs-comment"># 清晰地指定路径结构</span><br>          <span class="hljs-attribute">try_files</span> /<span class="hljs-variable">$proj</span><span class="hljs-variable">$rest</span> /dist_<span class="hljs-variable">$proj</span>/index.html =<span class="hljs-number">404</span>;<br>      &#125;<br><br>      <span class="hljs-comment"># 错误页面配置</span><br>      <span class="hljs-attribute">error_page</span>   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.html;<br>      <span class="hljs-section">location</span> = /50x.html &#123;<br>          <span class="hljs-attribute">root</span>   /usr/share/nginx/html;<br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="部署优化说明"><a href="#部署优化说明" class="headerlink" title="部署优化说明"></a>部署优化说明</h3><p>以上只是部署的一个大致流程，实际公司项目的部署应该会考虑很多优化点，例如：</p><ul><li>为了提升页面首屏性能，对 html 走协商缓存，css、js 走强缓存；同时采用 name-hash 的打包方式防止上线过程中资源请求错乱</li><li>为了减轻服务器压力，不选择将文件存储在 Nginx Web 服务器内某目录下，而是将静态资源部署到 CDN 上，再将 Nginx 上的流量转发到 CDN 上</li><li>。。。等等</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/7209900557712212026">Win10 安装 Docker 以及 Jenkins(超级详细篇)</a><br>（2）<a href="https://juejin.cn/post/7187326853336530981">Docker 安装 Jenkins，Nginx，实现前端项目自动化构建</a><br>（3）<a href="https://github.com/jenkinsci/docker/blob/master/README.md#connecting-agents">Docker Image Jenkins</a><br>（4）<a href="https://juejin.cn/post/6992848354753380389?searchId=202309061616378C8D0FA3A38070899341">【前端 Docker 部署实战】Docker 镜像+Nginx 配置部署 Vue 项目</a><br>（5）<a href="https://juejin.cn/post/7017710911443959839">2021 年当我们聊前端部署时，我们在聊什么</a><br>（6）<a href="https://juejin.cn/post/7269668219488354361">使用 Docker 实现前端应用的标准化构建、部署和运行</a></p>]]></content>
    
    
    <categories>
      
      <category>前端扩展</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>飞书机器人验证实现</title>
    <link href="/unknown404.github.io/2023/03/15/feishuEncode/"/>
    <url>/unknown404.github.io/2023/03/15/feishuEncode/</url>
    
    <content type="html"><![CDATA[<p>因工作需要设计了一个调用飞书机器人的接口，主要的实现点在于 webHook 的验证通过。</p><span id="more"></span><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入加密模块crypto</span><br><span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto&#x27;</span>)<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sendMsg</span>(<span class="hljs-params">&#123;url,secret&#125;</span>)&#123;<br>    <span class="hljs-keyword">const</span> &#123;ctx&#125; = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">let</span> dataBody=&#123;<br>        <span class="hljs-attr">msg_type</span>: <span class="hljs-string">&quot;text&quot;</span>,<br>        <span class="hljs-attr">content</span>: &#123;<br>            <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;test&#x27;</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 加密。时间戳单位是s</span><br>    <span class="hljs-keyword">const</span> timestamp = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>() / <span class="hljs-number">1000</span> + <span class="hljs-string">&#x27;&#x27;</span>) + <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-comment">// 存储到buffer时说明数据类型</span><br>    <span class="hljs-keyword">const</span> stringify = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;timestamp&#125;</span>\n<span class="hljs-subst">$&#123;secret&#125;</span>`</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>);<br>    <span class="hljs-comment">// sha256加密</span><br>    <span class="hljs-keyword">const</span> shasign = crypto.<span class="hljs-title function_">createHmac</span>(<span class="hljs-string">&#x27;SHA256&#x27;</span>, stringify);<br>    <span class="hljs-comment">// 只有调用update后才能通过调用 digest() 方法来生成加密结果，update内部传入的参数是一个长度为 0 的空缓冲区，表示此时没有要加密的数据</span><br>    shasign.<span class="hljs-title function_">update</span>(<span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">0</span>));<br>    <span class="hljs-comment">// base64加密</span><br>    <span class="hljs-keyword">const</span> sign = shasign.<span class="hljs-title function_">digest</span>(<span class="hljs-string">&#x27;base64&#x27;</span>)<br>    dataBody = &#123;<br>            timestamp,<br>            sign,<br>            ...dataBody<br>        &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> &#123;<br>            res<br>        &#125; = <span class="hljs-keyword">await</span> ctx.<span class="hljs-title function_">curl</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>`</span>, &#123;<br><br>            <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>            <span class="hljs-attr">rejectUnauthorized</span>: <span class="hljs-literal">false</span>,<br>            <span class="hljs-attr">headers</span>: &#123;<br>                <span class="hljs-string">&quot;content-type&quot;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>            &#125;,<br>            <span class="hljs-attr">data</span>: dataBody,<br>            <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span><br>        &#125;)<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">code</span>: res.<span class="hljs-property">data</span>.<span class="hljs-property">code</span>,<br>            <span class="hljs-attr">message</span>: res.<span class="hljs-property">data</span>.<span class="hljs-property">msg</span><br>        &#125;;<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://blog.csdn.net/weixin_43110609/article/details/121082091">飞书自定义机器人签名-node</a><br>（2）<a href="https://open.feishu.cn/document/ukTMukTMukTM/ucTM5YjL3ETO24yNxkjN?lang=zh-CN">飞书自定义机器人文档</a></p>]]></content>
    
    
    <categories>
      
      <category>工作技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向面试的算法题</title>
    <link href="/unknown404.github.io/2023/03/08/jsFunction/"/>
    <url>/unknown404.github.io/2023/03/08/jsFunction/</url>
    
    <content type="html"><![CDATA[<h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h3 id="1-数组展平"><a href="#1-数组展平" class="headerlink" title="1.数组展平"></a>1.数组展平</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const flat = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">array</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">array</span>.<span class="hljs-built_in">reduce</span>(<br>    <span class="hljs-function">(<span class="hljs-params">acc, it</span>) =&gt;</span> acc.concat(<span class="hljs-built_in">Array</span>.isArray(it) ? flat(it) : it),<br>    []<br>  );<br>&#125;;<br>const <span class="hljs-built_in">array</span> = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, [<span class="hljs-number">5</span>]]]]];<br>const flatArray = flat(<span class="hljs-built_in">array</span>); <span class="hljs-comment">// [1, 2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure><h3 id="2-compose-函数实现"><a href="#2-compose-函数实现" class="headerlink" title="2.compose 函数实现"></a>2.compose 函数实现</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span><span class="hljs-params">(<span class="hljs-rest_arg">...funcs</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (funcs.length === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> arg =&gt; arg<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (funcs.length === <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> funcs[<span class="hljs-number">0</span>]<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-限制并发请求数"><a href="#3-限制并发请求数" class="headerlink" title="3.限制并发请求数"></a>3.限制并发请求数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">multiRequest</span>(<span class="hljs-params">urls = [], maxNum</span>) &#123;<br>  <span class="hljs-comment">// 请求总数量</span><br>  <span class="hljs-keyword">const</span> len = urls.<span class="hljs-property">length</span>;<br>  <span class="hljs-comment">// 根据请求数量创建一个数组来保存请求的结果</span><br>  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(len).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-comment">// 当前完成的数量</span><br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 请求maxNum个</span><br>    <span class="hljs-keyword">while</span> (count &lt; maxNum) &#123;<br>      <span class="hljs-title function_">next</span>();<br>    &#125;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">let</span> current = count++;<br>      <span class="hljs-comment">// 处理边界条件</span><br>      <span class="hljs-keyword">if</span> (current &gt;= len) &#123;<br>        <span class="hljs-comment">// 请求全部完成就将promise置为成功状态, 然后将result作为promise值返回</span><br>        !result.<span class="hljs-title function_">includes</span>(<span class="hljs-literal">false</span>) &amp;&amp; <span class="hljs-title function_">resolve</span>(result);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">const</span> url = urls[current];<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`开始 <span class="hljs-subst">$&#123;current&#125;</span>`</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toLocaleString</span>());<br>      <span class="hljs-title function_">fetch</span>(url)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>          <span class="hljs-comment">// 保存请求结果</span><br>          result[current] = res;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`完成 <span class="hljs-subst">$&#123;current&#125;</span>`</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toLocaleString</span>());<br>          <span class="hljs-comment">// 请求没有全部完成, 就递归</span><br>          <span class="hljs-keyword">if</span> (current &lt; len) &#123;<br>            <span class="hljs-title function_">next</span>();<br>          &#125;<br>        &#125;)<br>        .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`结束 <span class="hljs-subst">$&#123;current&#125;</span>`</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toLocaleString</span>());<br>          result[current] = err;<br>          <span class="hljs-comment">// 请求没有全部完成, 就递归</span><br>          <span class="hljs-keyword">if</span> (current &lt; len) &#123;<br>            <span class="hljs-title function_">next</span>();<br>          &#125;<br>        &#125;);<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-树结构转换"><a href="#4-树结构转换" class="headerlink" title="4.树结构转换"></a>4.树结构转换</h3><p>非递归方法： 1.先构建 map 结构，以各个子项 id 为 key 2.再循环目标数组，判断上面构建的 map 中，是否存在当前遍历的 pid 3.存在就可以进行 children 的插入 4.不存在就是顶级节点，直接 push 即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<br>  &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">pid</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;body&quot;</span>,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">pid</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;title&quot;</span>,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-attr">pid</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;div&quot;</span>,<br>  &#125;,<br>];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">toTree</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">let</span> res = [],<br>    map = &#123;&#125;;<br>  arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> (map[item.<span class="hljs-property">id</span>] = item));<br>  arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> parent = map[item.<span class="hljs-property">pid</span>];<br>    <span class="hljs-keyword">if</span> (parent) &#123;<br>      <span class="hljs-keyword">if</span> (!parent.<span class="hljs-property">children</span>) &#123;<br>        parent.<span class="hljs-property">children</span> = [];<br>      &#125;<br>      parent.<span class="hljs-property">children</span>.<span class="hljs-title function_">push</span>(item);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      res.<span class="hljs-title function_">push</span>(item);<br>    &#125;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-数组相等判断"><a href="#5-数组相等判断" class="headerlink" title="5.数组相等判断"></a>5.数组相等判断</h3><p>判断思路：1.数组长度是否相等；2.元素可重复的情况需要进行计数，最好用 Map 数据结构保存，以防数组中有 1 和‘1’两种元素、计数时会被混淆；3.边界问题考虑（NaN 等）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">areArraysContentEqual</span>(<span class="hljs-params">arr1, arr2</span>) &#123;<br>  <span class="hljs-comment">// 数组长度是否相等</span><br>  <span class="hljs-keyword">if</span> (arr1.<span class="hljs-property">length</span> !== arr2.<span class="hljs-property">length</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 创建计数对象，用于记录每个元素在数组中的出现次数</span><br>  <span class="hljs-keyword">const</span> countMap1 = <span class="hljs-title function_">count</span>(arr1);<br>  <span class="hljs-keyword">const</span> countMap2 = <span class="hljs-title function_">count</span>(arr2);<br><br>  <span class="hljs-comment">// 统计数组中的元素出现次数</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">count</span>(<span class="hljs-params">arr = []</span>) &#123;<br>    <span class="hljs-keyword">const</span> resMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> arr) &#123;<br>      resMap.<span class="hljs-title function_">set</span>(item, (resMap.<span class="hljs-title function_">get</span>(item) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> resMap;<br>  &#125;<br>  <span class="hljs-comment">// 检查计数对象是否相等</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, count] <span class="hljs-keyword">of</span> countMap1) &#123;<br>    <span class="hljs-keyword">if</span> (countMap2.<span class="hljs-title function_">get</span>(key) !== count) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> array1 = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;11&quot;</span>, <span class="hljs-number">11</span>];<br><span class="hljs-keyword">const</span> array2 = [<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;11&quot;</span>, <span class="hljs-number">11</span>];<br><br><span class="hljs-title function_">areArraysContentEqual</span>(array1, array2); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="6-发布订阅模式"><a href="#6-发布订阅模式" class="headerlink" title="6.发布订阅模式"></a>6.发布订阅模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventEmitter</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span> = &#123;&#125;; <span class="hljs-comment">// 存储事件与回调</span><br>  &#125;<br><br>  <span class="hljs-comment">// 订阅事件</span><br>  <span class="hljs-title function_">on</span>(<span class="hljs-params">eventName, callback</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[eventName]) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[eventName] = [];<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[eventName].<span class="hljs-title function_">push</span>(callback);<br>  &#125;<br><br>  <span class="hljs-comment">// 取消订阅</span><br>  <span class="hljs-title function_">off</span>(<span class="hljs-params">eventName, callback</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[eventName]) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 如果不传 callback，则移除所有监听</span><br>    <span class="hljs-keyword">if</span> (!callback) &#123;<br>      <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[eventName];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[eventName] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[eventName].<span class="hljs-title function_">filter</span>(<br>        <span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> cb !== callback<br>      );<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 触发事件</span><br>  <span class="hljs-title function_">emit</span>(<span class="hljs-params">eventName, ...args</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[eventName]) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[eventName].<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">callback</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">callback</span>(...args);<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">// 订阅一次后自动取消订阅</span><br>  <span class="hljs-title function_">once</span>(<span class="hljs-params">eventName, callback</span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">wrapper</span> = (<span class="hljs-params">...args</span>) =&gt; &#123;<br>      <span class="hljs-title function_">callback</span>(...args);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">off</span>(eventName, wrapper); <span class="hljs-comment">// 调用后立即移除监听</span><br>    &#125;;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">on</span>(eventName, wrapper);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-实现一个带并发限制的异步调度器-Scheduler，保证同时运行的任务最多有两个。完善下面代码中的-Scheduler-类，使得以下程序能正确输出。"><a href="#7-实现一个带并发限制的异步调度器-Scheduler，保证同时运行的任务最多有两个。完善下面代码中的-Scheduler-类，使得以下程序能正确输出。" class="headerlink" title="7.实现一个带并发限制的异步调度器 Scheduler，保证同时运行的任务最多有两个。完善下面代码中的 Scheduler 类，使得以下程序能正确输出。"></a>7.实现一个带并发限制的异步调度器 Scheduler，保证同时运行的任务最多有两个。完善下面代码中的 Scheduler 类，使得以下程序能正确输出。</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs stylus">class Scheduler &#123;<br>  <span class="hljs-built_in">add</span>(promiseCreator) &#123; ... &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br>const timeout = (time) =&gt; new <span class="hljs-built_in">Promise</span>(resolve =&gt; &#123;<br>  <span class="hljs-built_in">setTimeout</span>(resolve, time)<br>&#125;)<br><br>const scheduler = new <span class="hljs-built_in">Scheduler</span>()<br>const addTask = (<span class="hljs-selector-tag">time</span>, <span class="hljs-attribute">order</span>) =&gt; &#123;<br>  scheduler<span class="hljs-selector-class">.add</span>(() =&gt; <span class="hljs-built_in">timeout</span>(time))<span class="hljs-selector-class">.then</span>(() =&gt; console<span class="hljs-selector-class">.log</span>(<span class="hljs-attribute">order</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">addTask</span><span class="hljs-params">(<span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;1&#x27;</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">addTask</span><span class="hljs-params">(<span class="hljs-number">500</span>, <span class="hljs-string">&#x27;2&#x27;</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">addTask</span><span class="hljs-params">(<span class="hljs-number">300</span>, <span class="hljs-string">&#x27;3&#x27;</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">addTask</span><span class="hljs-params">(<span class="hljs-number">400</span>, <span class="hljs-string">&#x27;4&#x27;</span>)</span></span><br><br><span class="hljs-comment">// 打印顺序是：2 3 1 4</span><br></code></pre></td></tr></table></figure><p>实现方法：题目中scheduler.add(() &#x3D;&gt; timeout(time))之后接的是then，说明add方法一定是一个Promise。add方法可以被立即调用，但是不一定会立即执行，说明维护了一个队列，存放我们的任务。<br>另外，同时运行的任务最多有两个，说明要维护一个变量存放正在运行的任务数量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Scheduler</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span> = []; <span class="hljs-comment">// 存储等待执行的任务</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">running</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前正在执行的任务数</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxConcurrent</span> = <span class="hljs-number">2</span>; <span class="hljs-comment">// 最大并发数</span><br>  &#125;<br><br>  <span class="hljs-title function_">add</span>(<span class="hljs-params">promiseCreator</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">promiseCreator</span>().<span class="hljs-title function_">then</span>(resolve));<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">runNext</span>(); <span class="hljs-comment">// 尝试运行下一个任务</span><br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">runNext</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">running</span> &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxConcurrent</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 超过并发限制或无任务时直接返回</span><br>    &#125;<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">running</span>++; <span class="hljs-comment">// 增加当前运行的任务数</span><br>    <span class="hljs-keyword">const</span> task = <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-title function_">shift</span>(); <span class="hljs-comment">// 取出队列中的第一个任务</span><br>    <span class="hljs-title function_">task</span>().<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">running</span>--; <span class="hljs-comment">// 当前任务完成后减少计数</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">runNext</span>(); <span class="hljs-comment">// 继续运行下一个任务</span><br>    &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 工具函数，模拟延迟</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">timeout</span> = (<span class="hljs-params">time</span>) =&gt;<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(resolve, time);<br>  &#125;);<br><br><span class="hljs-comment">// 实例化 Scheduler</span><br><span class="hljs-keyword">const</span> scheduler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scheduler</span>();<br><br><span class="hljs-comment">// 添加任务</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">addTask</span> = (<span class="hljs-params">time, order</span>) =&gt; &#123;<br>  scheduler.<span class="hljs-title function_">add</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">timeout</span>(time)).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(order));<br>&#125;;<br><br><span class="hljs-comment">// 调用任务</span><br><span class="hljs-title function_">addTask</span>(<span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;1&#x27;</span>);<br><span class="hljs-title function_">addTask</span>(<span class="hljs-number">500</span>, <span class="hljs-string">&#x27;2&#x27;</span>);<br><span class="hljs-title function_">addTask</span>(<span class="hljs-number">300</span>, <span class="hljs-string">&#x27;3&#x27;</span>);<br><span class="hljs-title function_">addTask</span>(<span class="hljs-number">400</span>, <span class="hljs-string">&#x27;4&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>（1）<a href="https://www.jb51.net/article/211898.htm">字节跳动面试之如何用 JS 实现 Ajax 并发请求控制</a><br>（2）<a href="https://juejin.cn/post/7290786959441117243">面试官：如何判断两个数组的内容是否相等</a></p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>JavaScript</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法与数据结构</title>
    <link href="/unknown404.github.io/2023/03/02/algorithm/"/>
    <url>/unknown404.github.io/2023/03/02/algorithm/</url>
    
    <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p><strong>时间复杂度</strong>：随着输入数据规模的增长，算法执行时间的增长趋势。<br><strong>空间复杂度</strong>：随着输入数据规模的增长，算法所需要的存储空间的增长趋势。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="下划线转驼峰"><a href="#下划线转驼峰" class="headerlink" title="下划线转驼峰"></a>下划线转驼峰</h4><p>正则筛选下划线+首字母点位</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">camelCase</span>(<span class="hljs-params">str</span>) &#123;<br>  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/_([a-z])/g</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">match, group1</span>) &#123;<br>    <span class="hljs-keyword">return</span> group1.<span class="hljs-title function_">toUpperCase</span>();<br>  &#125;);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">camelCase</span>(<span class="hljs-string">&quot;some_string&quot;</span>));<br></code></pre></td></tr></table></figure><h4 id="数字千分位分割"><a href="#数字千分位分割" class="headerlink" title="数字千分位分割"></a>数字千分位分割</h4><ol><li>toLocaleString<br>如果考虑带小数点的情况，则需要配置属性</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> number = <span class="hljs-number">1234567890.12345</span>;<br><span class="hljs-keyword">const</span> formattedNumber = number.<span class="hljs-title function_">toLocaleString</span>(<span class="hljs-string">&quot;en-US&quot;</span>, &#123;<br>  <span class="hljs-attr">minimumFractionDigits</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">maximumFractionDigits</span>: <span class="hljs-number">2</span>,<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(formattedNumber); <span class="hljs-comment">// &quot;1,234,567,890.12&quot;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>正则<br>将整数部分和小数部分分开处理，再进行千分位分割。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">formatNumber</span>(<span class="hljs-params">num</span>) &#123;<br>  <span class="hljs-keyword">const</span> parts = num.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>);<br>  parts[<span class="hljs-number">0</span>] = parts[<span class="hljs-number">0</span>].<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\B(?=(\d&#123;3&#125;)+(?!\d))/g</span>, <span class="hljs-string">&quot;,&quot;</span>);<br>  <span class="hljs-keyword">return</span> parts.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;.&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> number = <span class="hljs-number">1234567890.12345</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">formatNumber</span>(number)); <span class="hljs-comment">// &quot;1,234,567,890.12345&quot;</span><br></code></pre></td></tr></table></figure><h4 id="字符串相加（大数相加）"><a href="#字符串相加（大数相加）" class="headerlink" title="字符串相加（大数相加）"></a>字符串相加（大数相加）</h4><p>解题思路：按数学加法的思路，需维护进位符 flag，从个位开始，每次将两个字符串的个位和 flag 相加如果结果有进位则将进位符 flag 设为 1，没有则置 0，进入下一位的运算。如此循环，直到遍历完所有位数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">num1</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">num2</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">string</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> addStrings = <span class="hljs-keyword">function</span> (<span class="hljs-params">num1, num2</span>) &#123;<br>  <span class="hljs-keyword">let</span> flag = <span class="hljs-number">0</span>,<br>    numArr1 = num1.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>),<br>    numArr2 = num2.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>),<br>    res = [];<br>  <span class="hljs-keyword">for</span> (<br>    <span class="hljs-keyword">let</span> i = numArr1.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>, j = numArr2.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span> || flag;<br>    i--, j--<br>  ) &#123;<br>    <span class="hljs-keyword">let</span> count1 = i &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : numArr1[i];<br>    <span class="hljs-keyword">let</span> count2 = j &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : numArr2[j];<br>    <span class="hljs-keyword">let</span> tmp = (count1 + count2 + flag) % <span class="hljs-number">10</span>;<br>    flag = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((count1 + count2 + flag) / <span class="hljs-number">10</span>);<br>    res.<span class="hljs-title function_">push</span>(tmp);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="最长字符串"><a href="#最长字符串" class="headerlink" title="最长字符串"></a>最长字符串</h4><p>解题思路： 使用一个数组来维护滑动窗口<br>遍历字符串，判断字符是否在滑动窗口数组里</p><ul><li>不在则 push 进数组</li><li>在则删除滑动窗口数组里相同字符及相同字符前的字符，然后将当前字符 push 进数组</li><li>然后将 max 更新为当前最长子串的长度</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> lengthOfLongestSubstring = <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">let</span> arr = [], max = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">let</span> index = arr.<span class="hljs-title function_">indexOf</span>(s[i])<br>        <span class="hljs-keyword">if</span>(index !== -<span class="hljs-number">1</span>) &#123;<br>            arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, index+<span class="hljs-number">1</span>);<br>        &#125;<br>        arr.<span class="hljs-title function_">push</span>(s.<span class="hljs-title function_">charAt</span>(i))<br>        max = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(arr.<span class="hljs-property">length</span>, max)<br>    &#125;<br>    <span class="hljs-keyword">return</span> max<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="数组乱序"><a href="#数组乱序" class="headerlink" title="数组乱序"></a>数组乱序</h4><p>思路：洗牌算法，从数组的最后一个元素开始，生成一个随机索引 j，这个索引的范围是从 0 到当前元素的索引 i。交换数组中索引为 i 和 j 的元素。每次将当前索引 i 减 1，直到整个数组遍历完毕。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">shuffle</span>(<span class="hljs-params">array</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = array.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-comment">// 生成一个随机索引 j，范围是 0 到 i（包含 i）</span><br>    <span class="hljs-keyword">const</span> j = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (i + <span class="hljs-number">1</span>));<br>    <span class="hljs-comment">// 交换 array[i] 和 array[j]</span><br>    [array[i], array[j]] = [array[j], array[i]];<br>  &#125;<br>  <span class="hljs-keyword">return</span> array;<br>&#125;<br><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">shuffle</span>(arr)); <span class="hljs-comment">// 输出乱序后的数组</span><br><br></code></pre></td></tr></table></figure><h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h4><ol><li>indexOf 和 filter（无法带 NaN）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">unique</span> = arr =&gt; arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">e,i</span>) =&gt;</span> arr.<span class="hljs-title function_">indexOf</span>(e) === i);<br></code></pre></td></tr></table></figure><ol start="2"><li>Set</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">unique</span> = arr =&gt; [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)];<br></code></pre></td></tr></table></figure><ol start="3"><li>reduce 和 includes<br>通过 reduce 方法遍历数组，并使用 includes 来判断结果数组中是否已经存在当前元素，来实现去重。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> uniqueArray = array.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, item</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (!acc.<span class="hljs-title function_">includes</span>(item)) &#123;<br>    acc.<span class="hljs-title function_">push</span>(item);<br>  &#125;<br>  <span class="hljs-keyword">return</span> acc;<br>&#125;, []);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uniqueArray); <span class="hljs-comment">// 输出: [1, 2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure><ol start="4"><li>Map 和 filter</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><span class="hljs-keyword">const</span> uniqueArray = array.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> !map.<span class="hljs-title function_">has</span>(item) &amp;&amp; map.<span class="hljs-title function_">set</span>(item, <span class="hljs-literal">true</span>));<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uniqueArray); <span class="hljs-comment">// 输出: [1, 2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure><h4 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h4><ol><li>递归（reduce 方法类似）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">flat</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">const</span> result = []<br>    arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(item)) &#123;<br>            result.<span class="hljs-title function_">push</span>(...<span class="hljs-title function_">flat</span>(item))<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            result.<span class="hljs-title function_">push</span>(item)<br>        &#125;<br>    &#125;)<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flat</span>(<span class="hljs-params">arr,res=[]</span>)&#123;<br>  arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(item))&#123;<br>      res.<span class="hljs-title function_">push</span>(item)<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-title function_">flat</span>(item,res)<br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">return</span> res<br>&#125;<br><span class="hljs-keyword">const</span> arr = <span class="hljs-title function_">flat</span>(arr)<br></code></pre></td></tr></table></figure><ol start="2"><li>reduce</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> acc.<span class="hljs-title function_">concat</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(cur) ? <span class="hljs-title function_">flatten</span>(cur) : cur)<br>  &#125;, []);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>现成 API</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 第一种方案：用现成flat</span><br><span class="hljs-keyword">const</span> arr1 = arr.<span class="hljs-title function_">flat</span>(<span class="hljs-title class_">Infinity</span>)<br><br><span class="hljs-comment">// 第二种方案：利用join展平</span><br><span class="hljs-keyword">const</span> arr2 = arr.<span class="hljs-title function_">join</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>)<br><br><span class="hljs-comment">// 第三种方案：利用toString直接展平</span><br><span class="hljs-keyword">const</span> arr3 = arr.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>)<br></code></pre></td></tr></table></figure><h4 id="数组转树形结构"><a href="#数组转树形结构" class="headerlink" title="数组转树形结构"></a>数组转树形结构</h4><p>首先，我们创建一个空的 map 对象，它的键是每个 id，值是包含 children 的每个节点的引用。这样可以快速查找每个节点的父节点。通过两次遍历：第一次遍历将节点存储到 map，第二次遍历通过 pid 建立父子关系。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">jsonToTree</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-comment">// 初始化结果数组，并判断输入数据的格式</span><br>  <span class="hljs-keyword">let</span> result = [];<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(data)) &#123;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>  <span class="hljs-comment">// 使用map，将当前对象的id与当前对象对应存储起来</span><br>  <span class="hljs-keyword">let</span> map = &#123;&#125;;<br>  data.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>    map[item.<span class="hljs-property">id</span>] = item;<br>  &#125;);<br>  <span class="hljs-comment">//</span><br>  data.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> parent = map[item.<span class="hljs-property">pid</span>];<br>    <span class="hljs-keyword">if</span> (parent) &#123;<br>      (parent.<span class="hljs-property">children</span> || (parent.<span class="hljs-property">children</span> = [])).<span class="hljs-title function_">push</span>(item);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      result.<span class="hljs-title function_">push</span>(item);<br>    &#125;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="两数之和、三数之和"><a href="#两数之和、三数之和" class="headerlink" title="两数之和、三数之和"></a>两数之和、三数之和</h4><h5 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h5><p>情景：给定一个整数数组 nums 和一个目标值 target，请在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。<br>思路：使用一个 map 将遍历过的数字存起来，值作为 key，下标作为值。</p><p>对于每一次遍历：</p><p>取 map 中查找是否有 key 为<code>target-nums[i]</code>的值<br>如果取到了，则条件成立，返回。<br>如果没有取到，将当前值作为 key，下标作为值存入 map</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">arr, target</span>) &#123;<br>  <span class="hljs-keyword">var</span> res = [],<br>    map = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (map[target - arr[i]] != <span class="hljs-literal">undefined</span>) &#123;<br>      res = [i, map[target - arr[i]]];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      map[arr[i]] = i;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h5><p>情景：给定一个整数数组 nums 和一个目标值 target，请在该数组中找出和为目标值的那 3 个整数，并返回他们的数组。<br>思路：需要考虑结果去重。思路与两数之和有类似的地方，遍历数组时选定基准值<code>arr[i]</code>，在数组最左和最右设立指针，判断左指针+基准值+右指针的和是否等于目标值，如果不是需移动指针来靠近。移动指针规则：如果和大于目标值右指针左移，小于左指针右移，等于的时候执行循环，判断左界和右界是否和下一位置重复，去除重复解。并同时将 L,R 移到下一位置，寻找新的解</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> threeSum = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) &#123;<br>  <span class="hljs-keyword">let</span> res = [];<br>  <span class="hljs-keyword">if</span> (nums.<span class="hljs-property">length</span> &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> res;<br>  nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span> - <span class="hljs-number">2</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> first = nums[i];<br>    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; first == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span> (first &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">let</span> left = i + <span class="hljs-number">1</span>,<br>      right = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>      <span class="hljs-keyword">if</span> (first + nums[left] + nums[right] == <span class="hljs-number">0</span>) &#123;<br>        res.<span class="hljs-title function_">push</span>([first, nums[left], nums[right]]);<br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) &#123;<br>          left++;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) &#123;<br>          right--;<br>        &#125;<br>        left++;<br>        right--;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (first + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>) &#123;<br>          right--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          left++;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="对象展开"><a href="#对象展开" class="headerlink" title="对象展开"></a>对象展开</h4><p>思路：递归实现，遍历对象的 key 值，如果 key 对应的 value 是对象，则将展开的 key 值传入递归的函数里，为新键名提供父键信息；否则直接将 key-value 赋给新对象，返回结果必须参与递归入参进行 key 值更新</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">flattenObject</span>(<span class="hljs-params">obj, parentKey = <span class="hljs-string">&quot;&quot;</span>, result = &#123;&#125;</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (obj.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      <span class="hljs-keyword">const</span> newKey = parentKey ? <span class="hljs-string">`<span class="hljs-subst">$&#123;parentKey&#125;</span>.<span class="hljs-subst">$&#123;key&#125;</span>`</span> : key;<br><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj[key] === <span class="hljs-string">&quot;object&quot;</span> &amp;&amp; obj[key] !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 如果是数组，继续递归处理每个数组元素</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj[key])) &#123;<br>          obj[key].<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">// 递归处理数组中的对象，其他类型直接赋值</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> item === <span class="hljs-string">&quot;object&quot;</span> &amp;&amp; item !== <span class="hljs-literal">null</span>) &#123;<br>              <span class="hljs-title function_">flattenObject</span>(item, <span class="hljs-string">`<span class="hljs-subst">$&#123;newKey&#125;</span>[<span class="hljs-subst">$&#123;index&#125;</span>]`</span>, result);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              result[<span class="hljs-string">`<span class="hljs-subst">$&#123;newKey&#125;</span>[<span class="hljs-subst">$&#123;index&#125;</span>]`</span>] = item;<br>            &#125;<br>          &#125;);<br>        &#125;<br>        <span class="hljs-comment">// 如果是对象，递归进行扁平化处理</span><br>        <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-title function_">flattenObject</span>(obj[key], newKey, result);<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 不是对象或数组，直接赋值</span><br>        result[newKey] = obj[key];<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 示例对象和数组</span><br><span class="hljs-keyword">const</span> nestedObj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">address</span>: &#123;<br>    <span class="hljs-attr">city</span>: <span class="hljs-string">&quot;New York&quot;</span>,<br>    <span class="hljs-attr">postalCode</span>: &#123;<br>      <span class="hljs-attr">code</span>: <span class="hljs-string">&quot;10001&quot;</span>,<br>      <span class="hljs-attr">area</span>: <span class="hljs-string">&quot;Manhattan&quot;</span>,<br>    &#125;,<br>  &#125;,<br>  <span class="hljs-attr">hobbies</span>: [<span class="hljs-string">&quot;Reading&quot;</span>, <span class="hljs-string">&quot;Travelling&quot;</span>],<br>  <span class="hljs-attr">contact</span>: &#123;<br>    <span class="hljs-attr">email</span>: <span class="hljs-string">&quot;john@example.com&quot;</span>,<br>    <span class="hljs-attr">phone</span>: &#123;<br>      <span class="hljs-attr">home</span>: <span class="hljs-string">&quot;123-456-7890&quot;</span>,<br>      <span class="hljs-attr">work</span>: <span class="hljs-string">&quot;987-654-3210&quot;</span>,<br>    &#125;,<br>  &#125;,<br>&#125;;<br><br><span class="hljs-comment">// 执行对象扁平化</span><br><span class="hljs-keyword">const</span> flatObj = <span class="hljs-title function_">flattenObject</span>(nestedObj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(flatObj);<br></code></pre></td></tr></table></figure><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>特点：每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。<br>数据结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">TreeNode</span>(<span class="hljs-params">x</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = x;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">left</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">right</span> = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>特点：</p><ul><li>所有叶子节点都出现在 k 或者 k-1 层，而且从 1 到 k-1 层必须达到最大节点数；(第 n 层的节点数最多为 2^n 个节点 n 层二叉树最多有 2^0+…+2^n&#x3D;2^(n+1)-1 个节点)</li><li>第 k 层可以不是满的，但是第 k 层的所有节点必须集中在最左边。</li><li>任何一个节点不能只有左子树没有右子树</li></ul><h4 id="二叉查找树（又叫二叉排序树）"><a href="#二叉查找树（又叫二叉排序树）" class="headerlink" title="二叉查找树（又叫二叉排序树）"></a>二叉查找树（又叫二叉排序树）</h4><p>特点：</p><ul><li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</li><li>左、右子树也分别为二叉排序树。</li><li>二叉排序树的中序遍历一定是从小到大的</li></ul><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>前序遍历：根节点 + 左子树前序遍历 + 右子树前序遍历<br>中序遍历：左子树中序遍历 + 根节点 + 右字数中序遍历<br>后序遍历：左子树后序遍历 + 右子树后序遍历 + 根节点</p><h5 id="递归遍历法"><a href="#递归遍历法" class="headerlink" title="递归遍历法"></a>递归遍历法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">preOrder</span>(<span class="hljs-params">root,arr=[]</span>)&#123;<br>    <span class="hljs-keyword">if</span>(root)&#123;<br>        arr.<span class="hljs-title function_">push</span>(root.<span class="hljs-property">val</span>)<br>        <span class="hljs-title function_">preOrder</span>(root.<span class="hljs-property">left</span>,arr)<br>        <span class="hljs-title function_">preOrder</span>(root.<span class="hljs-property">right</span>,arr)<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">inOrder</span>(<span class="hljs-params">root,arr=[]</span>)&#123;<br>    <span class="hljs-keyword">if</span>(root)&#123;<br>        <span class="hljs-title function_">inOrder</span>(root.<span class="hljs-property">left</span>,arr)<br>        arr.<span class="hljs-title function_">push</span>(root.<span class="hljs-property">val</span>)<br>        <span class="hljs-title function_">inOrder</span>(root.<span class="hljs-property">right</span>,arr)<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">postOrder</span>(<span class="hljs-params">root,arr=[]</span>)&#123;<br>    <span class="hljs-keyword">if</span>(root)&#123;<br>        <span class="hljs-title function_">postOrder</span>(root.<span class="hljs-property">left</span>,arr)<br>        <span class="hljs-title function_">postOrder</span>(root.<span class="hljs-property">right</span>,arr)<br>        arr.<span class="hljs-title function_">push</span>(root.<span class="hljs-property">val</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h5><p>思路：利用栈的特性<br>前序遍历：前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。(保证入栈顺序和遍历顺序相反)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">preOrder</span>(<span class="hljs-params">root</span>)&#123;<br>    <span class="hljs-keyword">let</span> stack=[],current=root,res=[]<br>    stack.<span class="hljs-title function_">push</span>(current)<br>    <span class="hljs-keyword">while</span>(stack.<span class="hljs-property">length</span>)&#123;<br>        current=stack.<span class="hljs-title function_">pop</span>()<br>        res.<span class="hljs-title function_">push</span>(current.<span class="hljs-property">val</span>)<br>        <span class="hljs-keyword">if</span>(current.<span class="hljs-property">right</span>)&#123;<br>            stack.<span class="hljs-title function_">push</span>(current.<span class="hljs-property">right</span>)<br>        &#125;<br>        <span class="hljs-keyword">if</span>(current.<span class="hljs-property">left</span>)&#123;<br>            stack.<span class="hljs-title function_">push</span>(current.<span class="hljs-property">left</span>)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>中序遍历：中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">inOrder</span>(<span class="hljs-params">root</span>)&#123;<br>    <span class="hljs-keyword">let</span> stack=[],current=root,res=[]<br>    <span class="hljs-keyword">while</span>(current||stack.<span class="hljs-property">length</span>!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">while</span>(current)&#123;<br>            stack.<span class="hljs-title function_">push</span>(current)<br>            current=current.<span class="hljs-property">left</span><br>        &#125;<br>        <span class="hljs-keyword">let</span> node=stack.<span class="hljs-title function_">pop</span>()<br>        res.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>)<br>        current=node.<span class="hljs-property">right</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br><br>&#125;<br></code></pre></td></tr></table></figure><p>后序遍历：后序遍历是左右中，可以看作是前序遍历的逆序，先将根节点放入栈中。只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转 result 数组，输出的结果顺序就是左右中了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">postOrder</span>(<span class="hljs-params">root</span>)&#123;<br>    <span class="hljs-keyword">let</span> stack=[],current=root,res=[]<br>    stack.<span class="hljs-title function_">push</span>(current)<br>    <span class="hljs-keyword">while</span>(stack.<span class="hljs-property">length</span>)&#123;<br>        current=stack.<span class="hljs-title function_">pop</span>()<br>        res.<span class="hljs-title function_">push</span>(current.<span class="hljs-property">val</span>)<br>        <span class="hljs-keyword">if</span>(node.<span class="hljs-property">left</span>)stack.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">left</span>)<br>        <span class="hljs-keyword">if</span>(node.<span class="hljs-property">right</span>)stack.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">reverse</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>二叉树的问题基本可以认为是这两种遍历方式的延展，可以看以下几个例子</p><h4 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h4><p>思路：对于根节点来说就是将左子树翻转的结果放到右指针、右子树翻转的结果放在左指针；因此可以用递归的方式解决</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> invertTree = <span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) &#123;<br>  <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;<br>  <span class="hljs-keyword">let</span> leftTree = <span class="hljs-title function_">invertTree</span>(root.<span class="hljs-property">right</span>);<br>  <span class="hljs-keyword">let</span> rightTree = <span class="hljs-title function_">invertTree</span>(root.<span class="hljs-property">left</span>);<br>  root.<span class="hljs-property">left</span> = leftTree;<br>  root.<span class="hljs-property">right</span> = rightTree;<br>  <span class="hljs-keyword">return</span> root;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="二叉树最大深度"><a href="#二叉树最大深度" class="headerlink" title="二叉树最大深度"></a>二叉树最大深度</h4><p>思路：根节点的最大深度可以看作是左子树的最大深度和右子树最大深度比较，最大值加上根节点的 1 就是结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">maxDepth</span>(<span class="hljs-params">root</span>) &#123;<br>  <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> leftDepth = <span class="hljs-title function_">maxDepth</span>(root.<span class="hljs-property">left</span>);<br>  <span class="hljs-keyword">let</span> rightDepth = <span class="hljs-title function_">maxDepth</span>(root.<span class="hljs-property">right</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(leftDepth, rightDepth) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉树的最大直径"><a href="#二叉树的最大直径" class="headerlink" title="二叉树的最大直径"></a>二叉树的最大直径</h4><p>思路：可以看成是二叉树的最大深度的延伸，节点直径就是该节点的左子树的最大深度加右子树最大深度加节点本身，所以最大直径就是遍历节点，把每个节点的直径进行比较。比较的过程可以放在最大深度的递归中实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> diameterOfBinaryTree = <span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) &#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">maxDepth</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> leftDepth = <span class="hljs-title function_">maxDepth</span>(root.<span class="hljs-property">left</span>);<br>    <span class="hljs-keyword">let</span> rightDepth = <span class="hljs-title function_">maxDepth</span>(root.<span class="hljs-property">right</span>);<br>    res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, leftDepth + rightDepth + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(leftDepth, rightDepth) + <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-title function_">maxDepth</span>(root);<br>  <span class="hljs-keyword">return</span> res - <span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="二叉树层级遍历"><a href="#二叉树层级遍历" class="headerlink" title="二叉树层级遍历"></a>二叉树层级遍历</h4><p>思路：运用迭代的思想，用队列维护每层的节点进出。注意 for 循环遍历队列前要先记录队列长度，因为循环内对队列长度有操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> levelOrder = <span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) &#123;<br>  <span class="hljs-keyword">let</span> temp = [],<br>    arr = [];<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> arr;<br>  temp.<span class="hljs-title function_">push</span>(root);<br>  <span class="hljs-keyword">while</span> (temp.<span class="hljs-property">length</span>) &#123;<br>    <span class="hljs-keyword">let</span> arrItem = [],<br>      size = temp.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>      <span class="hljs-keyword">let</span> current = temp.<span class="hljs-title function_">shift</span>();<br>      arrItem.<span class="hljs-title function_">push</span>(current.<span class="hljs-property">val</span>);<br>      <span class="hljs-keyword">if</span> (current.<span class="hljs-property">left</span>) &#123;<br>        temp.<span class="hljs-title function_">push</span>(current.<span class="hljs-property">left</span>);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (current.<span class="hljs-property">right</span>) &#123;<br>        temp.<span class="hljs-title function_">push</span>(current.<span class="hljs-property">right</span>);<br>      &#125;<br>    &#125;<br>    arr.<span class="hljs-title function_">push</span>(arrItem);<br>    arrItem = [];<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>特点：用一组任意存储的单元来存储线性表的数据元素。一个对象存储着本身的值和下一个元素的地址。<br>数据结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ListNode</span>(<span class="hljs-params">x</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = x;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>val 属性存储当前的值，next 属性存储下一个节点的引用。当 next 节点是 null 时，说明是最后一个节点，停止遍历。<br>链表数据是线性的，存储空间是不连续的，访问的时间复杂度为 O（n）,增删的时间复杂度为 O(1)。<br>解题思路：</p><ol><li>涉及到可能对头部节点变动时，可以设置虚拟节点 dummy 与 head 连接</li><li>双指针思想：利用两个或多个不同位置的指针，通过速度和方向的变换解决问题。</li></ol><h4 id="链表常规操作"><a href="#链表常规操作" class="headerlink" title="链表常规操作"></a>链表常规操作</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 插入节点</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertNode</span>(<span class="hljs-params">head,index,val</span>)&#123;<br>    <span class="hljs-keyword">const</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>)<br>    dummy.<span class="hljs-property">next</span> = head<br>    <span class="hljs-keyword">const</span> target=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(val)<br>    <span class="hljs-keyword">let</span> start=<span class="hljs-number">0</span>,current=dummy<br>    <span class="hljs-keyword">while</span>(current)&#123;<br>        <span class="hljs-keyword">if</span>(start===index)&#123;<br>            target.<span class="hljs-property">next</span>=current.<span class="hljs-property">next</span><br>            current.<span class="hljs-property">next</span>=target<br>        &#125;<br>        start++<br>        current=current.<span class="hljs-property">next</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span><br>&#125;<br><span class="hljs-comment">// 删除节点</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteNode</span>(<span class="hljs-params">head,index</span>)&#123;<br>    <span class="hljs-keyword">const</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>)<br>    dummy.<span class="hljs-property">next</span> = head<br>    <span class="hljs-keyword">let</span> start=<span class="hljs-number">0</span>,current=dummy<br>    <span class="hljs-keyword">while</span>(current.<span class="hljs-property">next</span>)&#123;<br>        <span class="hljs-keyword">if</span>(start===index)&#123;<br>            current.<span class="hljs-property">next</span>=current.<span class="hljs-property">next</span>.<span class="hljs-property">next</span><br>        &#125;<br>        start++<br>        current=current.<span class="hljs-property">next</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span><br>&#125;<br><span class="hljs-comment">// 从尾到头打印指针</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printListNode</span>(<span class="hljs-params">head</span>)&#123;<br>    <span class="hljs-keyword">let</span> arr=[],current=head<br>    <span class="hljs-keyword">while</span>(current)&#123;<br>        arr.<span class="hljs-title function_">unshift</span>(current.<span class="hljs-property">val</span>)<br>        current=current.<span class="hljs-property">next</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="翻转列表"><a href="#翻转列表" class="headerlink" title="翻转列表"></a>翻转列表</h4><p>思路：双指针，慢指针保存前一个节点的值，快指针进行遍历修改指针方向；需要先存储快指针下一个节点，快指针改变方向时慢指针赋值原快指针，同时将快指针赋值为 next；最后快指针会最先到 null，所以返回的应该是慢指针</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> reverseList = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-keyword">let</span> pre =<span class="hljs-literal">null</span>,cur = head<br>    <span class="hljs-keyword">while</span>(cur)&#123;<br>        <span class="hljs-keyword">let</span> next =cur.<span class="hljs-property">next</span><br>        cur.<span class="hljs-property">next</span> = pre<br>        pre = cur<br>        cur = next<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="链表倒数第-K-个节点"><a href="#链表倒数第-K-个节点" class="headerlink" title="链表倒数第 K 个节点"></a>链表倒数第 K 个节点</h4><p>思路：双指针，快指针比慢指针间隔 k 步当快指针移动到 null 时慢指针位于 n-k 处</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findKthFromTail</span>(<span class="hljs-params">head,k</span>)&#123;<br>    <span class="hljs-keyword">let</span> fast=head,slow=head,index=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span>(fast)&#123;<br>        fast=fast.<span class="hljs-property">next</span><br>        index++<br>        <span class="hljs-keyword">if</span>(index&gt;k)&#123;<br>            slow=slow.<span class="hljs-property">next</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="延伸：删除倒数第-K-个节点"><a href="#延伸：删除倒数第-K-个节点" class="headerlink" title="延伸：删除倒数第 K 个节点"></a>延伸：删除倒数第 K 个节点</h5><p>思路：类似链表倒数第 K 个节点，只是需要找到的节点是倒数 K+1，方便做指针操作：初始化时慢指针在 dummyHeader，快指针在 header。快指针比慢指针间隔 k 步当快指针移动到 null 时慢指针位于 n-k 处，刚好慢指针把倒数第 k 个指针指向改变；由于删除操作有可能涉及头部节点操作，最好加 dummy</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteKthFromTail</span>(<span class="hljs-params">head,k</span>)&#123;<br>    <span class="hljs-keyword">const</span> dummy=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>)<br>    dummy.<span class="hljs-property">next</span>=head<br>    <span class="hljs-keyword">let</span> fast=dummy,slow=dummy,index=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span>(fast)&#123;<br>        fast=fast.<span class="hljs-property">next</span><br>        index++<br>        <span class="hljs-keyword">if</span>(index&gt;k+<span class="hljs-number">1</span>)&#123;<br>            slow=slow.<span class="hljs-property">next</span><br>        &#125;<br>    &#125;<br>    slow.<span class="hljs-property">next</span>=slow.<span class="hljs-property">next</span>.<span class="hljs-property">next</span><br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="链表是否含环"><a href="#链表是否含环" class="headerlink" title="链表是否含环"></a>链表是否含环</h4><p>思路：快慢指针，快指针移动的速度是慢指针的 2 倍，如果快指针和慢指针相遇说明有环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hasCircle</span>(<span class="hljs-params">head</span>)&#123;<br>    <span class="hljs-keyword">let</span> fast=head,slow=head,index<br>    <span class="hljs-keyword">while</span>(fast&amp;&amp;fast.<span class="hljs-property">next</span>)&#123;<br>        fast=fast.<span class="hljs-property">next</span>.<span class="hljs-property">next</span><br>        slow=slow.<span class="hljs-property">next</span><br>        <span class="hljs-keyword">if</span>(fast===slow)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="延伸：找出环起点"><a href="#延伸：找出环起点" class="headerlink" title="延伸：找出环起点"></a>延伸：找出环起点</h5><p>思路：相遇时快慢指针的路程差，是环周长的整数倍。如果相遇以后慢指针回到 head、两指针同速，则两指针到环起点会相遇</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findCircleStart</span>(<span class="hljs-params">head</span>)&#123;<br>    <span class="hljs-keyword">let</span> fast=head,slow=head,index<br>    <span class="hljs-keyword">while</span>(fast&amp;&amp;fast.<span class="hljs-property">next</span>)&#123;<br>        fast=fast.<span class="hljs-property">next</span>.<span class="hljs-property">next</span><br>        slow=slow.<span class="hljs-property">next</span><br>        <span class="hljs-keyword">if</span>(fast===slow)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//判断是否有环</span><br>    <span class="hljs-keyword">if</span>(fast==<span class="hljs-literal">null</span>||fast.<span class="hljs-property">next</span>==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span><br>    slow=head<br>    <span class="hljs-keyword">while</span>(slow!=fast)&#123;<br>        slow=slow.<span class="hljs-property">next</span><br>        fast=fast.<span class="hljs-property">next</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> slow<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="链表合并"><a href="#链表合并" class="headerlink" title="链表合并"></a>链表合并</h4><p>思路：创建新的链表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeList</span>(<span class="hljs-params">list1,list2</span>)&#123;<br>    <span class="hljs-keyword">const</span> dummy=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">let</span> p1=list1,p2=list2,p=dummy<br>    <span class="hljs-keyword">while</span>(p1&amp;&amp;p2)&#123;<br>        <span class="hljs-keyword">if</span>(p1.<span class="hljs-property">val</span>&gt;p2.<span class="hljs-property">val</span>)&#123;<br>            p.<span class="hljs-property">next</span>=p2<br>            p2=p2.<span class="hljs-property">next</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            p.<span class="hljs-property">next</span>=p1<br>            p1=p1.<span class="hljs-property">next</span><br>        &#125;<br>        p=p.<span class="hljs-property">next</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(p1)&#123;<br>        p.<span class="hljs-property">next</span>=p1<br>    &#125;<br>    <span class="hljs-keyword">if</span>(p2)&#123;<br>        p.<span class="hljs-property">next</span>=p2<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><h4 id="有效括号"><a href="#有效括号" class="headerlink" title="有效括号"></a>有效括号</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> isValid = <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">let</span> map = &#123;<br>        <span class="hljs-string">&#x27;&#123;&#x27;</span>: <span class="hljs-string">&#x27;&#125;&#x27;</span>,<br>        <span class="hljs-string">&#x27;(&#x27;</span>: <span class="hljs-string">&#x27;)&#x27;</span>,<br>        <span class="hljs-string">&#x27;[&#x27;</span>: <span class="hljs-string">&#x27;]&#x27;</span><br>    &#125;<br>    <span class="hljs-keyword">let</span> stack = []<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span> ; i++) &#123;<br>        <span class="hljs-keyword">if</span>(map[s[i]]) &#123;<br>            stack.<span class="hljs-title function_">push</span>(s[i])<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] !== map[stack.<span class="hljs-title function_">pop</span>()])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stack.<span class="hljs-property">length</span> === <span class="hljs-number">0</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>思路：双循环，外层循环确定冒泡执行的范围；内层循环执行冒泡，冒泡的原理是内循环的首元素跟附近的元素比较，如果大小顺序相反则进行置换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bubbleSort</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> outer=arr.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>;outer&gt;<span class="hljs-number">0</span>;outer--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> inner=<span class="hljs-number">0</span>;inner&lt;outer;inner++)&#123;<br>            <span class="hljs-keyword">if</span>(arr[inner]&gt;arr[inner+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">const</span> tmp=arr[inner]<br>                arr[inner]=arr[inner+<span class="hljs-number">1</span>]<br>                arr[inner+<span class="hljs-number">1</span>]=tmp<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>思路：双循环，外层循环确定选择执行的范围；内层循环执行选择排序，找到本次循环的最值移动到对应的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">selectSort</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">if</span>(arr.<span class="hljs-property">length</span>&lt;=<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> arr<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> outer=arr.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>;outer&gt;<span class="hljs-number">0</span>;outer--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> inner=<span class="hljs-number">0</span>;inner&lt;outer;inner++)&#123;<br>            <span class="hljs-keyword">if</span>(arr[inner]&gt;arr[outer])&#123;<br>                <span class="hljs-keyword">const</span> tmp=arr[inner]<br>                arr[inner]=arr[outer]<br>                arr[outer]=tmp<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>思路：递归，函数体内以传入数组长度小于等于 1 的情况作为结束递归的方式。选取数组内的一个值作为基准，将其他的值分为两个数组存储，一个是大于基准的数组，一个是小于基准的数组，对这两个数组进行快速排序后和基准值进行连接</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">quickSort</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">if</span>(arr.<span class="hljs-property">length</span>&lt;=<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> arr<br>    <span class="hljs-keyword">const</span> ele=arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>),left=[],right=[]<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-property">length</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(arr[i]&lt;ele)&#123;<br>            left.<span class="hljs-title function_">push</span>(arr[i])<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            right.<span class="hljs-title function_">push</span>(arr[i])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">quickSort</span>(left).<span class="hljs-title function_">concat</span>(ele,<span class="hljs-title function_">quickSort</span>(right))<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h4><p>情景：有一楼梯共 n 级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第 n 级，共有多少种走法<br>思路：倒退，完成最后一步时可能是 n-1 级台阶走一级，也可能是 n-2 级台阶走两级。在完成 n-1 级台阶走法的计算方式和 n 级走法计算本质是一样的。所以需要找基本情况即递归的结束情况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">climbStairs</span>(<span class="hljs-params">n</span>)&#123;<br>    <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span>(n===<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span>(n===<span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">climbStairs</span>(n-<span class="hljs-number">1</span>)+<span class="hljs-title function_">climbStairs</span>(n-<span class="hljs-number">2</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法属于尾递归，即递归调用的结果直接作为函数的返回值。这种特殊的递归形式可以被编译器优化，以减少栈空间的使用，从而提高程序的性能。</p><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>回溯是递归的副产品，只要有递归就会有回溯。</p><p>回溯模版：<br>回溯算法中函数通常没有返回值</p><ol><li>设置终止条件</li><li>回溯遍历：回溯法的搜索过程就是一个树型结构的遍历过程，for 循环用来横向遍历，递归的过程是纵向遍历。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">参数</span>) &#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        <span class="hljs-title function_">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>回溯解决问题类型：</p><ol><li>组合问题：N 个数里面按一定规则找出 k 个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个 N 个数的集合里有多少符合条件的子集</li><li>排列问题：N 个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N 皇后，解数独等等</li></ol><h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><p>情景：给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。<br>解题思路：</p><ul><li>增加存储变量：k 个数组合的结果可以用 tmp 暂时存储，最终的结果用 res 存储；组合内部是没有顺序要求的，因此需要记录起始点</li><li>设置回溯函数形参：存储变量一定也加到形参</li><li>设置回溯函数终止条件：tmp 推入的数据长度等于目标长度 k 时需要将本次组合推入 res 结束递归，注意要传 tmp 的复制而不是本身，因为 tmp 后续还要做操作</li><li>设置回溯函数循环体：循环体的起始点取形参的传入变量，tmp 推入元素，backtrack 函数调用更新 startIdx，再退出路径</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">n</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">k</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[][]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> combine = <span class="hljs-keyword">function</span>(<span class="hljs-params">n, k</span>) &#123;<br>    <span class="hljs-keyword">let</span> tmp=[],res=[]<br>    <span class="hljs-title function_">backtrack</span>(n,k,tmp,res,<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;;<br><span class="hljs-keyword">var</span> backtrack=<span class="hljs-keyword">function</span>(<span class="hljs-params">n,k,tmp,res,startIdx</span>)&#123;<br>    <span class="hljs-keyword">if</span>(tmp.<span class="hljs-property">length</span>===k)&#123;<br>        res.<span class="hljs-title function_">push</span>(tmp.<span class="hljs-title function_">slice</span>())<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=startIdx;i&lt;=n;i++)&#123;<br>        tmp.<span class="hljs-title function_">push</span>(i)<br>        <span class="hljs-title function_">backtrack</span>(n,k,tmp,res,i+<span class="hljs-number">1</span>)<br>        tmp.<span class="hljs-title function_">pop</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="和为-sum-的-n-个数"><a href="#和为-sum-的-n-个数" class="headerlink" title="和为 sum 的 n 个数"></a>和为 sum 的 n 个数</h4><p>情景：给你一个 无重复元素 的整数数组  candidates 和一个目标整数  target ，找出  candidates  中可以使数字和为目标数  target 的 所有   不同组合 ，并以列表形式返回。<br>解题思路：</p><ul><li>增加存储变量：k 个数组合的结果可以用 tmp 暂时存储，最终的结果用 res 存储；组合内部是没有顺序要求的，因此需要记录起始点</li><li>设置回溯函数形参：存储变量一定也加到形参</li><li>设置回溯函数终止条件：tmp 推入的数据和等于目标值 时需要将本次组合推入 res 结束递归，大于目标值 时直接结束递归；注意要传 tmp 的复制而不是本身，因为 tmp 后续还要做操作</li><li>设置回溯函数循环体：循环体的起始点取形参的传入变量，tmp 推入元素，backtrack 函数调用更新 startIdx（startIdx 是当前索引值即可），再退出路径</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">candidates</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">target</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[][]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> combinationSum = <span class="hljs-keyword">function</span>(<span class="hljs-params">candidates, target</span>) &#123;<br>    <span class="hljs-keyword">var</span> res=[],tmp=[]<br>    <span class="hljs-title function_">backtracking</span>(candidates,target,tmp,res,<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;;<br><span class="hljs-keyword">var</span> backtracking=<span class="hljs-keyword">function</span>(<span class="hljs-params">candidates,target,tmp,res,startIdx</span>)&#123;<br>    <span class="hljs-keyword">if</span>(tmp.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>)=&gt;</span>pre+cur,<span class="hljs-number">0</span>)&gt;target)&#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(tmp.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>)=&gt;</span>pre+cur,<span class="hljs-number">0</span>)===target)&#123;<br>        res.<span class="hljs-title function_">push</span>(tmp.<span class="hljs-title function_">slice</span>())<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=startIdx;i&lt;candidates.<span class="hljs-property">length</span>;i++)&#123;<br>        tmp.<span class="hljs-title function_">push</span>(candidates[i])<br>        <span class="hljs-title function_">backtracking</span>(candidates,target,tmp,res,i)<br>        tmp.<span class="hljs-title function_">pop</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="延伸情景"><a href="#延伸情景" class="headerlink" title="延伸情景"></a>延伸情景</h5><ol><li>给定一个候选人编号的集合  candidates  和一个目标数  target ，找出  candidates  中所有可以使数字和为  target  的组合。<br>candidates  中的每个数字在每个组合中只能使用   一次  。<br>思路：与上一题相比需要排除相同元素的组合结果。解决方法是需要先进行排序，让相同的元素靠在一起，如果发现 <code>nums[i] == nums[i-1]</code>，则跳过</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">candidates</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">target</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[][]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> combinationSum2 = <span class="hljs-keyword">function</span>(<span class="hljs-params">candidates, target</span>) &#123;<br><span class="hljs-keyword">var</span> res=[],tmp=[]<br>    <span class="hljs-title function_">backtracking</span>(candidates.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>a-b),target,tmp,res,<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;;<br><span class="hljs-keyword">var</span> backtracking=<span class="hljs-keyword">function</span>(<span class="hljs-params">candidates,target,tmp,res,startIdx</span>)&#123;<br>    <span class="hljs-keyword">if</span>(tmp.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>)=&gt;</span>pre+cur,<span class="hljs-number">0</span>)&gt;target)&#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(tmp.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>)=&gt;</span>pre+cur,<span class="hljs-number">0</span>)===target)&#123;<br>        res.<span class="hljs-title function_">push</span>(tmp.<span class="hljs-title function_">slice</span>())<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=startIdx;i&lt;candidates.<span class="hljs-property">length</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(i&gt;startIdx&amp;&amp;candidates[i]===candidates[i-<span class="hljs-number">1</span>])<span class="hljs-keyword">continue</span><br>        tmp.<span class="hljs-title function_">push</span>(candidates[i])<br>        <span class="hljs-title function_">backtracking</span>(candidates,target,tmp,res,i+<span class="hljs-number">1</span>)<br>        tmp.<span class="hljs-title function_">pop</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h4><p>情景：给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。<br>解题思路：<br><strong>思路 1</strong></p><ul><li>增加存储变量：全排列组合的结果可以用 tmp 暂时存储，最终的结果用 res 存储；组合内部有顺序要求，只是使用过的元素不可以再次使用，因此使用 boolean 数组 used 存储</li><li>设置回溯函数形参：存储变量一定也加到形参</li><li>设置回溯函数终止条件：tmp 推入的数据长度等于目标长度 k 时需要将本次组合推入 res 结束递归，注意要传 tmp 的复制而不是本身，因为 tmp 后续还要做操作</li><li>设置回溯函数循环体：循环体内部判断元素是否已经使用，使用则 continue 跳过此次循环 tmp 推入元素，used 更新，backtrack 函数调用更新 used，再退出路径</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[][]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> permute = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-keyword">var</span> tmp=[],res=[],used=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(nums.<span class="hljs-property">length</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-title function_">backtracking</span>(tmp,res,nums,used)<br>    <span class="hljs-keyword">return</span> res;<br><br>&#125;;<br><span class="hljs-keyword">var</span> backtracking=<span class="hljs-keyword">function</span>(<span class="hljs-params">tmp,res,nums,used</span>)&#123;<br>    <span class="hljs-keyword">if</span>(nums.<span class="hljs-property">length</span>==tmp.<span class="hljs-property">length</span>)&#123;<br>        res.<span class="hljs-title function_">push</span>(tmp.<span class="hljs-title function_">slice</span>())<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-property">length</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(used[i])<span class="hljs-keyword">continue</span><br>        tmp.<span class="hljs-title function_">push</span>(nums[i]);<br>        used[i]=<span class="hljs-literal">true</span><br>        <span class="hljs-title function_">backtracking</span>(tmp,res,nums,used)<br>        tmp.<span class="hljs-title function_">pop</span>();<br>        used[i]=<span class="hljs-literal">false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路 2</strong><br>全排列的思路是使用数组的一个元素，剩下的元素接着进行全排列，再与提取出来的元素组合。因此可以在回溯算法内部改变使用的数组内容，同时终止条件也需要改变</p><ul><li>增加存储变量：全排列组合的结果可以用 tmp 暂时存储，最终的结果用 res 存储</li><li>设置回溯函数形参：存储变量一定也加到形参</li><li>设置回溯函数终止条件：nums 长度为 0 即所有元素全排列结束时需要将本次组合推入 res 结束递归，注意要传 tmp 的复制而不是本身，因为 tmp 后续还要做操作</li><li>设置回溯函数循环体：循环体内部 tmp 推入元素，backtrack 函数调用更新 传入的数组 nums，再退出路径</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[][]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> permute = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-keyword">var</span> tmp=[],res=[];<br>    <span class="hljs-title function_">backtracking</span>(tmp,res,nums)<br>    <span class="hljs-keyword">return</span> res;<br><br>&#125;;<br><span class="hljs-keyword">var</span> backtracking=<span class="hljs-keyword">function</span>(<span class="hljs-params">tmp,res,nums</span>)&#123;<br>    <span class="hljs-keyword">if</span>(nums.<span class="hljs-property">length</span>==<span class="hljs-number">0</span>)&#123;<br>        res.<span class="hljs-title function_">push</span>(tmp.<span class="hljs-title function_">slice</span>())<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-property">length</span>;i++)&#123;<br>        tmp.<span class="hljs-title function_">push</span>(nums[i]);<br>        <span class="hljs-title function_">backtracking</span>(tmp,res,nums.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>,i).<span class="hljs-title function_">concat</span>(nums.<span class="hljs-title function_">slice</span>(i+<span class="hljs-number">1</span>)))<br>        tmp.<span class="hljs-title function_">pop</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>特点：本质是穷举法，问题存在「重叠子问题」，需要用数组或者其他数据结构维护子问题的结果，避免不必要的计算；具有「最优子结构」，可以以「状态转移方程」的形式展示<br>思路：</p><ul><li>定义 dp 数组&#x2F;函数的含义</li><li>明确 base case</li></ul><p>使用场景：</p><ul><li>求最值，最长递增子序列，最小编辑距离</li></ul><p><strong>关于状态转移方程</strong><br>状态转移方程是动态规划中一个核心概念，它描述了系统从一个状态到另一个状态的转变过程。状态转移方程的一般形式为 x(t+1) &#x3D; f(x(t), u(t))，其中 x 表示系统的状态向量，u 表示系统的控制输入向量，t 表示时间。f 是状态转移函数，它描述了系统状态从 t 时刻到 t+1 时刻的变化规律。</p><h4 id="最长递增序列"><a href="#最长递增序列" class="headerlink" title="最长递增序列"></a>最长递增序列</h4><p>情景：给你一个整数数组 nums ，找到其中最长严格递增子序列（）的长度。<br>思路：将 dp 数组每个元素设置为以 nums[i]这个数结尾的最长递增子序列的长度。计算 nums[i]时考虑既然是递增子序列，只要找到 0 ～（i-1）前面那些结尾比 nums[i] 小的子序列，然后把 nums[i] 接到这些子序列末尾，就可以形成一个新的递增子序列，而且这个新的子序列长度加一。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> lengthOfLIS = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) &#123;<br>  <span class="hljs-keyword">let</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(nums.<span class="hljs-property">length</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>      <span class="hljs-keyword">if</span> (nums[j] &lt; nums[i]) &#123;<br>        dp[i] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[j] + <span class="hljs-number">1</span>, dp[i]);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...dp);<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h4><p>情景：给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>思路：只需要求出这个数组每个位置的 最大子序和，然后返回最大子序数组中的最大值即可。对于位置 i 求最大子序，可以考虑 nums[i] 单独成为一段还是加入（i-1）位置的最大子序值 f(i−1) 对应的那一段，这取决于 nums[i] 和 f(i−1)+nums[i] 的大小。在这个问题中 dp 数组的元素即 nums[i]的最大子序和</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxSubArray = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) &#123;<br>  <span class="hljs-keyword">let</span> pre = <span class="hljs-number">0</span>,<br>    max = nums[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>    pre = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(pre + nums[i], nums[i]);<br>    max = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(pre, max);<br>  &#125;<br>  <span class="hljs-keyword">return</span> max;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索(BFS)"></a>广度优先搜索(BFS)</h3><p>特点:越是接近根结点的结点将越早地遍历。<br>在 BFS 中，结点的处理顺序与它们添加到队列的顺序是完全相同的顺序，即先进先出，所以广度优先搜索一般使用队列实现。<br>适用场景：</p><ol><li>前序遍历、层序遍历、之字遍历，树的最左最右点，二叉树最小深度</li><li>矩阵&#x2F;网格的最短路径</li></ol><p>模版：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params"></span>)&#123;<br>    queue.<span class="hljs-title function_">push</span>(start)<br>    <span class="hljs-keyword">while</span>(queue.<span class="hljs-property">length</span>)&#123;<br>        <span class="hljs-keyword">var</span> size=queue.<span class="hljs-property">length</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>            <span class="hljs-keyword">var</span> node=queue.<span class="hljs-title function_">shift</span>()<br>            <span class="hljs-keyword">var</span> next=node+dir<br>            <span class="hljs-keyword">if</span>(越界)<span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span>(满足条件)queue.<span class="hljs-title function_">push</span>(next)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉树层序遍历"><a href="#二叉树层序遍历" class="headerlink" title="二叉树层序遍历"></a>二叉树层序遍历</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[][]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> levelOrder = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!root)<span class="hljs-keyword">return</span> []<br>    <span class="hljs-keyword">let</span> res=[],queue=[root],tmp=[]<br>    <span class="hljs-keyword">while</span>(queue.<span class="hljs-property">length</span>)&#123;<br>        <span class="hljs-keyword">let</span> size=queue.<span class="hljs-property">length</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>            <span class="hljs-keyword">let</span> node=queue.<span class="hljs-title function_">shift</span>()<br>            tmp.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>)<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">left</span>)queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">left</span>)<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">right</span>)queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>)<br>        &#125;<br>        res.<span class="hljs-title function_">push</span>(tmp)<br>        tmp=[]<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉树最小深度"><a href="#二叉树最小深度" class="headerlink" title="二叉树最小深度"></a>二叉树最小深度</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">minDepth</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!root)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">let</span> queue=[],dep=<span class="hljs-number">0</span><br>    queue.<span class="hljs-title function_">push</span>(root)<br>    <span class="hljs-keyword">while</span>(queue.<span class="hljs-property">length</span>)&#123;<br>        <span class="hljs-keyword">let</span> size=queue.<span class="hljs-property">length</span><br>        dep++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>            <span class="hljs-keyword">let</span> node=queue.<span class="hljs-title function_">shift</span>()<br>            <span class="hljs-keyword">if</span>(!node.<span class="hljs-property">left</span>&amp;&amp;!node.<span class="hljs-property">right</span>)<span class="hljs-keyword">return</span> dep<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">left</span>)queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">left</span>)<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">right</span>)queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索(DFS)"></a>深度优先搜索(DFS)</h3><p>特点：更早访问的结点可能不是更靠近根结点的结点。<br>结点的处理顺序是完全相反的顺序，就像它们被添加到栈中一样，它是后进先出。所以深度优先搜索一般使用栈实现。</p><p>模版：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 二叉树的遍历</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root</span>)&#123;<br>   <span class="hljs-title function_">dfs</span>(root.<span class="hljs-property">left</span>)<br>   <span class="hljs-title function_">dfs</span>(root.<span class="hljs-property">right</span>)<br>&#125;<br><span class="hljs-comment">// 二维矩阵的遍历</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">grid:number[][],i:number,j:number,visited:boolean[][]</span>)&#123;<br>    <span class="hljs-keyword">let</span> m = grid.<span class="hljs-property">length</span>, n = grid[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= m || j &gt;= n) &#123;<br>        <span class="hljs-comment">// 超出索引边界</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (visited[i][j]) &#123;<br>        <span class="hljs-comment">// 已遍历过 (i, j)</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 进⼊节点 (i, j)</span><br>    visited[i][j] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-title function_">dfs</span>(grid, i - <span class="hljs-number">1</span>, j, visited); <span class="hljs-comment">// 上</span><br>    <span class="hljs-title function_">dfs</span>(grid, i + <span class="hljs-number">1</span>, j, visited); <span class="hljs-comment">// 下</span><br>    <span class="hljs-title function_">dfs</span>(grid, i, j - <span class="hljs-number">1</span>, visited); <span class="hljs-comment">// 左</span><br>    <span class="hljs-title function_">dfs</span>(grid, i, j + <span class="hljs-number">1</span>, visited); <span class="hljs-comment">// 右</span><br>&#125;<br></code></pre></td></tr></table></figure><p>适用场景：</p><ol><li>中序遍历、二叉树最大深度</li><li>岛屿数量</li></ol><h4 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h4><p>情景：给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">targetSum</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> hasPathSum = <span class="hljs-keyword">function</span>(<span class="hljs-params">root, targetSum</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!root)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">if</span>(!root.<span class="hljs-property">left</span>&amp;&amp;!root.<span class="hljs-property">right</span>)<span class="hljs-keyword">return</span> root.<span class="hljs-property">val</span>===targetSum<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">hasPathSum</span>(root.<span class="hljs-property">left</span>,targetSum-root.<span class="hljs-property">val</span>)||<span class="hljs-title function_">hasPathSum</span>(root.<span class="hljs-property">right</span>,targetSum-root.<span class="hljs-property">val</span>)<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h4><p>思路：遍历二维数组，同时维护一个与原数组同样大小的 boolean 数组 visited（创建二维数组时避免数组元素指向同一引用）记录已经遍历过的元素；也可以使用海水淹没法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">character[][]</span>&#125; <span class="hljs-variable">grid</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> numIslands = <span class="hljs-keyword">function</span> (<span class="hljs-params">grid</span>) &#123;<br>    <span class="hljs-keyword">const</span> m = grid.<span class="hljs-property">length</span>, n = grid[<span class="hljs-number">0</span>].<span class="hljs-property">length</span><br>    <span class="hljs-keyword">let</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(m).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">false</span>)), res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; visited[i][j] === <span class="hljs-literal">false</span>) &#123;<br>                res++;<br>                <span class="hljs-title function_">dfs</span>(grid, visited, i, j, m, n)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;;<br><span class="hljs-keyword">var</span> dfs = <span class="hljs-keyword">function</span> (<span class="hljs-params">grid, visited, i, j, m, n</span>) &#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= m || i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || j &gt;= n) <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span> || visited[i][j] === <span class="hljs-literal">true</span>) <span class="hljs-keyword">return</span><br>    visited[i][j] = <span class="hljs-literal">true</span><br>    <span class="hljs-title function_">dfs</span>(grid, visited, i - <span class="hljs-number">1</span>, j, m, n)<br>    <span class="hljs-title function_">dfs</span>(grid, visited, i + <span class="hljs-number">1</span>, j, m, n)<br>    <span class="hljs-title function_">dfs</span>(grid, visited, i, j - <span class="hljs-number">1</span>, m, n)<br>    <span class="hljs-title function_">dfs</span>(grid, visited, i, j + <span class="hljs-number">1</span>, m, n)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/6844903919722692621">前端该如何准备数据结构和算法</a></p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端监控平台搭建</title>
    <link href="/unknown404.github.io/2023/03/02/errorMonitor/"/>
    <url>/unknown404.github.io/2023/03/02/errorMonitor/</url>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>通常情况下对上线的前端项目进行修改 bug 时，只能依赖用户使用时的反馈，开发者来根据用户所描述的场景去模拟这个错误的产生，效率较低</p><h3 id="1-1-常见的监控平台"><a href="#1-1-常见的监控平台" class="headerlink" title="1.1 常见的监控平台"></a>1.1 常见的监控平台</h3><table><thead><tr><th align="center"></th><th align="center">sentry</th><th align="center">webfunny</th><th align="center">fundebug</th></tr></thead><tbody><tr><td align="center">支持平台</td><td align="center">前端 JavaScript、Vue、React、Angular、React Native 以及后端 Node.js</td><td align="center">h5，PC，微信小程序，uni-app</td><td align="center">前端 JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native 以及后端 Node.js</td></tr><tr><td align="center">是否开源</td><td align="center">是</td><td align="center">否</td><td align="center">否</td></tr><tr><td align="center">支持私有化部署</td><td align="center">是</td><td align="center">是</td><td align="center">否</td></tr><tr><td align="center">费用</td><td align="center">80 美元&#x2F;月</td><td align="center">1500 元&#x2F;年</td><td align="center">159 元&#x2F;月</td></tr></tbody></table><p>使用三方监控的缺点：SDK 并非都是开源，扩展性差，难以覆盖到全端；报错数据不能完全保证私有；要管理公司内部的多个项目时 sentry 的收费会增加</p><h3 id="1-2-监控平台构成"><a href="#1-2-监控平台构成" class="headerlink" title="1.2 监控平台构成"></a>1.2 监控平台构成</h3><p><img src="/unknown404.github.io/img/web-monitor.png"></p><p>SDK 模块：负责采集和上报功能，数据如何采集、采集哪些端，上报哪些信息<br>服务器：负责存储和管理功能，上报的数据结构应该是什么样，数据怎么分类<br>可视化平台：总结异常情况，发送给使用者</p><h2 id="二、SDK-实现"><a href="#二、SDK-实现" class="headerlink" title="二、SDK 实现"></a>二、SDK 实现</h2><h3 id="2-1-SDK-架构"><a href="#2-1-SDK-架构" class="headerlink" title="2.1 SDK 架构"></a>2.1 SDK 架构</h3><p><strong>monorepo</strong></p><p><img src="/unknown404.github.io/img/mono-repo.png"></p><p>特点：一种管理代码的方式，即一个大的 Git 仓库，管理所有的代码。所有的代码处于同样的规则，同样的约束。</p><p>优势： 1.分模块打包、分模块热更新、分包发布（提高开发体验） 2.抽离抽象类、工具类到某个包，代码结构清晰（降低耦合性，提高代码可读性）</p><p><strong>包与包之间关系（mito 为例）</strong></p><p><img src="/unknown404.github.io/img/mito.png"></p><p>各端 SDK 依赖相同的公共包和核心包，core 将客户端的一些共通操作抽离成 baseClient 下的方法由客户端 SDK 继承和实现</p><h3 id="2-2-SDK-原理"><a href="#2-2-SDK-原理" class="headerlink" title="2.2 SDK 原理"></a>2.2 SDK 原理</h3><h4 id="2-2-1-SDK-报错实现"><a href="#2-2-1-SDK-报错实现" class="headerlink" title="2.2.1 SDK 报错实现"></a>2.2.1 SDK 报错实现</h4><p>整体代码架构使用发布-订阅设计模式以便后续迭代功能，处理逻辑基本都在 HandleEvents 文件中</p><p><img src="/unknown404.github.io/img/monitor-sdk.png"></p><h5 id="2-2-1-1-监听-x2F-重写原生事件"><a href="#2-2-1-1-监听-x2F-重写原生事件" class="headerlink" title="2.2.1.1 监听&#x2F;重写原生事件"></a>2.2.1.1 监听&#x2F;重写原生事件</h5><p>SDK 采集的常见错误包括：</p><ol><li>JS 错误和资源错误<br>通过 window.addEventListener 来监听 window 的 error 事件，注意拦截操作放在捕获阶段，一方面因为资源加载错误不会冒泡到 window 上，另一方面防止业务代码的阻止冒泡捕获不到事件<br>判断是否是资源错误的要点：判断 e.target.localName 是否有值，有的话就是资源错误</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">handleError</span>(<span class="hljs-params">errorEvent</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; target &#125; = errorEvent;<br>    <span class="hljs-keyword">if</span> (target.<span class="hljs-property">localName</span>) &#123;<br>    <span class="hljs-comment">// 资源加载错误 提取有用数据</span><br>        <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">resourceTransform</span>(errorEvent.<span class="hljs-property">target</span>);<br>        <span class="hljs-keyword">return</span> reportData.<span class="hljs-title function_">send</span>(data);<br>    &#125;<br>    <span class="hljs-comment">// code error</span><br>    <span class="hljs-keyword">const</span> &#123;<br>    message, filename, lineno, colno, error,<br>    &#125; = errorEvent;<br>    <span class="hljs-keyword">let</span> result;<br>    <span class="hljs-keyword">if</span> (error &amp;&amp; <span class="hljs-title function_">isError</span>(error)) &#123;<br>        result = <span class="hljs-title function_">extractErrorStack</span>(error, <span class="hljs-variable constant_">LEVEL</span>.<span class="hljs-property">Normal</span>);<br>    &#125;<br>    <span class="hljs-comment">// 处理 SyntaxError，stack 没有 lineno、colno</span><br>    <span class="hljs-keyword">if</span> (result) &#123;<br>        <span class="hljs-title class_">HandleEvents</span>.<span class="hljs-title function_">handleNotErrorInstance</span>(message, filename, lineno, colno);<br>    &#125;<br>    result.<span class="hljs-property">type</span> = <span class="hljs-variable constant_">ERRORTYPES</span>.<span class="hljs-property">JAVASCRIPT_ERROR</span>;<br>    reportData.<span class="hljs-title function_">send</span>(result);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>接口错误：所有的请求第三方库都是基于 xhr、fetch 二次封装的，所以只需要重写这两个事件就可以拿到所有的接口请求的信息，通过判断 status 的值来判断当前接口是否是正常的。<br>监控原生事件，如果不支持 addEventListener，那么就是重写原生函数拿到入参，再将原函数返回。<br>以 fetch 为例：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchIntercept</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//拿到老的 fetch 函数</span><br>    <span class="hljs-keyword">const</span> oldFetch = <span class="hljs-variable language_">window</span>.<span class="hljs-property">fetch</span>;<br>    <span class="hljs-comment">// 重写</span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">fetch</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">url, config</span>) &#123;<br>        <span class="hljs-keyword">return</span> oldFetch.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">window</span>, [url, config]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">const</span> tempRes = res.<span class="hljs-title function_">clone</span>()<br>                tempRes.<span class="hljs-title function_">text</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;method&#x27;</span>,config.<span class="hljs-property">method</span>)<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;url&#x27;</span>,url)<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;reqData&#x27;</span>,config.<span class="hljs-property">body</span>)<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;status&#x27;</span>, tempRes.<span class="hljs-property">status</span>)<br>            &#125;)<br>            <span class="hljs-keyword">return</span> res<br>        &#125;,<br>        <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>        <span class="hljs-keyword">throw</span> err<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>unhandledrejection 错误<br>当 Promise 被 reject 且没有 reject 处理器的时候，会触发 unhandledrejection 事件<br>通过 window.addEventListener 可以监听 window 的 unhandledrejection 事件</li></ol><p><strong>Vue 报错捕获</strong><br>Vue 提供了一个函数 errorHandler 供开发者来获取框架层面的错误，所以直接重写该方法并拿到入参即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">errorHandler</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">err, vm, info</span>) &#123;<br>    handleVueError.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, [err, vm, info, <span class="hljs-variable constant_">LEVEL</span>.<span class="hljs-property">Normal</span>, <span class="hljs-variable constant_">LEVEL</span>.<span class="hljs-property">Error</span>, <span class="hljs-title class_">Vue</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p>重写函数需要区分 vue2 和 vue3 的区别</p><p><strong>React 报错捕获</strong></p><ul><li>渲染错误：errorBoundary 组件 React16.13 中提供了 componentDidCatch 钩子函数来回调错误信息，所以我们可以新建一个类 ErrorBoundary 来继承 React，然后然后声明 componentDidCatch 钩子函数，可以拿到错误信息</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> h = <span class="hljs-title class_">React</span>.<span class="hljs-property">createElement</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span> &#125;<br>    &#125;<br><br>    <span class="hljs-title function_">componentDidCatch</span>(<span class="hljs-params">error, errorInfo</span>) &#123;<br>        <span class="hljs-variable constant_">MITO</span>.<span class="hljs-title function_">errorBoundaryReport</span>(error)<br>        <span class="hljs-keyword">if</span> (error) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>                <span class="hljs-attr">hasError</span>: <span class="hljs-literal">true</span><br>            &#125;)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">hasError</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;子组件抛出异常&#x27;</span>)<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">children</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JSX"><span class="hljs-comment">// 然后用 ErrorBoundary 包裹需要处理的组件</span><br>&lt;<span class="hljs-title class_">ErrorBoundary</span>&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><br>&lt;/<span class="hljs-title class_">ErrorBoundary</span>&gt;<br></code></pre></td></tr></table></figure><ul><li>非渲染错误：window.onerror 可以捕捉到</li></ul><h5 id="2-2-1-2-错误上报"><a href="#2-2-1-2-错误上报" class="headerlink" title="2.2.1.2 错误上报"></a>2.2.1.2 错误上报</h5><p><strong>常见的错误上报方式</strong></p><table><thead><tr><th align="center"></th><th align="center">img 请求</th><th align="center">fetch&#x2F;xhr</th><th align="center">navigator.sendBeacon()</th></tr></thead><tbody><tr><td align="center">优点</td><td align="center">兼容性</td><td align="center">兼容性</td><td align="center">不丢点不延迟加载</td></tr><tr><td align="center">缺点</td><td align="center">部分浏览器丢点；延时页面加载；get 长度限制</td><td align="center">fetch 丢点，同步 xhr 不丢点，延迟页面卸载</td><td align="center">兼容性</td></tr></tbody></table><p>丢点：页面卸载时正在上报的请求丢失</p><p><strong>采样上报</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 只采集 20%</span><br><span class="hljs-keyword">if</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &lt; <span class="hljs-number">0.2</span>) &#123;<br><span class="hljs-title function_">collect</span>(data) <span class="hljs-comment">// 记录错误信息</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-2-性能上报原理"><a href="#2-2-2-性能上报原理" class="headerlink" title="2.2.2 性能上报原理"></a>2.2.2 性能上报原理</h4><p>PerformanceTiming：会返回一个对象，从输入 url 到用户可以使用页面的全过程时间统计，单位均为毫秒</p><table><thead><tr><th align="center">目标指标</th><th align="center">计算方式</th><th align="center">定义</th></tr></thead><tbody><tr><td align="center">DNS 解析时间</td><td align="center">domainLookupEnd - domainLookupStart</td><td align="center">从发起页面域名解析至完成</td></tr><tr><td align="center">TCP 建立链接时间</td><td align="center">connectEnd - connectStart</td><td align="center">从发起 TCP 链接到三次握手完成</td></tr><tr><td align="center">白屏时间</td><td align="center">responseStart - navigationStart</td><td align="center">从发起页面请求到服务器返回第一个字节</td></tr></tbody></table><p>SDK 总结：<br>监听 &#x2F; 劫持 原始方法，获取需要上报的数据、调整数据结构，在错误发生时触发函数上报。</p><h2 id="三、服务器"><a href="#三、服务器" class="headerlink" title="三、服务器"></a>三、服务器</h2><p>这个环节，输入是接口接收到的错误记录，输出是有效的数据入库。其核心功能包括对数据进行清洗和对数据进行入库。</p><h3 id="3-1-数据收集"><a href="#3-1-数据收集" class="headerlink" title="3.1 数据收集"></a>3.1 数据收集</h3><p>主要工作： 提供无状态的 API 服务，逻辑较轻。功能包括为 SDK 提供上报接口，进行 cookie 的识别鉴权</p><h3 id="3-2-数据处理"><a href="#3-2-数据处理" class="headerlink" title="3.2 数据处理"></a>3.2 数据处理</h3><p>•可为报错信息提供纬度补充（IP -&gt; 地理位置）， 设备情况（User-Agent ）等 SDK 拿不到的信息。<br>•由于数据量较大，所以所有数据并不是写在 elasticsearch 的一个索引里面的，这个时候就需要按天建立索引保存数据。</p><h3 id="3-3-错误存储"><a href="#3-3-错误存储" class="headerlink" title="3.3 错误存储"></a>3.3 错误存储</h3><p>常见的技术选型包括：ELK 类系统、Hadoop&#x2F;Hive、日志服务（SLS）</p><ul><li>ELK 系统：Elasticsearch、Logstash、Kibana 三个系统的合称<ul><li>Elasticsearch：一个近实时的分系统的分布式搜索和分析引擎，它可以用于全文搜索，结构化搜索以及分析。监控系统中 Elasticsearch 可以用来完成日志的检索、分析工作。</li><li>Logstash：一个用于管理日志和事件的工具，你可以用它去收集日志、转换日志、解析日志并将他们作为数据提供给其它模块调用，例如搜索、存储等。</li><li>Kibana：一个优秀的前端日志展示框架，它可以非常详细的将日志转化为各种图表，为用户提供强大的数据可视化支持。</li></ul></li></ul><p>日志数据在 ELK 系统流向<br><img src="/unknown404.github.io/img/elk.png"></p><ul><li><p>Hadoop&#x2F;Hive：Hadoop 是一个存储计算框架，其核心的设计就是：HDFS 和 MapReduce。HDFS 为海量的数据提供了存储，则 MapReduce 为海量的数据提供了计算。Hive 是基于 Hadoop 的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表并提供类 sql 查询功能，减小学习成本。</p></li><li><p>日志服务：由阿里云提供，需要付费。日志服务（SLS）一站式提供数据采集、加工、查询与分析、可视化、告警、消费与投递等功能。</p><table><thead><tr><th align="center"></th><th align="center">ELK 类系统</th><th align="center">Hadoop + Hive</th><th align="center">日志服务</th></tr></thead><tbody><tr><td align="center">可查延时</td><td align="center">1~60 秒</td><td align="center">几分钟~数小时</td><td align="center">实时</td></tr><tr><td align="center">查询延时</td><td align="center">小于 1 秒</td><td align="center">分钟级</td><td align="center">小于 1 秒</td></tr></tbody></table></li></ul><h2 id="四、可视化平台（dofin-为例）"><a href="#四、可视化平台（dofin-为例）" class="headerlink" title="四、可视化平台（dofin 为例）"></a>四、可视化平台（dofin 为例）</h2><p>涉及技术：umi+ant design pro</p><h3 id="4-1-为什么不直接用-Kibana-作为展示的可视化平台？"><a href="#4-1-为什么不直接用-Kibana-作为展示的可视化平台？" class="headerlink" title="4.1 为什么不直接用 Kibana 作为展示的可视化平台？"></a>4.1 为什么不直接用 Kibana 作为展示的可视化平台？</h3><p>在测试 SDK 的时候会对 Kibana 打印的日志数据进行分析。但 Kibana 的日志查询、筛选需要对 Lucene 语法有一定的掌握，面向用户性并不是很好；另一方面 Kinbana 不便于前端做很灵活的扩展，例如用户的身份关联、未来的报警等功能实现；使用 Kibana 做如均值的运算并不利于前端人员做后续维护</p><h3 id="4-2-页面基本需求"><a href="#4-2-页面基本需求" class="headerlink" title="4.2 页面基本需求"></a>4.2 页面基本需求</h3><h4 id="4-2-1-错误查看页面"><a href="#4-2-1-错误查看页面" class="headerlink" title="4.2.1 错误查看页面"></a>4.2.1 错误查看页面</h4><p>可视化平台的最终目的-&gt;how：怎么定位问题<br>实现目的所需要的信息-&gt;what：是什么错误<br>when：什么时候发生的<br>where：发生错误所处的环境、问题所在的页面</p><table><thead><tr><th align="center">主要页面</th><th align="center">基本需求</th></tr></thead><tbody><tr><td align="center">错误列表</td><td align="center">支持多种类型条件搜索，通过筛选来观察错误情况的共通性；通过报错时间来观察同类错误报错频繁度</td></tr><tr><td align="center">错误详情</td><td align="center">能确认错误的特征信息；对同类错误可以提供趋势表，便于观察错误的波动情况</td></tr></tbody></table><h4 id="4-2-2-性能查看页面"><a href="#4-2-2-性能查看页面" class="headerlink" title="4.2.2 性能查看页面"></a>4.2.2 性能查看页面</h4><p>CDN 测距：监听的是 front-end 工程的一个图片加载的起始时间和结束时间<br>server 测距：监听的是目标工程域名下的请求</p><h3 id="4-3-页面扩展需求"><a href="#4-3-页面扩展需求" class="headerlink" title="4.3 页面扩展需求"></a>4.3 页面扩展需求</h3><h4 id="4-3-1-权限管理"><a href="#4-3-1-权限管理" class="headerlink" title="4.3.1 权限管理"></a>4.3.1 权限管理</h4><p>通常一个项目的维护需要一个团队的协作，如果刚接手项目的成员不熟悉系统误操作了工程的删除会对后端维护造成一定的麻烦，因此参考了 gitlab 成员管理原则进行了权限限制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">//route.ts</span><br><span class="hljs-attr">routes</span>: [<br>&#123;<br><span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br><span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;../layouts/BasicLayout&#x27;</span>,<br><span class="hljs-attr">authority</span>: [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>],<br><span class="hljs-attr">routes</span>: [<br>&#123;<br><span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/admin&#x27;</span>,<br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;创建者管理页&#x27;</span>,<br><span class="hljs-attr">authority</span>: [<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>],<span class="hljs-comment">//管理员以上可访问</span><br>],<br>&#125;,<br>......<br><span class="hljs-comment">//basicLayout</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">setAuthorized</span>(<span class="hljs-title function_">getMatchMenu</span>(location.<span class="hljs-property">pathname</span> || <span class="hljs-string">&#x27;/&#x27;</span>, menu, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>).<span class="hljs-title function_">pop</span>() <span class="hljs-keyword">as</span> any || &#123;<br>        <span class="hljs-attr">authority</span>: <span class="hljs-string">&#x27;4&#x27;</span>,<br>    &#125;);<br>&#125;, [location.<span class="hljs-property">pathname</span>,menu.<span class="hljs-property">length</span>]);<br>......<br> &lt;<span class="hljs-title class_">Authorized</span> authority=&#123;authorized!.<span class="hljs-property">authority</span>&#125; noMatch=&#123;noMatch&#125;&gt;<br>    &#123;children&#125;<br>&lt;/<span class="hljs-title class_">Authorized</span>&gt;<br></code></pre></td></tr></table></figure><p>方法：在渲染前获取当前访问的页面的权限（与路由设置的 authority 相关），赋值 authorized.authority，在 Authorized 组件中会将存储在 localStorage 的用户权限等级与组件的 authority 属性进行比较，不匹配则展现默认页面</p><h4 id="4-3-2-未来展望：报警系统"><a href="#4-3-2-未来展望：报警系统" class="headerlink" title="4.3.2 未来展望：报警系统"></a>4.3.2 未来展望：报警系统</h4><p>报警创建思路</p><ol><li>前端针对业务需求设置某类错误的阈值、报警轮询间隔等规则，点击提交时请求与已有的报警规则数据比较，确定是新规则会传到后端</li><li>后端根据规则创建定时任务，定时任务的回调函数判断报错数是否超过设定阈值；同时将报警规则传入数据库</li><li>从日志服务器获取的每分钟错误数超过设定阈值时通过飞书 hook 报警到对应的群<br><img src="/unknown404.github.io/img/alarm.png"></li></ol><p><img src="/unknown404.github.io/img/robot.png"></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li><a href="https://juejin.cn/post/6987681953424080926#heading-17">https://juejin.cn/post/6987681953424080926#heading-17</a></li><li><a href="https://juejin.cn/post/7016897995031445511#heading-14">https://juejin.cn/post/7016897995031445511#heading-14</a></li><li><a href="https://juejin.cn/post/6862559324632252430#heading-7">https://juejin.cn/post/6862559324632252430#heading-7</a></li><li><a href="https://hub.fastgit.org/kisslove/web-monitoring/blob/e06d28312a17d8a09dbc2997a437f952075c8868/backend_server/business/site.js#L111">https://hub.fastgit.org/kisslove/web-monitoring/blob/e06d28312a17d8a09dbc2997a437f952075c8868/backend_server/business/site.js#L111</a></li><li><a href="https://juejin.cn/post/6960919409267474439#heading-4">https://juejin.cn/post/6960919409267474439#heading-4</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端监控</tag>
      
      <tag>分享记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序基础知识</title>
    <link href="/unknown404.github.io/2023/02/27/applet/"/>
    <url>/unknown404.github.io/2023/02/27/applet/</url>
    
    <content type="html"><![CDATA[<p>小程序基础知识汇总。</p><span id="more"></span><h2 id="微信小程序结构"><a href="#微信小程序结构" class="headerlink" title="微信小程序结构"></a>微信小程序结构</h2><p>小程序的运行环境分成渲染层和逻辑层，其中 WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。视图层和逻辑层通过 Native 层进行进行通信，并且通过 Native 层获得原生能力。<br>逻辑层和视图层之间的工作方式为：数据变更通过 setData 驱动视图更新；视图层交互触发事件，然后触发逻辑层的事件响应函数，函数中修改数据再次触发视图更新。</p><p><strong>特点</strong></p><ul><li>渲染线程、逻辑线程并行处理</li><li>JS 不能直接操作 DOM</li></ul><h2 id="微信小程序与-H5-的区别"><a href="#微信小程序与-H5-的区别" class="headerlink" title="微信小程序与 H5 的区别"></a>微信小程序与 H5 的区别</h2><ul><li>运行环境：小程序运行在微信客户端，H5 运行在浏览器</li><li>开发语言：小程序使用 WXML 和 WXSS，H5 使用 HTML 和 CSS</li><li>能力差异：小程序可调用微信原生 API，如扫码、支付等</li><li>性能：小程序采用双线程模式（渲染线程和逻辑线程分离），性能更好</li><li>发布方式：小程序需审核上线，H5 可直接发布</li></ul><h2 id="小程序框架"><a href="#小程序框架" class="headerlink" title="小程序框架"></a>小程序框架</h2><p>常见框架：mpvue、taro、uni-app<br>实现流程：</p><ul><li>编译阶段：将其他 DSL（domain-specific language） 转换为符合小程序语法的 WXML、WXSS、JS、JSON；</li><li>运行阶段：数据、事件、生命周期等部分的处理和对接；</li></ul><h3 id="mpvue"><a href="#mpvue" class="headerlink" title="mpvue"></a>mpvue</h3><p>特点：将 Vue 实例和小程序页面实例简单粗暴地做了关联，以达到使用 Vue 开发小程序的目的。</p><h3 id="taro"><a href="#taro" class="headerlink" title="taro"></a>taro</h3><p>特点：</p><ul><li>无 DSL 限制：无论是你们团队是 React 还是 Vue 技术栈，都能够使用 Taro 开发。</li><li>新特性无缝支持：由于 Taro Next 本质上是将 React&#x2F;Vue 运行在小程序上，因此，各种新特性也就无缝支持了。</li></ul><h3 id="uni-app"><a href="#uni-app" class="headerlink" title="uni-app"></a>uni-app</h3><p>特点：</p><ul><li>支持组件局部更新：mpvue 时小程序不支持自定义组件，所以组件编进 Page，更新也是 Page 级</li><li>setData 优化：将数据进行 diff，然后通过 setData 进行路径级别的更新</li></ul><h2 id="微信小程序生命周期"><a href="#微信小程序生命周期" class="headerlink" title="微信小程序生命周期"></a>微信小程序生命周期</h2><p>全局文件 app.js 中定义了一些声明周期的方法</p><p>onLaunch() 监听小程序初始化 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）<br>onShow() 监听小程序显示 当小程序启动，或从后台进入前台显示，会触发 onShow<br>onHide() 监听小程序隐藏 当小程序从前台进入后台，会触发 onHide</p><p>这是每个 page 页面的周期函数</p><p>onLoad() 页面加载时触发，全局只会调用一次，在该周期内可获取当前页面路径的参数<br>onShow() 页面显示时触发或者切入前台时触发，也就是在该周期内可以获取请求数据<br>onReady() 页面初次渲染完成时触发，只会调用一次，代表页面已经可以和视图层进行交互<br>onHide() 页面隐藏或者切入后台时触发，如底部 tab 切换到其他页面或小程序切入后台时触发。<br>onUnload() 页面卸载时触发</p><h2 id="小程序优化"><a href="#小程序优化" class="headerlink" title="小程序优化"></a>小程序优化</h2><ul><li>分包加载：将非首页功能放入子包</li><li>组件按需引入：避免全局注册</li><li>减少视图层初始数据：首屏关键数据优先</li><li>开启 Tree-shaking：移除无用代码</li><li>静态资源优化：图片压缩、CDN 加速</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/7517906186265657370">前端面试题之小程序篇</a></p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>英语笔记</title>
    <link href="/unknown404.github.io/2023/02/26/EnglishNotes/"/>
    <url>/unknown404.github.io/2023/02/26/EnglishNotes/</url>
    
    <content type="html"><![CDATA[<p>虽然自己现在不需要考证了，不过遇到有意思的演讲、文章还是记录一下自己不熟的词汇之类的，以防水平退步。</p><span id="more"></span><p>adrift adj. 漂流的，随波逐流的；松动的；<br>The survivors were adrift in a lifeboat for six days. 幸存者在救生艇上漂流了六天。<br>young people adrift in the big city 在大城市漂泊的年轻人</p><p>conceivable adj. 可想象的；可信的（possible）<br>It is conceivable that I’ll see her tomorrow. 我可能明天会见到她。</p><p>objective<br>n. 目标；目的<br>meet&#x2F;achieve your objectives 达到 ╱ 实现你的目标<br>adj. 客观的；(objectively adv.)</p><p>gnaw v.咬；啃；啮<br>She gnawed at her fingernails. 她咬手指甲。<br>Self-doubt began to gnaw away at her confidence. 对自己的怀疑渐渐吞噬了她的自信心。</p><p>resilient adj. 可迅速恢复的；有适应力的</p><p>renowned adj.~ (as&#x2F;for sth)有名的；闻名的；受尊敬的<br>It is renowned as one of the region’s best restaurants. 这是本地区最好的饭店之一。<br>She is renowned for her patience. 她的耐心是出了名的。</p><p>flounder<br>v.不知所措;艰苦挣扎<br>She was floundering around in the deep end of the swimming pool. 她在游泳池深水区挣扎着。<br>At that time the industry was floundering. 那时这个行业举步维艰。</p><p>transcendent adj. 卓越的；超常的；出类拔萃的<br>…the idea of a transcendent God who stood apart from mankind. …超越于人类之上的上帝的观点。</p><p>redeem v.补救，掩饰……之不足；挽回（声誉）;偿清；遵守（诺言）<br>The only redeeming feature of the job (&#x3D; good thing about it) is the salary. 这份工作唯一的可取之处就是它的工资。<br>redeem a loan&#x2F;mortgage 清偿贷款 ╱ 按揭贷款<br>redeem a pledge&#x2F;promise 遵守诺言</p><p>redemption n.拯救；救赎<br>BEYOND&#x2F;PAST REDEMPTION(too bad to be saved or improved) 无法挽救；不可救药</p><p>smug adj.沾沾自喜的；自鸣得意的</p><p>gist n. ~ (of sth)要点；主旨；大意<br>get (&#x3D; understand) the gist of an argument 理解辩论的主旨</p><p>banal adj. 平庸的；</p><p>cliché n. 陈词滥调；<br>She trotted out the old cliché that ‘a trouble shared is a trouble halved.’ 她又重复了“与人说愁愁减半”的陈词滥调。</p><p>malfunction n. 运转失常；失灵；出现故障</p><p>submissive adj.顺从的</p><p>uphold v.维持</p><p>instantiation n.实例化</p><p>deputy n. 代理；代理者</p><p>a surfeit of + noun 大量地；过剩的</p><p>stasis n.静止；停滞</p><p>subside v.下沉；消失；减弱</p><p>complacent adj. 满足的；自满的；得意的</p><p>tenacious adj.顽强的;坚持的;坚忍不拔的;紧握的;不松手的;</p><p>asunder adv. 化为碎片地,被撕裂;(诗&#x2F;文)分开地,分离地 adj. 化为碎片地,被撕裂;(诗&#x2F;文)分开地,分离地全部折叠<br>The boat was torn asunder on the rocks. 船触礁撞得支离破碎</p><p>relapse v. 退回原状;(病情好转后)重新恶化,复发;</p><p>impetus n.动力</p><p>conducive adj. 有助于……的；有利的；有引导性的<br>Exercise is conducive to health.锻炼有益于健康。<br>This is a more conducive atmosphere for studying. 这种环境更适宜学习。</p><p>procrastination n. 耽搁，拖延；拖延症<br>Procrastination is the thief of time.拖延就是浪费时间。</p><p>incentive n. 激励某人做某事的事物；刺激；诱因，动机<br>give sb. an incentive to do sth</p><p>apathetic adj. 冷漠的；无动于衷的，缺乏兴趣的<br>She roused herself from her apathetic musing 她从冷漠的沉思中清醒过来。</p><p>sabotage vt. 妨害；对…采取破坏行动；vi. 从事破坏活动；n. 破坏；怠工；破坏活动<br>sabotage an agreement 破坏协定</p><p>inexplicable adj. 无法说明的；费解的；不能解释的<br>an inexplicable animus against intellectuals. 对知识分子的莫名其妙的恶意</p><p>concoct vt. 捏造；混合而制；调合；图谋<br>concoct an excuse for being late编造迟到的借口</p>]]></content>
    
    
    <categories>
      
      <category>英语学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>词汇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node.js</title>
    <link href="/unknown404.github.io/2023/02/26/nodeJs/"/>
    <url>/unknown404.github.io/2023/02/26/nodeJs/</url>
    
    <content type="html"><![CDATA[<p>node 基础知识记录</p><span id="more"></span><h2 id="node-模块机制"><a href="#node-模块机制" class="headerlink" title="node 模块机制"></a>node 模块机制</h2><h3 id="require-的模块加载机制"><a href="#require-的模块加载机制" class="headerlink" title="require 的模块加载机制"></a>require 的模块加载机制</h3><ol><li>先计算模块路径</li><li>如果模块在缓存里面，取出缓存</li><li>加载模块</li><li>输出模块的 exports 属性即可</li></ol><h3 id="module-exports-vs-exports"><a href="#module-exports-vs-exports" class="headerlink" title="module.exports vs exports"></a>module.exports vs exports</h3><ul><li>exports 其实就是 module.exports，引用相同（module.exports 默认提供了空对象）</li><li>module.exports 可以直接赋值，exports 不可以，只能以增加健值的方式（模块加载时返回的是 module.exports 的内容）</li><li>如果要输出一个函数或数组，必须直接对 module.exports 对象赋值</li></ul><h3 id="npm-run-XXX-的流程"><a href="#npm-run-XXX-的流程" class="headerlink" title="npm run XXX 的流程"></a>npm run XXX 的流程</h3><ul><li>运行 npm run xxx 的时候，npm 会先在当前目录的 node_modules&#x2F;.bin 查找要执行的程序，如果找到则运行；</li><li>没有找到则从全局的 node_modules&#x2F;.bin 中查找，npm i -g xxx 就是安装到到全局目录；</li><li>如果全局目录还是没找到，那么就从 path 环境变量中查找有没有其他同名的可执行程序。</li></ul><h2 id="node-进程和线程"><a href="#node-进程和线程" class="headerlink" title="node 进程和线程"></a>node 进程和线程</h2><h3 id="进程和线程辨析"><a href="#进程和线程辨析" class="headerlink" title="进程和线程辨析"></a>进程和线程辨析</h3><p>进程：资源分配的最小单位，进程是线程的容器。<br>线程：操作系统能够进行运算调度的最小单位。线程是隶属于进程的，被包含于进程之中。一个线程只能隶属于一个进程，但是一个进程是可以拥有多个线程的。</p><p>概念区分：<br>Node.js 是单线程 —— 因为使用的语言是 JavaScript，JavaScript 是单线程的，所以 Node.js 也是单线程的。</p><p>启动的服务是多线程 —— Node 中最核心的是 v8 引擎，v8 是一个执行 JS 的引擎. 也就是翻译 JS. 包括我们熟悉的编译优化, 垃圾回收等等.在 Node 启动后，会创建 v8 的实例，这个实例是多线程的（包括主线程、编译&#x2F;优化线程、分析器线程、垃圾回收的几个线程）。</p><h3 id="node-多进程架构"><a href="#node-多进程架构" class="headerlink" title="node 多进程架构"></a>node 多进程架构</h3><p>使用 child_process、cluster 开启多个进程实现多进程单线程模式，使 CPU 的利用率提升。子进程独立于父进程</p><h3 id="创建子进程方法"><a href="#创建子进程方法" class="headerlink" title="创建子进程方法"></a>创建子进程方法</h3><p>模块 child_process 具有以下方法：</p><ul><li>spawn()： 启动一个子进程来执行命令</li><li>exec(): 启动一个子进程来执行命令，与 spawn()不同的是其接口不同，它有一个回调函数获知子进程的状况</li><li>execFlie(): 启动一个子进程来执行可执行文件</li><li>fork(): 与 spawn()类似，不同在于它创建 Node 子进程需要执行 js 文件</li></ul><h2 id="express-vs-koa"><a href="#express-vs-koa" class="headerlink" title="express vs koa"></a>express vs koa</h2><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>Express 中间件实现是基于 Callback 回调函数同步的，它不会去等待异步（Promise）完成<br>Koa 的中间件机制中使用 Async&#x2F;Await（背后全是 Promise）以同步的方式来管理异步代码</p><h4 id="中间件原理"><a href="#中间件原理" class="headerlink" title="中间件原理"></a>中间件原理</h4><p>内部维护一个函数数组，这个函数数组表示在发出响应之前要执行的所有函数，也就是中间件数组使用 app.use(fn)后，传进来的 fn 就会被扔到这个数组里，执行完毕后调用 next()方法执行函数数组里的下一个函数，如果没有调用 next()的话，就不会调用下一个函数了，也就是说调用就会被终止</p><h3 id="洋葱模型实现"><a href="#洋葱模型实现" class="headerlink" title="洋葱模型实现"></a>洋葱模型实现</h3><p>Koa 的中间件是按顺序执行的，每个中间件可以对请求进行处理，并且在适当的时候将控制权交给下一个中间件。当所有中间件都执行完后，再一层一层地返回响应，类似剥洋葱。</p><p>中间件执行过程：<br>请求进入：请求到达服务器时，按照注册的顺序，依次进入每个中间件。<br>调用 await next()：在中间件函数内部调用 await next() 时，控制权被传递给下一个中间件，直到最后一个中间件完成。<br>返回阶段：当所有中间件执行完毕，控制流回溯，逐个返回响应的处理，类似洋葱剥皮的过程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 中间件组合函数，可以参考 https://github.com/koajs/compose/blob/master/index.js</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> Array </span>&#125; <span class="hljs-variable">middlewares</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span>(<span class="hljs-params">ctx, middlewares</span>) &#123;<br>  <span class="hljs-comment">// &#123;1&#125;</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(middlewares)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Middlewares stack must be an array!&#x27;</span>)<br><br>  <span class="hljs-comment">// &#123;2&#125;</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> fn <span class="hljs-keyword">of</span> middlewares) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Middleware must be composed of functions!&#x27;</span>)<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> len = middlewares.<span class="hljs-property">length</span>; <span class="hljs-comment">// &#123;3&#125; 获取数组长度</span><br>    <span class="hljs-keyword">const</span> dispatch = <span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) &#123; <span class="hljs-comment">// &#123;4&#125; 这里是我们实现的关键</span><br>      <span class="hljs-keyword">if</span> (len === i) &#123; <span class="hljs-comment">// &#123;5&#125; 中间件执行完毕</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">const</span> fn = middlewares[i]; <span class="hljs-comment">// &#123;6&#125;</span><br><br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// &#123;7&#125; 这里一定要 bind 下，不要立即执行</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">fn</span>(ctx, dispatch.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, (i + <span class="hljs-number">1</span>))));<br>        &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>          <span class="hljs-comment">// &#123;8&#125; 返回错误</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(err);<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> fn = <span class="hljs-title function_">compose</span>(ctx, middlewares);<br><br><span class="hljs-title function_">fn</span>();<br><br></code></pre></td></tr></table></figure><h2 id="数据库比较：mysql-vs-mongodb"><a href="#数据库比较：mysql-vs-mongodb" class="headerlink" title="数据库比较：mysql vs mongodb"></a>数据库比较：mysql vs mongodb</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>MySQL</strong></p><ul><li>关系型数据库，存储结构化数据</li><li>可以通过外键，主键将不同表中的属性关联起来</li><li>读取数据可以使用 sql</li><li>需通过新增服务器配置来支持规模扩张</li></ul><p><strong>MongoDB</strong></p><ul><li>非关系型数据库，可以在不首先定义结构的情况下创建记录</li><li>不支持表关联</li><li>不能用 sql 查询</li><li>可通过新增服务器实现扩展，解决大量查询问题</li></ul><h3 id="术语对比"><a href="#术语对比" class="headerlink" title="术语对比"></a>术语对比</h3><table><thead><tr><th align="center">MySQL</th><th align="center">MongoDB</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">database</td><td align="center">database</td><td align="center">数据库</td></tr><tr><td align="center">table</td><td align="center">collection</td><td align="center">表&#x2F;集合</td></tr><tr><td align="center">row</td><td align="center">document</td><td align="center">行&#x2F;文档</td></tr><tr><td align="center">column</td><td align="center">field</td><td align="center">字段&#x2F;域</td></tr><tr><td align="center">index</td><td align="center">index</td><td align="center">索引</td></tr><tr><td align="center">join</td><td align="center">嵌入文档</td><td align="center">表关联&#x2F;MongoDB 不支持 join，MongoDB 通过嵌入式文档来替代多表连接</td></tr><tr><td align="center">primary key</td><td align="center">primary key</td><td align="center">主键&#x2F;MongoDB 自动将_id 字段设置为主键</td></tr></tbody></table><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>(1)<a href="https://juejin.cn/post/6844903951742025736">NodeJS 有难度的面试题，你能答对几个？</a><br>(2)<a href="https://juejin.cn/post/6844904071501971469">挑战一轮大厂后的面试总结 (含六个方向) - nodejs 篇</a><br>(3)<a href="https://juejin.cn/post/7078924628525056007">三面面试官：运行 npm run xxx 的时候发生了什么？</a><br>(4)<a href="https://juejin.cn/post/6844904099767386126">多维度分析 Express、Koa 之间的区别</a></p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack</title>
    <link href="/unknown404.github.io/2023/02/19/webpack/"/>
    <url>/unknown404.github.io/2023/02/19/webpack/</url>
    
    <content type="html"><![CDATA[<p>前端 webpack 打包工具方面知识整理。</p><span id="more"></span><h2 id="webpack-基本概念"><a href="#webpack-基本概念" class="headerlink" title="webpack 基本概念"></a>webpack 基本概念</h2><h3 id="webpack-作用"><a href="#webpack-作用" class="headerlink" title="webpack 作用"></a>webpack 作用</h3><p>静态模块打包工具。主要作用：</p><ul><li>模块打包。可以将不同模块的文件打包整合在一起，并且保证它们之间的引用正确，执行有序。</li><li>编译兼容。通过 webpack 的 Loader 机制，编译转换诸如.less，.vue，.jsx 这类在浏览器无法识别的格式文件</li><li>能力扩展。通过 webpack 的 Plugin 机制，我可以进一步实现诸如按需加载，代码压缩等一系列功能</li></ul><h3 id="webpack-构建流程"><a href="#webpack-构建流程" class="headerlink" title="webpack 构建流程"></a>webpack 构建流程</h3><p>初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler<br>编译：从 entry 出发，针对每个 Module 串行调用对应的 loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理<br>输出：将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中</p><h3 id="loader-和-plugin-区别"><a href="#loader-和-plugin-区别" class="headerlink" title="loader 和 plugin 区别"></a>loader 和 plugin 区别</h3><ul><li>功能方面：loader 是文件加载器，能够加载资源文件，并对这些文件进行一些处理；plugin 可以扩展 Webpack 的功能，监听在 Webpack 运行的生命周期中会广播出的许多事件并做处理，解决 loader 无法实现的其他事。</li><li>运行时机方面：loader 运行在打包文件之前；plugin 则是在整个编译周期都起作用。</li><li>配置书写方面：loader 在 module.rules 中配置，作为模块的解析规则，类型为数组，内部包含了 test(类型文件)、loader、options (参数)等属性需要配置。plugin 在 plugins 中单独配置，类型为数组，每一项是一个 plugin 的实例，参数都通过构造函数传入。</li></ul><h3 id="webpack-热更新原理"><a href="#webpack-热更新原理" class="headerlink" title="webpack 热更新原理"></a>webpack 热更新原理</h3><p>webpack-dev-server 与浏览器之间维护了一个 websocket，当本地资源发生变化时，webpack-dev-server 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 webpack-dev-server 发起 Ajax 请求来获取更改内容。后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由 HotModulePlugin 来完成</p><h3 id="Webpack-的-Tree-Shaking-原理"><a href="#Webpack-的-Tree-Shaking-原理" class="headerlink" title="Webpack 的 Tree Shaking 原理"></a>Webpack 的 Tree Shaking 原理</h3><p>Tree Shaking 也叫摇树优化，是一种通过移除多于代码，从而减小最终生成的代码体积的方法（函数级），生产环境默认开启。<br>原理：</p><ul><li>ES6 模块系统：Tree Shaking 的基础是 ES6 模块系统，它具有静态特性，意味着模块的导入和导出关系在编译时就已经确定，不会受到程序运行时的影响。</li><li>静态分析：在 Webpack 构建过程中，Webpack 会通过静态分析依赖图，从入口文件开始，逐级追踪每个模块的依赖关系，以及模块之间的导入和导出关系。</li><li>标记未使用代码： 在分析模块依赖时，Webpack 会标记每个变量、函数、类和导入，以确定它们是否被实际使用。如果一个导入的模块只是被导入而没有被使用，或者某个模块的部分代码没有被使用，Webpack 会将这些未使用的部分标记为”unused”。</li><li>删除未使用代码: 在代码标记为未使用后，Webpack 会在最终的代码生成阶段，通过工具（如 UglifyJS 等）删除这些未使用的代码。这包括未使用的模块、函数、变量和导入。</li></ul><h3 id="webpack打包速度优化"><a href="#webpack打包速度优化" class="headerlink" title="webpack打包速度优化"></a>webpack打包速度优化</h3><ol><li>多线程处理：thread-loader</li><li>缓存机制：babel-loader 缓存，文件系统缓存</li><li>代码分割和动态加载</li><li>减少构建体积：treeshaking</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/7196630860811075642">2023 前端面试系列– webpack &amp; Git 篇</a><br>（2）<a href="https://juejin.cn/post/7272009063406272571">前端铜九铁十面试必备八股文——工程化</a></p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode调试Node代码</title>
    <link href="/unknown404.github.io/2023/02/17/vscodeRunNode/"/>
    <url>/unknown404.github.io/2023/02/17/vscodeRunNode/</url>
    
    <content type="html"><![CDATA[<h2 id="实现操作"><a href="#实现操作" class="headerlink" title="实现操作"></a>实现操作</h2><ol><li>点击vscode左侧边栏的三角形状加🐛的符号，如果直接调试当前文件可以先打好断点、点击按钮Run and Debug；如果需要自定义然后点击create a launch.json file</li><li>编辑launch.json<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123;<br>    <span class="hljs-regexp">//</span> 使用 IntelliSense 了解相关属性。 <br>    <span class="hljs-regexp">//</span> 悬停以查看现有属性的描述。<br>    <span class="hljs-regexp">//</span> 欲了解更多信息，请访问: https:<span class="hljs-regexp">//g</span>o.microsoft.com<span class="hljs-regexp">/fwlink/</span>?linkid=<span class="hljs-number">830387</span><br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.2.0&quot;</span>,<br>    <span class="hljs-string">&quot;configurations&quot;</span>: [<br>        &#123;<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;node&quot;</span>,<br>            <span class="hljs-string">&quot;request&quot;</span>: <span class="hljs-string">&quot;launch&quot;</span>,<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;启动程序&quot;</span>,<br>            <span class="hljs-string">&quot;skipFiles&quot;</span>: [<br>                <span class="hljs-string">&quot;&lt;node_internals&gt;/**&quot;</span><br>            ],<br>            <span class="hljs-string">&quot;program&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ul><li>执行单一文件时：修改program的内容，改为要运行的可执行文件或源代码的路径</li><li>调试服务器时：将配置文件修改为如下内容：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;attach&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Attach NestJS WS&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9229</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;restart&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;stopOnEntry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;protocol&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;inspector&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure>request由launch改为了attach，目的是为了将Visual Studio Code的调试器绑定到一个已经处于运行状态的应用。这个配置文件的含义是告诉Visual Studio Code的调试进程，去连接127.0.0.1:9229上的应用调试进程去调试。</li></ul><ol start="3"><li>配置完后点击调试栏的运行，如果是调试服务器接口需要先执行debug指令运行起服务器，以eggjs为例是<code>egg-bin debug</code>；以nest为例是<code>nest start --debug --watch</code>。此时会启动127.0.0.1:9229的调试进程，如果事先打好断点，在postman上调试本地接口时会在对应接口的逻辑断点前停止运行。<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2>（1）<a href="https://juejin.cn/post/6981820158046109703">让你 nodejs 水平暴增的 debugger 技巧</a><br>（2）<a href="https://juejin.cn/post/6844903838864900110">如何用Visual Studio Code远程调试运行在服务器上的nodejs应用</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>工作技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试技巧</title>
    <link href="/unknown404.github.io/2023/02/15/interviewSkill/"/>
    <url>/unknown404.github.io/2023/02/15/interviewSkill/</url>
    
    <content type="html"><![CDATA[<ol><li>项目中你遇到的难解决的问题有哪些，最后怎么处理的这种问题<br>难解决的问题分为两种：1.业务问题，需求不清。这时需要拉上懂业务的同事理清需求，必要的时候需要调整设计。同时自主学习，增强对业务的了解。2.技术问题，可能是由于之前技术栈限制导致需求难以实现，或者说现有技术导致实现需求会有性能、可维护性问题，或者是自身储备或者周边资源不足(比如说没有现成的组件库)导致工期比预想长。可以通过最小限度实现需求、请教公司或同项目组的同事寻找合适的工具、交叉集成其他框架等方式解决，但最重要的是及早沟通。</li></ol>]]></content>
    
    
    <categories>
      
      <category>工作技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端使用shell指令</title>
    <link href="/unknown404.github.io/2023/01/16/shelljs/"/>
    <url>/unknown404.github.io/2023/01/16/shelljs/</url>
    
    <content type="html"><![CDATA[<h2 id="node-js-使用-shell-指令"><a href="#node-js-使用-shell-指令" class="headerlink" title="node.js 使用 shell 指令"></a>node.js 使用 shell 指令</h2><h3 id="child-process"><a href="#child-process" class="headerlink" title="child_process"></a>child_process</h3><p>node 提供的一个子进程 API</p><h4 id="常见指令"><a href="#常见指令" class="headerlink" title="常见指令"></a>常见指令</h4><h5 id="child-process-spawn-command-args-options"><a href="#child-process-spawn-command-args-options" class="headerlink" title="child_process.spawn(command[, args][, options])"></a>child_process.spawn(command[, args][, options])</h5><p>创建一个新进程来执行指令。指令执行的参数为该函数传入的第二个参数。child_process.spawn 返回 stdout 和 stderr 流对象。 程序可以通过 stdout 的 data、end 或者其他事件来获取子进程返回的数据。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> &#123; spawn &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>);<br><span class="hljs-keyword">const</span> ls = <span class="hljs-title function_">spawn</span>(<span class="hljs-string">&#x27;ls&#x27;</span>, [<span class="hljs-string">&#x27;-lh&#x27;</span>, <span class="hljs-string">&#x27;/usr&#x27;</span>]);<br><br>ls.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`stdout: <span class="hljs-subst">$&#123;data&#125;</span>`</span>);<br>&#125;);<br><br>ls.<span class="hljs-property">stderr</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`stderr: <span class="hljs-subst">$&#123;data&#125;</span>`</span>);<br>&#125;);<br><br>ls.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">code</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`child process exited with code <span class="hljs-subst">$&#123;code&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="child-process-exec-command-options-callback"><a href="#child-process-exec-command-options-callback" class="headerlink" title="child_process.exec(command[, options][, callback])"></a>child_process.exec(command[, options][, callback])</h5><p>创建一个 shell 执行指令。存在数据大小限制。 当子进程返回的数据超过默认大小时，程序就会产生”Error: maxBuffer exceeded”异常。</p><h5 id="child-process-execFile-file-args-options-callback"><a href="#child-process-execFile-file-args-options-callback" class="headerlink" title="child_process.execFile(file[, args][, options][, callback])"></a>child_process.execFile(file[, args][, options][, callback])</h5><p>同 exec 类似，但使用的是制定的文件创建进程执行。需要单独写.sh 文件，可编写复杂逻辑，但在 windows 上使用时会有兼容问题</p><h3 id="shelljs"><a href="#shelljs" class="headerlink" title="shelljs"></a>shelljs</h3><p>基于 nodeAPI 的一个扩展，要引入插件。相比原生的 child_process 的兼容性更好，使用更灵活。<br><strong>安装指令</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span>--save-dev <span class="hljs-keyword">shelljs</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">or</span><br><span class="hljs-keyword"></span>yarn <span class="hljs-keyword">add </span><span class="hljs-keyword">shelljs </span>-D<br></code></pre></td></tr></table></figure><p><strong>使用方法</strong></p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-comment">// 局部模式</span><br><span class="hljs-variable">var</span> <span class="hljs-variable">shell</span> = <span class="hljs-function"><span class="hljs-title">require</span>(<span class="hljs-string">&#x27;shelljs&#x27;</span>);</span><br><span class="hljs-function"><span class="hljs-variable">shell.exec</span>(<span class="hljs-string">&#x27;git add .&#x27;</span>);</span><br><span class="hljs-function"><span class="hljs-variable">shell.exec</span>(<span class="hljs-string">&quot;git commit -m &#x27;auto-commit&#x27;&quot;</span>)</span><br><span class="hljs-variable">shell.exec</span>(<span class="hljs-string">&#x27;git push&#x27;</span>)<br><br><span class="hljs-comment">// 全局模式下，就不需要用shell开头了。</span><br><span class="hljs-function"><span class="hljs-title">require</span>(<span class="hljs-string">&#x27;shelljs/global&#x27;</span>);</span><br><span class="hljs-function"><span class="hljs-title">exec</span>(<span class="hljs-string">&#x27;git add .&#x27;</span>);</span><br><span class="hljs-function"><span class="hljs-title">exec</span>(<span class="hljs-string">&quot;git commit -m &#x27;auto-commit&#x27;&quot;</span>)</span><br><span class="hljs-function"><span class="hljs-title">exec</span>(<span class="hljs-string">&#x27;git push&#x27;</span>)</span><br></code></pre></td></tr></table></figure><h2 id="shell-常用指令"><a href="#shell-常用指令" class="headerlink" title="shell 常用指令"></a>shell 常用指令</h2><h3 id="pwd-显示当前目录名称"><a href="#pwd-显示当前目录名称" class="headerlink" title="pwd - 显示当前目录名称"></a>pwd - 显示当前目录名称</h3><h3 id="ls-显示目录信息"><a href="#ls-显示目录信息" class="headerlink" title="ls - 显示目录信息"></a>ls - 显示目录信息</h3><p><strong>使用参数</strong></p><p>-a :显示包括隐藏文件和目录在内的所有目录和文件</p><p>-l :显示文件的详细信息</p><p>-h :配合-l 以人性化的方式显示文件大小</p><p>-t :按文件最后修改时间排序文件</p><h3 id="cd-目录切换"><a href="#cd-目录切换" class="headerlink" title="cd - 目录切换"></a>cd - 目录切换</h3><p><strong>使用示例</strong></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span> 返回根目录<br><span class="hljs-keyword">cd</span><br><span class="hljs-string">//</span> 返回上一级目录<br><span class="hljs-keyword">cd</span> <span class="hljs-string">..</span><br><span class="hljs-string">//</span> 前往当前文件夹下的某目录<br><span class="hljs-keyword">cd</span> &lt;directory&gt;<br></code></pre></td></tr></table></figure><h3 id="rm-删除文件"><a href="#rm-删除文件" class="headerlink" title="rm - 删除文件"></a>rm - 删除文件</h3><p><strong>使用参数</strong></p><p>-f :强制删除文件</p><p>-r :递归删除目录及内容</p><h3 id="cp-复制文件"><a href="#cp-复制文件" class="headerlink" title="cp - 复制文件"></a>cp - 复制文件</h3><p><strong>指令格式</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cp</span> [<span class="hljs-keyword">options</span>] <span class="hljs-symbol">&lt;source&gt;</span> <span class="hljs-symbol">&lt;dest&gt;</span><br></code></pre></td></tr></table></figure><p><strong>使用参数</strong><br>-a :复制时保留链接、文件属性</p><p>-f :覆盖已经存在的目标文件而不给出提示</p><p>-r :若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件</p><h3 id="echo-显示指定文本"><a href="#echo-显示指定文本" class="headerlink" title="echo - 显示指定文本"></a>echo - 显示指定文本</h3><p><strong>使用示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 显示普通字符串</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello world&quot;</span><br><br><span class="hljs-comment"># 显示转义字符</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\&quot;hello world\&quot;&quot;</span> <span class="hljs-comment"># 此时结果显示为&quot;hello world&quot;</span><br><br><span class="hljs-comment"># 显示变量</span><br>content=<span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;He said <span class="hljs-variable">$&#123;content&#125;</span>&quot;</span><br><br><span class="hljs-comment"># 显示换行</span><br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;hello \n&quot;</span> <span class="hljs-comment"># -e开启转义，即\n可以换行</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;world&quot;</span><br><br><span class="hljs-comment"># 显示结果定向至文件</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello world &gt; test&quot;</span><br></code></pre></td></tr></table></figure><h3 id="chmod-控制用户对文件的权限"><a href="#chmod-控制用户对文件的权限" class="headerlink" title="chmod - 控制用户对文件的权限"></a>chmod - 控制用户对文件的权限</h3><p><strong>指令格式</strong></p><ol><li>参数法</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">chmod <span class="hljs-selector-attr">[user]</span><span class="hljs-selector-attr">[operator]</span><span class="hljs-selector-attr">[permission]</span> &lt;filename&gt;<br></code></pre></td></tr></table></figure><p><strong>使用参数</strong><br><strong>user</strong>：限定权限调整的用户范围</p><ul><li>u：user 表示该文件的所有者</li><li>g：group 表示与该文件的所有者属于同一组( group )者，即用户组</li><li>o：other 表示其它用户组</li><li>a：all 表示这三者皆是</li></ul><p><strong>operator</strong>：权限调整内容</p><ul><li>+：增加权限</li><li>-：撤销权限</li><li>&#x3D;：设定权限</li></ul><p><strong>permission</strong>：权限内容</p><ul><li>r：read，表示可读取，对于一个目录，如果没有 r 权限，那么就意味着不能通过 ls 查看这个目录的内容。</li><li>w：write，表示可写入，对于一个目录，如果没有 w 权限，那么就意味着不能在目录下创建新的文件。</li><li>x：excute，表示可执行，对于一个目录，如果没有 x 权限，那么就意味着不能通过 cd 进入这个目录。</li></ul><ol start="2"><li>数字法</li></ol><p>chmod 命令可以使用八进制数来指定权限。文件或目录的权限位是由 9 个权限位来控制，每三位为一组，它们分别是文件所有者（User）的读、写、执行，用户组（Group）的读、写、执行以及其它用户（Other）的读、写、执行。一组权限位中已设置时置为 1，不设置时置为 0。<br>以权限 rwx 为例，其对应的二进制表示为 111，即 4+2+1，也就是 7.<br><strong>使用示例</strong></p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi"># 表示所有的用户都有读写执行文件<span class="hljs-keyword">file</span>的权利，等同于chmod a=wrx <span class="hljs-keyword">file</span><br>chmod <span class="hljs-number">777</span> <span class="hljs-keyword">file</span><br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://nodejs.org/dist/latest-v12.x/docs/api/child_process.html">Nodejs 文档</a><br>（2）<a href="https://juejin.cn/post/6921734567342637070">如何在 nodejs 执行 shell 指令</a><br>（3）<a href="https://juejin.cn/post/7161392772665540644">package.json 配置完全解读</a></p>]]></content>
    
    
    <categories>
      
      <category>工作技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node.js</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hash路由使用锚点解决方案</title>
    <link href="/unknown404.github.io/2022/12/16/hashAnchor/"/>
    <url>/unknown404.github.io/2022/12/16/hashAnchor/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>页面的锚点功能需要 url 的 hash 值与页面的 DOM id 相一致才能进行跳转；而路由在 hash 模式下已经将#占用, 页面的锚点功能失效</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="场景-1-原生锚点"><a href="#场景-1-原生锚点" class="headerlink" title="场景 1:原生锚点"></a>场景 1:原生锚点</h3><p>需要手动获取锚点元素，再使用scrollIntoView方法</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs JSX"><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">CustomLink</span>=(<span class="hljs-params">props:&#123;id:string, children:any&#125;</span>)=&gt; &#123;<br>  <span class="hljs-keyword">const</span> &#123;id,children&#125;=props<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClick</span> = (<span class="hljs-params">e:any</span>) =&gt; &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>();<br>    <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(id);<br>    <span class="hljs-comment">// scrollIntoView()将目标元素移动到浏览器顶部</span><br>    <span class="hljs-comment">// scrollIntoView(false)将目标元素移动到浏览器底部</span><br>    element?.<span class="hljs-title function_">scrollIntoView</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span>&#123;children&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> &gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;anchor&#x27;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">CustomLink</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;test1&#x27;</span>&gt;</span>test1<span class="hljs-tag">&lt;/<span class="hljs-name">CustomLink</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">CustomLink</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;test2&#x27;</span>&gt;</span>test2<span class="hljs-tag">&lt;/<span class="hljs-name">CustomLink</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">height:</span> &#x27;<span class="hljs-attr">600vh</span>&#x27;, <span class="hljs-attr">padding:</span> <span class="hljs-attr">8</span> &#125;&#125;&gt;</span>Scroll to bottom<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;test1&#x27;</span>&gt;</span>test1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Scroll to bottom<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">height:</span> &#x27;<span class="hljs-attr">600vh</span>&#x27;, <span class="hljs-attr">padding:</span> <span class="hljs-attr">8</span> &#125;&#125;&gt;</span>Scroll to bottom<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Scroll to bottom<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">height:</span> &#x27;<span class="hljs-attr">600vh</span>&#x27;, <span class="hljs-attr">padding:</span> <span class="hljs-attr">8</span> &#125;&#125; <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;test2&#x27;</span>&gt;</span>test2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Scroll to bottom<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="场景-2-antd-的-anchor-组件"><a href="#场景-2-antd-的-anchor-组件" class="headerlink" title="场景 2:antd 的 anchor 组件"></a>场景 2:antd 的 anchor 组件</h3><p>anchor 组件在点击锚点后会修改 URL，而单页应用中如果使用哈希模式的路由，当 URL 被修改后，刷新页面会导致当前路由没有定义而出现 404 的情况。<br>对于这一情况的解决方案就是利用组件的 onClick 事件阻止默认的 url 修改</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JSX"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Anchor</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;antd&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; useHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;umi&#x27;</span>;<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Link</span> &#125; = <span class="hljs-title class_">Anchor</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> history = <span class="hljs-title function_">useHistory</span>();<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Anchor</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;(event:</span> <span class="hljs-attr">Event</span>, <span class="hljs-attr">link:</span> &#123; <span class="hljs-attr">href:</span> <span class="hljs-attr">string</span>; <span class="hljs-attr">title</span>?<span class="hljs-attr">:</span> <span class="hljs-attr">string</span> &#125;) =&gt;</span> &#123;</span><br><span class="language-xml">        event.preventDefault();</span><br><span class="language-xml">        history.push(`$&#123;history.location.pathname&#125;$&#123;link.href&#125;`);</span><br><span class="language-xml">      &#125;&#125;</span><br><span class="language-xml">    &gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#何时使用&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;何时使用&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#代码演示&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;代码演示&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#api&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;API&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#anchor-props&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Anchor Props&quot;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#link-props&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Link Props&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#faq&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;FAQ&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Anchor</span>&gt;</span></span><br>  );<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>经过实际测试发现，调用 event.preventDefault()之后，只会阻止 URL 被修改，并不会阻止点击锚点后的滚动事件。所以不需要像原生场景一样使用 scrollView 函数。但为了url和锚点相对应，增加了history.push函数来实现。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://blog.csdn.net/weixin_43487782/article/details/108873639">antd的anchor组件点击锚点导致路由发生变化</a><br>（2）<a href="https://blog.csdn.net/Whoopsina/article/details/123804087">项目中使用了Hash路由时如何同时使用锚点？</a></p>]]></content>
    
    
    <categories>
      
      <category>踩坑经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端路由</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码样式调整</title>
    <link href="/unknown404.github.io/2022/12/15/codeFormat/"/>
    <url>/unknown404.github.io/2022/12/15/codeFormat/</url>
    
    <content type="html"><![CDATA[<p>为了使代码风格统一，更有利于阅读，可以借助一些工具进行优化。</p><span id="more"></span><h2 id="prettier"><a href="#prettier" class="headerlink" title="prettier"></a>prettier</h2><p>代码格式化工具。</p><h3 id="安装指令"><a href="#安装指令" class="headerlink" title="安装指令"></a>安装指令</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span>--save-dev prettier<br><span class="hljs-keyword">or</span><br><span class="hljs-keyword"></span>yarn <span class="hljs-keyword">add </span>prettier -D<br></code></pre></td></tr></table></figure><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><p>在根目录新建 .prettierrc.json，配置自己所需要的参数：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123;<br>  <span class="hljs-string">&quot;singleQuote&quot;</span>: true,  <span class="hljs-regexp">//</span> 使用单引号<br>  <span class="hljs-string">&quot;semi&quot;</span>: false,  <span class="hljs-regexp">//</span> 不使用分号<br>  <span class="hljs-string">&quot;bracketSpacing&quot;</span>: true,  <span class="hljs-regexp">//</span> 在对象,数组括号与文字之间加空格<br>  <span class="hljs-string">&quot;htmlWhitespaceSensitivity&quot;</span>: <span class="hljs-string">&quot;ignore&quot;</span>,  <span class="hljs-regexp">//</span> 对html的空格不敏感<br>  <span class="hljs-string">&quot;endOfLine&quot;</span>: <span class="hljs-string">&quot;auto&quot;</span>,  <span class="hljs-regexp">//</span> 行结尾统一样式，保持现有的行尾<br>  <span class="hljs-string">&quot;trailingComma&quot;</span>: <span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-regexp">//</span> 对象，数组等末尾不加逗号<br>  <span class="hljs-string">&quot;tabWidth&quot;</span>: <span class="hljs-number">2</span> <span class="hljs-regexp">//</span>  水平缩进的空格数为<span class="hljs-number">2</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="lint-staged"><a href="#lint-staged" class="headerlink" title="lint-staged"></a>lint-staged</h2><p>本地暂存代码检查工具。只检测 git add . 中暂存区的文件，对过滤出的文件执行脚本。</p><h3 id="安装指令-1"><a href="#安装指令-1" class="headerlink" title="安装指令"></a>安装指令</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span>lint-staged --save-dev<br><span class="hljs-keyword">or</span><br><span class="hljs-keyword"></span>yarn <span class="hljs-keyword">add </span>lint-staged -D<br></code></pre></td></tr></table></figure><h3 id="配置方式-1"><a href="#配置方式-1" class="headerlink" title="配置方式"></a>配置方式</h3><p>lint-staged 从 v3.1 开始可以使用不同的方式进行配置：</p><ul><li>package.json<br>示例：</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;lint-staged&quot;</span>: &#123;<br>    <span class="hljs-regexp">//</span> 匹配暂存区所有的js，vue文件，并执行命令<br>  <span class="hljs-string">&quot;*.&#123;js,vue,jsx,tsx&#125;&quot;</span>: [<br>    <span class="hljs-string">&quot;prettier --write&quot;</span>,<br>    <span class="hljs-string">&quot;eslint --cache --fix&quot;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>配置对象的 key 值为匹配的文件，右侧 value 对应执行指令。lint-staged 指令自动在最后包含了 git add 的操作，所以可以不用专门去写</p><ul><li>.lintstagedrc JSON 或 YML 格式的文件</li><li>lint-staged.config.js 格式的文件</li></ul><h2 id="husky"><a href="#husky" class="headerlink" title="husky"></a>husky</h2><p>Git hooks 工具，对 git 执行的一些命令，通过对应的 hooks 钩子触发，执行自定义的脚本程序。<br>常用的 gitHooks 包括：</p><ul><li>pre-commit：每次 commit 之前会执行的操作，常用于触发时进行代码格式验证</li><li>commit-msg：启动提交信息编辑器，常用于对 commit 消息和用户进行校验</li><li>pre-push：远程推代码前执行，常用于推代码前做单元测试和 e2e</li></ul><h3 id="安装指令-2"><a href="#安装指令-2" class="headerlink" title="安装指令"></a>安装指令</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">npm</span> install husky@<span class="hljs-number">4</span>.<span class="hljs-number">3</span> --save-dev<br><span class="hljs-attribute">or</span><br><span class="hljs-attribute">yarn</span> add husky@<span class="hljs-number">4</span>.<span class="hljs-number">3</span> -D<br></code></pre></td></tr></table></figure><h3 id="配置方式-2"><a href="#配置方式-2" class="headerlink" title="配置方式"></a>配置方式</h3><p>husky 版本在 6 以下时可以直接在 package.json 配置，例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;husky&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;hooks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;pre-commit&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;lint-staged&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>6 版本以上的 husky 把的配置提取到了根目录，package.json 中的配置在 husky 升级后无效了。需要执行指令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">npx husky <span class="hljs-keyword">add</span><span class="language-bash"> .husky/pre-commit <span class="hljs-string">&quot;npx lint-staged&quot;</span></span><br></code></pre></td></tr></table></figure><p>指令执行后会在根目录创建 .husky 文件夹，文件夹内部有一个 pre-commit 文件，包含指令 npx lint-staged</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://www.npmjs.com/package/lint-staged#Configuration">lint-staged 官方文档</a><br>（2）<a href="https://www.prettier.cn/docs/index.html">prettier 官方文档</a><br>（3）<a href="https://juejin.cn/post/6947200436101185566">GitHook 工具 —— husky（格式化代码）</a></p>]]></content>
    
    
    <categories>
      
      <category>工作技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>package.json分析</title>
    <link href="/unknown404.github.io/2022/12/15/packageJson/"/>
    <url>/unknown404.github.io/2022/12/15/packageJson/</url>
    
    <content type="html"><![CDATA[<p>虽然管理维护前端项目时经常需要跟该文件打交道，但在安装代码规范相关工具时，发现自己对其中的配置并不十分了解，所以想记录一下。</p><span id="more"></span><h2 id="文件配置"><a href="#文件配置" class="headerlink" title="文件配置"></a>文件配置</h2><p>描述配置在这里略过不计，除非自己要写包，不然感觉记忆没什么用</p><h3 id="workspaces"><a href="#workspaces" class="headerlink" title="workspaces"></a>workspaces</h3><p>workspaces 主要用于 monorepo 仓库管理模式、解决如何在一个顶层 root package 下管理多个子 packages 的问题，在 workspaces 声明目录下的 package 会软链到最上层 root package 的 node_modules 中，不用手动执行 npm link 操作。</p><p>通常子项目都会平铺管理在 packages 目录下，所以根目录下 workspaces 通常配置为：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-string">&quot;workspaces&quot;</span>: [<br>  <span class="hljs-string">&quot;packages/*&quot;</span><br>]<br></code></pre></td></tr></table></figure><h2 id="脚本配置"><a href="#脚本配置" class="headerlink" title="脚本配置"></a>脚本配置</h2><h3 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h3><p>指定项目的一些内置脚本命令，这些命令可以通过 npm run 来执行。npm run 的时候，就会自动创建一个 shell 脚本，将本地目录的 node_modules&#x2F;.bin 子目录加入 PATH 变量。这意味着，当前目录的 node_modules&#x2F;.bin 子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>  <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack&quot;</span>,<br>  <span class="hljs-string">&quot;prebuild&quot;</span>: <span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-regexp">//</span> build 执行之前的钩子<br>  <span class="hljs-string">&quot;postbuild&quot;</span>: <span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-regexp">//</span> build 执行之后的钩子<br>&#125;<br></code></pre></td></tr></table></figure><p>如果存在前缀指令<code>pre-*</code>、<code>post-*</code>的话，执行指令 npm run build 时会按照<code>prebuild - build - postbuild</code>执行顺序执行，这种语法现在并不推崇，需谨慎使用。</p><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>用于设置 scripts 里的脚本在运行时的参数。</p><h2 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h2><h3 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h3><p>运行依赖，也就是项目生产环境下需要用到的依赖。比如 react，vue，状态管理库以及组件库等。</p><p>使用 npm install xxx 或则 npm install xxx –save 时，会被自动插入到该字段中。</p><h4 id="备注：别名安装依赖"><a href="#备注：别名安装依赖" class="headerlink" title="备注：别名安装依赖"></a>备注：别名安装依赖</h4><p>以 node-sass 为例，该安装包可以在 Node.js 中原生地编译.scss 文件为 css，但是它已经被废弃，因此可以使用 dart-sass 代替，执行指令<code>npm install node-sass@npm:dart-sass@1.25.0</code>即可实现无缝地从 node-sass 切换到 dart-sass，而不影响项目的正常运行，同时也可以让项目 package.json 自动生成”node-sass”: “npm:<a href="mailto:&#x64;&#x61;&#x72;&#116;&#x2d;&#115;&#x61;&#x73;&#x73;&#64;&#x31;&#46;&#50;&#x35;&#46;&#48;">&#x64;&#x61;&#x72;&#116;&#x2d;&#115;&#x61;&#x73;&#x73;&#64;&#x31;&#46;&#50;&#x35;&#46;&#48;</a>“这个依赖项，方便项目管理和维护</p><h3 id="devDependencies"><a href="#devDependencies" class="headerlink" title="devDependencies"></a>devDependencies</h3><p>开发依赖，项目开发环境需要用到而运行时不需要的依赖，用于辅助开发，通常包括项目工程化工具比如 webpack，vite，eslint 等。<br>使用 npm install xxx -D 或者 npm install xxx –save-dev 时，会被自动插入到该字段中。</p><h2 id="三方配置"><a href="#三方配置" class="headerlink" title="三方配置"></a>三方配置</h2><p>package.json 中也存在很多三方属性，比如 tsc 中使用的 types、构建工具中使用的 sideEffects,git 中使用的 husky，eslint 使用的 eslintIgnore。这里只列举部分属性。</p><h3 id="lint-staged"><a href="#lint-staged" class="headerlink" title="lint-staged"></a>lint-staged</h3><p>lint-staged 是一个在 Git 暂存文件上运行 linters 的工具，配置后每次修改一个文件即可给所有文件执行一次 lint 检查，通常配合 gitHooks 一起使用。</p><h3 id="browserslist"><a href="#browserslist" class="headerlink" title="browserslist"></a>browserslist</h3><p>browserslist 字段用来告知支持哪些浏览器及版本。也可以使用 .browserslistrc 单文件配置。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-string">&quot;browserslist&quot;</span>: [<br>  <span class="hljs-string">&quot;&gt; 1%&quot;</span>,<br>  <span class="hljs-string">&quot;last 2 versions&quot;</span><br>]<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/7099041402771734559">深入浅出 package.json</a><br>（2）<a href="https://juejin.cn/post/7023539063424548872">关于前端大管家 package.json，你知道多少？</a><br>（3）<a href="https://juejin.cn/post/7161392772665540644">package.json 配置完全解读</a></p>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端依赖包管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react中获取ref相关的函数总结</title>
    <link href="/unknown404.github.io/2022/12/09/reactRef/"/>
    <url>/unknown404.github.io/2022/12/09/reactRef/</url>
    
    <content type="html"><![CDATA[<p>虽然 react 中很少使用操作 DOM 的逻辑，但为了能够理解开源代码，还是整理记录了常用的几个相关函数。</p><span id="more"></span><h2 id="获取-react-元素"><a href="#获取-react-元素" class="headerlink" title="获取 react 元素"></a>获取 react 元素</h2><h3 id="createRef"><a href="#createRef" class="headerlink" title="createRef"></a>createRef</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>常用于 class 组件（函数组件也可以用）</li><li>可获取原生 DOM 和自定义 class 组件的引用</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">//父组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoFocusTextInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  constructor(props) &#123;<br>    <span class="hljs-keyword">super</span>(props);<br>    <span class="hljs-keyword">this</span>.textInput = <span class="hljs-type">React</span>.createRef();<br>  &#125;<br><br>  componentDidMount() &#123;<br>    <span class="hljs-keyword">this</span>.textInput.current.focusTextInput();<br>  &#125;<br><br>  render() &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;<span class="hljs-type">CustomTextInput</span> ref=&#123;<span class="hljs-keyword">this</span>.textInput&#125; /&gt;<br>    );<br>  &#125;<br>&#125;<br><span class="hljs-comment">//子组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomTextInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  constructor(props) &#123;<br>    <span class="hljs-keyword">super</span>(props);<br>    <span class="hljs-comment">// 创建一个 ref 来存储 textInput 的 DOM 元素</span><br>    <span class="hljs-keyword">this</span>.textInput = <span class="hljs-type">React</span>.createRef();<br>    <span class="hljs-keyword">this</span>.focusTextInput = <span class="hljs-keyword">this</span>.focusTextInput.bind(<span class="hljs-keyword">this</span>);<br>  &#125;<br><br>  focusTextInput() &#123;<br>    <span class="hljs-comment">// 直接使用原生 API 使 text 输入框获得焦点</span><br>    <span class="hljs-comment">// 注意：我们通过 &quot;current&quot; 来访问 DOM 节点</span><br>    <span class="hljs-keyword">this</span>.textInput.current.focus();<br>  &#125;<br><br>  render() &#123;<br>    <span class="hljs-comment">// 告诉 React 我们想把 &lt;input&gt; ref 关联到</span><br>    <span class="hljs-comment">// 构造器里创建的 `textInput` 上</span><br>    <span class="hljs-keyword">return</span> (<br>      &lt;div&gt;<br>        &lt;input<br>          <span class="hljs-class"><span class="hljs-keyword">type</span></span>=<span class="hljs-string">&quot;text&quot;</span><br>          ref=&#123;<span class="hljs-keyword">this</span>.textInput&#125; /&gt;<br>        &lt;input<br>          <span class="hljs-class"><span class="hljs-keyword">type</span></span>=<span class="hljs-string">&quot;button&quot;</span><br>          value=<span class="hljs-string">&quot;Focus the text input&quot;</span><br>          onClick=&#123;<span class="hljs-keyword">this</span>.focusTextInput&#125;<br>        /&gt;<br>      &lt;/div&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>createRef 每次渲染都会返回一个新的引用</li></ol><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const createRef = <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> &#123; current: <span class="hljs-literal">null</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol><li>只能用于函数组件</li><li>useRef 的引用存在于组件的整个生命周期</li></ol><h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">let obj = &#123; current: <span class="hljs-literal">null</span> &#125;<br><br>const useRef = <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> obj<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>createRef 与 useRef 区别</strong><br>虽然都是用于创建 ref 属性、访问 DOM 实例对象，但两者适用的组件语法略有差异：createRef 更适用于 class 组件，由于其并没有 Hooks 的效果，其内部的值会随着函数组件重复执行而不断被初始化，而在 class 组件中由于分离了生命周期，使初始化时机仅执行一次。</p></blockquote><p>以下面的代码为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; createRoot &#125; = <span class="hljs-title class_">ReactDOM</span>;<br><span class="hljs-keyword">const</span> &#123; useRef, useState, createRef &#125; = <span class="hljs-title class_">React</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>   <span class="hljs-keyword">const</span> [renderIndex,setRenderIndex] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> refFromUseRef = <span class="hljs-title function_">useRef</span>();<br>   <span class="hljs-keyword">const</span> refFromCreateRef = <span class="hljs-title function_">createRef</span>();<br><br><br>    <span class="hljs-keyword">if</span> (!refFromUseRef.<span class="hljs-property">current</span>)&#123;<br>       refFromUseRef.<span class="hljs-property">current</span>=renderIndex<br>   &#125;<br>    <span class="hljs-keyword">if</span> (!refFromCreateRef.<span class="hljs-property">current</span>) &#123;<br>        refFromCreateRef.<span class="hljs-property">current</span> = renderIndex<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>index &#123;renderIndex&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>refFromUseRef &#123;refFromUseRef.current&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>refFromCreateRef &#123;refFromCreateRef.current&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123; setRenderIndex(p=&gt;p+1)&#125;&#125;&gt;a<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ComponentDemo</span> = <span class="hljs-title class_">App</span>;<br><span class="hljs-title function_">createRoot</span>(mountNode).<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ComponentDemo</span> /&gt;</span></span>);<br><br></code></pre></td></tr></table></figure><p>在执行的过程中会发现即使组件重新渲染, 由于 refFromUseRef 的值一直存在(类似于 this ) , 无法重新赋值；而 refFromCreateRef 会随组件渲染不断改变引用值。</p><h2 id="父组件获取子组件内部的一个元素"><a href="#父组件获取子组件内部的一个元素" class="headerlink" title="父组件获取子组件内部的一个元素"></a>父组件获取子组件内部的一个元素</h2><h3 id="forwardRef"><a href="#forwardRef" class="headerlink" title="forwardRef"></a>forwardRef</h3><p>获取函数子组件内部元素的 ref 得用 forwardRef，因为 ref 不像 props 作为参数可以传递。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 父元素。可以直接获取 DOM button 的 ref：</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span>=(<span class="hljs-params"></span>)=&gt;&#123;<br>    <span class="hljs-keyword">const</span> ref = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>();<br>    <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">FancyButton</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span>&gt;</span>Click me!<span class="hljs-tag">&lt;/<span class="hljs-name">FancyButton</span>&gt;</span></span>)<br>&#125;<br><br><span class="hljs-comment">//子元素</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">FancyButton</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;FancyButton&quot;</span>&gt;</span></span><br><span class="language-xml">    &#123;props.children&#125;</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>));<br></code></pre></td></tr></table></figure><h2 id="父组件获取子组件内部多个元素-x2F-方法"><a href="#父组件获取子组件内部多个元素-x2F-方法" class="headerlink" title="父组件获取子组件内部多个元素&#x2F;方法"></a>父组件获取子组件内部多个元素&#x2F;方法</h2><h3 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h3><p>useImperativeHandle 需要和 forwardRef 结合使用。可以让你在使用 ref 时自定义暴露给父组件的实例值。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const FancyInput= React.forwardRef(props, ref) =&gt; &#123;<br>  const inputRef = useRef();<br>  useImperativeHandle(ref, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (&#123;<br>    focus: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      inputRef.current.focus();<br>    &#125;<br>  &#125;));<br>  <span class="hljs-keyword">return</span> &lt;input ref=&#123;inputRef&#125; ... /&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>本例中渲染<code> &lt;FancyInput ref=&#123;inputRef&#125; /&gt;</code> 的父组件可以调用 inputRef.current.focus()。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://blog.csdn.net/frontend_frank/article/details/104243286">什么是 useRef , useRef 与 createRef 区别, 以及在什么情况下使用 useRef</a><br>（2）<a href="https://juejin.cn/post/6844904079164964878">精读《useRef 与 createRef 的区别》</a><br>（3）<a href="https://juejin.cn/post/7146095092674068487">一文学会 useImperativeHandle</a></p>]]></content>
    
    
    <categories>
      
      <category>前端技术体系</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>页面置灰的实现方式</title>
    <link href="/unknown404.github.io/2022/12/02/cssUsage/"/>
    <url>/unknown404.github.io/2022/12/02/cssUsage/</url>
    
    <content type="html"><![CDATA[<p>记一次 css 踩坑经历</p><span id="more"></span><h2 id="业务需求描述"><a href="#业务需求描述" class="headerlink" title="业务需求描述"></a>业务需求描述</h2><p>涉及一些重要的悼念活动时，需要将网站主页面置为灰色，同时希望不要影响其他功能页面的颜色</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>可将页面的 CSS 样式设置为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css">.<span class="hljs-selector-attr">[classname]</span>  &#123;<br>    -webkit-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    -moz-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    -ms-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    -o-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    <span class="hljs-attribute">filter</span>: gray;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的点是如果页面组件有 fixed 定位，上述 css 写法可能会导致组件位置出现问题，根据 MDN 的文档，对 position 定位有下面一段描述：</p><blockquote><p><strong>fixed</strong><br>元素会被移出正常文档流，并不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform, perspective 或 filter 属性非 none 时，容器由视口改为该祖先。</p></blockquote><p><strong>解决方法：</strong><br>将 filter 的样式写在 html 上。<br><strong>注意点：</strong></p><ol><li>非 SPA 项目处理时书写方式最好是：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>  &#123;<br>    -webkit-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    -moz-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    -ms-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    -o-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    <span class="hljs-attribute">filter</span>: gray;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是因为尽管 html5.0 规范允许在<code>&lt;html&gt;</code>标签上添加 class 属性，但没有保证该 class 属性一定能生效。</p><ol start="2"><li>处理 SPA 页面时如果书写上述样式，会导致所有页面样式都会变灰。比较好的实现方式是利用页面的生命周期，为 html 节点手动添加样式。并在页面跳转时去除变灰样式。这里以 react 为例：</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">componentDidMount</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">if</span>(global.document)&#123;<br>      const html=document<span class="hljs-selector-class">.getElementsByTagName</span>(<span class="hljs-string">&#x27;html&#x27;</span>)<br>      <span class="hljs-built_in">if</span>(<span class="hljs-selector-tag">html</span><span class="hljs-selector-attr">[0]</span>)&#123;<br>        <span class="hljs-selector-tag">html</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.style</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;filter&#x27;</span> as any]</span>=<span class="hljs-string">&#x27;grayscale(100%)&#x27;</span><br>      &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">componentWillUnmount</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">if</span>(global.document)&#123;<br>        const html=document<span class="hljs-selector-class">.getElementsByTagName</span>(<span class="hljs-string">&#x27;html&#x27;</span>)<br>        <span class="hljs-built_in">if</span>(<span class="hljs-selector-tag">html</span><span class="hljs-selector-attr">[0]</span>)&#123;<br>            <span class="hljs-selector-tag">html</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.style</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;filter&#x27;</span>  as any]</span>=<span class="hljs-string">&#x27;none&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>使用 js 添加样式时，如果代码使用了 ts 语法，可能会报错：<code>Element implicitly has an &#39;any&#39; type because index expression is not of type &#39;number&#39;</code>，这是因为 CSSStyleDeclaration 它的 index 值设置为了 number 而不是 string，这个报错的根本原因，兼容浏览器的 css 属性<code>-webkit-*</code>、<code>-o-*</code>等已经不在 CSSStyleDeclaration 内部了。考虑到现在大部分浏览器都支持 css3 了，兼容性写法可以适时去掉</li></ol><h2 id="扩展：固定定位组件兼容祖先元素的样式"><a href="#扩展：固定定位组件兼容祖先元素的样式" class="headerlink" title="扩展：固定定位组件兼容祖先元素的样式"></a>扩展：固定定位组件兼容祖先元素的样式</h2><p>根据<a href="https://juejin.cn/post/7265121637497733155">这篇文章</a>的说法，可以考虑找到相对定位的祖先元素，相对该祖先元素计算定位。其寻找定位参考的祖先元素的思路与 <a href="">popper-js</a> 类似，popper-js 具备自动跟踪的定位的功能，比如滚动条滚动的时候，会自动帮你更改定位坐标</p><ol><li>寻找定位参考的祖先元素<br>定位参考的祖先元素、即包含块也可能是由满足以下条件的最近父级元素的内边距区的边缘组成的：</li></ol><ul><li>transform  或  perspective  的值不是  none</li><li>will-change  的值是  transform  或  perspective</li><li>filter  的值不是  none  或  will-change  的值是  filter（只在 Firefox 下生效）。</li><li>contain  的值是  paint（例如：contain: paint;）</li><li>backdrop-filter  的值不是  none（例如：backdrop-filter: blur(10px);）</li></ul><blockquote><p>包含块：元素用来计算和定位一个的框。</p><ul><li>根元素(很多场景下可以看成<code>&lt;html&gt;</code>)被称为‘初始包含块’,其尺寸等同于浏览器可视窗口的大小。</li><li>对于其他元素，如果该元素的 position 是 relative 或者 static，则包含块由其最近的块级祖先元素 content box 边界形成。</li><li>如果元素的 position:fixed，则‘包含块’是初始包含块。</li><li>如果元素的 position:absolute，则其包含块由最近的 position 值不为 static 的祖先元素建立。</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getContainingBlock</span>(<span class="hljs-params">element: Element</span>) &#123;<br>  <span class="hljs-keyword">let</span> currentNode = element.<span class="hljs-property">parentElement</span>;<br>  <span class="hljs-keyword">while</span> (currentNode) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isContainingBlock</span>(currentNode)) <span class="hljs-keyword">return</span> currentNode;<br>    currentNode = currentNode.<span class="hljs-property">parentElement</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-keyword">import</span> &#123; isSafari &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./isSafari&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getWindow</span>(<span class="hljs-params">node: any</span>): <span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> &#123;<br>  <span class="hljs-keyword">return</span> node?.<span class="hljs-property">ownerDocument</span>?.<span class="hljs-property">defaultView</span> || <span class="hljs-variable language_">window</span>;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getComputedStyle</span>(<span class="hljs-params">element: Element</span>): <span class="hljs-title class_">CSSStyleDeclaration</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">getWindow</span>(element).<span class="hljs-title function_">getComputedStyle</span>(element);<br>&#125;<br><span class="hljs-comment">// 判断包含块</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">isContainingBlock</span>(<span class="hljs-params">element: Element</span>): boolean &#123;<br>  <span class="hljs-keyword">const</span> safari = <span class="hljs-title function_">isSafari</span>();<br>  <span class="hljs-keyword">const</span> css = <span class="hljs-title function_">getComputedStyle</span>(element);<br><br>  <span class="hljs-comment">// https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block</span><br>  <span class="hljs-keyword">return</span> (<br>    css.<span class="hljs-property">transform</span> !== <span class="hljs-string">&quot;none&quot;</span> ||<br>    css.<span class="hljs-property">perspective</span> !== <span class="hljs-string">&quot;none&quot;</span> ||<br>    (css.<span class="hljs-property">containerType</span> ? css.<span class="hljs-property">containerType</span> !== <span class="hljs-string">&quot;normal&quot;</span> : <span class="hljs-literal">false</span>) ||<br>    (!safari &amp;&amp; (css.<span class="hljs-property">backdropFilter</span> ? css.<span class="hljs-property">backdropFilter</span> !== <span class="hljs-string">&quot;none&quot;</span> : <span class="hljs-literal">false</span>)) ||<br>    (!safari &amp;&amp; (css.<span class="hljs-property">filter</span> ? css.<span class="hljs-property">filter</span> !== <span class="hljs-string">&quot;none&quot;</span> : <span class="hljs-literal">false</span>)) ||<br>    [<span class="hljs-string">&quot;transform&quot;</span>, <span class="hljs-string">&quot;perspective&quot;</span>, <span class="hljs-string">&quot;filter&quot;</span>].<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span><br>      (css.<span class="hljs-property">willChange</span> || <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">includes</span>(value)<br>    ) ||<br>    [<span class="hljs-string">&quot;paint&quot;</span>, <span class="hljs-string">&quot;layout&quot;</span>, <span class="hljs-string">&quot;strict&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>].<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span><br>      (css.<span class="hljs-property">contain</span> || <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">includes</span>(value)<br>    )<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>getComputedStyle：获取节点的样式信息，window.getComputedStyle(element,pseudoClass)返回的是一个 CSS 样式声明对象([object CSSStyleDeclaration])，注意是只读。</li><li>getWindow：火狐浏览器不是很支持window.getComputedStyle，所以需要dom.ownerDocument.defaultView获取节点的根节点的关联的窗口对象（一般浏览器也就返回window了）。</li></ul><ol start="2"><li>计算定位<br>这里计算的定位不是组件组件相对于视口的，而是相对于包含块的。<br><img src="/unknown404.github.io/img/containPos.jpg"><br>从这个示意图可以看出，相对于包含块的定位计算方式为：</li></ol><p>x &#x3D; 按钮到视口左边的距离 - 定位上下文到视口左边的距离 + 定位上下文的横向滚动距离<br>y &#x3D; 按钮到视口顶部的距离 - 定位上下文到视口顶部的距离 + 定位上下文的纵向滚动距离</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">affixDom.<span class="hljs-property">style</span>.<span class="hljs-property">top</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;isHTMLElement(offsetParent) ? (fixedTop <span class="hljs-keyword">as</span> number) - offsetParent.getBoundingClientRect().top : fixedTop&#125;</span>px`</span>;<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position">MDN position</a><br>（2）<a href="https://stackoverflow.com/questions/53526178/element-implicitly-has-an-any-type-because-index-expression-is-not-of-type-nu">Element implicitly has an ‘any’ type because index expression is not of type ‘number’ [7015]</a><br>（3）<a href="https://www.cnblogs.com/leaf930814/p/6985017.html">js原生获取元素的css属性</a><br>（4）<a href="https://juejin.cn/post/7257785104713367611">【目前最好的react组件库教程】手写增强版 @popper-js （主体逻辑分析）</a></p>]]></content>
    
    
    <categories>
      
      <category>踩坑经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js实现从utf-8到base64编码</title>
    <link href="/unknown404.github.io/2022/11/29/encodeBase64/"/>
    <url>/unknown404.github.io/2022/11/29/encodeBase64/</url>
    
    <content type="html"><![CDATA[<p>编码知识小记</p><span id="more"></span><h2 id="编码相关概念的辨析"><a href="#编码相关概念的辨析" class="headerlink" title="编码相关概念的辨析"></a>编码相关概念的辨析</h2><h3 id="编码历史"><a href="#编码历史" class="headerlink" title="编码历史"></a>编码历史</h3><p>计算机起源之初，科学家对英语字符与二进制位之间的关系做了统一规定，定义了 128 个字符的编码规则，用七位二进制表示。这套编码规则被称为 ASCII 编码。随着计算机的普及，在不同的地区和国家，当地程序员为了适应本地的语言使用创建了新的字符编码。但不同国家间读取内容时由于编码方式的差异会导致内容乱码，对国际沟通交流造成了障碍。</p><p>这时候 Unicode 就出现了。 Unicode 是国际标准字符集，它将世界各种语言的每个字符定义一个唯一的编码，以满足跨语言、跨平台的文本信息转换。Unicode 字符集的编码范围是 0x0000 - 0x10FFFF , 可以容纳一百多万个字符， 每个字符都有一个独一无二的编码，也即每个字符都有一个二进制数值和它对应。</p><h3 id="Unicode、utf-8、utf-16-辨析"><a href="#Unicode、utf-8、utf-16-辨析" class="headerlink" title="Unicode、utf-8、utf-16 辨析"></a>Unicode、utf-8、utf-16 辨析</h3><p>Unicode 只是字符集，即很多个字符的集合；而 UTF-8、UTF-16、UTF-32 才是真正的字符编码规则：utf-8 是用一个字节来编码所有的字符，utf-16 是用两个字节来编码所有的字符，utf-32 则选择用 4 个字节来编码。<br>其中最常见的编码规则是 utf-8，因为互联网的大部分资源都是英文的，使用 utf-8 保存更节省空间。Unicode 转 utf-8 主要是变长编码，有具体表格展示不同 unicode 的编码规则，这里不再赘述。</p><h3 id="Base64-编码"><a href="#Base64-编码" class="headerlink" title="Base64 编码"></a>Base64 编码</h3><p>Base64 的编码方法要求把每三个 8bit 的字节转换成四个 6bit 的字节，然后把 6Bit 再添两位高位 0，组成四个 8Bit 的字节。经过 base64 编码后的字符串会比原来长 1&#x2F;3。</p><h2 id="前端页面表单数据转-base64"><a href="#前端页面表单数据转-base64" class="headerlink" title="前端页面表单数据转 base64"></a>前端页面表单数据转 base64</h2><p>需要注意的点是虽然 html 和 js 的编码是 utf-8，但 js 从页面得到的中文是 utf-16 编码，直接转 base64 是会出错的。<br>MDN 上给出了最简单的解决方法：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> utf8<span class="hljs-constructor">_to_b64(<span class="hljs-params">str</span>)</span> &#123;<br>  return window.btoa(unescape(encode<span class="hljs-constructor">URIComponent(<span class="hljs-params">str</span>)</span>));<br>&#125;<br><br><span class="hljs-keyword">function</span> b64<span class="hljs-constructor">_to_utf8(<span class="hljs-params">str</span>)</span> &#123;<br>  return decode<span class="hljs-constructor">URIComponent(<span class="hljs-params">escape</span>(<span class="hljs-params">window</span>.<span class="hljs-params">atob</span>(<span class="hljs-params">str</span>)</span>));<br>&#125;<br><br><span class="hljs-comment">// Usage:</span><br>utf8<span class="hljs-constructor">_to_b64(<span class="hljs-string">&quot;✓ à la mode&quot;</span>)</span>; <span class="hljs-comment">// &quot;4pyTIMOgIGxhIG1vZGU=&quot;</span><br>b64<span class="hljs-constructor">_to_utf8(<span class="hljs-string">&quot;4pyTIMOgIGxhIG1vZGU=&quot;</span>)</span>; <span class="hljs-comment">// &quot;✓ à la mode&quot;</span><br></code></pre></td></tr></table></figure><p>里面涉及的流程是：</p><ol><li>先用 encodeURIComponent 把 js 的字符串转成 UTF-8 的百分号编码形式。该方法不会对 ASCII 字母和数字及部分 ASCII 标点符号进行编码，非英文字符会先转为 UTF8 的字节码，然后前面加个%进行拼接；</li><li>再用 unescape 把百分号编码按字节转化成对应的含有 Latin-1 字符集字符的 js 字符串 （即使它是乱码）；</li><li>最后用 btoa 把只含有 Latin-1 的 js 字符串转换成 Base64 编码；根据 MDN 文档，btoa 可以将二进制字符串转为 base64 编码的 ASCII 字符串，在实际操作中发现如果直接对中文编码会抛出错误：‘The string to be encoded contains characters outside of the Latin1 range.’，可以推断 btoa 是可以处理 Latin-1 字符集字符的。</li></ol><p>关于这种编码方式，网上也看到有去掉 escape&#x2F;unescape 的版本，似乎同样能得到预期结果。但是这得到的编码并非 utf-8 转 base64 的结果，在只有 ASCII 码时 unescape 使用与否都能得到一样的答案，然而出现带百分号编码的字符串时省去 unescape 会使编码结果的长度增加了，因为 btoa 编码了百分号；且如果是将编码结果传给其他 API 时会很难理解其内容</p><h2 id="前端-node-js-转-base64"><a href="#前端-node-js-转-base64" class="headerlink" title="前端 node.js 转 base64"></a>前端 node.js 转 base64</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">//utf-8 转 base64</span><br>const txt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Buffer</span>(<span class="hljs-string">&#x27;文字&#x27;</span>).toString(<span class="hljs-string">&#x27;base64&#x27;</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(txt)<br><br><span class="hljs-comment">//base64 转 utf-8</span><br>const ztxt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Buffer</span>(txt, <span class="hljs-string">&#x27;base64&#x27;</span>).toString(<span class="hljs-string">&#x27;utf8&#x27;</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(ztxt)<br></code></pre></td></tr></table></figure><p>处理起来相对简单，可以直接用 buffer 模块的 api</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://zhuanlan.zhihu.com/p/427488961">Unicode、UTF-8、UTF-16 终于懂了</a><br>（2）<a href="https://developer.mozilla.org/en-US/docs/Glossary/Base64#Solution_2_%E2%80%93_escaping_the_string_before_encoding_it">Base64</a><br>（3）<a href="https://best33.com/311.moe">为什么 escape 可以使 btoa 正确处理 UTF-8 编码的字符串？</a><br>（4）<a href="https://stackoverflow.com/questions/30631927/converting-to-base64-in-javascript-without-deprecated-escape-call">Converting to Base64 in JavaScript without Deprecated ‘Escape’ call</a></p>]]></content>
    
    
    <categories>
      
      <category>工作技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>依赖失踪之谜 —— 记一次失败的问题查找</title>
    <link href="/unknown404.github.io/2022/11/29/nvmProblemSearch/"/>
    <url>/unknown404.github.io/2022/11/29/nvmProblemSearch/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>全局安装的依赖包突然找不到了，调用指令返回 <code>zsh: command not found:xxx</code> 的报错。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>对于上述报错问题，网上的回复基本统一是缺少环境变量配置。MAC 电脑的环境变量文件加载顺序为：</p><ul><li>&#x2F;etc&#x2F;profile，系统级文件，系统启动即加载</li><li>&#x2F;etc&#x2F;path，系统级文件，系统启动即加载</li><li>&#x2F;.bash_profile，用户级的环境变量配置文件，当该文件存在时忽略<del>&#x2F;.bash_login 、</del>&#x2F;.profile 、~&#x2F;.bashrc 文件的配置</li></ul><p>解决环境变量问题步骤：</p><ol><li>打开 zsh 控制台，输入指令：<code>open .zshrc</code></li><li>查看环境变量 PATH。PATH 的通常写法为</li></ol><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">export <span class="hljs-built_in">PATH</span> = &lt;<span class="hljs-built_in">path</span> <span class="hljs-number">1</span>&gt; : &lt;<span class="hljs-built_in">path</span> <span class="hljs-number">2</span>&gt; ... : &lt;<span class="hljs-built_in">path</span> n&gt; : $<span class="hljs-built_in">PATH</span><br></code></pre></td></tr></table></figure><p>涉及多个环境变量时用分号隔开。</p><p>当前电脑配置的 zshrc 内容为：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">NVM_DIR</span>=<span class="hljs-string">&quot;/Users/danhuipeng/.nvm&quot;</span><br>[ -s <span class="hljs-string">&quot;<span class="hljs-variable">$NVM_DIR</span>/nvm.sh&quot;</span> ] &amp;&amp; \. <span class="hljs-string">&quot;<span class="hljs-variable">$NVM_DIR</span>/nvm.sh&quot;</span>  # This loads nvm<br><br><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.yarn/bin:<span class="hljs-variable">$HOME</span>/.config/yarn/global/node_modules/.bin:<span class="hljs-variable">$PATH</span>&quot;</span><br><br>source ~/.bash_profile<br></code></pre></td></tr></table></figure><p>虽然有 yarn 的路径在环境变量中，但因为全局依赖包没有使用 yarn，所以现在的设置并不能解决问题。推测可能是因为当前的 path 内容并没有指向全局 npm 的依赖包目录下 。</p><ol start="3"><li>添加环境变量。使用指令<code>npm config get prefix</code>获取全局安装包时使用的 node，使用指令<code>npm root -g</code>来寻找全局仓库路径。得到的结果分别为：</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">～<span class="hljs-regexp">/.nvm/</span>versions<span class="hljs-regexp">/node/</span>v15.<span class="hljs-number">14.0</span><br>～<span class="hljs-regexp">/.nvm/</span>versions<span class="hljs-regexp">/node/</span>v15.<span class="hljs-number">14.0</span><span class="hljs-regexp">/lib/</span>node_modules<br></code></pre></td></tr></table></figure><p>根目录已省略。尝试将这两个变量添加到 path 后，执行指令发<code>source .zshrc</code>现并没有解决问题。为了明确为什么找不到依赖包执行了指令<code>cd ~/.nvm/versions/node/v15.14.0/lib/node_modules</code>到全局依赖目录下，尝试查看内容列表，然而执行指令<code>ls</code>后什么也没发生，即该目录下的内容已空！！为什么会空了呢？完全不知道原因，和其他版本的依赖目录比较发现连 npm 都没有了？？<br><img src="/unknown404.github.io/img/log.png"></p><p>问题排查到这里已经进行不下去了，只能进行依赖重装。</p><p>考虑到本人使用 node 15 的时候比较少，大多数项目使用的都是 14，所以采用指令<code>nvm alias default v14</code>调整 node 的默认版本。因为 node 15 现在连 npm 都没有了，所以使用<code>nvm uninstall v15</code>指令卸载 node15。使用指令<code>nvm ls</code>检查发现现在已经开始使用 node v14 了</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xl">       v10.<span class="hljs-number">24.1</span><br>       v12.<span class="hljs-number">16.3</span><br>       v12.<span class="hljs-number">22.1</span><br>-&gt;     v14.<span class="hljs-number">19.3</span><br><span class="hljs-function"><span class="hljs-title">default</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">v14</span> (-&gt;</span> v14.<span class="hljs-number">19.3</span>)<br><span class="hljs-function"><span class="hljs-title">iojs</span> -&gt;</span> N/A (default)<br><span class="hljs-function"><span class="hljs-title">unstable</span> -&gt;</span> N/A (default)<br><span class="hljs-function"><span class="hljs-title">node</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">stable</span> (-&gt;</span> v14.<span class="hljs-number">19.3</span>) (default)<br><span class="hljs-function"><span class="hljs-title">stable</span> -&gt;</span> <span class="hljs-number">14.19</span> (-&gt; v14.<span class="hljs-number">19.3</span>) (default)<br><span class="hljs-function"><span class="hljs-title">lts</span>/* -&gt;</span> <span class="hljs-function"><span class="hljs-title">lts</span>/hydrogen (-&gt;</span> N/A)<br><span class="hljs-function"><span class="hljs-title">lts</span>/argon -&gt;</span> <span class="hljs-function"><span class="hljs-title">v4</span>.9.1 (-&gt;</span> N/A)<br><span class="hljs-function"><span class="hljs-title">lts</span>/boron -&gt;</span> <span class="hljs-function"><span class="hljs-title">v6</span>.17.1 (-&gt;</span> N/A)<br><span class="hljs-function"><span class="hljs-title">lts</span>/carbon -&gt;</span> <span class="hljs-function"><span class="hljs-title">v8</span>.17.0 (-&gt;</span> N/A)<br><span class="hljs-function"><span class="hljs-title">lts</span>/dubnium -&gt;</span> v10.<span class="hljs-number">24.1</span><br><span class="hljs-function"><span class="hljs-title">lts</span>/erbium -&gt;</span> <span class="hljs-function"><span class="hljs-title">v12</span>.22.12 (-&gt;</span> N/A)<br><span class="hljs-function"><span class="hljs-title">lts</span>/fermium -&gt;</span> <span class="hljs-function"><span class="hljs-title">v14</span>.21.1 (-&gt;</span> N/A)<br><span class="hljs-function"><span class="hljs-title">lts</span>/gallium -&gt;</span> <span class="hljs-function"><span class="hljs-title">v16</span>.18.1 (-&gt;</span> N/A)<br><span class="hljs-function"><span class="hljs-title">lts</span>/hydrogen -&gt;</span> <span class="hljs-function"><span class="hljs-title">v18</span>.12.1 (-&gt;</span> N/A)<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>(1)<a href="https://wenku.baidu.com/view/2cb4a1ffae51f01dc281e53a580216fc700a53a9.html?_wkts_=1669702352151&bdQuery=zsh%E6%80%8E%E4%B9%88%E9%85%8D%E5%A4%9A%E4%B8%AA%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">Mac 在 bash 和 zsh 配置环境变量 path 的几种方法</a><br>(2)<a href="https://blog.csdn.net/Wildpiglolo/article/details/123828019">npm 全局安装后，对应的环境变量目录下找不到文件</a></p>]]></content>
    
    
    <categories>
      
      <category>踩坑经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>依赖安装</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小程序踩坑经历--canvas层级过高</title>
    <link href="/unknown404.github.io/2022/09/30/appletCanvas/"/>
    <url>/unknown404.github.io/2022/09/30/appletCanvas/</url>
    
    <content type="html"><![CDATA[<p>小程序开发弹窗功能时遇到的问题。</p><span id="more"></span><h2 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h2><p>需要在某一计算结果页设置收集信息弹窗，点击按钮时弹窗悬浮于页面正中；计算结果页包含绘制的饼图</p><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><p>canvas 属于原生组件，拥有最高层级，页面中其他组件无论设置 z-index 多少都无法覆盖在 canvas 上；且 canvas 标签不能使用<code>visibility:hidden</code>或 <code>opacity: 0;</code>去隐藏，放在父元素设置同样不可行</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>对于只需要展示文字或图片的简单弹窗，可以使用 cover-view 组件，该组件有小程序最高层级。<br>对于功能相对复杂的弹窗，则需要将 canvas 转为图片。<br>具体操作内容：</p><ol><li>模版部分：<br>新增替代 canvas 的图片模块，与 canvas 同级。这里为方便新增的模块和 canvas 同类名以便获取同样的样式大小设置。<br>新增变量 imgHide 和 chartImg，分别用于控制 canvas 到图片切换的过程和获取导出图片的临时路径。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Vue">&lt;template&gt;<br>    ...<br>    &lt;canvas<br>        :hidden=&quot;!imgHide&quot;<br>        class=&quot;chart-canvas&quot;<br>        canvas-id=&quot;ringCanvas&quot;<br>    &gt;&lt;/canvas&gt;<br>    &lt;view class=&quot;chart-canvas&quot; :hidden=&quot;imgHide&quot;&gt;<br>        &lt;img :src=&quot;chartImg&quot;/&gt;<br>    &lt;/view&gt;<br>    ...<br>    &lt;view @click=&quot;modalShow&quot;&gt;tap&lt;/view&gt;<br>    &lt;view class=&quot;modal&quot;&gt;<br>        ...<br>    &lt;/view&gt;<br>&lt;/template&gt;<br><br></code></pre></td></tr></table></figure><ol start="2"><li>JS 逻辑部分：<br>1）初始化 imgHide 和 chartImg，分别设为 false 和’’<br>2）增加新方法 canvasToImg，处理 canvas 导出图片的任务。这里 destWidth、destHeight 都设置为原宽高的 2 倍是因为 canvas 是位图，将它渲染到高清屏时,会被放大,每个像素点会用 devicePixelRatio 的平方个物理像素点来渲染,因此图片会变得模糊。使用 2 倍图可以解决问题。绘制成功时将文件路径赋值给 chartImg</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">canvasToImg</span>(<span class="hljs-params">width, height</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        wx.<span class="hljs-title function_">canvasToTempFilePath</span>(&#123;<br>            <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,<br>            <span class="hljs-attr">y</span>: <span class="hljs-number">0</span>,<br>            width,<br>            height,<br>            <span class="hljs-attr">destWidth</span>: width * <span class="hljs-number">2</span>,<br>            <span class="hljs-attr">destHeight</span>: height * <span class="hljs-number">2</span>,<br>            <span class="hljs-attr">canvasId</span>: <span class="hljs-string">&#x27;ringCanvas&#x27;</span>,<br>            <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>                <span class="hljs-keyword">const</span> filePath = res.<span class="hljs-property">tempFilePath</span><br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;tempFilePath&#x27;</span>, filePath)<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">chartImg</span> = filePath<br>            &#125;,<br>            <span class="hljs-attr">fail</span>: <span class="hljs-function"><span class="hljs-params">rej</span> =&gt;</span> &#123;<br>                <span class="hljs-keyword">throw</span> rej<br>            &#125;<br>        &#125;)<br>    &#125;, <span class="hljs-number">1000</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>选择 canvas 切 img 的时机。<br>如果在拿到导出图片路径时立即切图片，会导致页面的 chart 有一段不自然的闪烁看起来很奇怪；如果不考虑切换操作，直接在图片位置加 loading 图直到拿到导出图片路径，则体感加载时间会很长，因为 loading 时间包括了 canvas 绘制和图片导出，都是比较耗时的操作。<br>既然 canvas 换图片的操作是为了解决弹窗被遮挡的问题，那么可以将改变 imgHide 时机放置在点击按钮、弹出弹窗的方法中。<br>同时考虑到 canvas 导出图片的时间很长，如果在未完成该操作时弹窗就关闭的话用户就会看到空白的图片，所以需要在弹窗关闭的方法中增加是否需要切回 canvas 的判断。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">modalShow</span>(<span class="hljs-params"></span>) &#123;<br>    ...<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">imgHide</span> = <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-title function_">modalClose</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">chartImg</span> != <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">imgHide</span> = <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的点是如果 canvas 的面积大于弹窗的面积，那么当点击弹窗、canvas 尚未导出图片路径时，仍可以透过弹窗的 mask 看到没图的 img 元素的边框。<del>（这时最好不要做这个功能了）</del></p><ol start="4"><li>如果是需要反复绘制的场景，需要注意绘制前 canvas 是否仍然存在，否则 canvas 无法重新绘制，转成图片自然也不执行。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">onShow</span>(<span class="hljs-params"></span>) &#123;<br>    ...<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">imgHide</span> = <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://wenku.baidu.com/view/9d46b515ba0d6c85ec3a87c24028915f804d842d.html">微信小程序 canvas 层级过高，遮住弹窗解决方法</a></p>]]></content>
    
    
    <categories>
      
      <category>踩坑经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack配置踩坑经历</title>
    <link href="/unknown404.github.io/2022/09/20/webpackConfig/"/>
    <url>/unknown404.github.io/2022/09/20/webpackConfig/</url>
    
    <content type="html"><![CDATA[<h2 id="问题：webpack项目使用域名访问出现Invalid-Host-header，使用ip可访问"><a href="#问题：webpack项目使用域名访问出现Invalid-Host-header，使用ip可访问" class="headerlink" title="问题：webpack项目使用域名访问出现Invalid Host header，使用ip可访问"></a>问题：webpack项目使用域名访问出现Invalid Host header，使用ip可访问</h2><p><strong>原因</strong>：新版的webpack-dev-server出于安全考虑,默认检查hostname,如果hostname 不是配置内的,将中断访问。<br><strong>解决方法</strong>：找到server的配置文件，添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">devServer:</span> &#123;<br>  <span class="hljs-attr">disableHostCheck:</span> <span class="hljs-literal">true</span>,<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>踩坑经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue</title>
    <link href="/unknown404.github.io/2022/09/18/Vue/"/>
    <url>/unknown404.github.io/2022/09/18/Vue/</url>
    
    <content type="html"><![CDATA[<p>前端 vue 框架方面知识整理。</p><span id="more"></span><h2 id="Vue-相关基本概念"><a href="#Vue-相关基本概念" class="headerlink" title="Vue 相关基本概念"></a>Vue 相关基本概念</h2><h3 id="MVVM-和-MVC-的区别"><a href="#MVVM-和-MVC-的区别" class="headerlink" title="MVVM 和 MVC 的区别"></a>MVVM 和 MVC 的区别</h3><h4 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h4><ul><li>Model 代表数据模型，数据和业务逻辑都在 Model 层中定义；</li><li>View 代表 UI 视图，负责数据的展示；</li><li>ViewModel 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作；</li></ul><p>ViewModel 通过双向数据绑定连接 view 和 model，view 和 model 间的同步工作是自动的，无需手动操作 DOM</p><h4 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h4><ul><li>Model 代表数据模型，数据和业务逻辑都在 Model 层中定义，Model 发生的变化会通知到 View 层；</li><li>View 代表 UI 视图，负责数据的展示；</li><li>Controller 主要负责用户与应用的响应操作，用户与页面产生交互的时候，Controller 中的事件触发器会调用合适的 model 处理问题；</li></ul><h3 id="双向绑定-x2F-响应式原理"><a href="#双向绑定-x2F-响应式原理" class="headerlink" title="双向绑定&#x2F;响应式原理"></a>双向绑定&#x2F;响应式原理</h3><h4 id="Vue-2"><a href="#Vue-2" class="headerlink" title="Vue 2"></a>Vue 2</h4><p>Object.defineProperty 劫持数据，添加 setter&#x2F;getter 属性监听数据变化情况，发消息给订阅者触发监听回调</p><ol><li>实现一个监听器 observer：遍历对象属性，添加 setter&#x2F;getter，数据改变时可通过 setter 听到变化</li><li>实现一个编译器 compiler：编译模版，将模版的变量替换为数据，指令节点绑定更新函数</li><li>实现一个订阅者 watcher：连接 observer 和 compiler 桥梁，订阅 observer 属性变化消息，接收变化时触发 compiler 更新函数</li><li>实现一个订阅器 dep：订阅发布管理模式，统一管理 watcher 和 observer</li></ol><h5 id="为什么-defineProperty-不可以监听数组下标的变化-为什么实际应用中还可以监听到数组的增删？"><a href="#为什么-defineProperty-不可以监听数组下标的变化-为什么实际应用中还可以监听到数组的增删？" class="headerlink" title="为什么 defineProperty 不可以监听数组下标的变化 为什么实际应用中还可以监听到数组的增删？"></a>为什么 defineProperty 不可以监听数组下标的变化 为什么实际应用中还可以监听到数组的增删？</h5><p>Object.defineProperty 不能直接监听数组下标的变化是因为在 JavaScript 中，对数组的下标赋值操作（如 arr[0] &#x3D; 1）实际上是通过修改数组对象的内部属性（如 length 等）来实现的，而不是通过属性访问器（getter 和 setter）的方式。</p><p>然而，在实际应用中可以通过重写数组的 push、pop、shift、unshift、splice 等方法来实现对数组增删操作的监听。</p><h4 id="Vue-3"><a href="#Vue-3" class="headerlink" title="Vue 3"></a>Vue 3</h4><p>Proxy 可以代理整个对象进行读取、设置、删除属性。通过依赖收集（Dependency Collection）和触发更新（Trigger Update）来实现数据的自动同步：当一个响应式数据被读取时，Vue 3 会收集当前的依赖（即正在执行的副作用函数）；当响应式数据被修改时，Vue 3 会触发所有收集到的依赖，从而更新视图。</p><h3 id="Vue-diff-算法"><a href="#Vue-diff-算法" class="headerlink" title="Vue diff 算法"></a>Vue diff 算法</h3><ol><li>新旧 vnode 对比是不是同类型标签，不是同类型直接替换</li><li>如果是同类型标签，执行特有的 patchVnode 方法，判断新旧 vnode 是否相等。如果相等，直接返回。</li><li>新旧 vnode 不相等，需要比对新旧节点，比对原则是以新节点为主进行更新</li></ol><h4 id="vue-2-x-双端-diff"><a href="#vue-2-x-双端-diff" class="headerlink" title="vue 2.x - 双端 diff"></a>vue 2.x - 双端 diff</h4><p>双端 diff 算法是头尾指针向中间移动，分别判断头尾节点是否可以复用，如果没有找到可复用的节点再去遍历查找对应节点的下标，然后移动。全部处理完之后也要对剩下的节点进行批量的新增和删除。</p><h4 id="vue-3-最长递增子序列、静态标记"><a href="#vue-3-最长递增子序列、静态标记" class="headerlink" title="vue 3 - 最长递增子序列、静态标记"></a>vue 3 - 最长递增子序列、静态标记</h4><p>Vue 3 中对没有 key 的列表元素采用最长递增子序列算法（LIS），用最少的移动操作来保持节点顺序，尤其在长列表渲染中性能提升显著。<br>Vue 3 在编译阶段对静态节点打上标记，从而在更新时能够快速跳过静态内容，仅更新动态部分。</p><h3 id="Vue-属性"><a href="#Vue-属性" class="headerlink" title="Vue 属性"></a>Vue 属性</h3><h4 id="data-为什么是一个函数而不是对象"><a href="#data-为什么是一个函数而不是对象" class="headerlink" title="data 为什么是一个函数而不是对象"></a>data 为什么是一个函数而不是对象</h4><p>如果 data 是对象，当组件复用时，由于多个实例引用同一个对象，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。</p><h4 id="vue-为什么-this-foo-可以访问-this-data-foo"><a href="#vue-为什么-this-foo-可以访问-this-data-foo" class="headerlink" title="vue 为什么 this.foo 可以访问 this.data.foo"></a>vue 为什么 this.foo 可以访问 this.data.foo</h4><p>Vue 在初始化组件时，会对 data 中的属性进行代理。Vue 使用 Object.defineProperty（Vue 2）或 Proxy（Vue 3） 将 data 中的每个属性代理到组件实例上</p><h4 id="computed-和-watch-区别"><a href="#computed-和-watch-区别" class="headerlink" title="computed 和 watch 区别"></a>computed 和 watch 区别</h4><p><strong>computed</strong></p><ol><li>支持缓存</li><li>不支持异步</li><li>如果 computed 属性的属性值是函数，那么默认使用 get 方法，函数的返回值就是属性的属性值；在 computed 中，属性有一个 get 方法和一个 set 方法，当数据被赋值时，会调用 set 方法。</li><li>第一次加载时会监听</li><li>computed 属性函数需要 return</li></ol><p><strong>watch</strong></p><ol><li>不支持缓存</li><li>支持异步</li><li>监听数据必须是 data 中声明的或者父组件传递过来的 props 中的数据</li><li>第一次加载时默认不监听，除非 immediate 为 true</li><li>watch 属性函数不需要 return</li></ol><h3 id="Vue-模版指令"><a href="#Vue-模版指令" class="headerlink" title="Vue 模版指令"></a>Vue 模版指令</h3><h4 id="v-show-和-v-if-区别"><a href="#v-show-和-v-if-区别" class="headerlink" title="v-show 和 v-if 区别"></a>v-show 和 v-if 区别</h4><p>v-show 只是在 display: none 和 display: block 之间切换。DOM 一直存在<br>v-if 的话就得说到 Vue 底层的编译了。当属性初始为 false 时，组件就不会被渲染，直到条件为 true，并且切换条件时会触发销毁&#x2F;挂载组件</p><h4 id="v-if-和-v-for-共用时控制台报错"><a href="#v-if-和-v-for-共用时控制台报错" class="headerlink" title="v-if 和 v-for 共用时控制台报错"></a>v-if 和 v-for 共用时控制台报错</h4><p>Vue 3 里当它们同时存在于一个节点上时，v-if 比 v-for 的优先级更高。这意味着 v-if 的条件将无法访问到 v-for 作用域内定义的变量别名<br>正确写法：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;todo in todos&quot;</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;!todo.isComplete&quot;</span>&gt;</span></span><br><span class="language-xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">todo.name</span> &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="Vue3-0-新特性"><a href="#Vue3-0-新特性" class="headerlink" title="Vue3.0 新特性"></a>Vue3.0 新特性</h3><h4 id="Proxy-替代-Object-defineProperty"><a href="#Proxy-替代-Object-defineProperty" class="headerlink" title="Proxy 替代 Object.defineProperty"></a>Proxy 替代 Object.defineProperty</h4><h5 id="Proxy-特点"><a href="#Proxy-特点" class="headerlink" title="Proxy 特点"></a>Proxy 特点</h5><ol><li>可以直接监听整个对象而非属性；</li><li>Proxy 可以直接监听数组的变化；</li><li>Proxy 与 Object.defineProperty 相比有更多拦截方法；</li><li>Proxy 返回的是一个新对象，可以只操作新的对象达到目的，而 Object.defineProperty 只能遍历对象属性直接修改;</li></ol><h5 id="Object-defineProperty-特点"><a href="#Object-defineProperty-特点" class="headerlink" title="Object.defineProperty 特点"></a>Object.defineProperty 特点</h5><ol><li>Object.defineProperty 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历</li><li>Object.defineProperty 也不能对 es6 新产生的 Map,Set 这些数据结构做出监听，不能监听数组和对象</li><li>Object.defineProperty 不能监听新增和删除操作</li></ol><h4 id="组合式-API"><a href="#组合式-API" class="headerlink" title="组合式 API"></a>组合式 API</h4><p>Vue 之前的风格可以说属于选项式 API，用包含多个选项的对象来描述组件的逻辑，例如 data、methods 和 mounted。组合式 API 是写在标签<code>&lt;script setup&gt;</code>的内部的，风格接近 react 钩子函数</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>1）生命周期钩子只有 onBeforeMount、onMounted、onBeforeUpdate、onUpdated、onBeforeUnmount 和 onUnmounted，不存在跟 beforeCreate 和 created 生命周期相关的钩子<br>2）父子组件之间的数据交互依赖于函数 defineProps 和 defineEmits、defineExpose<br>3）不会使用 this（因为不存在组件实例了）<br>4）需要使用 ref 或者 reactive 创建响应式数据</p><h5 id="与选项式相比优点"><a href="#与选项式相比优点" class="headerlink" title="与选项式相比优点"></a>与选项式相比优点</h5><ol><li>逻辑复用性好：通过 setup 函数将逻辑模块化，并可直接使用函数导入和返回数据。</li><li>逻辑聚合性好：可以将与业务功能相关的逻辑组织在一起，提高了代码的可读性和可维护性。</li></ol><h5 id="ref-和-reactive-区别"><a href="#ref-和-reactive-区别" class="headerlink" title="ref 和 reactive 区别"></a>ref 和 reactive 区别</h5><p><strong>ref</strong>：通常用来定义常用的基础类型(String,Number,Boolean 等等)，ref 函数包裹的数据需要用.value 来查询<br><strong>reactive</strong>：通常用来定义对象</p><h4 id="支持-TypeScript"><a href="#支持-TypeScript" class="headerlink" title="支持 TypeScript"></a>支持 TypeScript</h4><p>Vue 3.0 是用 TypeScript 编写的，因此支持 TypeScript。<br>在单文件组件中使用 TypeScript，需要在 <code>&lt;script&gt;</code> 标签上加上 lang&#x3D;”ts” 的 attribute。<br><strong>类型推断对比</strong></p><table style="text-align:center;">    <tr>       <th></th>        <th>组合式API</th>      <th>选项式API</th>   </tr>   <tr>       <td>props类型推导</td>           <td>defineProps</td>           <td>defineComponent</td>   </tr>   <tr>       <td>emits类型推导</td>           <td>defineEmits</td>           <td>defineComponent</td>   </tr>   <tr>       <td>计算属性类型推导</td>           <td>泛型参数显式指定computed()类型</td>           <td>显式地标记出计算属性的类型</td>   </tr>   <tr>       <td>事件处理函数类型推导</td>           <td colspan="2">显式地强制转换 event 上的属性(例：event.target as HTMLInputElement）</td>   </tr>   <tr>       <td>ref类型推导</td>           <td>Ref传入泛型参数;ref初始化时也会推导类型</td>           <td rowspan="2">无</td>   </tr>    <tr>       <td>reactive类型推导</td>           <td>interface定义</td>   </tr></table><h4 id="新内置组件-Suspense、Teleport"><a href="#新内置组件-Suspense、Teleport" class="headerlink" title="新内置组件 Suspense、Teleport"></a>新内置组件 Suspense、Teleport</h4><ul><li><p><strong>Suspense</strong>：组件有两个插槽：#default 和 #fallback。两个插槽都只允许一个直接子节点。初始渲染时渲染默认的插槽内容。如果遇到异步依赖，则会进入挂起状态。在挂起状态期间，展示的是后备内容。当所有遇到的异步依赖都完成后，将展示出默认插槽的内容。</p></li><li><p><strong>Teleport</strong>：接收一个 to 的属性来指定传送的目标。to 的值可以是 CSS 选择器字符串，也可以是一个 DOM 元素对象。被 Teleport 标签包裹的模块将置于 to 指定的 DOM 之下。适用于子组件调用公共组件如全局提示框的场景</p></li></ul><h2 id="Vue-生命周期（Vue3-0-版本）"><a href="#Vue-生命周期（Vue3-0-版本）" class="headerlink" title="Vue 生命周期（Vue3.0 版本）"></a>Vue 生命周期（Vue3.0 版本）</h2><p><img src="/unknown404.github.io/img/life-cycle.png"></p><h3 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h3><p>实例初始化完成、props 解析之后、data() 和 computed 等选项处理之前立即调用。</p><h3 id="created"><a href="#created" class="headerlink" title="created"></a>created</h3><p>data、computed、method、watch 已经设置完成。跟 DOM 操作相关的属性方法仍不可使用。</p><h3 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h3><p>即将首次执行 DOM 渲染过程。</p><p>服务器渲染流程不包括该生命周期。</p><h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h3><p>组件挂载完之后调用。挂载完成的定义为：所有同步子组件都已经被挂载且其自身的 DOM 树已经创建完成并插入了父容器中。<br>该生命周期通常用于执行需要访问组件所渲染的 DOM 树相关的副作用。</p><p>服务器渲染流程不包括该生命周期。</p><h3 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h3><p>响应式数据更新时调用，可以用来在 Vue 更新 DOM 之前访问 DOM 状态。</p><p>服务器渲染流程不包括该生命周期。</p><h3 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h3><p>调用时，组件 DOM 已经更新，所以可以执行依赖于 DOM 的操作。</p><p>服务器渲染流程不包括该生命周期。</p><h3 id="beforeUnmount"><a href="#beforeUnmount" class="headerlink" title="beforeUnmount"></a>beforeUnmount</h3><p>一个组件实例被卸载之前调用。当这个钩子被调用时，组件实例依然还保有全部的功能。</p><p>服务器渲染流程不包括该生命周期。</p><h3 id="unmounted"><a href="#unmounted" class="headerlink" title="unmounted"></a>unmounted</h3><p>一个组件实例被卸载之后调用。可以在这个钩子中手动清理一些副作用，例如计时器、DOM 事件监听器或者与服务器的连接。</p><p>服务器渲染流程不包括该生命周期。<br><strong>备注</strong>：<br>Vue2 的生命周期钩子除了最后两个的名称是 beforeDestroy 和 destroyed，其他都一样</p><h3 id="KeepAlive-组件生命周期"><a href="#KeepAlive-组件生命周期" class="headerlink" title="KeepAlive 组件生命周期"></a>KeepAlive 组件生命周期</h3><h4 id="KeepAlive-组件简介"><a href="#KeepAlive-组件简介" class="headerlink" title="KeepAlive 组件简介"></a>KeepAlive 组件简介</h4><p>vue 的内置组件，它的功能是在多个组件间动态切换时缓存被移除的组件实例。</p><h4 id="activated"><a href="#activated" class="headerlink" title="activated"></a>activated</h4><p>在首次挂载、以及每次从缓存中被重新插入的时候调用</p><h4 id="deactivated"><a href="#deactivated" class="headerlink" title="deactivated"></a>deactivated</h4><p>在从 DOM 上移除、进入缓存以及组件卸载时调用</p><h3 id="适合做异步请求的生命周期"><a href="#适合做异步请求的生命周期" class="headerlink" title="适合做异步请求的生命周期"></a>适合做异步请求的生命周期</h3><p>created、beforeMount、mounted 都可以做异步请求，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。<br>考虑到服务端渲染不包括周期 beforeMount、mounted，异步请求放在 created 一致性更好；另一方面 created 调用异步数据相比其他周期调用页面加载时间会缩短。</p><h3 id="父子组件嵌套时，父组件和子组件生命周期钩子执行顺序"><a href="#父子组件嵌套时，父组件和子组件生命周期钩子执行顺序" class="headerlink" title="父子组件嵌套时，父组件和子组件生命周期钩子执行顺序"></a>父子组件嵌套时，父组件和子组件生命周期钩子执行顺序</h3><ul><li><strong>加载渲染过程</strong> 父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</li><li><strong>子组件更新过程</strong> 父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</li><li><strong>父组件更新过程</strong> 父 beforeUpdate -&gt; 父 updated</li><li><strong>销毁过程</strong> 父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</li></ul><h2 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h2><h3 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h3><p><strong>1）props</strong><br>通过 props 传递数据给子组件<br><strong>2）emit</strong><br>父组件可以通过 v-on 或 @ 来选择性地监听子组件上抛的事件，如示例中自定义的事件 increaseBy；该属性的处理函数可以写在父组件的 method 里<br>子组件调用内置的 $emit 方法，通过传入事件名称来抛出一个事件；也可以通过设置 emits 属性实现</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 父组件</span><br>&lt;MyButton <span class="hljs-meta">@increase</span>-<span class="hljs-keyword">by</span>=<span class="hljs-string">&quot;(n) =&gt; count += n&quot;</span> /&gt;<br><br><span class="hljs-comment">// 子组件</span><br>&lt;button <span class="hljs-meta">@click</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$emit</span>(&#x27;increaseBy&#x27;, 1)&quot;</span>&gt;<br>  Increase <span class="hljs-keyword">by</span> <span class="hljs-number">1</span><br>&lt;/button&gt;<br></code></pre></td></tr></table></figure><p><strong>3）v-model</strong><br>v-model 用于实现表单组件及自定义组件的数据绑定。<br>当 v-model 指令用于自定义的组件时，Vue3 等效于如下写法：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir">&lt;CustomInput<br>  <span class="hljs-symbol">:modelValue=<span class="hljs-string">&quot;searchText&quot;</span></span><br>  <span class="hljs-variable">@update</span><span class="hljs-symbol">:modelValue=<span class="hljs-string">&quot;newValue =&gt; searchText = newValue&quot;</span></span><br>/&gt;<br></code></pre></td></tr></table></figure><p>如果要实现和原生元素 input 一样的绑定效果，自定义组件 CustomInput 内部需要做如下操作：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- CustomInput.vue --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;modelValue&#x27;</span>],</span><br><span class="language-javascript">  <span class="hljs-attr">emits</span>: [<span class="hljs-string">&#x27;update:modelValue&#x27;</span>]</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;modelValue&quot;</span></span><br><span class="hljs-tag">    @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;</span></span><br><span class="hljs-tag">  /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>子组件中通过将属性 modelValue 和原生元素 input 的 value 绑定，当 input 的值变化时通过 emit 向上传递变化的值</p><p><strong>扩展</strong>：和 Vue2 的 v-model 不同之处</p><ol><li><p>默认 Prop 和 Event 名称<br>Vue 2：v-model 默认使用 value 作为 prop，input 作为事件。<br>Vue 3：v-model 默认使用 modelValue 作为 prop，update:modelValue 作为事件。</p></li><li><p>支持多个 v-model 绑定<br>Vue 2：每个组件只支持一个 v-model 绑定。<br>Vue 3：支持多个 v-model 绑定，这在处理多个状态时特别有用。</p></li></ol><p><strong>4）ref</strong><br>使用选项式 API 时，可以通过 this.$refs.name 的方式获取指定元素或者组件</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs perl">// 父组件<br><br>&lt;template&gt;<br>&lt;child <span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;childNode&quot;</span>&gt;&lt;<span class="hljs-regexp">/child&gt;</span><br><span class="hljs-regexp">&lt;/</span>template&gt;<br>&lt;script&gt;<br>export default&#123;<br>  data()&#123;&#125;,<br>  methods:&#123;<br>    test()&#123;<br>      this.$refs.childNode.childMethod()<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;<span class="hljs-regexp">/script&gt;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><br><br>// 子组件(child)<br><br>&lt;script&gt;<br>export default&#123;<br>  data()&#123;&#125;,<br>  methods:&#123;<br>    childMethod()&#123;<br>      console.log(<span class="hljs-string">&#x27;test&#x27;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>使用组合式 api 时，需要注意<code>&lt;script setup&gt;</code> 语法糖的组件是默认关闭的，也即通过模板 ref 或者 $parent 链获取到的组件的公开实例，不会暴露任何在 <code>&lt;script setup&gt;</code> 中声明的绑定<br>对于该问题的解决方式是子组件使用 defineExpose 明确暴露的属性。如下示例所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- ChildComponent.vue --&gt;<br>&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;p&gt;Child Component&lt;/p&gt;<br>    &lt;p&gt;Count: &#123;&#123; count &#125;&#125;&lt;/p&gt;<br>    &lt;button @click=&quot;increment&quot;&gt;Increment&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; ref, defineExpose &#125; from &quot;vue&quot;;<br><br>export default &#123;<br>  setup() &#123;<br>    const count = ref(0);<br><br>    const increment = () =&gt; &#123;<br>      count.value++;<br>    &#125;;<br><br>    // 使用 defineExpose 暴露属性给父组件<br>    defineExpose(&#123;<br>      count,<br>      increment,<br>    &#125;);<br><br>    return &#123;<br>      count,<br>      increment,<br>    &#125;;<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br><br>&lt;!-- ParentComponent.vue --&gt;<br><br>&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;p&gt;Parent Component&lt;/p&gt;<br>    &lt;p&gt;Count from Child: &#123;&#123; childCount &#125;&#125;&lt;/p&gt;<br>    &lt;ChildComponent ref=&quot;childRef&quot; /&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>import &#123; ref &#125; from &quot;vue&quot;;<br>import ChildComponent from &quot;./ChildComponent.vue&quot;;<br>export default &#123;<br>  setup() &#123;<br>    const childRef = ref();<br>    const childCount = childRef.value.count;<br>    return &#123;<br>      childCount,<br>    &#125;;<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>5) $attrs</strong><br>子组件的$attrs 对象包含了除组件所声明的 props 和 emits 之外的所有其他 attribute，例如 class，style，v-on 监听器等等。子组件可以利用<code>v-bind=&quot;$attrs&quot;</code>将属性传到目标元素上。<br>vue2 中$listeners包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。而在vue3，$listeners 被移除了</p><h3 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h3><h4 id="parent"><a href="#parent" class="headerlink" title="$parent"></a>$parent</h4><p><code>$parent</code> 可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法）<br>可以通过共同的父组件来管理状态和事件函数。比如说其中一个兄弟组件调用父组件传递过来的事件函数修改父组件中的状态，然后父组件将状态传递给另一个兄弟组件。</p><h4 id="eventBus"><a href="#eventBus" class="headerlink" title="eventBus"></a>eventBus</h4><p>Vue3 中移除了事件总线，但是可以借助于第三方工具来完成，Vue 官方推荐 mitt 或 tiny-emitter；<br>但基本的使用方法保持不变，组件 1 使用 emit 函数发送事件名和参数，组件 2 使用 on 函数监听对应的事件名，执行处理函数</p><h3 id="跨多层次组件通信"><a href="#跨多层次组件通信" class="headerlink" title="跨多层次组件通信"></a>跨多层次组件通信</h3><h4 id="provide、inject"><a href="#provide、inject" class="headerlink" title="provide、inject"></a>provide、inject</h4><p>祖先组件：使用 provide 属性或方法，指定想要提供给后代组件的数据或方法<br>后代组件：使用 inject 获取祖先组件的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs vue">// 祖先组件<br><br>&lt;script setup&gt;<br>import &#123; ref, provide &#125; from &quot;vue&quot;;<br>import &#123; fooSymbol &#125; from &quot;./injectionSymbols&quot;;<br><br>// 提供静态值<br>provide(&quot;foo&quot;, &quot;bar&quot;);<br><br>// 提供响应式的值<br>const count = ref(0);<br>provide(&quot;count&quot;, count);<br><br>// 提供时将 Symbol 作为 key<br>provide(fooSymbol, count);<br>&lt;/script&gt;<br>///////////////////////////////////////////////// // 后代组件<br><br>&lt;script setup&gt;<br>import &#123; inject &#125; from &quot;vue&quot;;<br>import &#123; fooSymbol &#125; from &quot;./injectionSymbols&quot;;<br><br>// 注入值的默认方式<br>const foo = inject(&quot;foo&quot;);<br><br>// 注入响应式的值<br>const count = inject(&quot;count&quot;);<br><br>// 通过 Symbol 类型的 key 注入<br>const foo2 = inject(fooSymbol);<br><br>// 注入一个值，若为空则使用提供的默认值<br>const bar = inject(&quot;foo&quot;, &quot;default value&quot;);<br><br>// 注入时为了表明提供的默认值是个函数，需要传入第三个参数<br>const fn = inject(&quot;function&quot;, () =&gt; &#123;&#125;, false);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="Vue-生态"><a href="#Vue-生态" class="headerlink" title="Vue 生态"></a>Vue 生态</h2><h3 id="单页面应用（SPA）"><a href="#单页面应用（SPA）" class="headerlink" title="单页面应用（SPA）"></a>单页面应用（SPA）</h3><p>使用 vue 全家桶构建的项目一般就属于单页面应用项目。其特点为：初始加载时只加载一个 HTML 页面，后续的导航通过 JavaScript 动态地更新页面内容</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>用户体验：加载初始页面后，页面导航可以在不刷新页面的情况下加载和渲染新内容。</li><li>前后端分离：独立部署，利于开发。</li><li>负载较低：只有初始页面加载时需要从服务器获取 HTML、CSS 和 JavaScript 文件，减轻了服务器的负载。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>首次加载时间：SPA 首次加载时需要下载较大的 JavaScript 文件，这可能导致初始加载时间较长。</li><li>SEO（搜索引擎优化）问题：由于 SPA 的内容是通过 JavaScript 动态生成的，搜索引擎的爬虫可能无法正确地获取和索引页面的内容</li></ul><h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><h4 id="前端路由和后端路由区别"><a href="#前端路由和后端路由区别" class="headerlink" title="前端路由和后端路由区别"></a>前端路由和后端路由区别</h4><p>前端路由：页面跳转的 URL 规则匹配由前端来控制，把渲染的任务交给了浏览器，通过客户端的算力来解决页面的构建<br>后端路由：浏览器地址输入栏输入 URL 回车时后端根据路径将对应的 html 模版渲染好返回给前端</p><h4 id="直接使用-a-链接与使用-router-link-的区别"><a href="#直接使用-a-链接与使用-router-link-的区别" class="headerlink" title="直接使用 a 链接与使用 router-link 的区别"></a>直接使用 a 链接与使用 router-link 的区别</h4><p>抹平了两种模式下 href 的书写方式，会得到正确的 href 值；history 模式下调用 pushState 并阻止默认行为。</p><h4 id="hash-模式和-history-模式区别"><a href="#hash-模式和-history-模式区别" class="headerlink" title="hash 模式和 history 模式区别"></a>hash 模式和 history 模式区别</h4><h5 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a>hash 模式</h5><p>开发中默认的模式，它的 URL 带着一个#。<br>特点：hash 值会出现在 URL 里面，但是不会出现在 HTTP 请求中，对后端完全没有影响。所以改变 hash 值，不会重新加载页面。<br>原理： hash 模式的主要原理就是监听 onhashchange()事件</p><h5 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a>history 模式</h5><p>传统的路由分发模式，即用户在输入一个 URL 时，服务器会接收这个请求，并解析这个 URL，然后做出相应的逻辑处理。URL 不会带#。<br>特点：history 模式下的某些路径如果后台没有配置，URL 输入访问时会返回 404。解决方法为需要在服务器上添加一个简单的回退路由。<br>原理：通过按钮进行的路由跳转用 pushState、replaceState 来改变路由但不触发后端请求，再用回调函数调用新页面组件；点击浏览器前进后退按钮时监听 popstate 事件进行页面切换</p><h4 id="route-和-router-的区别"><a href="#route-和-router-的区别" class="headerlink" title="$route 和$router 的区别"></a>$route 和$router 的区别</h4><p>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数<br>$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</p><h4 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h4><h5 id="全局路由钩子"><a href="#全局路由钩子" class="headerlink" title="全局路由钩子"></a>全局路由钩子</h5><p><strong>beforeEach</strong><br>触发时机：进入路由之前<br>应用：登录态判断跳转<br><strong>beforeResolve</strong><br>触发时机：进入路由之前、可以访问 route 配置中自定义的 meta 变量。在 beforeRouteEnter 之后<br>应用：页面访问权限判断跳转<br><strong>afterEach</strong><br>触发时机：进入路由之后<br>应用：跳转之后滚动条回到顶部</p><h5 id="单个路由钩子"><a href="#单个路由钩子" class="headerlink" title="单个路由钩子"></a>单个路由钩子</h5><p><strong>beforeEnter</strong><br>在路由配置文件中使用，beforeEnter 属性可传入函数数组<br>触发时机：只在进入路由时触发，不会在 params、query 或 hash 改变时触发。<br>应用：为不同的路由配置重定向逻辑</p><h5 id="路由组件内钩子"><a href="#路由组件内钩子" class="headerlink" title="路由组件内钩子"></a>路由组件内钩子</h5><p><strong>beforeRouteEnter</strong><br>触发时机 ∶ 进入组件前触发，此时组件未创建，不能用 this<br><strong>beforeRouteUpdate</strong><br>触发时机 ∶ 当前地址改变并且改组件被复用时触发，举例来说，带有动态参数的路径 foo&#x2F;∶id，在 &#x2F;foo&#x2F;1 和 &#x2F;foo&#x2F;2 之间跳转的时候，由于会渲染同样的 foo 组件，这个钩子在这种情况下就会被调用。发生在 beforeEnter 前<br><strong>beforeRouteLeave</strong><br>触发时机 ∶ 离开组件被调用<br>应用：离开页面前弹出提示语</p><h5 id="路由钩子执行生命周期的顺序"><a href="#路由钩子执行生命周期的顺序" class="headerlink" title="路由钩子执行生命周期的顺序"></a>路由钩子执行生命周期的顺序</h5><ol><li>导航被触发。</li><li>在失活的组件里调用 beforeRouteLeave 守卫。</li><li>调用全局的 beforeEach 守卫。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。</li><li>在路由配置里调用 beforeEnter。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫(2.5+)。</li><li>导航被确认。</li><li>调用全局的 afterEach 钩子。</li><li>触发 DOM 更新。</li><li>调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ol><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><p>为 Vue.js 应用程序开发的状态管理模式。</p><h4 id="vuex-属性"><a href="#vuex-属性" class="headerlink" title="vuex 属性"></a>vuex 属性</h4><ul><li>state：数据源存放地</li><li>getters：从基本数据 state 派生出来的数据，store 的计算属性</li><li>mutations：同步提交更改数据的方法(目的：方便调试)</li><li>actions：异步调用 mutation 方法</li><li>module：模块化 vuex</li></ul><h4 id="vuex-vs-localStorage"><a href="#vuex-vs-localStorage" class="headerlink" title="vuex vs localStorage"></a>vuex vs localStorage</h4><ol><li>存储位置：vuex 存储在内存，localStorage 则以文件的方式存储在本地</li><li>存储内容：localStorage 只能存储字符串类型的数据</li><li>持久性：刷新或关闭页面时 vuex 存储的值会丢失，localstorage 不会</li></ol><h3 id="pinia"><a href="#pinia" class="headerlink" title="pinia"></a>pinia</h3><p>全新的 Vue 状态管理库，vuex 的代替者。</p><h4 id="pinia-特点"><a href="#pinia-特点" class="headerlink" title="pinia 特点"></a>pinia 特点</h4><ol><li>Vue2 和 Vue3 都能支持</li><li>抛弃传统的 mutation ，只有 state, getter 和 action ，简化状态管理库</li><li>不需要嵌套模块，符合 Vue3 的 Composition api，让代码扁平化</li><li>TypeScript 支持</li></ol><h4 id="pinia-数据修改"><a href="#pinia-数据修改" class="headerlink" title="pinia 数据修改"></a>pinia 数据修改</h4><p><strong>简单数据修改</strong>：直接操作 <code>store.属性名</code>进行修改<br><strong>多条数据修改</strong>：</p><ol><li>使用$patch 方法。patch 接受对象和函数作为入参。在涉及集合的修改(例如，从数组中推送、移除、拼接一个元素)的操作，使用对象的语法更加耗时，官方文档推荐使用函数。代码示例：</li></ol><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">store</span>.$patch(&#123;<br>  var<span class="hljs-number">1</span>:<span class="hljs-keyword">store</span>.var<span class="hljs-number">1</span>++<span class="hljs-punctuation">,</span><br>  var<span class="hljs-number">2</span>:<span class="hljs-keyword">store</span>.var<span class="hljs-number">2</span>++<br>&#125;)<br><span class="hljs-keyword">store</span>.$patch((<span class="hljs-keyword">store</span>)<span class="hljs-operator">=</span>&gt;&#123;<br>  var<span class="hljs-number">1</span>:<span class="hljs-keyword">store</span>.var<span class="hljs-number">1</span>++<span class="hljs-punctuation">,</span><br>  var<span class="hljs-number">2</span>:<span class="hljs-keyword">store</span>.var<span class="hljs-number">2</span>++<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="2"><li>使用 store 的 action 方法</li></ol><h2 id="Vue-项目开发注意事项"><a href="#Vue-项目开发注意事项" class="headerlink" title="Vue 项目开发注意事项"></a>Vue 项目开发注意事项</h2><h3 id="assets-和-static-的区别"><a href="#assets-和-static-的区别" class="headerlink" title="assets 和 static 的区别"></a>assets 和 static 的区别</h3><p>相同点：都是存放静态资源文件。<br>不同点：assets 中存放的静态资源文件在项目打包时会进行压缩体积，代码格式化操作。static 文件夹下的文件则不会。</p><h3 id="Class-与-Style-如何动态绑定"><a href="#Class-与-Style-如何动态绑定" class="headerlink" title="Class 与 Style 如何动态绑定"></a>Class 与 Style 如何动态绑定</h3><p>使用对象语法或数组语法进行绑定。这里以 class 为例，style 类似</p><ul><li>对象语法</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> v-bind:<span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br><br>data: &#123;<br>  isActive: <span class="hljs-literal">true</span>,<br>  hasError: <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>数组语法</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;div v-bind:<span class="hljs-keyword">class</span>=&quot;[<span class="hljs-symbol">isActive</span> ? <span class="hljs-symbol">activeClass</span> : &#x27;&#x27;, <span class="hljs-symbol">errorClass</span>]&quot;&gt;&lt;/<span class="hljs-symbol">div</span>&gt;<br><br><span class="hljs-symbol">data: </span>&#123;<br>  activeClass: <span class="hljs-string">&#x27;active&#x27;</span>,<br>  errorClass: <span class="hljs-string">&#x27;text-danger&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Vue-的性能优化有哪些"><a href="#Vue-的性能优化有哪些" class="headerlink" title="Vue 的性能优化有哪些"></a>Vue 的性能优化有哪些</h2><h3 id="编码阶段"><a href="#编码阶段" class="headerlink" title="编码阶段"></a>编码阶段</h3><p>v-if 和 v-for 不一起使用<br>v-for 保证 key 的唯一性<br>使用 keep-alive 缓存组件<br>v-if 和 v-show 酌情使用<br>路由懒加载、异步组件<br>图片懒加载<br>节流防抖</p><h3 id="打包优化"><a href="#打包优化" class="headerlink" title="打包优化"></a>打包优化</h3><p>压缩代码<br>使用 CDN 加载第三方模块<br>抽离公共文件</p><h3 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h3><p>骨架屏<br>客户端缓存</p><h2 id="扩展：-Vue-和-React-对比"><a href="#扩展：-Vue-和-React-对比" class="headerlink" title="扩展： Vue 和 React 对比"></a>扩展： Vue 和 React 对比</h2><p>相同点：</p><ul><li>渐进式框架：以从一个小的功能或页面引入，而不需要全盘接管整个项目</li></ul><h3 id="Vue-和-React-区别"><a href="#Vue-和-React-区别" class="headerlink" title="Vue 和 React 区别"></a>Vue 和 React 区别</h3><ul><li>数据绑定：Vue 双向数据绑定，React 单向数据流</li><li>生命周期：Vue 提供完整的生命周期钩子（如 beforeCreate、created、beforeMount 等），React 函数式已没有生命周期，使用 useEffect 来处理生命周期需求。</li><li>响应式：Vue 使用 Proxy 或 Object.defineProperty 实现，React 不会直接追踪状态依赖变化，而是通过对组件的更新触发 re-render</li></ul><h3 id="Vue-和-React-diff-区别"><a href="#Vue-和-React-diff-区别" class="headerlink" title="Vue 和 React diff 区别"></a>Vue 和 React diff 区别</h3><p>相同点：</p><ul><li>使用 vdom</li><li>使用 key 标识列表节点优化渲染</li><li>大部分情况同层级节点比较</li></ul><p>不同点：</p><ul><li>Vue 在编译过程中对静态和动态节点的标记，在更新时，Vue 会跳过这些静态节点的比较；React 每次组件的状态更新时会重新渲染整个虚拟 DOM 树，并且重新比较每个节点</li><li>Vue 的 diff 优化从编译时就开始，而 React 在运行时开始</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/6964779204462247950/">「2021」高频前端面试题汇总之 Vue 篇（下）</a><br>（2）<a href="https://juejin.cn/post/7064368176846340132"> Vue 这一块拿捏了</a></p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES7装饰器语法</title>
    <link href="/unknown404.github.io/2022/09/02/decorator/"/>
    <url>/unknown404.github.io/2022/09/02/decorator/</url>
    
    <content type="html"><![CDATA[<p>装饰器是是一种与类（class）相关的语法，用来注释或修改类和类方法。装饰器在 Python 和 Java 等语言中也被大量使用。目前在前端框架 Nestjs 也已经有应用。因此本文主要记录装饰器相关的知识点，帮助理解 Nestjs 程序。</p><span id="more"></span><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>装饰器模式是一种结构型设计模式，它允许向一个现有的对象添加新的功能，同时又不改变其结构，是作为对现有类的一个包装。<br>装饰器是针对这种设计模式的一个语法糖。其用法是：使用 @ 作为标识符，紧跟返回装饰器函数的表达式，被放置在被装饰代码前面。<br>由于该语法目前还处于第 2 阶段提案中，使用它之前需要使用 Babel 模块编译成 ES5 或 ES6。</p><h2 id="装饰器用法"><a href="#装饰器用法" class="headerlink" title="装饰器用法"></a>装饰器用法</h2><p>装饰器主要用于:</p><ol><li>装饰类</li><li>装饰方法或属性</li></ol><h3 id="装饰类"><a href="#装饰类" class="headerlink" title="装饰类"></a>装饰类</h3><p>装饰类的时候，装饰器方法一般会接收一个目标类作为参数。</p><h4 id="babel-编译情况"><a href="#babel-编译情况" class="headerlink" title="babel 编译情况"></a>babel 编译情况</h4><p>编译前：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@annotation</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123; &#125;<br><br><span class="hljs-function">function <span class="hljs-title">annotation</span><span class="hljs-params">(<span class="hljs-keyword">target</span>)</span> </span>&#123;<br>   <span class="hljs-keyword">target</span>.annotated = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译后：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">var <span class="hljs-number">_</span><span class="hljs-keyword">class</span>;<br><br><span class="hljs-keyword">let</span> MyClass = <span class="hljs-keyword">annotation</span>(<span class="hljs-number">_</span><span class="hljs-keyword">class</span> = <span class="hljs-keyword">class</span> MyClass &#123;&#125;) || <span class="hljs-number">_</span><span class="hljs-keyword">class</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">annotation</span>(target) &#123;<br>  target.annotated = true;<br>&#125;<br></code></pre></td></tr></table></figure><p>从编译的结果可以看出类装饰器的第一个参数就是要装饰的类，它的功能就是对类进行处理。</p><h4 id="类装饰器的作用"><a href="#类装饰器的作用" class="headerlink" title="类装饰器的作用"></a>类装饰器的作用</h4><ol><li>给目标类增加静态属性</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> add<span class="hljs-constructor">Attribute(<span class="hljs-params">targetClass</span>)</span> &#123;<br>  targetClass.isUseDecorator = <span class="hljs-literal">true</span>;<br>&#125;<br><br>@addAttribute<br><span class="hljs-keyword">class</span> TargetClass &#123; &#125;<br><br>console.log(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TargetClass</span>.</span></span>isUseDecorator); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>在上面这个例子中，我们定义了 addAttribute 的装饰器，用于为 TargetClass 添加静态属性 isUseDecorator 并设置为 true。<br>另一方面，类装饰器可以使用表达式传入参数为静态属性赋值，利用装饰器工厂模式。如下面的代码：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">function</span> <span class="hljs-title function_">addAttribute</span>(<span class="hljs-params">content</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable">function</span> <span class="hljs-title function_">decFn</span>(<span class="hljs-params">targetClass</span>) &#123;<br>    <span class="hljs-variable">targetClass</span>.<span class="hljs-property">content</span> <span class="hljs-operator">=</span> <span class="hljs-variable">content</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable">targetClass</span>;<br>  &#125;;<br>&#125;<br><br>@<span class="hljs-title function_">addAttribute</span>(&#x27;这是内容～～～&#x27;)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TargetClass</span> &#123; &#125;<br><br><span class="hljs-variable">console</span>.<span class="hljs-property">log</span>(<span class="hljs-title class_">TargetClass</span>.<span class="hljs-property">content</span>); <span class="hljs-comment">// 这是内容～～～</span><br></code></pre></td></tr></table></figure><p>该示例就是为 TargetClass 添加静态属性 content 并用传入的参数‘这是内容～～～’为 content 赋值。这种使用方法更加灵活。</p><ol start="2"><li>添加原型方法<br>既然类装饰器接收的参数就是类定义本身，那么该装饰器也可以通过访问类的 prototype 属性来添加或修改原型方法</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">targetClass</span>) &#123;<br>  targetClass.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">decFun</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;这里是装饰器 decorator 添加的原型方法 decFun~&#x27;</span>);<br>  &#125;;<br>&#125;<br><br>@decorator<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TargetClass</span> &#123; &#125;<br><br><span class="hljs-keyword">const</span> targetClass = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TargetClass</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(targetClass);<br>targetClass.<span class="hljs-title function_">decFun</span>();<br></code></pre></td></tr></table></figure><h3 id="装饰方法和属性"><a href="#装饰方法和属性" class="headerlink" title="装饰方法和属性"></a>装饰方法和属性</h3><h4 id="预备知识：属性描述符"><a href="#预备知识：属性描述符" class="headerlink" title="预备知识：属性描述符"></a>预备知识：属性描述符</h4><p>属性描述符表达了一个属性的相关信息(元数据）,本质上是一个对象。属性主要分为两种：访问器属性和数据属性。</p><h5 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h5><p>特点：当给属性赋值或者取值的时候，会自动的运行一个函数。<br>具有描述符属性：configurable、enumerable、get、set</p><h5 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h5><p>特点：在我们使用对象的过程中，对一个对象进行取值和赋值的时候，该属性称之为 数据属性<br>具有描述符属性：configurable、enumerable、writable、value<br>如示例所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> o = &#123;&#125;;<br>o.a = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 等同于 :</span><br><span class="hljs-built_in">Object</span>.defineProperty(o, <span class="hljs-string">&quot;a&quot;</span>, &#123;<br>  value : <span class="hljs-number">1</span>,<br>  writable : <span class="hljs-keyword">true</span>,<br>  configurable : <span class="hljs-keyword">true</span>,<br>  enumerable : <span class="hljs-keyword">true</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>两种属性共有的属性为 configurable 和 enumerable。<br>configurable：是否可配置，默认为 false。为 true 时，表示当前属性的‘属性表述符’对象可以被更改，该属性可以使用 delete 删除<br>enumerable：是否可枚举，默认为 false。为 true 时，表示当前属性可以被枚举，也就是当前属性是否可以在 for…in 循环和 Object.keys() 中被遍历出来</p><p>(value 和 writable)与(get 和 set)是不共存的，只要定义了其中一个，就定下来了该描述符的性质是数据属性还是访问器属性。</p><h4 id="babel-编译情况-1"><a href="#babel-编译情况-1" class="headerlink" title="babel 编译情况"></a>babel 编译情况</h4><p>根据<a href="https://github.com/mqyqingfeng/Blog/issues/109">ES6 系列之我们来聊聊装饰器</a>,babel 编译后的方法装饰器可以分为 3 个处理步骤：</p><ol><li>拷贝需要装饰的属性其对应的属性描述符<br>使用 Object.getOwnPropertyDescriptor 可以获得指定属性的属性描述符。该函数接收两个参数：属性所在对象和要取得描述的属性。<br>其中 Babel 的 Class 为了与 decorator 配合而产生了一个属性 initializer</li><li>应用多个 decorators 方法：当同一个方法使用多个装饰器模型时，遵从洋葱模型，从外到内进入，然后由内向外执行</li></ol><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">decorator1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;decorator1&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">decFn1</span>(<span class="hljs-params">targetClass</span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;decFn1&#x27;</span>);<br>    <span class="hljs-keyword">return</span> targetClass;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">decorator2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;decorator2&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">decFn2</span>(<span class="hljs-params">targetClass</span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;decFn2&#x27;</span>);<br>    <span class="hljs-keyword">return</span> targetClass;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>假如存在装饰器 decorator1、decorator2，修饰同一个方法 targetFunc，其输出结果为：<code>decorator1-&gt;decorator2-&gt;decFn2-&gt;decFn1</code></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@decorator1</span>()<br><span class="hljs-variable">@decorator2</span>()<br>targetFunc()<br></code></pre></td></tr></table></figure><ol start="3"><li>处理需要装饰的属性或方法，属性描述符的调整最终还是由 Object.defineProperty 来实现</li></ol><h4 id="方法装饰器使用方法"><a href="#方法装饰器使用方法" class="headerlink" title="方法装饰器使用方法"></a>方法装饰器使用方法</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function">function <span class="hljs-title">readonly</span><span class="hljs-params">(<span class="hljs-keyword">target</span>, name, descriptor)</span> </span>&#123;<br>  descriptor.writable = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-keyword">return</span> descriptor;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-meta">@readonly</span><br>  name = <span class="hljs-string">&#x27;zhangsan&#x27;</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person();<br></code></pre></td></tr></table></figure><p>如示例所示，方法装饰器接收的入参同 Object.defineProperty 一致，包括：</p><ul><li>要定义属性的对象（obj）</li><li>要定义或修改的属性名或 Symbol（props）</li><li>要定义或修改的属性描述符（descriptor）</li></ul><h2 id="装饰器应用"><a href="#装饰器应用" class="headerlink" title="装饰器应用"></a>装饰器应用</h2><h3 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h3><p>使用高阶函数 connect 时，需要将代码写成以下格式：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyReactComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(<span class="hljs-type">MyReactComponent</span>);<br></code></pre></td></tr></table></figure><p>而使用装饰器后代码可简化为：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@connect</span>(mapStateToProps, mapDispatchToProps)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyReactComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;&#125;;<br></code></pre></td></tr></table></figure><p>语义也更加简洁明了</p><h3 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h3><p>在频繁触发事件的场景下，为了提升性能常会用防抖和节流函数，其特点是会返回一个匿名函数。为了能在组件销毁时能有效解绑事件，需要用变量将匿名函数存储起来。但使用装饰器语法后就不需要再设置多余的变量了。防抖装饰器的实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//防抖函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_debounce</span>(<span class="hljs-params">func, wait, immediate</span>) &#123;<br><br>    <span class="hljs-keyword">var</span> timeout;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> context = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-keyword">var</span> args = <span class="hljs-variable language_">arguments</span>;<br><br>        <span class="hljs-keyword">if</span> (timeout) <span class="hljs-built_in">clearTimeout</span>(timeout);<br>        <span class="hljs-keyword">if</span> (immediate) &#123;<br>            <span class="hljs-keyword">var</span> callNow = !timeout;<br>            timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>                timeout = <span class="hljs-literal">null</span>;<br>            &#125;, wait)<br>            <span class="hljs-keyword">if</span> (callNow) func.<span class="hljs-title function_">apply</span>(context, args)<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>                func.<span class="hljs-title function_">apply</span>(context, args)<br>            &#125;, wait);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//防抖装饰器</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">wait, immediate</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleDescriptor</span>(<span class="hljs-params">target, key, descriptor</span>) &#123;<br>    <span class="hljs-keyword">const</span> callback = descriptor.<span class="hljs-property">value</span>;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyntaxError</span>(<span class="hljs-string">&#x27;Only functions can be debounced&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> fn = <span class="hljs-title function_">_debounce</span>(callback, wait, immediate)<br><br>    <span class="hljs-keyword">return</span> &#123;<br>      ...descriptor,<br>      <span class="hljs-title function_">value</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">fn</span>()<br>      &#125;<br>    &#125;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在使用时只需要在目标函数上方添加@debounce，传入等待时间和是否立即响应的变量即可。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Toggle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br><br>  <span class="hljs-meta">@debounce</span>(<span class="hljs-number">500</span>, <span class="hljs-literal">true</span>)<br>  handleClick() &#123;<br>    console.log(&#x27;toggle&#x27;)<br>  &#125;<br><br>  render() &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;button onClick=&#123;<span class="hljs-keyword">this</span>.handleClick&#125;&gt;<br>        button<br>      &lt;/button&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>节流的实现也基本相似，这里不再列举。</p><h2 id="TypeScript-装饰器"><a href="#TypeScript-装饰器" class="headerlink" title="TypeScript 装饰器"></a>TypeScript 装饰器</h2><p>在 TypeScript 中，可以实现以下五种装饰器：类装饰器、方法装饰器、属性装饰器、访问器装饰器、参数装饰器</p><h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>格式：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs r"><span class="hljs-keyword">function</span> classDecorator<span class="hljs-operator">&lt;</span><span class="hljs-built_in">T</span> extends Constructor<span class="hljs-operator">&gt;</span><span class="hljs-punctuation">(</span>targetClass<span class="hljs-operator">:</span><span class="hljs-built_in">T</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">&#123;</span><br><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>入参：<br>targetClass - 类构造器</p><h3 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h3><p>格式：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-keyword">method</span><span class="hljs-constructor">Decorator(<span class="hljs-params">target</span>: Object, <span class="hljs-params">propertyName</span>: <span class="hljs-params">string</span>, <span class="hljs-params">propertyDescriptor</span>: PropertyDescriptor)</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>入参：<br>target - 如果是静态方法就是类的构造器（TargetClass），如果是实例方法就是类的原型（TargetClass.prototype）<br>propertyName - 函数名<br>propertyDescriptor - 函数的属性描述符</p><h3 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h3><p>格式：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> property<span class="hljs-constructor">Decorator(<span class="hljs-params">target</span>: Object, <span class="hljs-params">propertyName</span>: <span class="hljs-params">string</span>)</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>入参：<br>target - 如果是静态方法就是类的构造器（TargetClass），如果是实例方法就是类的原型（TargetClass.prototype）<br>propertyName - 属性名</p><h3 id="参数装饰器"><a href="#参数装饰器" class="headerlink" title="参数装饰器"></a>参数装饰器</h3><p>格式：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> parameter<span class="hljs-constructor">Decorator(<span class="hljs-params">target</span>: Object, <span class="hljs-params">propertyName</span>: <span class="hljs-params">string</span>, <span class="hljs-params">index</span>: <span class="hljs-params">number</span>)</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>入参：<br>target - 如果是静态方法就是类的构造器（TargetClass），如果是实例方法就是类的原型（TargetClass.prototype）<br>propertyName - 参数名<br>index - 参数在函数参数列表的位置</p><h3 id="访问器装饰器"><a href="#访问器装饰器" class="headerlink" title="访问器装饰器"></a>访问器装饰器</h3><p>格式：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> accessor<span class="hljs-constructor">Decorator(<span class="hljs-params">target</span>: Object, <span class="hljs-params">propertyName</span>: <span class="hljs-params">string</span>, <span class="hljs-params">propertyDescriptor</span>: PropertyDescriptor)</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>入参：<br>target - 如果是静态方法就是类的构造器（TargetClass），如果是实例方法就是类的原型（TargetClass.prototype）<br>propertyName - 属性名<br>propertyDescriptor - 函数的属性描述符</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://github.com/mqyqingfeng/Blog/issues/109">系列之我们来聊聊装饰器</a><br>（2）<a href="https://juejin.cn/post/7072883925764276254">Decorator 装饰器</a><br>（3）<a href="https://juejin.cn/post/6844904100144889864">都 2020 年了，你还不会 JavaScript 装饰器</a><br>（4）<a href="https://juejin.cn/post/6996590290555371534">TypeScript 装饰器的基本语法</a></p>]]></content>
    
    
    <categories>
      
      <category>前端技术体系</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6语法</title>
    <link href="/unknown404.github.io/2022/08/29/es6/"/>
    <url>/unknown404.github.io/2022/08/29/es6/</url>
    
    <content type="html"><![CDATA[<p>面试时常问的 ES6 特性</p><span id="more"></span><h2 id="let-const"><a href="#let-const" class="headerlink" title="let,const"></a>let,const</h2><p>创建块级作用域，若调用发生在声明前会暂时性死区<br>const 指向地址不能改变，但可以增加内部属性</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>特点：没有 this 和 arguments；不能作为构造函数；没有函数提升<br>与普通函数本质区别：主要在于 this 的绑定方式。普通函数的 this 指向在运行时动态确定，取决于调用方式，而箭头函数的 this 是在定义时从外层作用域继承而来，不会随着调用方式的改变而改变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br> <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tyler&#x27;</span>,<br> <span class="hljs-attr">a</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;Anderson&#x27;</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-title function_">test</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>  &#125;<br>  <span class="hljs-title function_">test</span>()<br> &#125;,<br>&#125;<br>obj.<span class="hljs-title function_">a</span>()<br><br><span class="hljs-comment">// Tyler</span><br><span class="hljs-comment">// 找到最近的非箭头函数a，所以箭头函数的this 就是a 的this。</span><br><span class="hljs-comment">// a目前是由obj调用的，因此此时箭头函数的this 为obj</span><br></code></pre></td></tr></table></figure><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>使用方法：const proxy &#x3D; new Proxy(target, handler)<br>输入参数：</p><ul><li>target：拦截的目标对象</li><li>handler：定制拦截行为</li></ul><h3 id="Proxy-与-Object-defineProperty-对比"><a href="#Proxy-与-Object-defineProperty-对比" class="headerlink" title="Proxy 与 Object.defineProperty 对比"></a>Proxy 与 Object.defineProperty 对比</h3><p>Proxy 的优点：</p><ul><li>Proxy 可以直接监听整个对象而非属性。</li><li>Proxy 可以直接监听数组的变化。</li><li>Proxy 有 13 种拦截方法，如 ownKeys、deleteProperty、has 等是 Object.defineProperty 不具备的。</li><li>Proxy 返回的是一个新对象，我们可以只操作新的对象达到目的，而 Object.defineProperty 只能遍历对象属性直接修改;</li><li>Proxy 做为新标准将受到浏览器产商重点持续的性能优化,也就是传说中的新标准的性能红利。</li></ul><p>Object.defineProperty 的优点：</p><ul><li>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平。</li></ul><p>Object.defineProperty 的缺点：</p><ul><li>Object.defineProperty 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。</li><li>Object.defineProperty 不能监听数组。是通过重写数据的那 7 个可以改变数据的方法来对数组进行监听的。</li><li>Object.defineProperty 也不能对 es6 新产生的 Map,Set 这些数据结构做出监听。</li><li>Object.defineProperty 也不能监听新增和删除操作，通过 Vue.set()和 Vue.delete 来实现响应式的。</li></ul><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>导入导出方式：<br>commonJs：require、module.exports、exports<br>es6：import、export、export default</p><h3 id="commonJs-vs-ES6"><a href="#commonJs-vs-ES6" class="headerlink" title="commonJs vs ES6"></a>commonJs vs ES6</h3><ol><li>commonJs 输出是值的拷贝，es6 输出值的引用</li><li>commonJs 模块运行时加载（先加载全部模块再导入方法），es6 模块是编译时加载（指定加载某输出值）</li><li>commonJs 同步导入，es6 模块异步导入</li></ol><h3 id="其他模块化方法特点"><a href="#其他模块化方法特点" class="headerlink" title="其他模块化方法特点"></a>其他模块化方法特点</h3><p>amd ：应用实例 requireJs。特点：依赖预加载；依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致（依赖前置、提前执行）<br>cmd ：应用实例 seaJs。特点：就近依赖，按需加载；模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句的时候执行依赖模块（依赖就近、延迟执行）<br>umd：通用模块定义规范，兼容之前提到的模块规范 amd 和 commonJs 及全局变量。在 webpack 项目调用 umd 模块时工具自动处理，使得 import 语句能够正常工作 ‌</p><h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>3 种状态：1）pending；2）resolved；3）rejected<br>特点：1）立即执行；2）then 异步回调；3）状态不可逆；4）链式调用</p><h4 id="promise-简易实现"><a href="#promise-简易实现" class="headerlink" title="promise 简易实现"></a>promise 简易实现</h4><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs pf">function myPromise(fn) &#123;<br>    <span class="hljs-keyword">const</span> that = this<br>    that.<span class="hljs-keyword">state</span> = &#x27;pending&#x27;<br>    that.value = null<br>    that.resolvedCallbacks = []<br>    that.rejectedCallbacks = []<br><br>    function resolve(value) &#123;<br>        if (that.<span class="hljs-keyword">state</span> === &#x27;pending&#x27;) &#123;<br>            that.<span class="hljs-keyword">state</span> = &#x27;resolved&#x27;<br>            that.value = value<br>            that.resolvedCallbacks.map(cb =&gt; cb(value))<br>        &#125;<br>    &#125;<br><br>    function reject(value) &#123;<br>        if (that.<span class="hljs-keyword">state</span> === &#x27;pending&#x27;) &#123;<br>            that.<span class="hljs-keyword">state</span> = &#x27;rejected&#x27;<br>            that.value = value<br>            that.rejectedCallbacks.map(cb =&gt; cb(value))<br>        &#125;<br>    &#125;<br>    try &#123;<br>        fn(resolve, reject)<br>    &#125; catch (e) &#123;<br>        reject(e)<br>    &#125;<br>&#125;<br>myPromise.prototype.then = function (<span class="hljs-keyword">on</span>Fulfilled, <span class="hljs-keyword">on</span>Rejected) &#123;<br>    <span class="hljs-keyword">const</span> that = this<br>    <span class="hljs-keyword">on</span>Fulfilled = typeof <span class="hljs-keyword">on</span>Fulfilled === &#x27;function&#x27; ? <span class="hljs-keyword">on</span>Fulfilled : v =&gt; v<br>    <span class="hljs-keyword">on</span>Rejected = typeof <span class="hljs-keyword">on</span>Rejected === &#x27;function&#x27; ? <span class="hljs-keyword">on</span>Rejected : e =&gt;<br>        throw e<br>    if (that.<span class="hljs-keyword">state</span> === &#x27;resolved&#x27;) <span class="hljs-keyword">on</span>Fulfilled(that.value)<br>    if (that.<span class="hljs-keyword">state</span> === &#x27;rejected&#x27;) <span class="hljs-keyword">on</span>Rejected(that.value)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Promise-all-简易实现"><a href="#Promise-all-简易实现" class="headerlink" title="Promise.all 简易实现"></a>Promise.all 简易实现</h4><p>函数返回一个 promise，每个异步任务进入 resolve 态时计数都加 1，只有当计数与异步任务总数一致时返回的 promise 的状态置为 resolved</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">promiseAll</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(promises)) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">`argument must be a array`</span>);<br>    &#125;<br>    <span class="hljs-keyword">var</span> resolvedCounter = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">var</span> promiseNum = promises.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">var</span> resolvedResult = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; promiseNum; i++) &#123;<br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promises[i]).<span class="hljs-title function_">then</span>(<br>        <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>          resolvedCounter++;<br>          resolvedResult[i] = value;<br>          <span class="hljs-keyword">if</span> (resolvedCounter == promiseNum) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>(resolvedResult);<br>          &#125;<br>        &#125;,<br>        <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(error);<br>        &#125;<br>      );<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Promise-race-简易实现"><a href="#Promise-race-简易实现" class="headerlink" title="Promise.race 简易实现"></a>Promise.race 简易实现</h4><p>因为 Promise 的状态只能改变一次, 那么我们只需要把 Promise.race 中产生的 Promise 对象的 resolve 方法, 注入到数组中的每一个 Promise 实例中的回调函数中即可.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">race</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">args</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = args.<span class="hljs-property">length</span>; i &lt; len; i++) &#123;<br>      args[i].<span class="hljs-title function_">then</span>(resolve, reject);<br>    &#125;<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h3><p>generator 的语法糖。<br>async 声明 function 是一个异步函数，返回一个 promise 对象，可以使用 then 方法添加回调函数。<br>await 操作符只能在异步函数 async function 内部使用。await 会阻塞后面的代码，等待接在 await 后面的表达式返回 Promise 对象结果。</p><h2 id="数据类型-Set、Map"><a href="#数据类型-Set、Map" class="headerlink" title="数据类型 Set、Map"></a>数据类型 Set、Map</h2><h3 id="Set-和-weakSet、Map-和-WeakMap-区别"><a href="#Set-和-weakSet、Map-和-WeakMap-区别" class="headerlink" title="Set 和 weakSet、Map 和 WeakMap 区别"></a>Set 和 weakSet、Map 和 WeakMap 区别</h3><p>weakSet 结构与 Set 类似，是不重复值集合，但 weakSet 只能是对象且为弱引用，且不可遍历<br>weakMap 结构与 Map 类似，但 weakMap 只接受对象为键名，键名是对象弱引用，且不可遍历</p><h3 id="Map-和-Object-的区别"><a href="#Map-和-Object-的区别" class="headerlink" title="Map 和 Object 的区别"></a>Map 和 Object 的区别</h3><p>1）Key filed：在 Object 中， key 必须是简单数据类型（整数，字符串或者是 symbol），而在 Map 中则可以是 JavaScript 支持的所有数据类型，也就是说可以用一个 Object 来当做一个 Map 元素的 key。<br>2）元素顺序：Map 元素的顺序遵循插入的顺序，而 Object 的则没有这一特性。<br>3）初始化、增查删改方式</p><h2 id="for-in-和-for-of-区别"><a href="#for-in-和-for-of-区别" class="headerlink" title="for in 和 for of 区别"></a>for in 和 for of 区别</h2><ul><li>for in：用于遍历对象的可枚举属性（包括原型链上的属性），也可以用于数组。不过，当用于数组时，它遍历的是数组的索引而不是元素。</li><li>for of：用于遍历可迭代对象（例如数组、字符串、Map、Set 等）。它遍历的是可迭代对象的值，不适合遍历对象的属性。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>1）<a href="https://zhuanlan.zhihu.com/p/108217164">《模块化系列》彻底理清 AMD,CommonJS,CMD,UMD,ES6</a></p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>依赖包管理工具比较</title>
    <link href="/unknown404.github.io/2022/08/23/packageInfo/"/>
    <url>/unknown404.github.io/2022/08/23/packageInfo/</url>
    
    <content type="html"><![CDATA[<p>前端常用的包依赖管理工具有 npm、yarn 以及近期非常受欢迎的 pnpm，本文主要也是对比这几个工具之间的区别。</p><span id="more"></span><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>最早出现的安装包工具， Node.js 标准的软件包管理器。</p><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p>npm 是围绕着<a href="https://semver.org/">语义版本控制（semver）</a>的思想而设计的。大致的准则为：</p><ul><li>版本号由三部分组成：major.minor.patch，即主版本号.次版本号.修补版本号。<ul><li>主版本号：更改时代表了一个破坏兼容性的大变化。</li><li>次版本号：更改时不会破坏任何内容，增加了新功能。</li><li>修补版本号：更改时表示做了向后兼容的缺陷修复。</li></ul></li><li>版本是严格递增的，如该例所示：16.2.0 -&gt; 16.3.0 -&gt; 16.3.1</li><li>修补版本号有时后面可能还会有先行版本号，例如 1.0.0-alpha.1。常用的先行版本一般为 alpha（内部先行版），beta（公开测试版），rc（候选版），stable（稳定版）</li></ul><h4 id="版本控制符"><a href="#版本控制符" class="headerlink" title="版本控制符"></a>版本控制符</h4><p>使用 npm install 时，会发现 package.json 文件的版本号前面默认出现符号<code>^</code>，该符号即为版本控制符。常见的版本控制符包括：</p><ul><li><code>~</code> 会匹配最近的小版本依赖包，比如 ~1.2.3 会匹配所有 1.2.x 版本，但是不包括 1.3.0</li><li><code>^ </code>会匹配最新的大版本依赖包（npm i 默认的版本控制符），比如 ^1.2.3 会匹配所有 1.x.x 的包，包括 1.3.0，但是不包括 2.0.0</li><li><code>* </code>安装最新版本的依赖包，比如 *1.2.3 会匹配 x.x.x<br>除此之外还有其他版本控制方法：</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123; <span class="hljs-string">&quot;dependencies&quot;</span> :<br>  &#123; <span class="hljs-string">&quot;foo&quot;</span> : <span class="hljs-string">&quot;1.0.0 - 2.9999.9999&quot;</span>,<span class="hljs-regexp">//</span> 大于等于<span class="hljs-number">1.0</span>.<span class="hljs-number">0</span> 小于 <span class="hljs-number">2.9999</span>.<span class="hljs-number">9999</span><br>  <span class="hljs-string">&quot;bar&quot;</span> : <span class="hljs-string">&quot;&gt;=1.0.2 &lt;2.1.2&quot;</span>, <span class="hljs-regexp">//</span> 比较清晰  左闭右开<br>  <span class="hljs-string">&quot;baz&quot;</span> : <span class="hljs-string">&quot;&gt;1.0.2 &lt;=2.3.4&quot;</span>, <span class="hljs-regexp">//</span> 左开右闭<br>  <span class="hljs-string">&quot;boo&quot;</span> : <span class="hljs-string">&quot;2.0.1&quot;</span>, <span class="hljs-regexp">//</span> 规定版本<br>  <span class="hljs-string">&quot;qux&quot;</span> : <span class="hljs-string">&quot;&lt;1.0.0 || &gt;=2.3.1 &lt;2.4.5 || &gt;=2.5.2 &lt;3.0.0&quot;</span>, <span class="hljs-regexp">//</span> 表达式也算清晰<br>  <span class="hljs-string">&quot;asd&quot;</span> : <span class="hljs-string">&quot;http://asdf.com/asdf.tar.gz&quot;</span>, <span class="hljs-regexp">//</span> 指定下载地址代替版本<br>  <span class="hljs-string">&quot;til&quot;</span> : <span class="hljs-string">&quot;^1.2.3&quot;</span>, <span class="hljs-regexp">//</span> 同一主版本号，不小于<span class="hljs-number">1.2</span>.<span class="hljs-number">3</span> 即 <span class="hljs-number">1</span>.x.y  x&gt;=<span class="hljs-number">2</span> y&gt;=<span class="hljs-number">3</span><br>  <span class="hljs-string">&quot;elf&quot;</span> : <span class="hljs-string">&quot;~1.2.3&quot;</span>,  <span class="hljs-regexp">//</span> 同一主版本和次版本号 即<span class="hljs-number">1.2</span>.x x&gt;= <span class="hljs-number">2</span><br>  <span class="hljs-string">&quot;two&quot;</span> : <span class="hljs-string">&quot;2.x&quot;</span> , <span class="hljs-regexp">//</span> 这个比较形象，x&gt;=<span class="hljs-number">0</span>  即<span class="hljs-number">2.0</span>.<span class="hljs-number">0</span> 以上均可<br>  <span class="hljs-string">&quot;thr&quot;</span> : <span class="hljs-string">&quot;3.3.x&quot;</span> , <span class="hljs-regexp">//</span> 同上 x&gt;= <span class="hljs-number">0</span>  即<span class="hljs-number">3.3</span>.<span class="hljs-number">0</span> 以上<br>  <span class="hljs-string">&quot;lat&quot;</span> : <span class="hljs-string">&quot;latest&quot;</span>,  <span class="hljs-regexp">//</span> 最新版本<br>  <span class="hljs-string">&quot;dyl&quot;</span> : <span class="hljs-string">&quot;file:../dyl&quot;</span>,  <span class="hljs-regexp">//</span> 从本地下载<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="package-lock-json"><a href="#package-lock-json" class="headerlink" title="package-lock.json"></a>package-lock.json</h4><p>早期的 npm 没有锁定包版本的功能，如果某个依赖包发布了不兼容或者有 bug 版本，部署上线时项目就可能会发生问题。针对这一问题 yarn 提出了固化版本的方案，而 npm 在^5.x.x.x 以后才有的 package-lock.json。<br>不同版本 npm 对 package-lock.json 的实现是不同的。是在一直迭代和发展的：</p><ol><li>npm 5.0.x 版本，不管 package.json 怎么变，npm i 时都会根据 lock 文件下载。</li><li>5.1.0 版本后 npm install 会无视 lock 文件 去下载最新的 npm 包</li><li>5.4.2 版本如果改了 package.json，且 package.json 和 lock 文件不同，那么执行 npm i 时 npm 会根据 package 中的版本号以及语义含义去下载最新的包，并更新至 lock。<br>如果两者是同一状态，那么执行 npm i 都会根据 lock 下载，不会理会 package 实际包的版本是否有新。</li></ol><p>package-lock.json 的文件格式如下：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs perl">...<br><span class="hljs-string">&quot;@ant-design/colors&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;4.0.5&quot;</span>,<br>    <span class="hljs-string">&quot;resolved&quot;</span>: <span class="hljs-string">&quot;http://npm.internal.focus.cn:80/@ant-design%2fcolors/-/colors-4.0.5.tgz&quot;</span>,<br>    <span class="hljs-string">&quot;integrity&quot;</span>: <span class="hljs-string">&quot;sha1-19EA11Rcyo9iSVRgSmiS/Ei6Wq4=&quot;</span>,<br>    <span class="hljs-string">&quot;requires&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;tinycolor2&quot;</span>: <span class="hljs-string">&quot;^1.4.1&quot;</span><br>    &#125;<br>&#125;,<br><span class="hljs-string">&quot;@ant-design/icons&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;4.6.2&quot;</span>,<br>    <span class="hljs-string">&quot;resolved&quot;</span>: <span class="hljs-string">&quot;https://registry.npmjs.org/@ant-design/icons/-/icons-4.6.2.tgz&quot;</span>,<br>    <span class="hljs-string">&quot;integrity&quot;</span>: <span class="hljs-string">&quot;sha512-QsBG2BxBYU/rxr2eb8b2cZ4rPKAPBpzAR+0v6rrZLp/lnyvflLH3tw1vregK+M7aJauGWjIGNdFmUfpAOtw25A==&quot;</span>,<br>    <span class="hljs-string">&quot;requires&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;@ant-design/colors&quot;</span>: <span class="hljs-string">&quot;^6.0.0&quot;</span>,<br>    <span class="hljs-string">&quot;@ant-design/icons-svg&quot;</span>: <span class="hljs-string">&quot;^4.0.0&quot;</span>,<br>    <span class="hljs-string">&quot;@babel/runtime&quot;</span>: <span class="hljs-string">&quot;^7.11.2&quot;</span>,<br>    <span class="hljs-string">&quot;classnames&quot;</span>: <span class="hljs-string">&quot;^2.2.6&quot;</span>,<br>    <span class="hljs-string">&quot;rc-util&quot;</span>: <span class="hljs-string">&quot;^5.9.4&quot;</span><br>    &#125;,<br>    <span class="hljs-string">&quot;dependencies&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;@ant-design/colors&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;6.0.0&quot;</span>,<br>        <span class="hljs-string">&quot;resolved&quot;</span>: <span class="hljs-string">&quot;https://registry.npmjs.org/@ant-design/colors/-/colors-6.0.0.tgz&quot;</span>,<br>        <span class="hljs-string">&quot;integrity&quot;</span>: <span class="hljs-string">&quot;sha512-qAZRvPzfdWHtfameEGP2Qvuf838NhergR35o+EuVyB5XvSA98xod5r4utvi4TJ3ywmevm290g9nsCG5MryrdWQ==&quot;</span>,<br>        <span class="hljs-string">&quot;requires&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;@ctrl/tinycolor&quot;</span>: <span class="hljs-string">&quot;^3.4.0&quot;</span><br>        &#125;<br>    &#125;<br>    &#125;<br>&#125;,<br>...<br></code></pre></td></tr></table></figure><p>可以看到，安装包需要的依赖包，如果顶级依赖满足需求的，则不再安装，仅有 requires 属性；如果不满足，则会在对应文件夹下面根据依赖安装符合版本，如上面的文件里的@ant-design&#x2F;icons，内部仍有 dependencies 属性。</p><h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><h4 id="npm-2-x"><a href="#npm-2-x" class="headerlink" title="npm 2.x"></a>npm 2.x</h4><p>npm2.x 版本安装依赖包时会安装每一个包所依赖的所有依赖项，依赖项的依赖包也会安装在其 node_modules 目录下。如下图所示，即 node_modules 存在嵌套。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">.</span><br><span class="hljs-bullet"></span>└──node<span class="hljs-emphasis">_modules</span><br><span class="hljs-emphasis">        ├──test1</span><br><span class="hljs-emphasis">        └──test2</span><br><span class="hljs-emphasis">            └──node_</span>modules<br><span class="hljs-code">                    └──test3</span><br></code></pre></td></tr></table></figure><p>这样的处理方式造成了两个问题：</p><ol><li>多个包之间难免会有公共的依赖，这样嵌套的话，同样的依赖会复制很多次，会占据比较大的磁盘空间。</li><li>windows 的文件路径最长是 260 多个字符，这样嵌套是会超过 windows 路径的长度限制的。</li></ol><h4 id="npm-3"><a href="#npm-3" class="headerlink" title="npm 3+"></a>npm 3+</h4><p>同 yarn 一样采用了扁平化依赖的方式解决问题。与之前的目录相比，现在的文件夹结构更接近于</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">.</span><br><span class="hljs-bullet"></span>└──node_modules<br><span class="hljs-code">        ├──test1</span><br><span class="hljs-code">        ├──test2</span><br><span class="hljs-code">        └──test3</span><br></code></pre></td></tr></table></figure><p>所有的依赖都被拍平到 node_modules 目录下，不再有很深层次的嵌套关系。这样在安装新的包时，根据 node require 机制，会不停往上级的 node_modules 当中去找，如果找到相同版本的包就不会重新安装，解决了大量包重复安装的问题，而且依赖层级也不会太深。<br>但扁平化依赖方法存在的问题包括：</p><ul><li>依赖结构的不确定性。</li><li>扁平化算法本身的复杂性很高，耗时较长。</li><li>项目中仍然可以非法访问没有声明过依赖的包<br>依赖结构的不确定性是如果声明的依赖包 test1、test2 同时依赖另一个包 test3，但是是不同版本的时候，扁平化的结果可能有两种。</li></ul><p><em>npm2.x 下 test1、test2 依赖包结构</em></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c">.<br>└──node_modules<br>        ├──test1<br>        <span class="hljs-string">|   └──node_modules</span><br>        <span class="hljs-string">|           └──test3@1.0.1</span><br>        └──test2<br>            └──node_modules<br>                    └──test3@<span class="hljs-number">1.0</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><em>npm3+下 test1、test2 安装结果 1</em></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c">.<br>└──node_modules<br>        ├──test1<br>        └──test2<br>        <span class="hljs-string">|   └──node_modules</span><br>        <span class="hljs-string">|           └──test3@1.0.2</span><br>        └──test3@<span class="hljs-number">1.0</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><em>npm3+下 test1、test2 安装结果 2</em></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c">.<br>└──node_modules<br>        ├──test1<br>        <span class="hljs-string">|   └──node_modules</span><br>        <span class="hljs-string">|           └──test3@1.0.1</span><br>        ├──test2<br>        └──test3@<span class="hljs-number">1.0</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>两种结果都有可能存在，实际安装时取决于 test1 和 test2 在 package.json 中的位置，如果 test1 声明在前面，那么就是前面的结构，否则是后面的结构。<br>为了解决依赖结构的不确定性的问题，npm 5.x 推出 package-lock.json，保证第一次安装以后 node_modules 以后在添加依赖或者重装时也不会变。</p><h2 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h2><p>yarn 是在 npm2.x 版本没有很好的优化方案时提出的，主要用于解决嵌套超过 windows 路径的长度限制的 node_modules。虽然现在 npm 也日益趋同 yarn，但在安装速度上 yarn 还是优于 npm</p><h3 id="版本控制-1"><a href="#版本控制-1" class="headerlink" title="版本控制"></a>版本控制</h3><p>默认依赖都会生成 yarn.lock 文件，该文件会通过包名+版本来确定具体信息。<br>yarn.lock 文件格式如下，yarn 用的是自己设计的格式，语法上有点像 YAML，# 开头的行是注释。依赖的依赖不会被记录在 dependencies，依赖包的依赖版本如果不存在语义冲突则会合并信息</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-string">&quot;@angular-devkit/core@12.2.10&quot;</span>:<br>  version <span class="hljs-string">&quot;12.2.10&quot;</span><br>  resolved <span class="hljs-string">&quot;http://npm.internal.focus.cn:80/@angular-devkit%2fcore/-/core-12.2.10.tgz#3da62eceef3904f92cd3f860618b4ae513029ce2&quot;</span><br>  integrity sha1-PaYuzu85BPks<span class="hljs-number">0</span>/hgYYtK5RMCnOI=<br>  dependencies:<br>    ajv <span class="hljs-string">&quot;8.6.2&quot;</span><br>    ajv-formats <span class="hljs-string">&quot;2.1.0&quot;</span><br>    fast-json-stable-stringify <span class="hljs-string">&quot;2.1.0&quot;</span><br>    magic-string <span class="hljs-string">&quot;0.25.7&quot;</span><br>    rxjs <span class="hljs-string">&quot;6.6.7&quot;</span><br>    source-<span class="hljs-keyword">map</span> <span class="hljs-string">&quot;0.7.3&quot;</span><br></code></pre></td></tr></table></figure><p>Yarn 仅以 flatten 格式 描述各个包之间的依赖关系，并依赖于其当前实现来创建目录结构。这意味着如果其内部算法发生变化，结构也会发生变化。</p><h3 id="依赖关系-1"><a href="#依赖关系-1" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>同 npm 基本一样，其共有的问题是：如果你有 100 个项目使用了某个依赖（dependency），就会有 100 份该依赖的副本保存在硬盘上</p><h2 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h2><p>同 npm 和 Yarn，都属于 Javascript 包管理安装工具，它较 npm 和 Yarn 在性能上得到很大提升，被称为快速的，节省磁盘空间的包管理工具。</p><h3 id="依赖关系-2"><a href="#依赖关系-2" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>为了解决 npm、yarn 安装时依赖可能复制多次、占用磁盘空间的问题，pnpm 采用了全局仓库保存依赖、项目通过 link 的方式访问内容。<br><img src="/unknown404.github.io/img/pnpm.png"></p><p>当执行 pnpm install 时，项目的 node_modules 文件夹下除了安装的包名 bar、其依赖保持原有的树状、不进行提升，还会有.pnpm 目录，目录下是以展平结构管理每个版本包的源码内容，以硬链接方式指向 pnpm-store 中的文件地址。pnpm-store 是全局的 store，存储所有 npm 包，同一版本的包仅存储一份内容，甚至不同版本的包也仅存储 diff 内容。<br>如上图所示一个包的寻找需要经过三层结构：<code>node_modules/bar</code> &gt; 软链接 <code>node_modules/.pnpm/bar@1.0.0/node_modules/bar</code> &gt; 硬链接 <code>~/.pnpm-store/v3/files/00/xxxxxx</code>。</p><h4 id="备注：软链接和硬链接"><a href="#备注：软链接和硬链接" class="headerlink" title="备注：软链接和硬链接"></a>备注：软链接和硬链接</h4><p>在 Linux 系统中，内核为每一个新创建的文件分配一个 Inode(索引结点)，每个文件都有一个惟一的 inode 号。文件属性保存在索引结点里，在访问文件时，索引结点被复制到内存在，从而实现文件的快速访问。<br>Linux 中包括两种链接：硬链接(Hard Link)和软链接(Soft Link)，软链接又称为符号链接（Symbolic link）。<br>硬链接说白了是一个指针，指向文件索引节点，系统并不为它重新分配 inode，他将与源文件共用一个 inode。<br>软链接相当于 windows 的快捷方式，软链接文件会将 inode 指向源文件的 block，原文件＆链接文件拥有不同的 inode 号</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/6932046455733485575">关于现代包管理器的深度思考——为什么现在我更推荐 pnpm 而不是 npm&#x2F;yarn?</a><br>（2）<a href="https://juejin.cn/post/6844904022718038024">yarn or npm 版本固化如何选择</a><br>（3）<a href="https://juejin.cn/post/7127295203177676837">pnpm 是凭什么对 npm 和 yarn 降维打击的</a><br>（4）<a href="https://mp.weixin.qq.com/s/bZ7AVSjBcZrZ3I387_esmg">该用 pnpm 了，“快、准、狠”。</a></p>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>npm</tag>
      
      <tag>前端依赖包管理</tag>
      
      <tag>yarn</tag>
      
      <tag>pnpm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>koroFileHeader使用技巧</title>
    <link href="/unknown404.github.io/2022/08/18/koroHeader/"/>
    <url>/unknown404.github.io/2022/08/18/koroHeader/</url>
    
    <content type="html"><![CDATA[<p>本来并不想记的，奈何记忆力太差，有些快捷键操作老要翻文档也很讨厌，所以在此简单记录下。</p><span id="more"></span> <h2 id="配置-setting-json"><a href="#配置-setting-json" class="headerlink" title="配置 setting.json"></a>配置 setting.json</h2><p><strong>方法 1</strong><br>点击顶部工具栏的 code 选项，按<code>首选项 &gt; 设置 &gt; 搜索fileheader &gt; 在setting.json中编辑</code>的步骤进入 setting.json 文件<br><strong>方法 2</strong><br>mac: command + p window: ctrl + p 的快捷键指令打开 vscode 命令面板，输入<code>&gt; Open Settings</code></p><h2 id="配置文件头部注释"><a href="#配置文件头部注释" class="headerlink" title="配置文件头部注释"></a>配置文件头部注释</h2><p>头部注释快捷键：window：ctrl+win+i,mac：ctrl+cmd+i</p><p>文件头部注释的配置修改主要在 fileheader.customMade 内部操作，通过增加或删除内部的属性来 DIY 合适的文件说明。</p><p>默认配置如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;fileheader.customMade&quot;</span>: &#123;<br>  <span class="hljs-string">&quot;Date&quot;</span>: <span class="hljs-string">&quot;Do not edit&quot;</span>, <span class="hljs-regexp">//</span> 文件创建时间(不变)<br>  <span class="hljs-regexp">//</span> 文件最后编辑者<br>  <span class="hljs-string">&quot;LastEditors&quot;</span>: <span class="hljs-string">&quot;git config user.name &amp;&amp; git config user.email&quot;</span>,<br>  <span class="hljs-string">&quot;LastEditTime&quot;</span>: <span class="hljs-string">&quot;Do not edit&quot;</span>, <span class="hljs-regexp">//</span> 文件最后编辑时间<br>  <span class="hljs-string">&quot;FilePath&quot;</span>: <span class="hljs-string">&quot;Do not edit&quot;</span> <span class="hljs-regexp">//</span> 文件在项目中的相对路径 自动更新<br>&#125;<br><span class="hljs-regexp">//</span> 不填写对应属性即关闭对应功能<br></code></pre></td></tr></table></figure><h2 id="配置函数注释"><a href="#配置函数注释" class="headerlink" title="配置函数注释"></a>配置函数注释</h2><p>文件头部注释的配置修改主要在 fileheader.cursorMode 内部操作，通过增加或删除内部的属性来 DIY 合适的函数说明。</p><p>默认配置如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;fileheader.cursorMode&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;param&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;return&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="配置函数使用方法"><a href="#配置函数使用方法" class="headerlink" title="配置函数使用方法"></a>配置函数使用方法</h3><p>函数识别快捷键：window：ctrl+win+t,mac：ctrl+cmd+t<br><strong>单行函数声明参数提取</strong><br>将鼠标光标放置于函数声明那一行，然后按函数注释快捷键生成<br><strong>多行函数声明参数提取</strong><br>当函数内参数过多时经过 prettier 优化的函数声明会变成多行，这时需要用鼠标左键选择多行函数声明区域，函数声明区域尽量精准，按快捷键生成</p><h3 id="插件配置项"><a href="#插件配置项" class="headerlink" title="插件配置项"></a>插件配置项</h3><p>可以用于决定自动生成注释的时机、注释的格式等内容</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://hub.fastgit.xyz/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE">koroFileHeader配置</a></p>]]></content>
    
    
    <categories>
      
      <category>工作技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vscode插件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工具函数</title>
    <link href="/unknown404.github.io/2022/08/18/toolFunc/"/>
    <url>/unknown404.github.io/2022/08/18/toolFunc/</url>
    
    <content type="html"><![CDATA[<p>记录一些常用的工具函数（不定期更新）。</p><span id="more"></span><ol><li>两个数组求交集</li></ol><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">intersectArr</span>(<span class="hljs-params">arr1,arr2</span>)&#123;<br>    <span class="hljs-keyword">return</span> arr1.<span class="hljs-built_in">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>arr2.<span class="hljs-built_in">includes</span>(item))<br>&#125;<br></code></pre></td></tr></table></figure><p>延伸：判断某数组是否包含另一数组的参数（适用于权限验证，用户的权限是否与路由设置的角色权限匹配）</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isIntersect</span>(<span class="hljs-params">arr1,arr2</span>)&#123;<br>    <span class="hljs-keyword">return</span> arr1.some(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>arr2.<span class="hljs-built_in">includes</span>(item))<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>删除对象中的 null 或 undefined 值</li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const removeNullorUndefinedofObj = <span class="hljs-function"><span class="hljs-params">(obj)</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.entries(obj).reduce(<br>    <span class="hljs-function"><span class="hljs-params">(cur, [key, value])</span> =&gt;</span> (value === <span class="hljs-literal">null</span> || value === <span class="hljs-literal">undefined</span> ? cur : (cur[key] = value), cur),<br>    &#123;&#125;,<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="3"><li>url 中搜索参数格式化</li></ol><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">const</span> parseQuery = () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">search</span> = <span class="hljs-keyword">window</span>.location.<span class="hljs-keyword">search</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">search</span><br>    .slice(1)<br>    .<span class="hljs-keyword">split</span>(<span class="hljs-string">&quot;&amp;&quot;</span>)<br>    .reduce((<span class="hljs-keyword">query</span>, it) =&gt; &#123;<br>      <span class="hljs-keyword">const</span> [key, value] = it.<span class="hljs-keyword">split</span>(<span class="hljs-string">&quot;=&quot;</span>);<br>      <span class="hljs-keyword">query</span>[key] = decodeURIComponent(value);<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">query</span>;<br>    &#125;, &#123;&#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="4"><li>快速创建 0 - n-1 范围的数组</li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Array</span>.<span class="hljs-keyword">from</span>(&#123;length: n&#125;, <span class="hljs-function"><span class="hljs-params">(_, i)</span> =&gt;</span> i)<br><br>[...<span class="hljs-built_in">Array</span>(n).keys()]<br><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n).fill(<span class="hljs-number">1</span>).map(<span class="hljs-function"><span class="hljs-params">(_, i)</span> =&gt;</span> i)<br></code></pre></td></tr></table></figure><ol start="5"><li>多个数组全组合的情况统计</li></ol><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">zuhe</span>(<span class="hljs-params">arr,n</span>)&#123;<br>    <span class="hljs-keyword">var</span> pass = <span class="hljs-keyword">new</span> Set();<br>    <span class="hljs-keyword">var</span> zh = []<br>    <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">0</span> || arr.<span class="hljs-built_in">length</span> &lt; n)&#123;throw <span class="hljs-string">&#x27;参数错误&#x27;</span>&#125;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">for</span>(let _arr of arr)&#123;<br>            <span class="hljs-keyword">for</span>(let v of _arr)&#123;<br>                <span class="hljs-keyword">if</span>(!pass.has(v))&#123; <span class="hljs-comment">//去重</span><br>                    pass.add(v);<br>                    zh.<span class="hljs-built_in">push</span>([v]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> zh;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(let i=<span class="hljs-number">0</span>; i &lt;= arr.<span class="hljs-built_in">length</span>-n; i++ )&#123;<br>        <span class="hljs-keyword">for</span>(let v of arr[i])&#123;<br>            <span class="hljs-keyword">if</span>(!pass.has(v))&#123; <span class="hljs-comment">//去重</span><br>                pass.add(v);<br>                let _zh = zuhe(arr.<span class="hljs-built_in">slice</span>(i+<span class="hljs-number">1</span>),n<span class="hljs-number">-1</span>).<span class="hljs-built_in">map</span>(<span class="hljs-function"><span class="hljs-params">a</span>=&gt;</span>&#123;<br>                    a.unshift(v)<br>                    <span class="hljs-keyword">return</span> a;<br>                &#125;)<br>                zh = zh.concat(_zh)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> zh;<br>&#125;<br><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>];<br><span class="hljs-keyword">var</span> arr2 = [<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>];<br><span class="hljs-keyword">var</span> arr3 = [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>];<br><br><span class="hljs-keyword">var</span> zh2 = zuhe([arr1,arr2,arr3],<span class="hljs-number">2</span>)<br><span class="hljs-keyword">var</span> zh3 = zuhe([arr1,arr2,arr3],<span class="hljs-number">3</span>)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(zh2)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(zh3)<br></code></pre></td></tr></table></figure><ol start="6"><li>数组转对象</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// method 1</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>]); <span class="hljs-comment">// &#123;0:&quot;a&quot;, 1:&quot;b&quot;, 2:&quot;c&quot;&#125;</span><br><span class="hljs-comment">// method 2</span><br>&#123; ...[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>] &#125;<br></code></pre></td></tr></table></figure><ol start="7"><li>浏览器环境下导出某段数据文件</li></ol><p>思路：利用 Blob 文件。Blob 构造函数的语法为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> aBlob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>(blobParts, options);<br></code></pre></td></tr></table></figure><p>相关的参数说明如下：·</p><p>blobParts：它是一个由 ArrayBuffer，ArrayBufferView，Blob，DOMString 等对象构成的数组。DOMStrings 会被编码为 UTF-8。<br>options：一个可选的对象，包含以下两个属性：<br>type —— 默认值为 “”，它代表了将会被放入到 blob 中的数组内容的 MIME 类型。常见的 MIME 类型有：超文本标记语言文本 .html text&#x2F;html、PNG图像 .png image&#x2F;png、普通文本 .txt text&#x2F;plain 等。<br>endings —— 默认值为 “transparent”，用于指定包含行结束符 \n 的字符串如何被写入。它是以下两个值中的一个：”native”，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 “transparent”，代表会保持 blob 中保存的结束符不变。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">downLoadData</span>(<span class="hljs-params">filename: <span class="hljs-built_in">string</span>, data: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-keyword">var</span> url = <span class="hljs-variable language_">window</span>.<span class="hljs-property">URL</span>.<span class="hljs-title function_">createObjectURL</span>(<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([data], &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;text/plain&quot;</span> &#125;)<br>  );<br>  <span class="hljs-keyword">var</span> link = <span class="hljs-variable language_">window</span>.<span class="hljs-property">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;a&quot;</span>);<br>  link.<span class="hljs-property">href</span> = url;<br>  link.<span class="hljs-property">download</span> = filename;<br>  link.<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">&quot;none&quot;</span>;<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-property">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(link);<br>  <span class="hljs-comment">// 模拟点击a连接，触发下载</span><br>  link.<span class="hljs-title function_">click</span>();<br>  <span class="hljs-comment">// 清除添加的dom，释放url资源</span><br>  <span class="hljs-variable language_">window</span>.<span class="hljs-property">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(link);<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-property">URL</span>.<span class="hljs-title function_">revokeObjectURL</span>(url);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://segmentfault.com/q/1010000018650936">js 多个数组元素两两组合三三组合</a><br>（2）<a href="https://stackoverflow.com/questions/4215737/convert-array-to-object">Convert Array to Object</a></p>]]></content>
    
    
    <categories>
      
      <category>工作技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rollup打包工具使用</title>
    <link href="/unknown404.github.io/2022/08/08/rollup/"/>
    <url>/unknown404.github.io/2022/08/08/rollup/</url>
    
    <content type="html"><![CDATA[<p>rollup 使用指南和相关知识梳理。</p><span id="more"></span><h2 id="rollup-概述"><a href="#rollup-概述" class="headerlink" title="rollup 概述"></a>rollup 概述</h2><p>rollup 是一个 js 模块打包器。与 webpack 相比，rollup 更适合打包库，而 webpack 适合打包项目；同体积的代码条件下 rollup 打包的代码体检要小于 webpack。rollup 对于代码的 Tree-shaking 和 ES6 模块有着先天的算法优势上的支持，而 webpack 在代码分割、静态资源导入及热模块替换(HMR)有着更多优势。</p><h2 id="rollup-使用"><a href="#rollup-使用" class="headerlink" title="rollup 使用"></a>rollup 使用</h2><h3 id="安装-rollup-工具"><a href="#安装-rollup-工具" class="headerlink" title="安装 rollup 工具"></a>安装 rollup 工具</h3><p>创建一个新的空工程，打开命令行执行<code>npm install --global rollup </code>指令。指令执行完成后项目的结构变为：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">├── node_modules<br>└── <span class="hljs-keyword">package</span>.json<br></code></pre></td></tr></table></figure><p>此时工程里已经预装了一些插件，允许我们用 cli 命令来打包。但复杂的工程中这种方式就比较麻烦。所以需要配置文件。</p><h3 id="配置打包文件"><a href="#配置打包文件" class="headerlink" title="配置打包文件"></a>配置打包文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs es6">import babel from &quot;@rollup/plugin-babel&quot;;<br>import commonjs from &quot;rollup-plugin-commonjs&quot;;<br>import resolve from &quot;@rollup/plugin-node-resolve&quot;;<br>import size from &quot;rollup-plugin-sizes&quot;;<br>import &#123; terser &#125; from &quot;rollup-plugin-terser&quot;;<br>import cleanup from &quot;rollup-plugin-cleanup&quot;;<br><br>export default &#123;<br>  input: &quot;./index.js&quot;,<br>  output: [<br>    &#123;<br>      file: &quot;./dist/dofin.js&quot;,<br>      format: &quot;umd&quot;,<br>      name: &quot;DOFIN&quot;,<br>    &#125;,<br>    &#123;<br>      file: &quot;./dist/dofin.min.js&quot;,<br>      format: &quot;iife&quot;,<br>      name: &quot;DOFIN&quot;,<br>      plugins: [terser()],<br>    &#125;,<br>  ],<br>  plugins: [<br>    resolve(),<br>    size(),<br>    cleanup(&#123;<br>      comments: &quot;none&quot;,<br>    &#125;),<br>    babel(&#123;<br>      babelHelpers: &quot;runtime&quot;,<br>      exclude: &quot;node_modules/**&quot;,<br>    &#125;),<br>    commonjs(),<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure><p>以上述某一配置文件 rollup.config.js 为例，该文件通常需要需要的核心参数包括：</p><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><p>打包文件入口</p><h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><p>文件输出配置</p><ul><li><strong>file</strong> 表示输出文件的路径</li><li><strong>format</strong> 表示输出的格式</li><li><strong>name</strong> 当 format 为 iife 和 umd 时必须提供，将作为全局变量挂在 window(浏览器环境)下：window.A&#x3D;…</li></ul><h4 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h4><p>使用的插件</p><h4 id="external"><a href="#external" class="headerlink" title="external"></a>external</h4><p>使用的外部依赖，不会被打包进输出文件</p><h4 id="global"><a href="#global" class="headerlink" title="global"></a>global</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">global:&#123;<br>    <span class="hljs-string">&#x27;jquery&#x27;</span>:<span class="hljs-string">&#x27;$&#x27;</span> <span class="hljs-regexp">//</span>告诉rollup 全局变量$即是jquery<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="执行打包指令"><a href="#执行打包指令" class="headerlink" title="执行打包指令"></a>执行打包指令</h3><p>可以直接在执行终端输入<code>rollup -c</code>默认执行 rollup.config.js 文件，也可以在 package.json 文件里的 scripts 属性配置指令：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs perl">&#123;<br><br>  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;build-browser&quot;</span>: <span class="hljs-string">&quot;rollup --config browser.rollup.config.js &quot;</span>,<br>、  &#125;,<br>  <span class="hljs-string">&quot;dependencies&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;@babel/runtime&quot;</span>: <span class="hljs-string">&quot;^7.14.6&quot;</span>,<br>    <span class="hljs-string">&quot;@rollup/plugin-json&quot;</span>: <span class="hljs-string">&quot;^4.1.0&quot;</span>,<br>    <span class="hljs-string">&quot;rollup-plugin-cleanup&quot;</span>: <span class="hljs-string">&quot;^3.2.1&quot;</span>,<br>    <span class="hljs-string">&quot;rollup-plugin-sizes&quot;</span>: <span class="hljs-string">&quot;^1.0.4&quot;</span>,<br>    <span class="hljs-string">&quot;tti-polyfill&quot;</span>: <span class="hljs-string">&quot;^0.2.2&quot;</span><br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>rollup 指令命令行常用的参数包括：</p><ul><li><code>-c</code>。指定 rollup 的配置文件。</li><li><code>-w</code>。监听源文件是否有改动，如果有改动，重新打包。</li><li><code>-f</code>。-f 参数是–format 的缩写，它表示生成代码的格式。</li><li><code>-o</code>。-o 指定了输出的路径<br>执行<code>npm run build-browser</code>即可打包完成，控制台会显示输出结果</li></ul><h2 id="输出代码格式说明"><a href="#输出代码格式说明" class="headerlink" title="输出代码格式说明"></a>输出代码格式说明</h2><p>通过配置文件，我们可以指定其输出 amd , cjs , esm , iife , umd , system 六种格式的文件。</p><h3 id="amd"><a href="#amd" class="headerlink" title="amd"></a>amd</h3><p>“Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。<br>打包后的代码其核心内容是一个全局方法 define。</p><p>define 方法可以有三个入参，以文章<a href="https://juejin.cn/post/7051236803344334862">说不清 rollup 能输出哪 6 种格式 😥 差点被鄙视</a>中的代码为例，分别是：</p><ul><li>模块名称 Test，如果没有指定不会出现</li><li>[exports, lodash] 分别表示模块的输出和外部依赖</li><li>代表模块的实际内容的一个匿名函数，一个以 exports 和 lodash 作为入参的方法。</li></ul><h4 id="运行方法"><a href="#运行方法" class="headerlink" title="运行方法"></a>运行方法</h4><p>调用打包后的模块内容时，需要执行以下操作：</p><ol><li>在浏览器内引入 require.js</li><li>通过 requirejs.config 方法定义全局的依赖</li><li>通过 requirejs.define 注册模块</li><li>通过 requirejs() 完成模块引入</li></ol><h4 id="适合场景"><a href="#适合场景" class="headerlink" title="适合场景"></a>适合场景</h4><p>只需要在浏览器端使用的场景。</p><h3 id="cjs"><a href="#cjs" class="headerlink" title="cjs"></a>cjs</h3><p>CommonJS 标准。是为了解决 node.js 在模块化上的缺失， 于 2009 年 10 月提出。所以并不能用于浏览器上。</p><h4 id="运行方法-1"><a href="#运行方法-1" class="headerlink" title="运行方法"></a>运行方法</h4><p>js 文件里使用 require 方法引入打包文件</p><h4 id="适合场景-1"><a href="#适合场景-1" class="headerlink" title="适合场景"></a>适合场景</h4><p>只需要在服务器端使用的场景。</p><h3 id="esm"><a href="#esm" class="headerlink" title="esm"></a>esm</h3><p>遵循 es6 模块化语法，通过 export 命令显式指定输出的代码，再通过 import 命令输入。</p><h4 id="运行方法-2"><a href="#运行方法-2" class="headerlink" title="运行方法"></a>运行方法</h4><p>如果需要在浏览器上使用，需要用<code>&lt;script type=&quot;module&quot;&gt;</code>标签才能支持模块引入语法，用<code>import ... from ...</code>导入代码。</p><h4 id="适合场景-2"><a href="#适合场景-2" class="headerlink" title="适合场景"></a>适合场景</h4><ol><li>还会被引用、二次编译的场景（如组件库等）</li><li>浏览器调试场景如 vite.js 的开发时</li><li>对浏览器兼容性非常宽松的场景。</li></ol><h3 id="iife"><a href="#iife" class="headerlink" title="iife"></a>iife</h3><p>IIFE 的全称是 “immediately invoked function expression”，即自执行函数。打包出来是一个匿名函数，对外部的依赖通过入参的形式传入该函数</p><h4 id="运行方法-3"><a href="#运行方法-3" class="headerlink" title="运行方法"></a>运行方法</h4><p>如果它没有其他依赖，只需要去引入文件，然后在 window 上取打包时命名的模块名即可。</p><p>jquery 就是典型的自执行函数模式，当你引入<code>http://cdn.bootcss.com/jquery/3.3.1/jquery.min.js</code>文件后，它就会挂在到 window.$ 上，可以直接在 js 文件使用 jquery 语法如<code>$(&#39;.input&#39;).addClass(&#39;test&#39;)</code></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p><strong>优点：</strong></p><ul><li>通过闭包营造了一个“私有”命名空间，防止影响全局，并防止被从外部修改私有变量。</li><li>简单易懂</li><li>对代码体积的影响不大<br><strong>缺点：</strong></li><li>输出的变量可能影响全局变量；引入依赖包时依赖全局变量。</li><li>需要使用者自行维护 script 标签的加载顺序。</li></ul><h4 id="适合场景-3"><a href="#适合场景-3" class="headerlink" title="适合场景"></a>适合场景</h4><p>适合部分场景作为 SDK 进行使用，尤其是需要把自己挂到 window 上的场景。</p><h3 id="umd"><a href="#umd" class="headerlink" title="umd"></a>umd</h3><p>umd 主要是处理兼容性问题，可以让模块同时兼容让模块同时兼容 AMD、CommonJs 和浏览器变量挂载的规范。</p><h4 id="运行方法-4"><a href="#运行方法-4" class="headerlink" title="运行方法"></a>运行方法</h4><ul><li>在浏览器端，它的运行方式可以和 amd 完全一致，也可以采用 iife 的调用方式</li><li>在 node.js 端，它则和 CommonJS 的运行方式完全一致</li></ul><h4 id="适合场景-4"><a href="#适合场景-4" class="headerlink" title="适合场景"></a>适合场景</h4><p>既可能在浏览器端也可能在 node.js 里使用的场景</p><h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><p>采用了 SystemJS 代码语法。由于很少使用该语法，这里暂时不展开。</p><h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><h3 id="resolve-插件"><a href="#resolve-插件" class="headerlink" title="resolve 插件"></a>resolve 插件</h3><h4 id="安装指令"><a href="#安装指令" class="headerlink" title="安装指令"></a>安装指令</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">npm i -D @rollup/plugin-<span class="hljs-keyword">node</span><span class="hljs-title">-resolve</span><br></code></pre></td></tr></table></figure><p><strong>注释</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"> <span class="hljs-selector-tag">i</span>  是 install 的简写<br>-S 就是 <span class="hljs-attr">--save</span> 的简写，安装的插件会被写入到 dependencies 区块里面去，在生产环境也存在对该包的依赖<br>-D 就是 <span class="hljs-attr">--save-dev</span> 的简写， 安装的插件会被写入到 devDependencies 域里面去，即插件只用于开发环境<br></code></pre></td></tr></table></figure><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>将我们编写的源码与依赖的第三方库代码进行合并，打包后的代码里会出现引用模块的代码。在使用 resolve 模块下，如果希望依赖的模块不被打包，保持外部引用状态时，就需要 config 文件使用 external 属性，来告诉 rollup.js 哪些是外部的类库。</p><h3 id="commonJs-插件"><a href="#commonJs-插件" class="headerlink" title="commonJs 插件"></a>commonJs 插件</h3><h4 id="安装指令-1"><a href="#安装指令-1" class="headerlink" title="安装指令"></a>安装指令</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i -D @rollup/plugin-commonjs<br></code></pre></td></tr></table></figure><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>rollup 编译源码中的模块引用默认只支持 ES6+的模块方式 import&#x2F;export。然而大量的 npm 模块是基于 CommonJS 模块方式，为支持这些模块的引入，支持 commonjs 语法的插件应运而生。</p><h3 id="babel-插件"><a href="#babel-插件" class="headerlink" title="babel 插件"></a>babel 插件</h3><h4 id="安装指令-2"><a href="#安装指令-2" class="headerlink" title="安装指令"></a>安装指令</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i -D @rollup/plugin-babel<br></code></pre></td></tr></table></figure><p>安装完成后在根目录文件夹下添加.babelrc 文件，配置内容</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>&#123;<br>  <span class="hljs-regexp">//</span> 开启默认预设<br>  <span class="hljs-string">&quot;presets&quot;</span>: [<br>    [<br>      <span class="hljs-string">&quot;@babel/env&quot;</span>,<br>      &#123;<br>        <span class="hljs-string">&quot;modules&quot;</span>: false  <span class="hljs-regexp">//</span> 关闭 esm 转化，统一交由 rollup 处理，防止冲突<br>      &#125;<br>    ]<br>  ],<br>  <span class="hljs-string">&quot;plugins&quot;</span>: [<span class="hljs-string">&quot;@babel/plugin-transform-runtime&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>完成后安装插件安装@babel&#x2F;core 和 @babel&#x2F;preset-env</p><h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><p>将代码中的 es6 语法转为 es5，防止打包后的模块在部分浏览器中无法正常运行</p><h3 id="typescript-插件"><a href="#typescript-插件" class="headerlink" title="typescript 插件"></a>typescript 插件</h3><h4 id="安装指令-3"><a href="#安装指令-3" class="headerlink" title="安装指令"></a>安装指令</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i -D @rollup/plugin-typescript<br></code></pre></td></tr></table></figure><p>该模块依赖于 tslib 和 typescript 模块，所以还需要再安装这两个组件。安装完后还需我们新建 tsconfig 配置，完成后才可在 package.json 的 plugins 配置该插件</p><h4 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h4><p>可以编译打包 ts 文件</p><h3 id="terser-插件"><a href="#terser-插件" class="headerlink" title="terser 插件"></a>terser 插件</h3><h4 id="安装指令-4"><a href="#安装指令-4" class="headerlink" title="安装指令"></a>安装指令</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i -D rollup-plugin-terser<br></code></pre></td></tr></table></figure><h4 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h4><p>压缩代码。rollup 中虽然也有 rollup-plugin-uglify 插件，但只适用于 es5 语法，所以还是需要 terser</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>（1）<a href="https://juejin.cn/post/6844904058394771470">Rollup 打包工具的使用（超详细，超基础，附代码截图超简单）</a><br>（2）<a href="https://juejin.cn/post/7051236803344334862">说不清 rollup 能输出哪 6 种格式 😥 差点被鄙视</a><br>（3）<a href="https://juejin.cn/post/6869551115420041229">一文带你快速上手 Rollup</a></p>]]></content>
    
    
    <categories>
      
      <category>前端技术体系</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rollup</tag>
      
      <tag>前端打包工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript基础</title>
    <link href="/unknown404.github.io/2022/06/18/javascript/"/>
    <url>/unknown404.github.io/2022/06/18/javascript/</url>
    
    <content type="html"><![CDATA[<h2 id="js-简介"><a href="#js-简介" class="headerlink" title="js 简介"></a>js 简介</h2><p>“解释型语言”，是通过解释器来实现的。运行过程：JS 代码-&gt;解析成 AST (期间伴随词法分析、语法分析)-&gt;生成字节码（V8）-&gt;生成机器码（编译器）</p><h2 id="js-数据类型"><a href="#js-数据类型" class="headerlink" title="js 数据类型"></a>js 数据类型</h2><ul><li>基本类型：null,undefined,string,bool,number,bigInt,symbol</li><li>引用类型：object,array,date</li></ul><p>存储位置：</p><ul><li>基本类型：栈，占据空间小，大小固定</li><li>引用类型：堆，占据空间大，大小不固定；栈中存储指向实体起始地址</li></ul><p>null vs undefined：null 是空对象，undefined 是声明的变量未定义</p><h3 id="0-1-0-2-为什么不等于-0-3"><a href="#0-1-0-2-为什么不等于-0-3" class="headerlink" title="0.1+0.2 为什么不等于 0.3"></a>0.1+0.2 为什么不等于 0.3</h3><p>因为像 0.1 和 0.2 这样的十进制数不能用二进制浮点数精确表示。因此，加法运算时，出现了微小的误差</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ol><li>使用 toFixed() 方法进行四舍五入</li><li>使用第三方库：像 decimal.js 或 big.js</li></ol><h4 id="为什么不推荐把小数变成整数再做运算"><a href="#为什么不推荐把小数变成整数再做运算" class="headerlink" title="为什么不推荐把小数变成整数再做运算"></a>为什么不推荐把小数变成整数再做运算</h4><p>在极端情况下，放大的整数依然可能会遇到溢出或精度问题，尤其是涉及非常大或非常小的数字时。</p><h2 id="js-类型判断"><a href="#js-类型判断" class="headerlink" title="js 类型判断"></a>js 类型判断</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>适用于判断基本类型，除 typeof null&#x3D;&#x3D;‘object’其他都可以识别（在 JavaScript 最初的版本中，使用 32 位的值表示一个变量，其中前 3 位用于表示值的类型。000 表示对象，在这种表示法下，null 被解释为一个全零的指针）</p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>使用于判断引用类型，其原理是是判断在其原型链中能否找到该类型的原型。</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myInstanceOf</span>(<span class="hljs-literal">left</span>,<span class="hljs-literal">right</span>)&#123;<br>  <span class="hljs-keyword">var</span> <span class="hljs-variable">prototype</span>=<span class="hljs-literal">right</span>.prototype<br>  <span class="hljs-keyword">var</span> <span class="hljs-variable">left</span>=<span class="hljs-literal">left</span>._proto_<br>  while(<span class="hljs-literal">true</span>)&#123;<br>    if(<span class="hljs-literal">left</span>==null||<span class="hljs-literal">left</span>==undefined)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><span class="hljs-comment">;</span><br>    if(<span class="hljs-literal">left</span>==prototype)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><span class="hljs-comment">;</span><br>    <span class="hljs-literal">left</span>=<span class="hljs-literal">left</span>._proto_<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call"></a>Object.prototype.toString.call</h3><p>辨析：为什么不直接用 obj.toString？<br>Array、Function 类型作为 Object 实例重写了 toString 方法</p><h3 id="延伸问题：数组判断"><a href="#延伸问题：数组判断" class="headerlink" title="延伸问题：数组判断"></a>延伸问题：数组判断</h3><ol><li>Array.isArray（arr）</li><li>arr instanceof Array</li><li>Object.prototype.toString.call（arr）</li></ol><h2 id="js-类型转换"><a href="#js-类型转换" class="headerlink" title="js 类型转换"></a>js 类型转换</h2><h3 id="其他类型转换为-boolean"><a href="#其他类型转换为-boolean" class="headerlink" title="其他类型转换为 boolean"></a>其他类型转换为 boolean</h3><table><thead><tr><th align="center">原类型</th><th align="center">boolean</th></tr></thead><tbody><tr><td align="center">false、null、undefined、0、’’、NaN</td><td align="center">false</td></tr><tr><td align="center">其他</td><td align="center">true</td></tr></tbody></table><h3 id="其他类型转换为-number"><a href="#其他类型转换为-number" class="headerlink" title="其他类型转换为 number"></a>其他类型转换为 number</h3><table><thead><tr><th align="center">原类型</th><th align="center">number</th></tr></thead><tbody><tr><td align="center">undefined</td><td align="center">NaN</td></tr><tr><td align="center">null</td><td align="center">0</td></tr><tr><td align="center">false</td><td align="center">0</td></tr><tr><td align="center">true</td><td align="center">1</td></tr><tr><td align="center">string</td><td align="center">NaN</td></tr><tr><td align="center">‘’</td><td align="center">0</td></tr><tr><td align="center">非空对象</td><td align="center">NaN</td></tr></tbody></table><h3 id="其他类型转换为-string"><a href="#其他类型转换为-string" class="headerlink" title="其他类型转换为 string"></a>其他类型转换为 string</h3><table><thead><tr><th align="center">原类型</th><th align="center">string</th></tr></thead><tbody><tr><td align="center">undefined</td><td align="center">‘undefined’</td></tr><tr><td align="center">null</td><td align="center">‘null’</td></tr><tr><td align="center">false</td><td align="center">‘false’</td></tr><tr><td align="center">true</td><td align="center">‘true’</td></tr><tr><td align="center">number</td><td align="center"><code>$&#123;number&#125;</code></td></tr><tr><td align="center">[ 1,2 ]</td><td align="center">‘1,2’</td></tr><tr><td align="center">[ ]</td><td align="center">‘’</td></tr><tr><td align="center">非空对象</td><td align="center">[ object Object ]</td></tr></tbody></table><h3 id="x3D-x3D-强制转换规则"><a href="#x3D-x3D-强制转换规则" class="headerlink" title="&#x3D;&#x3D;强制转换规则"></a>&#x3D;&#x3D;强制转换规则</h3><p><img src="/unknown404.github.io/img/type-change.jpeg"><br>如图所示，主要有以下几个步骤：</p><ol><li>类型是否相同</li><li>是否 null&#x3D;&#x3D;undefined</li><li>string&#x3D;&#x3D;number？是的话统一 number</li><li>是否有 boolean？有的话 boolean 转 number</li><li>object&#x3D;&#x3D;string&#x2F;number&#x2F;symbol？是的话 object 返回原始类型比较</li><li>返回 false</li></ol><h4 id="object-转原始类型"><a href="#object-转原始类型" class="headerlink" title="object 转原始类型"></a>object 转原始类型</h4><ol><li>调用 valueOf，如果转换为基础类型，则返回</li><li>调用 toString，如果转换为基础类型，则返回</li><li>报错</li></ol><h4 id="应用示例：让-a-x3D-x3D-1-amp-amp-a-x3D-x3D-2-amp-amp-a-x3D-x3D-3-成立"><a href="#应用示例：让-a-x3D-x3D-1-amp-amp-a-x3D-x3D-2-amp-amp-a-x3D-x3D-3-成立" class="headerlink" title="应用示例：让 a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3 成立"></a>应用示例：让 a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3 成立</h4><p><strong>解析</strong>：获取一次 a 的同时，让它自增 1。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> a = &#123;<br>  _a: <span class="hljs-number">0</span>,<br>  valueOf: <span class="hljs-keyword">function</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> ++a._a<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>延伸</strong>：让 a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D;&#x3D; 3 成立</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">Object</span><span class="hljs-selector-class">.defineProperties</span>(window, &#123;<br>  _a: &#123;<br>    value: <span class="hljs-number">0</span>,<br>    writable: true<br>  &#125;,<br>  <span class="hljs-selector-tag">a</span>: &#123;<br>    get: <span class="hljs-built_in">function</span>() &#123;<br>      return  ++_a<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="x3D-x3D-与-Object-is-的区别"><a href="#x3D-x3D-与-Object-is-的区别" class="headerlink" title="&#x3D;&#x3D;与 Object.is 的区别"></a>&#x3D;&#x3D;与 Object.is 的区别</h4><p>&#x3D;&#x3D;存在隐形类型转换<br>使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，即不存在类型转换。它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。</p><h3 id="四则运算转换"><a href="#四则运算转换" class="headerlink" title="四则运算转换"></a>四则运算转换</h3><p>1）+情况一方是字符串，则字符串拼接；如果一方不是字符串或者数字，那么会将它转换为数字或者字符串<br>2）其他情况存在数字另一方则转数字</p><h2 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>定义：拷贝对象间享有相同的引用数据</p><ol><li><strong>Object.assign</strong></li><li><strong>…展开扩展符</strong></li><li><strong>slice、concat</strong></li></ol><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>定义：两个对象有各自的存储区间</p><ol><li><strong>JSON.stringify</strong><br>缺点：不能拷贝函数和循环引用</li><li>递归函数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCloneObj</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">var</span> newObj = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj) ? [] : &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (obj.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      <span class="hljs-comment">//排除原型链继承来的属性</span><br>      newObj[key] =<br>        <span class="hljs-keyword">typeof</span> obj[key] == <span class="hljs-string">&quot;object&quot;</span> ? <span class="hljs-title function_">deepCloneObj</span>(obj[key]) : obj[key];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> newObj;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><p><strong>原型</strong>：<code>_proto_</code>指向的对象<br><strong>原型链</strong>：当对象某一属性在当前对象找不到时会沿<code>_proto_</code>属性向上一个对象查找，如果没有就沿着<code>_proto_</code>属性继续向上查找，这个查找依据的规则就是原型链<br><img src="/unknown404.github.io/img/proto-pic.jpg"></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();<br></code></pre></td></tr></table></figure><p>基本思路：将子类的 prototype 指向父类的实例<br>特点：引用类型被共享，不可向父实例传参</p><h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>基本思路：在子类型的构造函数中调用超类型构造函数<br>特点：每次创建实例都会创建一次方法，不能继承原型属性或者方法。</p><h3 id="组合继承（原型链继承-构造函数继承）"><a href="#组合继承（原型链继承-构造函数继承）" class="headerlink" title="组合继承（原型链继承+构造函数继承）"></a>组合继承（原型链继承+构造函数继承）</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">Child()</span>&#123;<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Parent</span>.</span></span>call(this)<br>&#125;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Child</span>.</span></span>prototype=<span class="hljs-keyword">new</span> <span class="hljs-constructor">Parent()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Child</span>.</span></span>prototype.constructor=Child<br></code></pre></td></tr></table></figure><p>基本思路：使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。<br>特点：调用了两次父类函数</p><h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">object</span>(o)&#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title">F</span>()&#123;&#125;;<br>    F.prototype = o;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">new</span> F();<br>&#125;<br></code></pre></td></tr></table></figure><p>基本思路：用临时构造函数的原型指向父类，返回临时构造函数的实例；对象浅拷贝，同时还不必因此创建自定义类型。<br>特点：可以实现基于一个对象的简单继承，不必创建构造函数；但缺点类似原型链继承</p><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>基本思路：创建一个仅用于封装继承过程的函数，该函数在内部以某种方式增强对象，最后返回这个对象。（Object.create原理类似object函数）<br>特点：在主要考虑对象而不是自定义类型和构造函数的情况下，实现简单的继承；缺点类似构造函数继承</p><h3 id="寄生组合型继承"><a href="#寄生组合型继承" class="headerlink" title="寄生组合型继承"></a>寄生组合型继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">extend</span>(<span class="hljs-params">subClass,superClass</span>)&#123;<br>  <span class="hljs-keyword">var</span> f=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;<span class="hljs-comment">//预防子类原型和父类原型共用，原型链不清</span><br>  f.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>=superClass.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br>  subClass.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>=<span class="hljs-keyword">new</span> <span class="hljs-title function_">f</span>()<br>  subClass.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>=subClass<br>  <span class="hljs-keyword">return</span> subClass<br>&#125;<br></code></pre></td></tr></table></figure><p>基本思路：继承原型时，继承的不是超类的实例对象，而是原型对象是超类原型对象的一个实例对象，这样就解决了基类的原型对象中增添了不必要的超类的实例对象中的所有属性的问题。<br>特点：解决了组合型调用 2 次父类构造函数的问题</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h3><p>this 指向最后调用它的对象</p><h3 id="改变-this-指向的方法"><a href="#改变-this-指向的方法" class="headerlink" title="改变 this 指向的方法"></a>改变 this 指向的方法</h3><p>1）箭头函数 2）call、apply、bind 3）new</p><h3 id="this-绑定"><a href="#this-绑定" class="headerlink" title="this 绑定"></a>this 绑定</h3><p>显式绑定：call、apply、bind<br>隐式绑定：直接被对象所包含的函数调用时<br>默认绑定：全局环境默认绑定到 window<br>new 绑定</p><h3 id="call-和-apply-区别"><a href="#call-和-apply-区别" class="headerlink" title="call 和 apply 区别"></a>call 和 apply 区别</h3><p>传入的参数不同，apply 传入 this 指向和参数数组（或类数组）两个变量；call 传入 this 指向和其他参数，传入的参数数量不固定</p><h3 id="call、apply、bind-的实现"><a href="#call、apply、bind-的实现" class="headerlink" title="call、apply、bind 的实现"></a>call、apply、bind 的实现</h3><ol><li>call</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">call</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>)&#123;<br>  <span class="hljs-keyword">var</span> context=context||<span class="hljs-variable language_">window</span><br>  context.<span class="hljs-property">fn</span>=<span class="hljs-variable language_">this</span><br>  <span class="hljs-keyword">var</span> args=[...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">var</span> res=context.<span class="hljs-title function_">fn</span>(...args)<br>  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span><br>  <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>apply</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">apply</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>)&#123;<br>  <span class="hljs-keyword">var</span> context=context||<span class="hljs-variable language_">window</span><br>  context.<span class="hljs-property">fn</span>=<span class="hljs-variable language_">this</span><br>  <span class="hljs-keyword">var</span> res<br>  <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>])&#123;<br>    res=context.<span class="hljs-title function_">fn</span>(...args)<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    res=context.<span class="hljs-title function_">fn</span>()<br>  &#125;<br>  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span><br>  <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>bind</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bind</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>)&#123;<br>  <span class="hljs-keyword">var</span> args=[...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>),_this=<span class="hljs-variable language_">this</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">// 函数作为构造函数时this指向改变</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> F)&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>(...args,...<span class="hljs-variable language_">arguments</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> _this.<span class="hljs-title function_">apply</span>(context,args.<span class="hljs-title function_">concat</span>(...<span class="hljs-variable language_">arguments</span>))<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>bind 多次时 this 的指向以第一次为准</p><h3 id="new-的过程"><a href="#new-的过程" class="headerlink" title="new 的过程"></a>new 的过程</h3><ol><li>创建新对象</li><li>对象原型指向构造函数 prototype</li><li>改变 this 指向</li><li>返回对象</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">create</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> obj=&#123;&#125;,<span class="hljs-title class_">Construct</span>=[].<span class="hljs-property">shift</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>)<br>  obj.<span class="hljs-property">_proto_</span>=<span class="hljs-title class_">Construct</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br>  <span class="hljs-keyword">var</span> res=<span class="hljs-title class_">Construct</span>.<span class="hljs-title function_">apply</span>(obj,<span class="hljs-variable language_">arguments</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> res===<span class="hljs-string">&#x27;object&#x27;</span>?<span class="hljs-attr">res</span>:obj<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="作用域相关"><a href="#作用域相关" class="headerlink" title="作用域相关"></a>作用域相关</h2><p>作用域：源码中定义变量的区域<br>词法作用域：函数的作用域在函数定义时决定<br>动态作用域：函数的作用域在函数调用时决定<br><strong>js 采用的是静态作用域，即函数的作用域在函数定义时就确定了。</strong></p><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>定义：当前代码的执行环境，包括全局上下文、函数上下文、eval 上下文</p><h4 id="执行上下文-3-个重要属性"><a href="#执行上下文-3-个重要属性" class="headerlink" title="执行上下文 3 个重要属性"></a>执行上下文 3 个重要属性</h4><ol><li>变量对象（VO）：存储了上下文定义的变量和函数声明</li><li>作用域链：一组对象列表，包括自身变量对象和指向父级变量对象作用域链属性。在当前执行上下文的变量对象中查找变量，如果在当前变量对象中找不到变量，JavaScript 引擎会沿着作用域链向上一级作用域的变量对象中查找，直到找到变量或者到达全局作用域。</li><li>this</li></ol><h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><ol><li>进入执行上下文阶段<br>变量对象内容：</li></ol><ul><li>1）函数所有形参</li><li>2）函数声明：由函数名+对应值变成变量对象属性；若变量对象由同名属性，则替换该属性</li><li>3）变量声明：由变量名+undefined 变成变量对象属性；若变量名称与函数或形参相同，则不干扰已存在属性</li></ul><ol start="2"><li>代码执行：根据代码修改变量对象的值<br>PS：函数上下文的变量对象初始化只包括 arguments</li></ol><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>定义：可以获取其他函数内变量的函数<br>优点：1.可创建私有变量；2.防止全局变量污染；3.模仿块级作用域<br>缺点：容易内存泄露（eg.意外的全局变量、定时器未及时清理、dom监听未取消、闭包循环引用）</p><h3 id="偏函数与柯里化"><a href="#偏函数与柯里化" class="headerlink" title="偏函数与柯里化"></a>偏函数与柯里化</h3><p>偏函数：将一个 n 元函数转为 n-x 函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">partial</span>(<span class="hljs-params">fn</span>)&#123;<br>  <span class="hljs-keyword">var</span> args=[...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> newArgs=args.<span class="hljs-title function_">concat</span>([...<span class="hljs-variable language_">arguments</span>])<br>    <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,newArgs)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>柯里化：将一个 n 元函数转为 n 个一元函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">fn</span>)&#123;<br>  <span class="hljs-keyword">var</span> args=[...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> newArgs=args.<span class="hljs-title function_">concat</span>([...<span class="hljs-variable language_">arguments</span>])<br>    <span class="hljs-keyword">if</span>(newArgs.<span class="hljs-property">length</span>&lt;fn.<span class="hljs-property">length</span>)&#123;<br>      <span class="hljs-keyword">return</span> curry.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,fn,newArgs)<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,newArgs)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="JavaScript-异步编程"><a href="#JavaScript-异步编程" class="headerlink" title="JavaScript 异步编程"></a>JavaScript 异步编程</h2><h3 id="什么是异步？"><a href="#什么是异步？" class="headerlink" title="什么是异步？"></a>什么是异步？</h3><p>一个异步过程调用发出后，调用者不会立刻得到结果。而是在”调用”发出后，”被调用者”通过状态、通知来通知调用者，或通过回调函数处理这个调用。JavaScript 是单线程的。同步代码意味着什么呢？意味着有可能会阻塞，当我们有一个任务需要时间较长时，如果使用同步方式，那么就会阻塞之后的代码执行。</p><h3 id="异步编程的实现方式"><a href="#异步编程的实现方式" class="headerlink" title="异步编程的实现方式"></a>异步编程的实现方式</h3><ul><li><strong>callback</strong>：多个回调函数嵌套的时候会造成回调函数地狱</li><li><strong>promise</strong>：使用 Promise 的方式可以将嵌套的回调函数作为链式调用。</li><li><strong>generator</strong>：可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。</li><li><strong>async</strong>：generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</li></ul><h3 id="AJAX-请求实现"><a href="#AJAX-请求实现" class="headerlink" title="AJAX 请求实现"></a>AJAX 请求实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><span class="hljs-comment">// 创建 Http 请求</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, url, <span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 设置状态监听函数</span><br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;<br>  <span class="hljs-keyword">if</span> (res.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">// 当请求成功时</span><br>  <span class="hljs-keyword">if</span> (res.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-title function_">handle</span>(res.<span class="hljs-property">response</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(res.<span class="hljs-property">statusText</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 设置请求失败时的监听函数</span><br>xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(res.<span class="hljs-property">statusText</span>);<br>&#125;;<br><span class="hljs-comment">// 设置请求头信息</span><br>xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;<br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br><span class="hljs-comment">// 发送 Http 请求</span><br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><h4 id="浏览器事件循环"><a href="#浏览器事件循环" class="headerlink" title="浏览器事件循环"></a>浏览器事件循环</h4><ul><li>macrotasks(宏任务):script(整体代码)、setTimeout、setInterval、setImmediate、I&#x2F;O、UI rendering</li><li>microtasks(微任务):process.nextTick、Promises、Object.observe、MutationObserver</li></ul><h5 id="浏览器循环机制"><a href="#浏览器循环机制" class="headerlink" title="浏览器循环机制"></a>浏览器循环机制</h5><p>JavaScript 有一个主线程和调用栈，所有的任务最终都会被放到调用栈等待主线程执行。宏任务会被放在调用栈中，按照顺序等待主线程依次执行。主线程之外存在一个回调队列，微任务有了结果后，会放入回调队列中。调用栈中任务执行完毕后，此时主线程处于空闲状态，会从回调队列中获取任务进行处理。上述过程不断重复。</p><ul><li>首先执行同步代码，这属于宏任务</li><li>当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行</li><li>执行所有微任务</li><li>当执行完所有微任务后，如有必要会渲染页面</li><li>然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 setTimeout 中的回调函数</li></ul><p><strong>备注</strong>：用户进行交互时会生成一个宏任务放到执行栈</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>)<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">async2</span>()<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 end&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async2 end&#x27;</span>)<br>&#125;<br><span class="hljs-title function_">async1</span>()<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Promise&#x27;</span>)<br>  <span class="hljs-title function_">resolve</span>()<br>&#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>)<br>  &#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)<br></code></pre></td></tr></table></figure><h6 id="概念区分：进程-vs-线程"><a href="#概念区分：进程-vs-线程" class="headerlink" title="概念区分：进程 vs 线程"></a>概念区分：进程 vs 线程</h6><p>进程：资源分配的基本单位<br>线程：cpu 调度的基本单位</p><h4 id="nodejs-事件循环"><a href="#nodejs-事件循环" class="headerlink" title="nodejs 事件循环"></a>nodejs 事件循环</h4><p>nodejs 的事件循环主要分为 6 个阶段：</p><ul><li>timers 阶段：这个阶段执行 timer（setTimeout、setInterval）的回调</li><li>I&#x2F;O callbacks：执行一些系统调用错误，比如网络通信的错误回调</li><li>idle,prepare：仅 node 内部使用</li><li>poll：获取新的 I&#x2F;O 事件, 适当的条件下 node 将阻塞在这里<br>1）有到期的定时器，执行定时器回调<br>2）处理 poll 队列：<ul><li>若队列为空：有 setImmediate 方法时 poll 阶段停止进入 check，执行回调；无 setImmediate 方法时等待新事件</li><li>若队列不为空：遍历回调队列并同步执行</li></ul></li><li>check：执行 setImmediate() 的回调</li><li>close callbacks：执行 socket 的 close 事件回调</li></ul><p><img src="/unknown404.github.io/img/eventLoop.jpeg"></p><p>事件循环的 6 个阶段中，我们只关心 4 个阶段的队列：timer queue、IO queue、check queue、close queue，这 4 个队列的回调都是宏任务。同时还有 2 个微任务队列：Promise queue 和 nextTick queue。<br>如上图的流程所示：</p><ul><li>事件循环依次进入并执行 timer queue、IO queue、check queue、close queue。事件循环进入下一阶段前，都需要先清空微任务队列。</li><li>每个宏任务执行完，都需要检查微任务队列是否有任务，如果有微任务，则先清空微任务，再执行下一个宏任务。</li><li>在 node 11 以前，每个阶段都需要先执行完宏任务，切换到下一阶段前，才会清空微任务队列。</li><li>微任务队列中，nextTick 的优先级比 Promise 高。微任务队列的执行，首先是检查 process.nextTick 队列，只有 process.nextTick 队列全部清空后,再检查 promise 队列；promise 队列全部清空后，再检查 process.nextTick 队列。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;同步&quot;</span>);<br><br>process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;nextTick&quot;</span>);<br>&#125;);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;微任务&quot;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 到达可执行条件才会执行，与</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;setTimeout&quot;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// poll之后会立即检查是否有setImmediate，如果存在就立即执行</span><br><span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;setImmediate&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>打印结果为：同步 - nextTick - 微任务 - setTimeout - setImmediate</p><h4 id="Node-和浏览器事件循环机制的区别"><a href="#Node-和浏览器事件循环机制的区别" class="headerlink" title="Node 和浏览器事件循环机制的区别"></a>Node 和浏览器事件循环机制的区别</h4><ul><li>浏览器事件循环会在宏任务结束后，检查微任务。而 Node 的微任务是在两个阶段之间执行。</li><li>node 的 process.nextTick 要高于其他微任务优先级。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/6941194115392634888">「2021」高频前端面试题汇总之 JavaScript 篇（下）</a></p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动端开发的踩坑经历</title>
    <link href="/unknown404.github.io/2022/06/18/mobileBrowser/"/>
    <url>/unknown404.github.io/2022/06/18/mobileBrowser/</url>
    
    <content type="html"><![CDATA[<p>记录移动端开发时出现的各种兼容性问题。</p><span id="more"></span><h2 id="问题-1-部分模块在-uc-浏览器不显示"><a href="#问题-1-部分模块在-uc-浏览器不显示" class="headerlink" title="问题 1:部分模块在 uc 浏览器不显示"></a>问题 1:部分模块在 uc 浏览器不显示</h2><p><strong>原因</strong>：uc 浏览器内置样式文件，与自定义的样式文件存在覆盖关系。例如如果模块命名为 ad-wrap，则该模块会被强制隐藏。</p><h2 id="问题-2-使用-em-为单位的模块在-qq-浏览器上比例失效"><a href="#问题-2-使用-em-为单位的模块在-qq-浏览器上比例失效" class="headerlink" title="问题 2:使用 em 为单位的模块在 qq 浏览器上比例失效"></a>问题 2:使用 em 为单位的模块在 qq 浏览器上比例失效</h2><p><strong>原因</strong>：父元素的 font-size 的赋值问题。有的浏览器会存在最小 font-size，小于该阈值则设置无效。qq 浏览器下 font-size 最小 8px，所以父元素的 font-size 的设置不能小于 8px</p><p><del>如果不是老项目的旧样式太多太难改了还是尽可能的用 vw 吧</del></p><h2 id="问题-3-输入框使用-keydown-enter-时回车操作键盘不会隐藏、对展示搜索结果有影响"><a href="#问题-3-输入框使用-keydown-enter-时回车操作键盘不会隐藏、对展示搜索结果有影响" class="headerlink" title="问题 3:输入框使用@keydown.enter 时回车操作键盘不会隐藏、对展示搜索结果有影响"></a>问题 3:输入框使用@keydown.enter 时回车操作键盘不会隐藏、对展示搜索结果有影响</h2><p><strong>原因</strong>：不明<br><strong>解决方式</strong>：使用 ref 方法，改为监听 keyup 事件，如果监听到 event.keyCode &#x3D;&#x3D; 13 进行后续操作，同时在之前的回调函数中增加 this.$refs.searchInput.blur()手动失焦</p><p><em>备注：开了新页面整理这些问题，这个文章内容不再更新</em></p>]]></content>
    
    
    <categories>
      
      <category>踩坑经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React</title>
    <link href="/unknown404.github.io/2022/06/09/React/"/>
    <url>/unknown404.github.io/2022/06/09/React/</url>
    
    <content type="html"><![CDATA[<p>前端 react 框架方面知识整理。</p><span id="more"></span><h2 id="React-相关基本概念"><a href="#React-相关基本概念" class="headerlink" title="React 相关基本概念"></a>React 相关基本概念</h2><h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><h4 id="JSX-定义"><a href="#JSX-定义" class="headerlink" title="JSX 定义"></a>JSX 定义</h4><p>一个类似于 XML 的 JavaScript 的语法扩展。用 js 语法表示 UI 的类模版语言，用于创建虚拟 DOM。</p><p>JSX 的本质是 React.createElement(component, props, …children)方法的语法糖。通过 babel 可以将 jsx 文件转为 React.createElement</p><h4 id="JSX-语法特点"><a href="#JSX-语法特点" class="headerlink" title="JSX 语法特点"></a>JSX 语法特点</h4><ul><li>只能有一个根元素</li><li>存在多行 dom 内容时，可以将内容包裹在括号中</li><li>标签首字母：<br>如果是小写字母开头，React 则将改标签转为 html 中同名元素，若 html 没有同名标签，则报错<br>如果是大写字母开头，React 就去渲染对应的组件，若组件没有定义，则报错</li><li>样式的类名指定不用 class，要用 className；style 内部样式属性也同样用 camelCase（小驼峰命名）来定义。这是因为 jsx 本质不是 html</li><li>{}中不能写 JS 语句</li></ul><h3 id="受控组件和非受控组件"><a href="#受控组件和非受控组件" class="headerlink" title="受控组件和非受控组件"></a>受控组件和非受控组件</h3><p>受控组件：表单组件如<code>&lt;input&gt;&lt;select&gt;&lt;textearea&gt;</code>等元素受外部数据源 state 控制，更新只能通过 onChange 事件内部设置 setState()来更新。<br>非受控组件：表单组件是通过使用 ref 来从 DOM 节点中获取表单数据、defaultValue 设置初始值。</p><p>根据 React 官方文档，绝大部分时候推荐使用受控组件来实现表单，因为在受控组件中，表单数据由 React 组件负责处理；如果选择受受控组件的话，表单数据就由 DOM 本身处理。</p><p>实际工作中，仅用于单次表单提交、提交时校验的情况使用非受控组件即可，其特点是更方便快捷，代码量小，但是控制能力比较弱。涉及对数据进行即时校验，格式化输入数据等需求，受控组件更适合使用，其控制能力强，但是代码量会比较多。在开发中应该权衡需求，进度进行相应的选择。</p><h3 id="单向数据流的优缺点"><a href="#单向数据流的优缺点" class="headerlink" title="单向数据流的优缺点"></a>单向数据流的优缺点</h3><p>优点：<br>数据流从上到下非常清晰，状态变化容易预测，易于调试。可避免副作用，例如数据可以在多个组件之间随意修改，可能导致的状态的不一致性。<br>缺点：<br>如果数据需要跨层级传递，可能会出现大量属性传递，代码繁琐，也会导致不必要的渲染。<br>如果数据传递不存在父子关系，组件的通信会变得复杂。</p><h3 id="react-组件重新渲染的方式"><a href="#react-组件重新渲染的方式" class="headerlink" title="react 组件重新渲染的方式"></a>react 组件重新渲染的方式</h3><ol><li>state 改变</li><li>props 改变</li><li>forceUpdate</li><li>父组件重新渲染（即使传入子组件的 props 未发生变化，那么子组件也会重新渲染）</li></ol><h3 id="虚拟-DOM"><a href="#虚拟-DOM" class="headerlink" title="虚拟 DOM"></a>虚拟 DOM</h3><h4 id="虚拟-DOM-实现原理"><a href="#虚拟-DOM-实现原理" class="headerlink" title="虚拟 DOM 实现原理"></a>虚拟 DOM 实现原理</h4><p>从本质上来说，Virtual Dom 是一个 JavaScript 对象，通过对象的方式来表示 DOM 结构。将页面的状态抽象为 JS 对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次 DOM 修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改 DOM 的重绘重排次数，提高渲染性能。</p><h4 id="虚拟-DOM-优缺点"><a href="#虚拟-DOM-优缺点" class="headerlink" title="虚拟 DOM 优缺点"></a>虚拟 DOM 优缺点</h4><p>优点：</p><ol><li>保证性能下限<br>在回流、重绘的情况下，真实 DOM 操作需要重建所有的 DOM，而虚拟 DOM 操作可以用 diff 算法统一更新必要的 DOM<br>Virtual DOM 的更新 DOM 的准备工作耗费更多的时间，也就是 JS 层面，相比于更多的 DOM 操作它的消费是极其便宜的。</li><li>可以跨平台</li><li>无需手动操作 DOM</li></ol><p>缺点：</p><ol start="4"><li>无法极致优化</li></ol><h4 id="React-diff-算法原理"><a href="#React-diff-算法原理" class="headerlink" title="React diff 算法原理"></a>React diff 算法原理</h4><ul><li>真实的 DOM 首先会映射为虚拟 DOM；</li><li>当虚拟 DOM 发生变化后，就会根据差距计算生成 patch，这个 patch 是一个结构化的数据，内容包含了增加、更新、移除等；</li><li>根据 patch 去更新真实的 DOM，反馈到用户的界面上。</li></ul><p>在 React16 之前，React 是直接递归比较 vdom 的，setState 会触发重新渲染，对比渲染出的新旧 vdom，对差异部分进行 dom 操作。<br>在 React16 之后，为了优化性能，会先把 vdom 转换成 fiber，也就是从树转换成链表，然后再渲染。整体渲染流程分成了两个阶段：</p><p><strong>reconciliation 阶段</strong>：从 vdom 转换成 fiber，并且对需要 dom 操作的节点打上 effectTag 的标记，通过 requestIdleCallback 或 Scheduler 分片执行<br><strong>commit 阶段</strong>：对有 effectTag 标记的 fiber 节点进行 dom 操作，并执行所有的 effect 副作用函数。这个阶段是同步的，不可中断，以保证最终的更新操作能应用到实际的 DOM 中。</p><p>从 vdom 转成 fiber 的过程叫做 reconcile（调和），这个过程是可以打断的，由 scheduler 调度执行。</p><p>React 的 diff 算法是分成两次遍历的：<br><strong>第一轮遍历</strong>，一一对比 vdom 和老的 fiber，如果 key 和 type 相同则认为该节点可以复用、处理下一个节点，否则就结束遍历。<br>如果所有的新的 vdom 处理完了，那就把剩下的老 fiber 节点删掉就行。<br>如果还有 vdom 没处理，那就进行第二次遍历；<br><strong>第二轮遍历</strong>，主要是解决节点移动的问题：遍历新的 vdom 节点，每一个都去看看这个节点在旧 fiber 链中的位置（旧位置），如果旧位置在最新固定节点的右边，说明这个节点位置不变，就是可复用，移动过来打上更新的标记，并成为新的固定节点；如果旧位置在最新固定节点的左边，当前这个节点的位置要往右挪。最后把剩下的老 fiber 删掉，剩下的新 vdom 新增。</p><h4 id="React-列表渲染为什么要用-key？"><a href="#React-列表渲染为什么要用-key？" class="headerlink" title="React 列表渲染为什么要用 key？"></a>React 列表渲染为什么要用 key？</h4><p>diff 算法中通过 tag 和 key 来判断是否是同一个节点，因此必须用 key。且<br><a href="https://juejin.cn/post/7099745927413366797">key 值最好不是 index</a>，因为列表依赖的数据长度可能会变化，而使用 index 作为 key 不能表征数据的变化，影响性能；在列表结构内部使用其他元素如 input 时 diff 算法会认为其没有发生变化，因此内部的数据也不会更新<br>key 值也不能是 random、不然会增加 diff 计算量<br>总结：</p><ol><li>减小 diff 算法计算量，提升渲染性能</li><li>避免列表项有状态的组件状态混乱</li></ol><h2 id="React-并发机制"><a href="#React-并发机制" class="headerlink" title="React 并发机制"></a>React 并发机制</h2><p>允许 React 在渲染过程中根据任务的优先级进行调度和中断，从而确保高优先级的更新能够及时渲染</p><h3 id="并发机制工作原理"><a href="#并发机制工作原理" class="headerlink" title="并发机制工作原理"></a>并发机制工作原理</h3><ul><li>时间分片</li><li>可中断渲染</li><li>优先调度</li></ul><h3 id="并发启用方式"><a href="#并发启用方式" class="headerlink" title="并发启用方式"></a>并发启用方式</h3><p>要在 React 应用中启用并发模式，需要使用 createRoot API</p><h2 id="React-事件机制"><a href="#React-事件机制" class="headerlink" title="React 事件机制"></a>React 事件机制</h2><h3 id="事件机制特点（以-react-16-为例）"><a href="#事件机制特点（以-react-16-为例）" class="headerlink" title="事件机制特点（以 react 16 为例）"></a>事件机制特点（以 react 16 为例）</h3><ol><li>在 jsx 文件中 onClick 或 onChange 绑定的事件处理函数,根本就没有注册到真实的 dom 上。是绑定在 document 上（react 17 以后是根节点上）统一管理的。</li><li>真实的 dom 上的 click 事件被单独处理,已经被 react 底层替换成空函数。</li><li>react 绑定的事件如 onChange，在 document 上，可能有多个事件与之对应。</li><li>react 并不是一开始，把所有的事件都绑定在 document 上，而是采取了一种按需绑定，比如发现了 onClick 事件,再去绑定 document click 事件。</li></ol><p>总结：采用了合成事件，即将浏览器的原生事件统一封装，暴露给组件以保持一致的事件接口；以事件委托的方式处理事件，即在根节点（如 document 或根 DOM 节点）上监听所有事件</p><h3 id="事件机制流程"><a href="#事件机制流程" class="headerlink" title="事件机制流程"></a>事件机制流程</h3><h4 id="注册合成事件"><a href="#注册合成事件" class="headerlink" title="注册合成事件"></a>注册合成事件</h4><p>构建初始化 React 合成事件和原生事件的对应关系，合成事件和对应的事件处理插件关系。</p><h4 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h4><ol><li>react dom 对应的 fiber 会在 memoizedProps 和 pendingProps 保存事件</li><li>diff 阶段如果判断是 react 合成事件，则会按照事件系统逻辑单独处理。</li><li>根据 React 合成事件类型，找到对应的原生事件的类型，然后调用判断原生事件类型，大部分事件都按照冒泡逻辑处理，少数事件会按照捕获逻辑处理（比如 scroll 事件）。</li><li>调用 addTrappedEventListener 进行真正的事件绑定，绑定在 document 上，dispatchEvent 为统一的事件处理函数。</li></ol><h4 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h4><ol><li>以触发点击事件为例，首先执行的是 dispatchEvent 函数，该函数包括的操作有：<br>1）根据真实的事件源对象，找到 e.target 真实的 dom 元素。<br>2）根据 dom 元素，找到与它对应的 fiber 对象 targetInst，在我们 demo 中，找到 button 按钮对应的 fiber。<br>3）进入 react 的 legacy 模式，在这个模式下，批量更新。</li><li>执行事件对应的处理插件中的 extractEvents，模拟事件捕获-&gt;事件源-&gt;事件冒泡这一过程。具体操作：<br>1）形成合成事件源对象<br>2）每次 React 会从事件源开始，从上遍历类型为 hostComponent 即 dom 类型的 fiber,判断 props 中是否有当前事件比如 onClick,对于冒泡阶段的事件(onClick)，将 push 到执行队列后面 ， 对于捕获阶段的事件(onClickCapture)，将 unShift 到执行队列的前面。最终形成一个事件执行队列。<br>3）将事件执行队列，保存到 React 事件源对象上。等待执行。</li><li>runEventsInBatch 执行事件队列，如果发现阻止冒泡，那么 break 跳出循环，最后重置事件源，放回到事件池中，完成整个流程。</li></ol><h3 id="React-事件-vs-原生事件"><a href="#React-事件-vs-原生事件" class="headerlink" title="React 事件 vs 原生事件"></a>React 事件 vs 原生事件</h3><p>1）事件名称命名方式：原生事件为全小写，react 事件采用小驼峰<br>2）事件函数处理语法：原生事件为字符串，react 事件为函数<br>3）默认行为处理：react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用 preventDefault()来阻止默认行为<br>4）执行时机：两种事件同时存在时，如果合成事件和原生事件绑定在同一个元素上，会先执行原生事件，再执行 react 合成事件，因为 React 的合成事件绑定在父节点上（事件委托），而原生事件直接绑定在元素上；如果合成事件绑定在 React 组件中，而原生事件绑定在其父元素上，合成事件会先触发，因为 React 的事件委托机制优先处理合成事件。<br>5）阻止冒泡行为的影响：原生事件（阻止冒泡）会阻止合成事件的执行，react 合成事件（阻止冒泡）不会阻止原生事件的执行</p><h3 id="react-使用合成事件的优点"><a href="#react-使用合成事件的优点" class="headerlink" title="react 使用合成事件的优点"></a>react 使用合成事件的优点</h3><ol><li>兼容所有浏览器，更好的跨平台；</li><li>将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。</li><li>方便 react 统一管理和事务机制。</li></ol><h2 id="React-Fiber"><a href="#React-Fiber" class="headerlink" title="React Fiber"></a>React Fiber</h2><p>React Fiber 并不是真正意义上的纤程（微线程、协程），而是一种基于浏览器的单线程调度算法：在这个过程中，React 渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。该算法依赖 requestIdleCallback（在一帧时间 16ms (1000ms &#x2F; 60)内，如果浏览器处理完包括用户输入、js 执行、动画、布局、绘制的任务之后，还有盈余时间，浏览器就会调用 requestIdleCallback 的回调）。</p><p>React V15 在渲染时，会递归比对 VirtualDOM 树，找出需要变动的节点，然后同步更新它们。在这个过程期间更新不能中断， 由于 React 占据着浏览器资源，用户触发的事件无法得到响应，导致用户感觉到卡顿。</p><p>而 Fiber 是一种将 reconciliation （递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢复。</p><h3 id="为什么-react-需要-fiber-，vue-不需要？"><a href="#为什么-react-需要-fiber-，vue-不需要？" class="headerlink" title="为什么 react 需要 fiber ，vue 不需要？"></a>为什么 react 需要 fiber ，vue 不需要？</h3><ul><li>react 更新组件，自顶向下，该组件以及它的子组件全部需要渲染。 vue 更新组件，通过 get、set 准确定位到视图</li><li>react 因为先天的不足——无法精确更新，所以需要 react fiber 把组件渲染工作切片；而 vue 基于数据劫持，更新粒度很小，没有这个压力；</li><li>react fiber 这种数据结构使得节点可以回溯到其父节点，只要保留下中断的节点索引，就可以恢复之前的工作进度</li></ul><h2 id="React-class-组件"><a href="#React-class-组件" class="headerlink" title="React class 组件"></a>React class 组件</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="/unknown404.github.io/img/life-cycle-detail.jpeg"><br>react 16.4 以上的生命周期如图所示，列举了常用的生命周期函数，主要分为 3 个阶段</p><h4 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h4><ul><li><strong>constructor</strong>：进行 state 的初始化，给事件处理方法绑定 this</li><li><strong>getDerivedStateFromProps</strong>：静态方法，会返回一个对象用于更新 state、或者返回 null 不更新。在接收到新的 props 或者调用了 setState 和 forceUpdate 时该函数会被调用。</li><li><strong>render</strong>：纯函数，根据 state 和 props 渲染组件。可返回的内容包括原生的 DOM、React 组件、Fragment、Portals、字符串和数字、Boolean 和 null 等</li><li><strong>componentDidMount</strong>：组件挂载完成后调用，可以进行以下操作：</li></ul><ol><li>执行依赖于 DOM 的操作；</li><li>发送网络请求；（官方建议）</li><li>添加订阅消息；（会在 componentWillUnmount 取消订阅）</li></ol><h4 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h4><p>当组件的 props 改变了，或组件内部调用了 setState&#x2F;forceUpdate，会触发更新重新渲染，这个过程可能会发生多次。</p><ul><li><strong>getDerivedStateFromProps</strong></li><li><strong>shouldComponentUpdate</strong>：有两个参数 nextProps 和 nextState，表示新的属性和变化之后的 state，返回一个布尔值，true 表示会触发重新渲染，false 表示不会触发重新渲染，默认返回 true,我们通常利用此生命周期来优化 React 程序性能</li><li><strong>render</strong></li><li><strong>getSnapshotBeforeUpdate</strong>：该函数有两个传入参数 prevProps 和 prevState，表示之前的属性和之前的 state，这个函数有一个返回值，会作为第三个参数传给 componentDidUpdate，通常默认会返回 null。此生命周期函数必须与 componentDidUpdate 搭配使用</li><li><strong>componentDidUpdate</strong>：该函数有 3 个传入参数 prevProps、prevState 和 snapshot。可以用于当组件更新后，对 DOM 进行操作或者 props 变化时执行网络请求</li></ul><h4 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h4><ul><li><strong>componentWillUnmount</strong>：主要操作包括</li></ul><ol><li>清除 timer，取消网络请求或清除</li><li>取消在 componentDidMount() 中创建的订阅等<br>这个生命周期在一个组件被卸载和销毁之前被调用，因此你不应该再这个方法中使用 setState。</li></ol><h3 id="废弃的生命周期"><a href="#废弃的生命周期" class="headerlink" title="废弃的生命周期"></a>废弃的生命周期</h3><h4 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a>componentWillMount</h4><p>在挂载阶段 render() 之前调用。可以使用 componentDidMount 和 constructor 来代替</p><h4 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a>componentWillReceiveProps</h4><p>props 更新时调用此方法用于更新 state。会破坏 state 数据的单一数据源，导致组件状态变得不可预测，另一方面也会增加组件的重绘次数。如果在 componentWillReceiveProps 生命周期直接调用父组件的某些有调用 setState 的函数，会导致程序死循环。可以使用 getDerivedStateFromProps 来代替</p><h4 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a>componentWillUpdate</h4><p>在更新阶段组件渲染 render()之前调用，通常，此方法可以替换为 componentDidUpdate()和 getSnapshotBeforeUpdate()。</p><p>对于异步渲染情况，渲染可分为两个阶段：reconciliation 和 commit 。前者过程是可以打断的，后者不能暂停，会一直更新界面直到完成。</p><table><thead><tr><th align="center">Reconciliation 阶段</th><th align="center">Commit 阶段</th></tr></thead><tbody><tr><td align="center">componentWillMount</td><td align="center">componentDidMount</td></tr><tr><td align="center">componentWillReceiveProps</td><td align="center">componentDidUpdate</td></tr><tr><td align="center">shouldComponentUpdate</td><td align="center">componentWillUnmount</td></tr><tr><td align="center">componentWillUpdate</td><td align="center"></td></tr></tbody></table><p>因为 Reconciliation 阶段是可以被打断的，所以 Reconciliation 阶段会执行的生命周期函数就可能会出现调用多次的情况，从而引起 Bug。由此对于 Reconciliation 阶段调用的几个函数，除了 shouldComponentUpdate 以外，其他都应该避免去使用。</p><h3 id="适合做异步请求的生命周期"><a href="#适合做异步请求的生命周期" class="headerlink" title="适合做异步请求的生命周期"></a>适合做异步请求的生命周期</h3><p>componentDidmount</p><h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><h4 id="setState-用法"><a href="#setState-用法" class="headerlink" title="setState 用法"></a>setState 用法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">setState</span>(object nextState[, <span class="hljs-keyword">function</span> callback])<br></code></pre></td></tr></table></figure><p>传入的参数包括：</p><ul><li>nextState，对象属性。将要设置的新状态，该状态会和当前的 state 合并</li><li>callback，回调函数。可选参数。该函数会在 setState 设置成功，且组件重新渲染后调用。等价于在 componentDidUpdate 生命周期内执行。在这个回调函数中你可以拿到更新后 state 的值。</li></ul><h4 id="setState-调用流程"><a href="#setState-调用流程" class="headerlink" title="setState 调用流程"></a>setState 调用流程</h4><p>setState 方法会将将新的 state 放进组件的状态队列里，等待合适的时机，批量更新 state，重新构建 React 元素树并且着手重新渲染整个 UI 界面。</p><h4 id="setState-同步还是异步"><a href="#setState-同步还是异步" class="headerlink" title="setState 同步还是异步"></a>setState 同步还是异步</h4><p>setState 并不是单纯同步&#x2F;异步的，它的表现会因调用场景的不同而不同。在源码中，通过 isBatchingUpdates 来判断 setState 是先存进 state 队列还是直接更新，如果值为 true 则执行异步操作，为 false 则直接更新。</p><p>“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值。</p><p>异步： 在 React 可以控制的地方，就为 true，比如在 React 生命周期事件和合成事件中，都会走合并操作，延迟更新的策略。<br>同步： 在 React 无法控制的地方，比如原生事件，具体就是在 addEventListener 、setTimeout、setInterval 等事件中，就只能同步更新。</p><h2 id="React-函数组件"><a href="#React-函数组件" class="headerlink" title="React 函数组件"></a>React 函数组件</h2><h3 id="hook-原理"><a href="#hook-原理" class="headerlink" title="hook 原理"></a>hook 原理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// react-reconciler/src/ReactFiberHooks.js</span><br><span class="hljs-keyword">export</span> type <span class="hljs-title class_">Hook</span> = &#123;<br>  <span class="hljs-attr">memoizedState</span>: any, <span class="hljs-comment">// 最新的状态值</span><br>  <span class="hljs-attr">baseState</span>: any, <span class="hljs-comment">// 初始状态值，如`useState(0)`，则初始值为0</span><br>  <span class="hljs-attr">baseUpdate</span>: <span class="hljs-title class_">Update</span>&lt;any, any&gt; | <span class="hljs-literal">null</span>,<br>  <span class="hljs-attr">queue</span>: <span class="hljs-title class_">UpdateQueue</span>&lt;any, any&gt; | <span class="hljs-literal">null</span>, <span class="hljs-comment">// 临时保存对状态值的操作，更准确来说是一个链表数据结构中的一个指针</span><br>  <span class="hljs-attr">next</span>: <span class="hljs-title class_">Hook</span> | <span class="hljs-literal">null</span>,  <span class="hljs-comment">// 指向下一个链表节点</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>hooks 的实现就是基于 fiber 的，会在 fiber 节点上放一个链表，节点的结构如上面的 Hook 所示。React Hooks 是用链表来保存状态的，memoizedState 属性保存的实际上是这个链表的头指针。<br>每个 useXxx 的 hooks 都有 mountXxx 和 updateXxx 两个阶段，mount 阶段在节点的 memorizedState 属性上存放了对应的数据，然后 update 阶段使用不同的 hooks api 使用对应的数据来完成更新的功能。较为简单的钩子函数如 useRef、useCallback、useMemo，它们只是对值做了缓存；而复杂的钩子如 useState、useEffect 则会涉及 fiber 的空闲调度</p><p>总结：React Hooks 的状态和副作用绑定在 Fiber 节点 上，Fiber 控制 Hooks 在组件中以固定顺序调用</p><h3 id="class-与-hook-区别"><a href="#class-与-hook-区别" class="headerlink" title="class 与 hook 区别"></a>class 与 hook 区别</h3><p><strong>类组件</strong>的根基是 OOP（面向对象编程），所以它有继承、有属性、有内部状态的管理。<br><strong>函数组件</strong>的根基是 FP，也就是函数式编程。它属于“结构化编程”的一种，与数学函数思想类似。也就是假定输入与输出存在某种特定的映射关系，那么输入一定的情况下，输出必然是确定的。</p><ul><li>类组件是可以实现继承的，而函数组件缺少继承的能力。继承比较黑盒，不建议采用。组合优于继承</li><li>类组件 this 模糊性</li><li>函数式组件写法简单，无生命周期函数，类组件划分了明确的生命周期</li><li>类组件在涉及状态管理时代码会显得很复杂，函数式相比之下简单点</li></ul><h3 id="useState-要使用数组而不是对象"><a href="#useState-要使用数组而不是对象" class="headerlink" title="useState 要使用数组而不是对象"></a>useState 要使用数组而不是对象</h3><p>数组解构可以重命名</p><ul><li>如果 useState 返回的是数组，那么使用者可以对数组中的元素命名，代码看起来也比较干净</li><li>如果 useState 返回的是对象，在解构对象的时候必须要和 useState 内部实现返回的对象同名，想要使用多次的话，必须得设置别名才能使用返回值</li></ul><h3 id="为何-Hooks-不能放在条件或循环之内？"><a href="#为何-Hooks-不能放在条件或循环之内？" class="headerlink" title="为何 Hooks 不能放在条件或循环之内？"></a>为何 Hooks 不能放在条件或循环之内？</h3><p>React 内部在执行函数组件时，会维护一个“Hook 调用栈”（本质上是一个数组）。每次组件重新渲染时，React 会根据调用顺序，把 hooks[0] 赋给第一个 useState，hooks[1] 赋给第二个。顺序一旦变了，整个状态系统就乱了。</p><h2 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h2><h3 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h3><p>父组件-&gt;子组件：通过 props 传递数据给子组件<br>子组件-&gt;父组件：子组件通过调用父组件传来的函数传递数据给父组件</p><h3 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h3><p>可以通过共同的父组件来管理状态和事件函数。比如说其中一个兄弟组件调用父组件传递过来的事件函数修改父组件中的状态，然后父组件将状态传递给另一个兄弟组件。</p><h3 id="跨多层次组件通信"><a href="#跨多层次组件通信" class="headerlink" title="跨多层次组件通信"></a>跨多层次组件通信</h3><p>可以使用 Context API</p><ul><li>React.createContext 会创建一个 Context 对象，每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。Provider 接收一个 value 属性，传递给消费组件。</li><li>Context 对象的 Consumer 组件可以接收当前的 context 值，并返回一个 React 节点。传递给函数的 value 值等价于组件树上方离这个 context 最近的 Provider 提供的 value 值。如果没有对应的 Provider，value 参数等同于传递给 createContext() 的 defaultValue。</li><li>挂载在 class 上的 contextType 属性可以赋值为由 React.createContext() 创建的 Context 对象。此属性可以让你使用 this.context 来获取最近 Context 上的值。</li></ul><h3 id="任意组件"><a href="#任意组件" class="headerlink" title="任意组件"></a>任意组件</h3><p>可以通过 Redux 或者 Event Bus 解决，另外如果你不怕麻烦的话，可以使用这种方式解决上述所有的通信情况</p><h2 id="React-生态"><a href="#React-生态" class="headerlink" title="React 生态"></a>React 生态</h2><h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><ul><li>state：数据源存放位置</li><li>action：定义分发行为</li><li>dispatch：分发 action 的函数</li><li>reducer：处理 action 的函数，返回新的 state</li></ul><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ul><li>首先，用户（通过 View）发出 Action，发出方式就用到了 dispatch 方法</li><li>然后，Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action，Reducer 会返回新的 State</li><li>State—旦有变化，Store 就会调用监听函数，通过 mapStateToProps 将新 state 传给组件来更新 View</li></ul><p>Redux 实现示例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs JSX"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Provider</span>, connect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">let</span> &#123; text, click, clickR &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>;<br>        <span class="hljs-keyword">return</span>(<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>数据:已有人&#123;text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;click&#125;</span>&gt;</span>加人<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;clickR&#125;</span>&gt;</span>减人<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> initialState = &#123;<br>    <span class="hljs-attr">text</span>:<span class="hljs-number">5</span><br>&#125;<br><span class="hljs-keyword">const</span> reducer = <span class="hljs-keyword">function</span>(<span class="hljs-params">state,action</span>)&#123;<br>    <span class="hljs-keyword">switch</span>(action.<span class="hljs-property">type</span>)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ADD&#x27;</span>:<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">text</span>:state.<span class="hljs-property">text</span>+<span class="hljs-number">1</span>&#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;REMOVE&#x27;</span>:<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">text</span>:state.<span class="hljs-property">text</span>-<span class="hljs-number">1</span>&#125;<br>        <span class="hljs-attr">default</span>:<br>            <span class="hljs-keyword">return</span> initialState;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable constant_">ADD</span> = &#123;<br>    <span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;ADD&#x27;</span><br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Remove</span> = &#123;<br>    <span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;REMOVE&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(reducer);<br><br><span class="hljs-keyword">let</span> mapStateToProps = <span class="hljs-keyword">function</span> (<span class="hljs-params">state</span>)&#123;<br>    <span class="hljs-keyword">return</span>&#123;<br>        <span class="hljs-attr">text</span>:state.<span class="hljs-property">text</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> mapDispatchToProps = <span class="hljs-keyword">function</span>(<span class="hljs-params">dispatch</span>)&#123;<br>    <span class="hljs-keyword">return</span>&#123;<br>        <span class="hljs-attr">click</span>:<span class="hljs-function">()=&gt;</span><span class="hljs-title function_">dispatch</span>(<span class="hljs-variable constant_">ADD</span>),<br>        <span class="hljs-attr">clickR</span>:<span class="hljs-function">()=&gt;</span><span class="hljs-title function_">dispatch</span>(<span class="hljs-title class_">Remove</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span> = <span class="hljs-title function_">connect</span>(mapStateToProps,mapDispatchToProps)(<span class="hljs-title class_">App</span>);<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span> = <span class="hljs-string">&#123;store&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">App</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">App</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span>,<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure><h4 id="Redux-中异步的请求怎么处理"><a href="#Redux-中异步的请求怎么处理" class="headerlink" title="Redux 中异步的请求怎么处理"></a>Redux 中异步的请求怎么处理</h4><p>使用 react-thunk 中间件</p><ol><li>store 配置中间件</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JSX"><span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-thunk&#x27;</span>;<br><span class="hljs-keyword">import</span> reducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducer&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; createStore, applyMiddleware, combineReducers &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getClientStore</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> defaultState = <span class="hljs-variable language_">window</span>.<span class="hljs-property">__context__</span>.<span class="hljs-property">state</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createStore</span>(reducer, defaultState, <span class="hljs-title function_">applyMiddleware</span>(thunk.<span class="hljs-title function_">withExtraArgument</span>(clientRequest)));<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>添加一个返回 action 的函数，内部调用异步接口</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  发送get请求，并生成相应action，更新store的函数</span><br><span class="hljs-comment">  <span class="hljs-doctag">@param</span> url &#123;string&#125; 请求地址</span><br><span class="hljs-comment">  <span class="hljs-doctag">@param</span> func &#123;function&#125; 真正需要生成的action对应的actionCreator</span><br><span class="hljs-comment">  <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">function</span>&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// dispatch为自动接收的store.dispatch函数</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getHttpAction</span> = (<span class="hljs-params">url, func</span>) =&gt; <span class="hljs-function">(<span class="hljs-params">dispatch</span>) =&gt;</span> &#123;<br>    axios.<span class="hljs-title function_">get</span>(url).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)&#123;<br>        <span class="hljs-keyword">const</span> action = <span class="hljs-title function_">func</span>(res.<span class="hljs-property">data</span>)<br>        <span class="hljs-title function_">dispatch</span>(action)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>分发 action</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JSX"><span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> action = <span class="hljs-title function_">getHttpAction</span>(<span class="hljs-string">&#x27;/getData&#x27;</span>, getInitTodoItemAction)<br>    <span class="hljs-comment">// 发送函数类型的action时，该action的函数体会自动执行</span><br>    store.<span class="hljs-title function_">dispatch</span>(action)<br>&#125;<br></code></pre></td></tr></table></figure><p>react-saga 也是处理异步的中间件，允许你在独立的 saga 文件中集中处理异步逻辑，相比 react-thunk 更适合复杂异步逻辑和流程控制的大型项目。</p><h3 id="DVA"><a href="#DVA" class="headerlink" title="DVA"></a>DVA</h3><p>基于 redux 和 redux-saga 的数据流方案，dva 额外内置了 react-router 和 fetch 简化开发</p><h4 id="相关概念-1"><a href="#相关概念-1" class="headerlink" title="相关概念"></a>相关概念</h4><ul><li>State 数据，通常为一个 JavaScript 对象，操作的时候每次都要当作不可变数据（immutable data）来对待，保证每次都是全新对象，没有引用关系，这样才能保证 State 的独立性，便于测试和追踪变化。</li><li>Action 行为，一个普通 JavaScript 对象，它是改变 State 的唯一途径。</li><li>dispatch，一个用于触发 action 改变 State 的函数。</li><li>Reducer 描述如何改变数据的纯函数，接受两个参数：已有结果和 action 传入的数据，通过运算得到新的 state。</li><li>Effects（Side Effects） 副作用，常见的表现为异步操作。dva 为了控制副作用的操作，底层引入了 redux-sagas 做异步流程控制，由于采用了 generator 的相关概念，所以将异步转成同步写法，从而将 effects 转为纯函数。</li><li>Connect 一个函数，绑定 State 到 View</li></ul><h4 id="实践示例"><a href="#实践示例" class="headerlink" title="实践示例"></a>实践示例</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JSX"><br><span class="hljs-comment">// 创建应用</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">dva</span>();<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">createLoading</span>()) <span class="hljs-comment">// 使用插件</span><br><span class="hljs-comment">// 注册 Model</span><br>app.<span class="hljs-title function_">model</span>(&#123;<br>  <span class="hljs-attr">namespace</span>: <span class="hljs-string">&#x27;count&#x27;</span>,<br>  <span class="hljs-attr">state</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">reducers</span>: &#123;<br>    <span class="hljs-title function_">add</span>(<span class="hljs-params">state</span>) &#123; <span class="hljs-keyword">return</span> state + <span class="hljs-number">1</span> &#125;,<br>  &#125;,<br>  <span class="hljs-attr">effects</span>: &#123;<br>    *<span class="hljs-title function_">addAfter1Second</span>(<span class="hljs-params">action, &#123; call, put &#125;</span>) &#123;<br>      <span class="hljs-keyword">yield</span> <span class="hljs-title function_">call</span>(delay, <span class="hljs-number">1000</span>);<br>      <span class="hljs-keyword">yield</span> <span class="hljs-title function_">put</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;add&#x27;</span> &#125;);<br>    &#125;,<br>  &#125;,<br>&#125;);<br><span class="hljs-comment">// 注册视图</span><br>app.<span class="hljs-title function_">router</span>(<span class="hljs-function">() =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ConnectedApp</span> /&gt;</span></span>);<br><span class="hljs-comment">// 启动应用</span><br>app.<span class="hljs-title function_">start</span>(<span class="hljs-string">&#x27;#root&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="辨析：Redux-vs-DVA"><a href="#辨析：Redux-vs-DVA" class="headerlink" title="辨析：Redux vs DVA"></a>辨析：Redux vs DVA</h4><ul><li>异步实现：Redux 需要借助中间件如 redux-thunk、redux-saga，dva 提供了 effects 函数处理</li><li>路由管理：Redux 不直接处理路由相关的功能，DVA 提供了对路由的内建支持</li><li>管理模型：在 Redux 中，store 和 actions 是应用状态管理的核心，DVA 引入了 model 的概念，将 state、reducers、effects（异步逻辑）和 subscriptions（订阅）集成在一起</li></ul><h3 id="React-SSR"><a href="#React-SSR" class="headerlink" title="React SSR"></a>React SSR</h3><p>代表框架：Next.js<br>特点：服务器端渲染 HTML 字符串并注入数据状态，在首次加载时生成完整页面的 DOM 结构，并在客户端接手后增强交互性。这样不仅能提高 SEO 性能，还改善了页面的首屏渲染体验。</p><h3 id="React-项目优化"><a href="#React-项目优化" class="headerlink" title="React 项目优化"></a>React 项目优化</h3><ul><li>使用 useMemo 缓存变量</li><li>使用 useCallback 缓存函数</li><li>循环添加 key, key 最好用数组项的唯一值，不推荐用 index</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/7068649069610024974">React 事件机制</a><br>（2）<a href="https://juejin.cn/post/6955636911214067720">「react 进阶」一文吃透 react 事件系统原理</a><br>（3）<a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">react 生命周期</a><br>（4）<a href="https://juejin.cn/post/6940942549305524238">「2021」高频前端面试题汇总之 React 篇（下）</a><br>（5）<a href="https://juejin.cn/post/7131741751152214030">图解 React 的 diff 算法：核心就两个字 —— 复用</a><br>（6）<a href="https://juejin.cn/post/6919302952486174733">深入理解 React Diff 算法</a><br>（7）<a href="https://alexjjwu.fun/web/docs/alexwjj/fe-study/">React</a><br>（8）<a href="https://juejin.cn/post/6963466553601835044">一文彻底搞懂 DvaJS 原理</a><br>（9）<a href="https://juejin.cn/post/7075701341997236261">React Hooks 的原理，有的简单有的不简单</a></p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML/CSS</title>
    <link href="/unknown404.github.io/2022/06/07/HTML/"/>
    <url>/unknown404.github.io/2022/06/07/HTML/</url>
    
    <content type="html"><![CDATA[<p>前端 HTML&#x2F;CSS 方面知识整理。</p><span id="more"></span><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="html5-0-新特性"><a href="#html5-0-新特性" class="headerlink" title="html5.0 新特性"></a>html5.0 新特性</h2><ol><li>语义化标签</li><li>拖拽释放 API</li><li>媒体标签</li><li>表单控件</li><li>数据存储 localStorage、sessionStorage</li></ol><h2 id="html5-0-移除特性"><a href="#html5-0-移除特性" class="headerlink" title="html5.0 移除特性"></a>html5.0 移除特性</h2><ol><li>纯表现标签</li><li>产生负面影响标签</li></ol><h2 id="语义化标签特点"><a href="#语义化标签特点" class="headerlink" title="语义化标签特点"></a>语义化标签特点</h2><ol><li>对机器友好，有利于 SEO 和读屏软件解析</li><li>对开发者友好增加可读性</li></ol><h2 id="HTML-元素"><a href="#HTML-元素" class="headerlink" title="HTML 元素"></a>HTML 元素</h2><p>行内元素：多个行内元素可占一行，只能设置 padding、margin 左右<br>块元素：一个块元素占一行，可设置宽高</p><h2 id="src-和-href-区别"><a href="#src-和-href-区别" class="headerlink" title="src 和 href 区别"></a>src 和 href 区别</h2><ol><li>资源类型：src 是资源引用，href 是超文本引用</li><li>解析资源方式：浏览器解析 src 资源时会暂停其他资源下载，直至该资源下载执行完毕；href 时浏览器会并行下载资源，不停止文档解析</li></ol><h2 id="script-标签中-defer-和-async-的区别"><a href="#script-标签中-defer-和-async-的区别" class="headerlink" title="script 标签中 defer 和 async 的区别"></a>script 标签中 defer 和 async 的区别</h2><p><strong>defer</strong>：script 下载不会打断 html 解析，在 html 解析完成之后 script 会按顺序执行<br><strong>async</strong>：script 下载会打断 html 解析，先加载完先执行</p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="css-新特性"><a href="#css-新特性" class="headerlink" title="css 新特性"></a>css 新特性</h2><ol><li>圆角、文字特效、渐变、动画</li><li>选择器 eg. last-child</li><li>媒体查询</li><li>多栏布局</li><li>flex 布局</li></ol><h2 id="css-选择器"><a href="#css-选择器" class="headerlink" title="css 选择器"></a>css 选择器</h2><h3 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h3><p>!important &gt; 内联 &gt; id &gt; class &gt; tag &gt; *</p><h3 id="伪元素-vs-伪类"><a href="#伪元素-vs-伪类" class="headerlink" title="伪元素 vs 伪类"></a>伪元素 vs 伪类</h3><p>伪元素（eg. ::after）：该元素在 dom 树下不存在，仅在 css 下渲染<br>伪类（eg. :hover）：为已存在的元素设置样式</p><h2 id="css-属性相关"><a href="#css-属性相关" class="headerlink" title="css 属性相关"></a>css 属性相关</h2><p><strong>position 属性</strong><br>static：默认<br>absolute：脱离文档流，相对非 static 父元素<br>fixed：脱离文档流，相对浏览器窗口<br>relative：相对原位置定位<br>sticky：须指定 top、left、right、bottom，跨越特定阈值前是 relative，之后是 fixed<br><strong>line-height 属性</strong><br>子元素如何继承父元素 line-height 属性？</p><ol><li>父元素的 line-height 写了具体数值，比如 30px，则子元素 line-height 继承该值。</li><li>父元素的 line-height 写了比例，比如 1.5 或 2，则子元素 line-height 也是继承该比例。</li><li>父元素的 line-height 写了百分比，比如 200%，则子元素 line-height 继承的是父元素 font-size * 200% 计算出来的值。</li></ol><h3 id="animation-和-transition-的区别"><a href="#animation-和-transition-的区别" class="headerlink" title="animation 和 transition 的区别"></a>animation 和 transition 的区别</h3><ul><li>实现方式：<br>transition 是过渡属性，强调过渡，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。<br>animation 是动画属性，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。</li><li>应用场景：<br>transition 用于实现简单的动态效果，例如鼠标悬停在一个元素上时，该元素背景色或透明度的变化。<br>animation 用于实现复杂的动态效果，例如元素的旋转、缩放、平移等复杂变换，以及多个动画状态之间的切换。</li><li>性能：<br>transition 在改变文档流的属性时，会引起页面的回流和重绘，对性能影响比较大。<br>animation 可以结合 keyframe 设置每一帧，但是 transition 只有两帧。</li></ul><h2 id="css-布局"><a href="#css-布局" class="headerlink" title="css 布局"></a>css 布局</h2><h3 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h3><p><strong>容器属性</strong></p><ul><li>flex-direction：主轴方向，默认 row</li><li>flex-wrap：换行方式</li><li>flex-flow：flex-direction 属性和 flex-wrap 属性的简写形式</li><li>justify-content：主轴对齐方式</li><li>align-items：交叉轴对齐方式</li><li>align-content：多轴对齐方式</li></ul><p><strong>item 属性</strong></p><ul><li>order：项目的排列顺序。数值越小，排列越靠前，默认为 0。</li><li>flex-grow：项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。属性都为 1，则它们将等分剩余空间（如果有的话）</li><li>flex-shrink：属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。为 0 时即使空间不足也不缩小</li><li>flex-basis：在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小。</li><li>flex：flex 属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。flex 为 1 时对应 3 个值 1 1 0</li><li>align-self：单个项目有与其他项目不一样的对齐方式</li></ul><h3 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h3><p>宽高用百分比表示<br>子元素属性的百分比相对于父元素的宽：width,margin,padding,left,right<br>子元素属性的百分比相对于父元素的高：height,top,bottom</p><h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><p>利用媒体查询获取屏幕宽高再设置宽度区间</p><h3 id="自适应布局"><a href="#自适应布局" class="headerlink" title="自适应布局"></a>自适应布局</h3><p>根据分辨率创建多个静态布局</p><h3 id="弹性布局"><a href="#弹性布局" class="headerlink" title="弹性布局"></a>弹性布局</h3><p>以 rem 为单位（rem 相对于根元素<code>html</code> font-size，em 相对于父元素 font-size）</p><h3 id="vw-布局"><a href="#vw-布局" class="headerlink" title="vw 布局"></a>vw 布局</h3><p>使用 vw、vh 作为单位</p><h2 id="块级格式化上下文（BFC）"><a href="#块级格式化上下文（BFC）" class="headerlink" title="块级格式化上下文（BFC）"></a>块级格式化上下文（BFC）</h2><p>特点：有独立渲染的区域，子元素不会影响到区域外；2 个块元素在区域内垂直分布；计算高度时浮动元素的高度也代入计算；不与浮动元素重叠<br>触发条件：</p><ol><li>根元素</li><li>overflow 不为 visible</li><li>display 为 inline-block 或 table、flex</li><li>position 为 absolute 或 fixed</li><li>float 不为 none</li></ol><h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><p>存在问题：父元素未设置高度且子元素浮动时父元素高度会坍塌<br>解决方法：</p><ol><li>父元素加高度</li><li>父元素加 float</li><li>父元素 overflow：hidden</li><li>增加 clear：both 空元素</li><li>父元素加伪元素</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span>&#123;<br>    zoom:<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span>&#123;<br>    <span class="hljs-attribute">content</span>:<span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-attribute">display</span>:block;<br>    <span class="hljs-attribute">height</span>:<span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">clear</span>:both;<br>    <span class="hljs-attribute">visibility</span>:hidden;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="外部引入-css-方式：link-vs-import"><a href="#外部引入-css-方式：link-vs-import" class="headerlink" title="外部引入 css 方式：link vs @import"></a>外部引入 css 方式：link vs @import</h2><ol><li>link 是 html 标签，@import 是 css 属性</li><li>link 可设置 rel，@import 只能引入 css</li><li>link 在页面加载时加载，@import 在加载完页面后加载</li><li>link 无兼容问题，@import 支持 IE5 以上</li><li>link 支持 js 控制 dom 改样式，@import 不支持</li></ol><h2 id="css-场景应用"><a href="#css-场景应用" class="headerlink" title="css 场景应用"></a>css 场景应用</h2><h3 id="样式文件内部-px-转-vw"><a href="#样式文件内部-px-转-vw" class="headerlink" title="样式文件内部 px 转 vw"></a>样式文件内部 px 转 vw</h3><ul><li>sass 文件：定义函数，接收参数并且返回计算值<br>eg.将 375px 宽度的设计稿转换成适应屏幕宽度的样式</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@function</span> pxToVW(<span class="hljs-variable">$px</span>) &#123;<br>  <span class="hljs-keyword">@return</span> (<span class="hljs-variable">$px</span>/<span class="hljs-number">375</span>) + vw;<br>&#125;<br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: pxToVW(<span class="hljs-number">36</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>less 文件：</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@windowWidth:</span> <span class="hljs-number">100vw</span>;<br><span class="hljs-selector-class">.rpxToVW</span>(<span class="hljs-variable">@name</span>,<span class="hljs-variable">@rpx</span>) &#123;<br>  <span class="hljs-comment">//传入不带单位的rpx数值，将rpx转为vw</span><br>  @&#123;name&#125;: <span class="hljs-selector-tag">unit</span>(<span class="hljs-variable">@rpx</span> / <span class="hljs-number">750</span> * <span class="hljs-variable">@windowWidth</span>, vw);<br>&#125;<br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-selector-class">.rpxToVW</span>(margin,<span class="hljs-number">20</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="画一个三角形-x2F-扇形"><a href="#画一个三角形-x2F-扇形" class="headerlink" title="画一个三角形&#x2F;扇形"></a>画一个三角形&#x2F;扇形</h3><p>思路：div 的宽高设置为 0，border 的宽度设置大一点，除一边外其余边颜色透明；扇形需要有 border-radius</p><h3 id="宽高自适应的正方形"><a href="#宽高自适应的正方形" class="headerlink" title="宽高自适应的正方形"></a>宽高自适应的正方形</h3><p>width：30vw；height：30vw；</p><h3 id="多行文本溢出"><a href="#多行文本溢出" class="headerlink" title="多行文本溢出"></a>多行文本溢出</h3><p>overflow:hidden;<br>text-overflow:ellipsis;<br>display:-webkit-box;<br>-webkit-box-orient:vertical;<br>-webkit-line-clamp:3;</p><h3 id="居中方式"><a href="#居中方式" class="headerlink" title="居中方式"></a>居中方式</h3><h4 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h4><p>1）行内元素：text-align：center；<br>2）块元素：margin：0 auto；<br>3）position：absolute；left：50%；transform：translateX（-50%）；<br>4）display：flex；justify-content：center；</p><h4 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h4><p>1）单行文本：line-height&#x3D;height<br>2）display：table-cell；vertical-align：middle；<br>3）position：absolute；top：50%；transform：translateY（-50%）；<br>4）display：flex；align-items：center；</p><h4 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h4><p>1）position: absolute; margin：auto；left：0；right：0；top：0；bottom：0；<br>2）position：absolute；left：50%；top：50%；transform：translate（-50%，-50%）；<br>3）display：flex；align-items：center；justify-content：center；</p><h3 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h3><p>1）float+margin<br>2）float+overflow<br>3）grid-template-columns<br>4）flex<br>5）absolute+margin</p><h3 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h3><h3 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#wrapper</span>&#123;<span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;<span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;<span class="hljs-attribute">height</span>:<span class="hljs-number">50px</span>;&#125;<br> <span class="hljs-selector-id">#center</span>&#123;<span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span> <span class="hljs-number">100px</span> <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;&#125;<br> <span class="hljs-selector-id">#left</span>&#123;<span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;<span class="hljs-attribute">margin-left</span>:-<span class="hljs-number">100%</span>;<span class="hljs-attribute">width</span>:<span class="hljs-number">200px</span>;<span class="hljs-attribute">height</span>:<span class="hljs-number">50px</span>;&#125;<br> <span class="hljs-selector-id">#right</span>&#123;<span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;<span class="hljs-attribute">margin-left</span>:-<span class="hljs-number">100px</span>;<span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;<span class="hljs-attribute">height</span>:<span class="hljs-number">50px</span>;&#125;<br></code></pre></td></tr></table></figure><h3 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#parent</span>&#123;<span class="hljs-attribute">height</span>:<span class="hljs-number">50px</span>;<span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span> <span class="hljs-number">100px</span> <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;&#125;<br> <span class="hljs-selector-id">#center</span>&#123;<span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;<span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;<span class="hljs-attribute">height</span>:<span class="hljs-number">50px</span>;&#125;<br> <span class="hljs-selector-id">#left</span>&#123;<span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;<span class="hljs-attribute">margin-left</span>:-<span class="hljs-number">100%</span>;<span class="hljs-attribute">width</span>:<span class="hljs-number">200px</span>;<span class="hljs-attribute">height</span>:<span class="hljs-number">50px</span>;<span class="hljs-attribute">position</span>:relative;<span class="hljs-attribute">left</span>:-<span class="hljs-number">200px</span>;&#125;<br> <span class="hljs-selector-id">#right</span>&#123;<span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;<span class="hljs-attribute">margin-left</span>:-<span class="hljs-number">100px</span>;<span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;<span class="hljs-attribute">height</span>:<span class="hljs-number">50px</span>;<span class="hljs-attribute">position</span>:relative;<span class="hljs-attribute">right</span>:<span class="hljs-number">100px</span>;&#125;<br></code></pre></td></tr></table></figure><h2 id="less-vs-sass"><a href="#less-vs-sass" class="headerlink" title="less vs sass"></a>less vs sass</h2><ul><li>变量定义方式不同：less 使用 @开头，sass 使用 $开头</li><li>循环和条件语句：sass 支持的内容更完整</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>表单提交功能的注意事项</title>
    <link href="/unknown404.github.io/2022/06/05/formSubmit/"/>
    <url>/unknown404.github.io/2022/06/05/formSubmit/</url>
    
    <content type="html"><![CDATA[<p>表单提交的操作可以被多个元素触发，包括 input、button、回车键等，需要辨析其中的区别。</p><span id="more"></span><h2 id="input-type-x3D-”submit”"><a href="#input-type-x3D-”submit”" class="headerlink" title="input[type&#x3D;”submit”]"></a>input[type&#x3D;”submit”]</h2><p>如果将 input 的 type 设置为 submit 的话，该组件会变成一个按钮。以下面的代码为例：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata">&lt;<span class="hljs-keyword">form</span>&gt;<br>  &lt;<span class="hljs-keyword">input</span> name=<span class="hljs-string">&quot;name&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;提交&quot;</span>&gt;<br>&lt;/<span class="hljs-keyword">form</span>&gt;<br></code></pre></td></tr></table></figure><p>input 的 type 默认值为 text，所以第一个 input 显示为文本框。input 设置 type&#x3D;submit 后，输入控件会变成一个按钮，显示的文字为其 value 值，默认值是 Submit。<br>form 具有属性 method，默认值为 GET，所以提交后会使用 GET 方式进行页面跳转。<br>在上述表单中如果输入 111111 后提交则 url 会变更为&#x2F;?name&#x3D;111111</p><h2 id="button"><a href="#button" class="headerlink" title="button"></a>button</h2><p>button 也具有 type 和 value 属性，除 IE 浏览器以外 type 都默认 submit。所以会触发表单提交。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;name&#x27;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>确定<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="回车提交"><a href="#回车提交" class="headerlink" title="回车提交"></a>回车提交</h2><p>当表单中只有一个单行 input 的时候可以用回车提交。</p><p>以上提交操作都涉及到 URL 的改变，触发页面刷新。如果希望阻止页面的默认提交、自己设计提交逻辑，可以在 form 的 onsubmit 属性对应的函数内部添加<code>e.preventDefault();</code>来阻止页面提交刷新。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>（1）<a href="https://www.yisu.com/zixun/118760.html">html 中 input submit、button 和回车键提交数据的示例分析</a><br>（2）<a href="https://blog.csdn.net/weixin_33974433/article/details/93702424">react 监听 移动端 手机键盘 enter 事件</a></p>]]></content>
    
    
    <categories>
      
      <category>踩坑经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/unknown404.github.io/2022/05/30/networkBasic/"/>
    <url>/unknown404.github.io/2022/05/30/networkBasic/</url>
    
    <content type="html"><![CDATA[<h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><h3 id="网络模型一览"><a href="#网络模型一览" class="headerlink" title="网络模型一览"></a>网络模型一览</h3><table style="text-align:center;">    <tr>         <th>OSI模型</th>      <th>五层模型</th>        <th>TCP/IP模型</th>   </tr>   <tr>       <td>应用层</td>           <td rowspan="3">应用层</td>           <td rowspan="3">应用层</td>   </tr>   <tr>       <td>表示层</td>   </tr>   <tr>       <td>会话层</td>   </tr>   <tr>       <td>传输层</td>           <td>传输层</td>           <td>传输层</td>   </tr>   <tr>       <td>网络层</td>           <td>网络层</td>           <td>网络层</td>   </tr>   <tr>       <td>数据链路层</td>           <td>数据链路层</td>           <td rowspan="2">网络接口层</td>   </tr>    <tr>       <td>物理层</td>           <td>物理层</td>   </tr></table><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>功能：为应用进程提供服务。<br>示例：http、ftp、dns</p><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>特点：无状态、无连接、灵活简单</p><h5 id="HTTP-版本"><a href="#HTTP-版本" class="headerlink" title="HTTP 版本"></a>HTTP 版本</h5><p><strong>HTTP1.0</strong>:默认短连接；支持 get、post；资源全请求；<br><strong>HTTP1.1</strong>:默认长连接（connection 为 keep-alive）；支持 put、options、head；资源可请求部分；请求和响应必包含 host、区分同一主机不同虚拟主机域名<br><strong>HTTP2.0</strong>:<br>1）二进制分帧；<br>2）多路复用：一个连接里客户端和浏览器可同时发送多个请求，无需按顺序一一对应，依赖于二进制分帧头部信息标记自己属于哪个流；<br>3）头部压缩；<br>4）服务器推送；<br><em>（HTTP2.0 存在问题：队头阻塞，出现丢包时整个 TCP 连接等待重传）</em><br><strong>HTTP3.0</strong>:QUIC，基于 UDP，省去握手时间，可多路复用不会队头阻塞</p><h5 id="HTTP-vs-HTTPS"><a href="#HTTP-vs-HTTPS" class="headerlink" title="HTTP vs HTTPS"></a>HTTP vs HTTPS</h5><p>1）安全性：http 明文传送，https 有 SSL 加密<br>2）费用：https 需要 CA 证书<br>3）端口号：http 端口号 80，https 端口号 443</p><h5 id="HTTPS-加密方式"><a href="#HTTPS-加密方式" class="headerlink" title="HTTPS 加密方式"></a>HTTPS 加密方式</h5><p>1）客户端预先向服务端发送其支持的加密协议及版本<br>2）server-client：服务端发送证书和公钥到客户端<br>3）客户端向证书认证机构确认公钥的真实性<br>4）client-server：客户端用公钥加密通话公钥给服务端<br>5）服务端用私钥解密后获得通话公钥<br>6）使用通话密钥对称加密信息</p><h5 id="HTTP-报文格式"><a href="#HTTP-报文格式" class="headerlink" title="HTTP 报文格式"></a>HTTP 报文格式</h5><p>HTTP 请求报文：请求方法+URI+协议版本+请求首部字段+内容<br>HTTP 响应报文：协议版本+状态码+响应首部字段+实体</p><h5 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h5><p>post vs get：<br>1）长度：get 传递大小受 URL 长度限制（来自浏览器），post 可传递更多<br>2）安全性：get 相对于 post 不安全<br>3）缓存：浏览器对 get 请求缓存，post 不会<br>4）幂等性：get 又幂等性，post 没有，post 可能会改写资源<br>5）回退刷新时：get 无影响、post 会再提交</p><h5 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h5><p><strong>1xx</strong>：信息<br>100 - continue<br><strong>2xx</strong>：成功<br>200 - OK<br>204 - no content<br><strong>3xx</strong>：重定向<br>301 - permanently moved<br>302 - found（不会像 301 一样更新书签）<br>304 - not modified<br><strong>4xx</strong>：客户端错误<br>400 - bad request<br>401 - unauthorized<br>403 - forbidden<br>404 - not found<br><strong>5xx</strong>：服务器错误<br>500 - internal error<br>502 - bad gateway</p><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><h5 id="DNS-域名解析"><a href="#DNS-域名解析" class="headerlink" title="DNS 域名解析"></a>DNS 域名解析</h5><p>1）查看本地 hosts 文件是否有映射<br>2）本地 DNS 解析缓存是否有 IP 映射<br>3）查询本地 DNS 服务器<br>4）设置本地 DNS 服务器查询方式：</p><ul><li>转发模式：请求层层上传</li><li>非转发模式：请求直接给根服务器</li></ul><h6 id="DNS-查询方式"><a href="#DNS-查询方式" class="headerlink" title="DNS 查询方式"></a>DNS 查询方式</h6><ul><li>迭代查询：根 DNS 返回给本地 DNS 下一个管理域名的 DNS 地址，让本地 DNS 向该 DNS 查询</li><li>递归查询：DNS 代替主机进行域名查询</li></ul><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>功能：为进程提供数据传输服务<br>示例：udp、tcp</p><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><h5 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h5><p>1）client-server：发送同步序列号 SYN，请求连接<br>2）server-client：收到请求，发送确认应答 SYN+ACK<br>3）client-server：发送确认 ACK，服务端确认后连接建立</p><h5 id="三次握手的原因"><a href="#三次握手的原因" class="headerlink" title="三次握手的原因"></a>三次握手的原因</h5><p>防止失效的请求连接到达服务器</p><h5 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h5><p>1）client-server：客户端发送请求释放报文<br>2）server-client：服务器收到请求，发送确认应答 ACK，客户端不能向服务器发送数据<br>3）server-client：服务器不需要连接、发送请求释放报文 FIN<br>4）client-server：发送确认应答 ACK，等待 2MSL（Maximum Segment Lifetime） 释放连接；服务器释放连接</p><h5 id="四次挥手原因"><a href="#四次挥手原因" class="headerlink" title="四次挥手原因"></a>四次挥手原因</h5><p>服务器收到释放报文的时候还要传数据，不能立即响应</p><h5 id="TCP-可靠性原因"><a href="#TCP-可靠性原因" class="headerlink" title="TCP 可靠性原因"></a>TCP 可靠性原因</h5><ul><li>1.超时重传</li><li>2.确认应答</li><li>3.流量控制：发送窗由接收窗剩余大小决定，发送端收到应答后会移动窗口</li><li>4.拥塞机制：<br>1）慢开始和拥塞避免：初始窗为 1，每经过一次 RTT 翻倍窗口，至阈值时窗口变化由翻倍变为+1；超时后阈值减半、窗口大小恢复初始<br>2）快重传和快恢复：收到 3 个重复确认后立即重传未收到的报文；阈值设为窗口一半，直接拥塞避免算法</li></ul><h5 id="TCP-vs-UDP"><a href="#TCP-vs-UDP" class="headerlink" title="TCP vs UDP"></a>TCP vs UDP</h5><p>1）tcp 面向连接，udp 无连接<br>2）tcp 面向字节流，udp 面向报文<br>3）tcp 点对点，udp 支持一对一、一对多<br>4）tcp 首部至少 20 字节、udp 首部 8 字节<br>5）tcp 可靠交付，udp 不可靠交付</p><p>tcp 支持的协议：telnet、ftp、smtp、http<br>udp 支持的协议：nfs、snmp、dns、tftp</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>功能：为主机提供数据传输服务<br>示例：路由、ip</p><h3 id="数据链层"><a href="#数据链层" class="headerlink" title="数据链层"></a>数据链层</h3><p>功能：将网络层的 IP 数据报封装成帧，在链路节点传输数据</p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>功能：确保数据在物理媒介上传输</p><h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><h3 id="xss-跨站脚本攻击"><a href="#xss-跨站脚本攻击" class="headerlink" title="xss 跨站脚本攻击"></a>xss 跨站脚本攻击</h3><p>将可执行代码注入到网页中<br>分类：<br>1）存储型：作用于数据库<br>2）反射型：作用于 URL<br>3）DOM 型：作用于 js<br>解决方法：<br>1）转义字符<br>2）设置 content-security-policy<br>3）cookie 设置 httpOnly</p><h3 id="CSRF-跨站请求伪造"><a href="#CSRF-跨站请求伪造" class="headerlink" title="CSRF 跨站请求伪造"></a>CSRF 跨站请求伪造</h3><p>诱导用户跳转到三方网站获取到用户跳转前网站的登录态，冒充用户来攻击网站<br>解决方法：<br>1）token、验证码验证<br>2）cookie 的 same-site<br>3）referer 检查</p><p><strong>同源策略可以预防 csrf 吗？</strong></p><p>同源策略可以预防 csrf，但通过跨域方法可以绕过同源策略的限制</p><h3 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h3><p>设置透明按钮诱导用户点击<br>解决方法：<br>1）js 防御：监听到 iframe 点击后将跳转页置空<br>2）设置 X-FRAME-OPTIONS</p><h3 id="DDos-分布式拒绝服务"><a href="#DDos-分布式拒绝服务" class="headerlink" title="DDos 分布式拒绝服务"></a>DDos 分布式拒绝服务</h3><p>伪造大量 IP 发送请求<br>解决方法：<br>1）限制单 IP 请求次数<br>2）缩短超时时间</p><h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><p>中间人截取服务端公钥，伪造证书、密钥给服务器<br>解决方法：<br>1）增加安全信道</p><h2 id="CDN-内容分发网络"><a href="#CDN-内容分发网络" class="headerlink" title="CDN 内容分发网络"></a>CDN 内容分发网络</h2><p>定义：将缓存服务器分布到用户访问集中到地区或网络中，用户访问网站资源时将访问指向最近的缓存服务器 ip<br>A：dns 解析记录里原 ip 映射结果<br>cname：cdn 服务商地址<br>cdn 回源：缓存服务器没有符合请求的资源时会回到源服务器请求资源，缓存后再响应用户</p><p>CDN 保持边缘节点与源站一致主要依赖以下策略：</p><ul><li>缓存失效：通过 Cache-Control、ETag 或 Last-Modified。</li><li>主动刷新：通过 API 或回源策略。</li><li>事件驱动更新：源站通知 CDN 更新。</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器</title>
    <link href="/unknown404.github.io/2022/05/29/browser/"/>
    <url>/unknown404.github.io/2022/05/29/browser/</url>
    
    <content type="html"><![CDATA[<p>浏览器相关知识点。</p><span id="more"></span><h2 id="浏览器存储"><a href="#浏览器存储" class="headerlink" title="浏览器存储"></a>浏览器存储</h2><table><thead><tr><th align="center"></th><th align="center">cookie</th><th align="center">localStorage</th><th align="center">sessionStorage</th><th align="center">indexDB</th></tr></thead><tbody><tr><td align="center">生命周期</td><td align="center">服务器生成，可没过期时间</td><td align="center">一直存在</td><td align="center">会话结束后清理</td><td align="center">一直存在</td></tr><tr><td align="center">存储大小</td><td align="center">4KB</td><td align="center">5MB</td><td align="center">5MB</td><td align="center">无限</td></tr><tr><td align="center">服务端通信</td><td align="center">携带于 header 中</td><td align="center">不参与</td><td align="center">不参与</td><td align="center">不参与</td></tr></tbody></table><h3 id="cookie-属性"><a href="#cookie-属性" class="headerlink" title="cookie 属性"></a>cookie 属性</h3><p><strong>value</strong>：保存用户登录态<br><strong>httpOnly</strong>：js 不可访问<br><strong>secure</strong>：只能 https 携带<br><strong>same-site</strong>：是否允许跨站携带<br><strong>domain</strong>：哪个域的 cookie 是有效的</p><h4 id="辨析：跨域（cross-origin）和跨站（cross-site）的区别"><a href="#辨析：跨域（cross-origin）和跨站（cross-site）的区别" class="headerlink" title="辨析：跨域（cross origin）和跨站（cross site）的区别"></a>辨析：跨域（cross origin）和跨站（cross site）的区别</h4><p>同源是指两个 URL 的协议&#x2F;主机名&#x2F;端口一致。<br>同站只要两个 URL 的 eTLD+1 相同即可，不需要考虑协议和端口。其中，eTLD 表示有效顶级域名，注册于 Mozilla 维护的公共后缀列表（Public Suffix List）中，例如，<code>.com</code>、<code>.co.uk</code>、<code>.github.io</code> 等。eTLD+1 则表示，有效顶级域名+二级域名，例如 <code>taobao.com </code>等。</p><h3 id="cookie-vs-session"><a href="#cookie-vs-session" class="headerlink" title="cookie vs session"></a>cookie vs session</h3><ol><li>存储位置：cookie 在浏览器，session 在服务器</li><li>存储容量：cookie 4KB，session 无理论上限</li><li>存储内容：cookie 只保存 ascii 字符串，session 接受任何字符类型</li><li>隐私策略：cookie 只能在浏览器查看</li><li>有效期：cookie 受 expires、max-age 限制，session 受 sessionId</li></ol><h3 id="浏览器垃圾回收机制"><a href="#浏览器垃圾回收机制" class="headerlink" title="浏览器垃圾回收机制"></a>浏览器垃圾回收机制</h3><p>1）标记清除：进入环境的变量都标记为进入环境，变量所占内存不得释放；离开环境时标记离开环境<br>2）引用计数：变量引用时计数+1，取别的值-1，计数为 0 时释放内存（存在问题：循环引用）</p><h3 id="浏览器缓存位置"><a href="#浏览器缓存位置" class="headerlink" title="浏览器缓存位置"></a>浏览器缓存位置</h3><ol><li><strong>service worker</strong>：浏览器的独立线程，必须 https<br>实现缓存的方式：<br>1）注册 service worker<br>2）监听 install 事件，回调中缓存所需文件<br>3）拦截所有请求事件，查询是否有缓存</li><li><strong>memory cache</strong>：会随进程释放而释放</li><li><strong>disk cache</strong></li><li><strong>push cache</strong>：上述 3 种缓存都未命中时使用，只存在于会话中</li></ol><h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><ol><li>expires：http1.0 产物，格林威治时间</li><li>cache-control：http1.1 产物，max-age 单位 s<br>cache-control其他属性：</li></ol><ul><li>no-cache：浏览器会存储资源，但在下一次访问时会向服务器发起验证请求</li><li>no-store：完全不缓存资源</li></ul><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><ol><li><p>Last-Modified&#x2F;If-Modified-Since：Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。但是如果本地文件被打开，会导致 Last-Modified 被修改</p></li><li><p>ETag&#x2F;If-None-Matched：ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高。适用文件周期查看、内容没变的情况或者资源频繁更新超过秒级情况</p></li></ol><h4 id="刷新操作对缓存内容影响"><a href="#刷新操作对缓存内容影响" class="headerlink" title="刷新操作对缓存内容影响"></a>刷新操作对缓存内容影响</h4><p>正常操作（地址栏输入 url，跳转链接，前进后退等）：强制缓存有效，协商缓存有效。<br>手动刷新（f5，点击刷新按钮，右键菜单刷新）：强制缓存失效，协商缓存有效。<br>强制刷新（ctrl + f5，shift+command+r）：强制缓存失效，协商缓存失效。</p><h2 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h2><p>浏览器一个 tab 就是一个进程</p><h3 id="回流-vs-重绘"><a href="#回流-vs-重绘" class="headerlink" title="回流 vs 重绘"></a>回流 vs 重绘</h3><p>回流：布局或元素几何属性改变<br>重绘：节点更改外观、不影响布局</p><p>重绘不会引起回流，回流一定会导致重绘</p><p>减少回流的方法：<br>1）transform 代替 top<br>2）visibility：hidden 代替 display：none<br>3）不用 table 布局<br>4）避免 css 表达式<br>5）动画选择 requestAnimationFrame</p><h3 id="浏览器从输入-URL-到返回页面的过程"><a href="#浏览器从输入-URL-到返回页面的过程" class="headerlink" title="浏览器从输入 URL 到返回页面的过程"></a>浏览器从输入 URL 到返回页面的过程</h3><p>1）DNS 解析网址<br>2）tcp3 次握手建立连接，发送 http 请求<br>3）解析 html 文件转换为 dom 树<br>4）解析 css 生成 css dom 树<br>5）dom 树和 css dom 树结合生成 render 树（过滤掉 display：none、head、script 等结构）<br>6）根据 render 树布局，gpu 绘制、合成图层，显示在屏幕</p><h4 id="为什么分图层渲染"><a href="#为什么分图层渲染" class="headerlink" title="为什么分图层渲染"></a>为什么分图层渲染</h4><ol><li>某些元素分离到独立图层可以利用 GPU 加速，提高渲染性能（eg. css动画，canvas绘制，webgl）。</li><li>减少重绘</li><li>处理动画：使用 CSS 的 3D 转换或动画时，浏览器通常会将这些元素提升到新的图层，以便更好地处理三维效果。</li></ol><h3 id="浏览器同源策略"><a href="#浏览器同源策略" class="headerlink" title="浏览器同源策略"></a>浏览器同源策略</h3><p>协议、域名、端口号一致</p><h3 id="跨域方法"><a href="#跨域方法" class="headerlink" title="跨域方法"></a>跨域方法</h3><p>1）<strong>jsonp</strong>：script（img、link、iframe 可跨域）设置 script 的 src 为要访问的网址并设置回调函数接收数据。<br>特点：简单、兼容性好、但只能处理 get 请求</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonp</span>(<span class="hljs-params">url,callback,success</span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> script=<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>)<br>  script.src=<span class="hljs-built_in">url</span><br>  script.async=<span class="hljs-literal">true</span><br>  script.type=<span class="hljs-string">&#x27;text/javascript&#x27;</span><br>  <span class="hljs-built_in">window</span>[callback]=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<br>    success&amp;&amp;success(data)<br>  &#125;<br>  <span class="hljs-built_in">document</span>.body.append(script)<br>&#125;<br></code></pre></td></tr></table></figure><p>2）<strong>CORS</strong>：跨域资源共享。服务端设置 Access-Control-Allow-Origin<br>简单请求：</p><ol><li>使用 get、post、head 请求</li><li>content-type 仅限于 text&#x2F;plain,multipart&#x2F;form-data,application&#x2F;x-www-form-urlencoded</li><li>header 中只能包含以下请求头字段 Accept、Accept-Language、Content-Language、Content-Type</li></ol><p>复杂请求：<br>会使用 option 发预检请求、Access-Control—Request-Method 告知服务器实际使用的方法，Access-Control-Request-Header 告知服务器实际请求所携带自定义首部字段；预检请求完成后发送实际请求</p><p>3）<strong>document.domain</strong>：只适用于二级域名相同的情况（备注：Chrome 101 版本开始，document.domain 将变为可读属性。即无法通过将两个页面的 document.domain 都设置为二级域名的方法绕过同源策略）<br>4）<strong>location.hash</strong>：通过中间页，不同域之间 iframe 用 location.hash 传值，相同域通过 js 访问<br>5）<strong>window.name</strong>：跨域数据由 iframe 的 window.name 从外域传到本地域，利用 window.name 在不同页面加载后仍然存在<br>6）<strong>postMessage</strong>：一个页面发信息，另一个页面监听该事件接收消息<br>7）<strong>nginx 反向代理</strong>：服务器代理目标服务器（eg.百度）将请求传给内部服务器</p><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><h3 id="事件的三个阶段"><a href="#事件的三个阶段" class="headerlink" title="事件的三个阶段"></a>事件的三个阶段</h3><ul><li>事件捕获</li><li>处于目标阶段</li><li>事件冒泡</li></ul><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>利用事件冒泡原理将监听注册在父元素上<br>优点：1）减少事件注册、减少内存消耗 2）新增对象时不需要加监听事件</p><h3 id="常见事件"><a href="#常见事件" class="headerlink" title="常见事件"></a>常见事件</h3><p>event.preventDefault()：阻止默认事件<br>event.stopPropagation()：阻止冒泡<br>event.stopImmediatePropagation()：阻止该节点其他注册事件及冒泡</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="页面渲染优化"><a href="#页面渲染优化" class="headerlink" title="页面渲染优化"></a>页面渲染优化</h3><ul><li>避免 js、css 阻塞：css 影响 renderTree 的构建，会阻塞页面的渲染，因此应该尽早加载；js 可以修改 CSSOM 和 DOM，因此 js 会阻塞页面的解析和渲染，需要放到底部</li><li>减少重绘和回流</li></ul><h3 id="JS-优化"><a href="#JS-优化" class="headerlink" title="JS 优化"></a>JS 优化</h3><ul><li><p>使用防抖和节流</p><div class="note note-info">            <p>  <strong>防抖（debounce）</strong><br>  不管事件触发频率多高，一定在事件触发 n 秒后才执行，如果你在一个事件触发的 n 秒内又触发了这个事件，就以新的事件的时间为准，n 秒后才执行，总之，触发完事件 n 秒内不再触发事件，n 秒后再执行。<br>  <em>应用场景</em></p><ol><li>窗口大小变化，调整样式</li><li>搜索框，输入后 1000 毫秒搜索</li><li>表单验证，输入 1000 毫秒后验证</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">event, time</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-built_in">clearTimeout</span>(timer);<br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      event.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>    &#125;, time);<br>  &#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>节流（throttle）</strong><br>不管事件触发频率多高，只在单位时间内执行一次。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 第一次必触发，最后一次不会触发</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">event, time</span>) &#123;<br>  <span class="hljs-keyword">let</span> pre = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - pre &gt; time) &#123;<br>      pre = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>      event.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 第一次事件不会触发，最后一次一定触发</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">event, time</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!timer) &#123;<br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        timer = <span class="hljs-literal">null</span>;<br>        event.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>      &#125;, time);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>          </div></li><li><p>使用 css 动画代替 js 动画</p></li><li><p>使用事件委托</p></li></ul><h3 id="css-优化"><a href="#css-优化" class="headerlink" title="css 优化"></a>css 优化</h3><ul><li>雪碧图</li><li>懒加载</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红蓝宝书1000题个人知识点笔记</title>
    <link href="/unknown404.github.io/2022/05/29/JapaneseNotes/"/>
    <url>/unknown404.github.io/2022/05/29/JapaneseNotes/</url>
    
    <content type="html"><![CDATA[<h2 id="随手记"><a href="#随手记" class="headerlink" title="随手记"></a>随手记</h2><p>正しく「まさしく」：的确。确实。诚然。<br>それは～彼のしわざだ／那的确是他干的；</p><p>すがる【縋る】<br>（１）〔つかまる〕扶，拄，靠．<br>（例）杖にすがって歩く／拄着拐杖走路．<br>（例）介護者の肩にすがって歩く／扶着看护人的肩膀走．<br>（２）〔頼る〕依靠，依赖．<br>（例）もはや彼の好意に～しかない／只能依靠他的帮助了．<br>（例）～思いで化学療法を受ける／抱着最后的希望接收化学治疗．<br>追い縋る、泣き縋る、泣き縋る、より縋る</p><p>でたらめ【出鱈目】<br>［根拠がない］荒唐；［いいかげんなことをする］胡来，瞎（胡）闹；［いいかげんなことを言う］胡扯，瞎说，胡说八道（成）．<br>（例）～を言う／胡说八道；信口开河．<br>（例）～で当てにならない／荒唐无稽不可靠．</p><p>わめく【喚く】<br>喊，叫，唤；［騒ぐ］嚷．<br>（例）大声で～／大声嚷嚷．</p><p>うつうつ【鬱鬱】<br>（１）（心情）郁郁，闷闷．<br>（例）心が～として楽しまない／心中郁郁不乐．<br>（２）（草木）繁茂．<br>（例）山は～たる森に覆われている／满山都是郁郁葱葱的森林．</p><p>きよい【清い】<br>（１）〔澄んでいる〕清澈，清，不混浊．<br>（例）～水／清水．<br>（例）～流れ／清流．<br>（２）〔けがれがない〕纯洁，洁白，纯真．<br>（例）～愛／纯洁的爱．<br>（例）～心／纯洁的心．<br>（３）〔さわやかな，正しい〕（内心）清爽，畅快；［恥じるところがない］清白，扪心无愧．</p><p>けずる【削る】<br>（１）〔刃物で〕［刀で］削；［かんなで］刨；［シャベルなどで］铲．<br>（例）ナイフで鉛筆を～／用刀削铅笔．<br>（２）〔除く〕［減らす］削减；［消す］删去，除掉；一点一点地削减．<br>（例）身を～ような思いをした／饱尝艰辛．<br>（例）余計な文字を～／把多余的文字删去．<br>（例）心身を～／费尽心血；劳神伤身．</p><p>はげむ【励む】<br>努力，刻苦，辛勤，奋勉，勤勉．<br>（例）仕事に～／努力工作；辛勤地劳动．<br>（例）勉強に～／勤奋学习．<br>（例）学問に～／刻苦钻研．</p><p>めくる<br>揭下；［本などを］翻．<br>（例）ページを～／翻书页．</p><p>つらなる【連なる】<br>（１）〔一列に続く〕成行，成排，成列；［つながる］连接，连绵，绵联，绵延，毗连．<br>（例）山脈が東西に～／山脉绵亘东西．<br>（２）〔関係が及ぶ〕牵连，关联．<br>（例）国際問題に～事件／涉及国际问题的事件．<br>（３）〔参加する〕列席，参加．<br>（例）委員の末席に～／列为委员之一．<br>（４）〔末端で一つになる〕末了归一．<br>（例）本流に～／同主流相连．</p><p>さとる【悟る】<br>（１）〔はっきりと知る〕悟，醒悟，觉悟，理解，领悟，认识，认清．<br>（例）過ちを～／认识过错；明白过错．<br>（２）〔感づく〕察觉，发觉，看破．<br>（例）陰謀を～／发现阴谋；察觉阴谋．<br>（例）人に悟られるとたいへんだから油断をするな／要是被人发觉了可不得了，不要大意．<br>（３）〈仏〉醒悟，悟道，了悟．<br>（例）人生をすっかり～／了悟人生；看破红尘．</p><p>可か不可「かかふか」</p><h2 id="红蓝宝书-1000-题"><a href="#红蓝宝书-1000-题" class="headerlink" title="红蓝宝书 1000 题"></a>红蓝宝书 1000 题</h2><h3 id="unit-1（1-36）"><a href="#unit-1（1-36）" class="headerlink" title="unit 1（1-36）"></a>unit 1（1-36）</h3><p>化粧：けしょ</p><p>～からといって虽说因为。。。，但是。。。<br>～が、かといって虽然。。。，但是（也不）。。。前面接短句<br>N 　＋　からいって从。。。来看</p><p>健康診断（固定搭配）</p><p>そそっかしい冒失的<br>心細い（こころぼそい）心中没底的，胆怯的</p><p>ｖ原形　＋　ことはない（建议）没必要。。。</p><p>船便：ふなびん<br>航空便：こうくうびん</p><p>突き当たる：碰撞<br>凭れる（もたれる）：倚靠<br>物語る：讲述</p><p>～折に：。。的时候<br>～ごとに：每。。。</p><p>余地（よち） 余裕（よゆう） 余る（あまる）</p><p>絞る（しぼる）：squeeze<br>縮める（ちぢめる）：shorten</p><p>大雨（おおあめ）ーーー小雨（こさめ）</p><p>せっせと：勤恳地<br>のろのろ：慢吞吞的</p><p>普遍的（ふへんてき）</p><p>賑わう（にぎわう）：热闹<br>栄える（さかえる）：繁荣</p><p>劣る（おとる）：比不上</p><h3 id="unit-2（37-72）"><a href="#unit-2（37-72）" class="headerlink" title="unit 2（37-72）"></a>unit 2（37-72）</h3><p>とっくに很早</p><p>感心する敬佩</p><p>列島（れっとう）</p><p>食事を済ませる 解决早餐<br>持たせる（もたせる）让。。拿着，维持</p><p>～どころか（A／NA／N）别说。。。，甚至。。<br>～ところが然而</p><p>慌ただしい（あわただし）<br>喧しい（やかましい）</p><p>ｖ（ます）＋さえすれば只要。。。就。。。<br>NA ＋でこそあれ／ｖーます・Ｎ＋こそすれ只能是。。。，（其他不可能）</p><p>～ことに（は）（A&#x2F;NA-な／ｖ－た）令人。。。的是、、</p><p>夕立（ゆうだち）傍晚雷阵雨</p><p>～にかけて（は）在。。方面（优秀）<br>～と同時に。。的同时<br>～に至って到了。。阶段</p><p>大体（だいたい）　　大抵（たいてい）</p><p>縮む（ちぢむ）：（自动词）缩小 縮める（ちぢめる）：（他动词）使。。缩小　縮れる（ちぢれる）：卷曲</p><p>振り向く：回头</p><p>厳重（げんじゅう）严肃，严格</p><p>お目にかかる＝会う自谦语<br>お目にかける＝見せる自谦语<br>拝見する＝みる自谦语<br>申（もう）し上げる、申す＝いう自谦语<br>おる＝いる自谦语<br>ござる＝ある自谦语</p><h3 id="unit-3（73-108）"><a href="#unit-3（73-108）" class="headerlink" title="unit 3（73-108）"></a>unit 3（73-108）</h3><p>安易（あんい）</p><p>見積もりを出す：做预算，估价<br>料理を注文する</p><p>見合い相亲</p><p>一斉に（いっせいに）一起，同时<br>一向に（いっこうに）気にしない丝毫不在意</p><p>以上（は）既然。。。就。。。<br>以上に／の：超出。。。</p><p>実施（じっし）　施設（しせつ）</p><p>取り付ける<br>１）合意（ごうい）を取り付ける：达成一致<br>２）カメラを取り付ける：安装照相机</p><p>準備を整える（ととのえる）</p><p>手ごろな価格／サイズ 合适的价格&#x2F;尺寸<br>手軽：简便</p><p>～も～ば～も～：既。。。又。。。</p><p>“动词连用形+ている”或”动词连用形+よう(う)十とする(としている)”＋ところへ：正在……的时候……<br>ｖーた＋ところで：即使。。。也。。<br>～ところが：然而</p><p>負債（ふさい）　負傷（ふしょう）</p><p>傾く（かたむく）：歪斜，倾向　賛成に傾く</p><p>N ＋の／ｖーた＋あげく接消极的结果<br>N ＋反面，表示事物的正反面</p><p>N ＋はおろか</p><ol><li>别说～；就是～也～；不用说是…；就连…也（～はもちろん</li><li>「A は言うまでもなく、更に B も～」。）<br>10 日はおろか、1 月かかってもできない。&#x2F;别说 10 天，就是一个月也完不成。<br>彼は汉字はおろか、ひらがなも书けない。&#x2F;他别说汉字了，就是平假名也不会写。<br>事故でけがをして、走ることはおろか歩くこともできない。&#x2F;在事故中受伤了，不要说是跑，连走路都不行了。</li></ol><p>N ＋もとより<br>① 当然；不用说。<br>② 一开始就…；本来；原来。<br>◆ 彼はアメリカはもとより日本にも行ったことがない。<br>别说去美国，他连日本都没去过</p><p>全滅（ぜんめつ）　絶滅（ぜつめつ）<br>勤続（きんぞく）：连续工作　勤続年数<br>連続（れんぞく）：持续　連続ドラマ　連続関数　火事が連続して起こる</p><p>ながら：接在名詞、動詞［ます］形（连用形）&#x2F;ない形（未然形）、形容詞终止形、形容动词词干的后面。<br>ものの：接在名詞+である、動詞・形容詞・形容动词连体形后面<br>ものの的转折口气要比ながら强很多，意为“一般来说，有了前者，自然而然地就会有后者，但出乎意料地不是”这个意思（带因果）</p><p>目前（もくぜん）に迫る<br>手前にある箸</p><p>～わけではない并不是<br>～ものではない不应该</p><h3 id="unit-4-109-144"><a href="#unit-4-109-144" class="headerlink" title="unit 4(109-144)"></a>unit 4(109-144)</h3><p>親孝行（おやこうこう）　親しむ（したしむ）</p><p>取り替える　電池を取り替える　<br>取り消す　注文を取り消す<br>取り入れる　先進技術を取り入れる</p><p>名詞「の形」+うえで<br>動詞「た形」+うえで<br>動詞「た形」+うえでの+名詞<br>意思：<br>表示同一个人做完前项之后再采取下一步行动。而且前项的动作或行为是为后项做准备的。主要用于口语。“……之后” 。</p><p>名詞「の形」＋もとで…<br>在…下…（在某影响所及的范围里）<br>◆ 彼女は厳格(げんかく)な両親のもとで育(そだ)った。<br>她在父母的严格管教下成长。</p><p>出生：<br>役所では「しゅっしょう」というケースが多い気がしますが、日常会話では「しゅっせい」と発音する人も多いです。</p><p>紙を適切な位置で切る＝切る場所に誤差を認めない。<br>紙を適当な位置で切る＝切る場所に誤差を認める。</p><p>浜辺（はまべ）　海辺（うみべ）</p><p>苦痛（くつう）を訴える（うったえる）</p><p>N ＋にかぎって偏偏；限于<br>N ＋において在。。方面</p><p>損得（そんとく）　損害（そんがい）　損失（そんしつ）</p><p>きっぱり汉语翻译：<br>［断固と］断然;<br>［あっさり］干脆,斩钉截铁『成』;<br>［はっきり］清楚,明确.<br>きっぱり言いきる／斩钉截铁地说;一口咬定.<br>きっぱり拒否した／断然〔干脆〕拒绝了.<br>話をきっぱりする必要がある／有必要把话讲清楚.</p><p>人たらし<br>最初は、「人をだますこと。また、その人」の意味でしたが、今では「多くの人々に好かれること。また、その人」</p><p>光景（こうけい）</p><p>意欲を高める：热情高昂<br>意図（いと）を隠す：隐藏意图</p><p>若々しい（わかわかしい）：有活力的<br>厚かましい（あつかましい）：厚脸皮的</p><p>ｖーた＋途端に</p><p>判子（はんこ）：印章</p><p>応募（おうぼ）　募集（ぼしゅう）</p><p>返却（へんきゃく）：退还（物品）<br>返済（へんさい）：偿还钱款</p><p>N ＋の＋ことだから：正因为是。。。</p><h3 id="unit-5-145-180"><a href="#unit-5-145-180" class="headerlink" title="unit 5(145-180)"></a>unit 5(145-180)</h3><p>平等（びょうどう）</p><p>上達（じょうたつ）が早い：进步迅速 発達（はったつ）が目覚ましい：发展惊人</p><p>書留（かきとめ） 勢い（いきおい）　趣（おもむき）<br>施す（ほどこす）eg.策を施す&#x2F;恩恵を施す</p><p>ｖーない＋こともない<br>◆ 買えないこともないが、最近お金を使いすぎたので、あまり使いたくない<br>～ことではない<br>ｖーます＋そうもない<br>今週は忙しくて、明日の映画は行けそうもない</p><p>動ます形＋（なんか）でもしたら 　<br>名詞＋（なんか）でもしたら<br>意味：<br>一旦…的话,就会… 　<br>如果…就（糟了）…<br>大切なものを奪われでもしたら、私は死ぬ気で奪い返す。</p><p>登山（とざん）</p><p>うんざり:厌烦</p><p>口を挟む：插嘴</p><p>……かのようだ<br>接续：<br>各名詞＋である＋かのようだ<br>動詞普通体＋かのようだ<br>意思：<br>表示虽然实际上不是那么回事，但是给人的感觉好像是那么回事。有时也用于说话人的一种遐想。比起（～ようだ）的表达形式来，更增添了一种不确切的推断语气。“就像……”。<br>例子：<br>1、彼は自分のものであるかのように勝手にぼくの物を使っている。&#x2F;他像是在用自个儿的东西似的，随意用我的东西。</p><p>髪の毛（け）</p><p>感染（かんせん）　伝染（でんせん）</p><p>好ましい（このましい）<br>（1）令人喜欢的。（気に入っている。）<br>好ましい返事。／令人满意的答复。<br>好ましくない印象。／不愉快的印象；印象不好。<br>好ましからぬ人。／讨厌的人；不受欢迎的人。<br>（2）令人满意的。（望ましい。）<br>これは決して好ましいことではないが、やむをえない。／这决不能令人满意，但是只好如此。</p><h3 id="unit-6-181-216"><a href="#unit-6-181-216" class="headerlink" title="unit 6(181-216)"></a>unit 6(181-216)</h3><p>輸入（ゆうにゅう）　輸送（ゆそう）</p><p>肌が荒れる（あれる）</p><p>錆びる（さびる）</p><p>砂漠（さばく）　土砂降り（どしゃぶり）</p><p>ｖーない＋ずに・ないで済む<br>&lt;接续&gt;<br>名／形动／动词连体形＋にすぎない<br>&lt;意思&gt;<br>只是，只不过是。表示“只是……”的意思。伴有“这并不重要”的语气。（…以上のものではない。ただ…だけだ。）<br>たんなる人違いにすぎない。／只不过是弄错人了。<br>「～にすぎない」（no more than,just,only)<br>程度が低いことを表す表現で、「大したことはない、価値があまりない」という気持ちが込められます。<br>・彼の言葉は言い訳にすぎない。<br>・彼はただの友達にすぎない。<br>・それは勝手な妄想にすぎない。</p><p>「にほかならない」（no other than,none other than,nothing but)<br>判断や考えを強調して、断定する表現で、「それ以外のものでは決してない。まさしくそうである。」という気持ちが込められます。<br>・彼が成功したのは彼の努力の成果にほかならない。<br>・私を勇気づけたのは彼の一言にほかならない。<br>・私を変えたのは、彼の存在にほかならない。<br>～からにほかならない</p><p>「共通（きょうつう）」是指“对于多个事物均适用的东西”，<br>eg.共通の利害&#x2F;共同的利害</p><p>「共有（きょうゆう）」就是指“共同所有”，是在“拥有”上的「共同」，与「専有」相对。<br>eg.財産を共有にする</p><p>釣り合う<br>（1）平衡，均衡。（二つの物の平衡が取れている。）<br>収入と支出が釣り合う。／收支平衡。<br>（2）匀称，适称，相称，调和。〔似合う。〕<br>着物の柄と帯とがよく釣り合う。／和服的花样和带子很调和。<br>油絵は日本間にはつりあわない。／日本式房间挂油画不适称。<br>釣り合わぬは不縁のもと。／（夫妇）不般配是造成离婚的根源。</p><p>代金を立て替えること:垫付，垫付款。</p><p>待ち合わせ　会う約束のための日時設定<br>待ち合わせ時間に合わせて、家を出る。</p><p>顔合わせ　お互いが誰であるかを会って確かめ合う<br>今日はチームメイトとコーチとの初顔合わせの日だ。</p><p>間近（まぢか）まもなく<br>身近（みぢか）<br>１）切身　身近に感じる<br>２）身边　危険が身近にせまる</p><p>間際　出発間際に腹痛に襲われる</p><p>病（やまい）</p><p>主催（しゅさい）　主要（しゅよう）</p><p>リストラ　【英】restructuring 的略语；在日本，多指裁员和雇用调整。</p><p>夕食を奢る（おごる）</p><h3 id="unit-7-217-252"><a href="#unit-7-217-252" class="headerlink" title="unit 7(217-252)"></a>unit 7(217-252)</h3><p>知識（ちしき）　承認（しょうにん）</p><p>[方面] [ほうめん] 。指的是限定了方向的笼统地域，多指那一带、那片区域。<br>如：<br>東京方面へ出張する。&#x2F;到东京地区出差。</p><p>[方向] [ほうこう] 。意思是：方向、方位。<br>如：<br>方向を誤る。&#x2F;走错方向。<br>逆の方向へ行く。&#x2F;走向相反的方向。</p><p>思い切って → ためらわないで、勇気を出してなにかをする、始める。<br>eg.<br>思い切って転職する。<br>思い切って留学する。<br>思い切って告白する。</p><p>思い切り → 行動の程度が大きい、強い。存分に（？）<br>eg.<br>バットを思い切りふる。<br>旅を思い切り楽しむ。<br>紙に思い切り大きく絵を書く。</p><p>道端（みちばた）</p><p>一切合切（いっさいがっさい）表示全部</p><p>「一概に（いちがいに） 必ずしも めったに」表示的是否定部分，而「一切（いっさい）」为全面，彻底否定。</p><p>刻む（きざむ）　削る（けずる）</p><p>としか言いようがない 就表示“只能说是….”</p><p>のぼせあがる头昏眼花;头昏脑胀</p><p>唆す（そそのかす）</p><p>キャリアを積む：积累经验</p><p>見当（けんとう） 1.方位，方向。 2.估计，推测，推断，猜测。 3.大约，左右，上下，大体数量。 4.标尺。</p><p>見解（けんかい）　見方（みかた）</p><p>N ＋を除いて（のぞいて）</p><p>粗末(そまつ)<br>１）粗糙。粗陋。简陋。<br>粗末な着物。<br>２）糟蹋。作践。不爱惜。<br>親を粗末にする。<br>怠慢父母。<br>物を粗末にする。<br>糟蹋东西。</p><p>出荷（しゅっか）　入荷（にゅうか）</p><p>1，～ために<br>「～ために」表示目的的时候，前后句子必须为同一主语。而且「ために」前边的动词必须是动作主靠自己的意志可以实现的事情。<br>接续：<br>名词+の+ために<br>动词原形（意向性动词）+ために<br>例句：<br>将来のために、今から頑張らなければならない。&#x2F;为了将来，现在必须要努力奋斗了。<br>ダイエットするために晩御飯の後散歩することにした。&#x2F;为了减肥决定在晚饭后散步。（减肥靠说话人的个人意志可以控制）</p><p>2，～ように<br>表示“为了使该状态&#x2F;状况成立、实现而……”前边多使用「なる」、「できる」等与人的意向无关的行为动词或者动词否定形等表示状态性的意思的表达方式、动词的可能态，后边的句子一般表示动作主意向行为的动词。前后主语无需一致。其中「～ように」的「に」可省略。<br>接续：<br>动词原形（无意向动词）+ように<br>动词ない形+ように<br>动词的可能态+ように<br>例句：<br>後ろの人が聞こえるように大きな声で話した。&#x2F;为了后面的人听得到，大声讲话。（“后边的人听得到”不是表达自己意志的）<br>風邪を引かないようにコートを着て出かけた。&#x2F;为了不感冒穿着外套出门了。<br>子供にも読めるよう名前に振り仮名をつけた。&#x2F;为了让孩子也能读出名字，在旁边标注上了假名。</p><p>惑星（わくせい）：1.行星。2.前途不可限量的人。</p><p>勘定（かんじょう）： 1.数，计数，计算。（計算する。） 2.算账，计算收支。（収支・代金計算。）<br>勘定合って銭足らず。&#x2F;理论与实践不一致。</p><p>ナ形容詞【な形】＋ばかりに<br>イ形容詞と動詞の辞書形＋ばかりに<br>文の【た形】＋ばかりに<br>～たい&#x2F;ほしい＋ばかりに<br>意思：<br>就因为前项的原因，才导致了后项预想不到的坏结果。</p><p>促す（うながす） 1.促使，促进。 2.催促，促使。<br>注意を促す　借金の返済を促す<br>催す（もよおす） 1.举行，举办；主办。 2.感觉（要……）。<br>会を催す　眠けを催す</p><p>下敷きになる被压在底下　 eg.～を下敷きにする。／以～为榜样。</p><p>下書き：草稿</p><h3 id="unit-8-253-294"><a href="#unit-8-253-294" class="headerlink" title="unit 8(253-294)"></a>unit 8(253-294)</h3><p>不正な取引（ふせいなとりひき）</p><p>根気（こんき）</p><p>かえって…相反；反而；反倒<br>◆ 心配をかけまいと無理に明(あか)るく振(ふ)る舞(ま)ったが、かえって家族に心配をかけてしまった。<br>　为了不让家人担心而故做开朗，反而让家人更担心。</p><p>ことか：多么……啊！是一种感叹表现，表说感叹，叹息。<br>多与「どんなに・どれほど・何度・なんと」等副词呼应使用。</p><p>ものか：决不会……。表示强烈的否定。口语为「～もんか」、郑重体是「～ものですか／～もんですか」。</p><p>追いつく，追上，差がほどんどない<br>追いかける，追赶、差を縮め（ちぢめ）よう</p><p>保守（ほしゅ）　保管（ほかん）　保存（ほぞん）</p><p>散らばる可以表示抽象的分散。偏向于表示原本整理好的、归拢在一起的东西分散了，同种类的事物分散了<br>散らかる是乱七八糟的意思。<br>散らす是自动词<br>散らかす是他动词。</p><p>著しい（いちじるしい）　著す（あらわす）<br>華々しい（はなばなしい）</p><p>納品（のうひん）</p><p>～と言うことだ 也就是说，听说<br>～というものだ 表评价</p><p>利口（りこう）</p><p>吹雪（ふぶき）</p><p>まごまご张皇失措　うろうろ彷徨，徘徊，转来转去．　うとうと迷迷糊糊．</p><p>【<del>てもらう】和【</del>てくれる】这两个句型都可以用于为我方做某事。<br>（他人に）<del>てもらう 更侧重我方请求对方做某事，主动方是我方。<br>私はタイ人の友達にタイ料理を教えてもらった。我请泰国朋友教我学做了泰国菜。<br>（他人が）</del>てくれる 更侧重对方主动为我方做了某事。</p><p>需要（じゅよう）　重要（じゅうよう）　要望（ようぼう）</p><p>続出（ぞくしゅつ）：接连发生<br>雨のため各地でスリップ事故が続出している／因雨各地接连发生打滑事故.<br>存続（そんぞく）: その存在が続くこと (similar to “to remain it”, or “to keep existing”)<br>伝統文化を存続させる<br>継続（けいぞく）: 前から続いていることを、続行すること (similar “to have been doing it and to keep doing it”)<br>持続（じぞく）：持续，继续，维持；［あくまでも］坚持．<br>続行（ぞっこう）: 引き続いて行うこと (similar to “to keep doing it”, that is it is not important if you have been doing it or not but you are doing it)</p><p>N ＋踏まえて：在。。基础上</p><h3 id="unit-9-295-324"><a href="#unit-9-295-324" class="headerlink" title="unit 9(295-324)"></a>unit 9(295-324)</h3><p>交渉（こうしょう）</p><p>～うえは：既然。。就，和【以上】用法接近<br>～上に：不仅。。而且<br>N・ｖーた＋上で：在。。之后</p><p>つもりだ 1.接续：动词&#x2F;形容词&#x2F;形容动词连体形&#x2F;名词の + つもりだ<br>解说：接在表状态的动词后，表示主观想法，自我感觉。可译为“自以为…”。<br>彼女はすべてを知っているつもりだが、本当は何も知らない。&#x2F;她自以为自己什么都懂，其实她什么也不知道。 2.接续：动词过去式 + つもりだ<br>解说：“つもり”接在动词过去式“…た”之后，表示一种假定，即尽管实际并非如此，暂且主观上认定是这样。可译为“就当做…，就以为…”。<br>自分の家に帰ったつもりで、ゆっくりお休みください。&#x2F;就像回到自己家里一样，好好休息吧!</p><p>v-たらどう？</p><p>献立（こんだて）　文献（ぶんけん）</p><p>すっと<br>（１）〔勢いよく〕［動作が］迅速地，轻快地；［時間的に］一下子，悠地，立刻．<br>（例）手を～差し出す／敏捷地伸出手来．<br>（例）～立ち上がる／立刻站起来；悠地一下站了起来．<br>（２）〔気分がさわやかで〕［さわやか］爽快；［うっぷんを晴らして］痛快，轻松．<br>（例）頭痛が治まって～する／头不痛了，觉得很清爽．</p><p>ほっと<br>（１）〔ため息〕叹气．<br>（例）～ため息をつく／叹一口气．<br>（２）〔安心〕放心．<br>（例）～胸をなでおろした／放了心，松了一口气．</p><p>ざっと<br>（１）〔大まかに〕粗略地，简略地，略微；［だいたい］大略，大致，大体上．<br>（例）～目を通す／略一过目；粗粗地看了一遍．<br>（例）～読んでみた／大致读了一下．<br>（例）～列挙してみる／笼统地列举一下．<br>（２）〔おおよそ〕大约，大概．<br>（例）～１万人が集まった／大约聚集了一万人．<br>（３）〔水音が〕哗啦，刷地．<br>（例）～夕立が来た／刷地一下子下起阵雨来了．<br>ざっとう【雑踏】</p><p>うちだす【打ち出す・撃ち出す】<br>（１）〔模様を〕锤成或压出凸花纹．<br>（例）花模様を～／锤出凸花纹．<br>（２）〔対策などを〕提出（主张）．<br>（例）主題をはっきりと～／突出主题．<br>（例）問題解決の新しい方途を～／提出解决问题的新方法．<br>（３）〔興行で打ち出し太鼓を打つ〕打散场鼓，散戏．<br>（４）〔うち始める〕开始打，打起来．<br>（例）大砲を～／开炮．<br>（例）テレタイプがそのニュースを打ち出していた／电传打字机已把这个消息打出来了．</p><p>うちけす【打ち消す】<br>（１）〔否定する〕否定；［否認する］否认．<br>（例）事実を～／否定事实．<br>（例）うわさを懸命に打ち消した／极力否认风传的流言；极力辟谣．<br>（２）〔音を消す〕消除．<br>（例）波の音に打ち消されてカモメの声は聞こえない／海鸥的叫声被波涛湮没，听不到了．</p><p>うちあげる【打ち上げる】<br>（１）〔空に〕打上去；［ロケットなどを］发射．<br>（例）花火を～／放焰火．<br>（例）人工衛星を成功裏に打ち上げた／成功地发射了人造卫星．<br>（２）〔岸に〕波浪把东西冲上岸．<br>（例）砂浜に波が～／波浪冲拍着沙滩．<br>（例）津波で大きな船が岸に打ち上げられた／因为海啸大船被冲上岸来．<br>（３）〔興行を〕结束．<br>（例）３か月の芝居興行を打ち上げた／结束了三个月的戏剧演出．<br>（４）〈碁〉拿掉．</p><p>傑作（けっさく）</p><p>要旨（ようし）<br>（例）～をまとめる／归纳要点．<br>（例）彼の話は～があいまいだ／他的话重点不突出．<br>要領（ようりょう）：［ポイント］要领，要点；［こつ］诀窍，窍门<br>～がいい：<br>（１）〔手際がいい〕灵巧．<br>（例）彼はプロだけあってさすがに～がいい／他不愧是专业，要领掌握得很好．<br>（２）〔悪賢く振る舞う〕精明．<br>（例）なんて～のいいやつだ／多么精明的家伙！<br>～が悪い：（遇事）抓不到点子上；做事笨拙；不会找窍门．<br>～を得ない：不得要领（成）．<br>（例）きみの言うことはまったく～を得ない／你说的话完全不得要领．<br>（例）～を得ない話だ／这个话不得要领．</p><p>めっきり（变化）显著，急剧．</p><p>ｖーた＋ところ做了前项，发生了后项意料之外的结果</p><p>ｖ原形＋よりほか(に&#x2F;は)ない・ほかしかたがない・ほかはない<br>除此之外，没有…<br>自立(じりつ)するためにはまず両親のもとを離(はな)れるよりほかない。要独立自主，首先必须要离开父母身边。</p><p>提供（ていきょう）　供給（きょうきゅう）　供える（そなえる）</p><p>携わる（たずさわる）：参与，参加，从事，有关系．<br>（例）教育に～／从事教育．<br>（例）政治に携わらない／不参与政治．</p><p>備わる（そなわる）<br>（１）〔設置〕装备，设置；装有．<br>（例）最新の設備が備わっている／设有最新设备．<br>（２）〔資質など〕具有，具备．<br>（例）生まれながらの資質が備わっている／具有与生俱来的资质．</p><p>ｖ<del>ます</del>＋つつある正在…不断地…(表示某动作，事态正朝某一方向持续发展）<br>ｖ<del>ます</del>＋っぱなし本该做的事情却不去做，还是保持原样。某个状态的持续</p><h3 id="unit-10（325-360）"><a href="#unit-10（325-360）" class="headerlink" title="unit 10（325-360）"></a>unit 10（325-360）</h3><p>わりと意外地</p><p>滞在（たいざい）逗留，停留；<br>（例）海外に～する／在海外居住；旅居海外．</p><p>渋滞（じゅうたい）堵塞，不通畅；不顺利<br>（例）交通～に巻き込まれる／遇上交通堵塞．<br>（例）～のない文章／流畅的文章．</p><p>潤い（うるおい）<br>（１）〔湿り気〕湿润．<br>（例）肌の～を保つ化粧品／润肤化妆品．<br>（２）〔利益〕补益（書）．<br>（例）少々の援助でも財政の～になる／再少的援助，对财政也是有所补益的．<br>（３）〔情趣〕风趣，情趣．<br>（例）～のある声／甘美的声调．</p><p>蛇口（じゃぐち）</p><p>ぶかぶか<br>（１）〔服などが〕肥大．<br>（例）このズボンは～だ／这条裤子肥肥的．<br>（２）〔ラッパなどの音〕达达达地．<br>（例）～とラッパを吹く／达达达地吹喇叭．</p><p>N ＋の・A・ｖ　＋わりには</p><p>N&#x2F;Na （である）に越したことはない<br>A-いに越したことはない<br>V-るに越したことはない<br>表示「没有比这更好的、这是最好的」等意思。<br>お金はあるに越したことはない。有钱是再好不过的了。</p><p>湿気（しっけ）<br>豊作（ほうさく）　豊富（ほうふ）<br>N ＋向けに 面向。。。，以。。为对象　<br>N ＋に向けて<br>1）人或交通工具等朝着某个方向、目的地行进。（～に向かって）的意思基本相同。<br>2）针对某人、某团体采取什么态度或什么行为，和（～に向かって&#x2F;に対して）的意思基本相同。<br>3）表示以某个事情为目标而努力。相当于（～を目指して）的意思。</p><p>交代（こうたい）交替，替换，换班；［輪番の］轮流，轮换．<br>生地（きじ）　保障（ほしょう）</p><p>アイデアをおもいつく</p><p>ｖーた・ｖ＋か＋ｖ－ない＋か＋のうちに刚。。。就。。。</p><p>喪失（そうしつ）　紛失（ふんしつ）</p><p>一種（いっしゅ）</p><p>ところを 强调被中断，打断。经常会被用在被人发现和抓住的情况，所以接续一般为「見る、見つける、見かける、発見する、捕まる、捕まえる、襲う、助ける」<br>ところに&#x2F;へ 强调动作发生时间点。表示正在做某动作时，发生了另一个事情受到了影响，而这个事情通常是令人意外的或者因此受到了阻碍，原本需要做的动作因为此事做出了调整，用中文来说，就是“正在～的时候”。</p><p>ご存知です：「知っている」<br>存じておる</p><p>ｖーている・A・N ＋の　＋最中に</p><p>「〜ものがある」经常和「～には」「～のは」搭配使用。<br>含义：“有…的一面””的确很…”<br>动词［辞書形］＋ものがある<br>动词［ない形］＋ものがある<br>い形容词［ーい］＋ものがある<br>な形容词［ーな］＋ものがある</p><h3 id="unit-11（361-396）"><a href="#unit-11（361-396）" class="headerlink" title="unit 11（361-396）"></a>unit 11（361-396）</h3><p>【ちかぢか】 1.最近。不久 2.近距离地。直接。</p><p>たちまち【忽ち】<br>（１）〔すぐに〕转瞬间，立刻，马上，登时；［まもなく］不大工夫．<br>（例）音楽会の切符は～売り切れた／音乐会的票不大工夫就卖完了．<br>（２）〔にわかに〕忽然，突然．<br>（例）～大粒の雨が降り出した／突然下起了大雨点的雨．</p><p>決行（けっこう）</p><p>か何か ：。。。什么的<br>例如： コーヒーか何か飲みませんか。 喝点咖啡什么的吧<br>かどうか：表示是否，是……还是（不）<br>例如： 彼は来るかどうか知りますか 他来还是不来你知道吗？<br>かいなか：硬い表現で、書き言葉です。意味は「かどうか」と同じです。</p><p>競馬（けいば）　競う（きそう）<br>分布（ぶんぷ）<br>～を通じて<br>N ＋に渡る：长达。。。，多达。。。（时间、空间范围）</p><p>繁盛（はんじょう）　繁栄（はんえい）<br>徒歩（とほ）</p><p>ぎっしり满满的．</p><p>（例）かばんは～詰まっている／挎包装得满满的．</p><p>（例）会場は人で～だ／会场挤满了人．</p><p>（例）～詰まったスケジュール／排得满满的日程表．</p><p>（例）両側に家が～立ち並んでいる／两旁房屋鳞次栉比．</p><p>どっさり很多，好些．</p><p>（例）お年玉を～もらう／得到了好些压岁钱．</p><p>（例）ここでは毎年米が～とれる／这里每年可收好多稻米．</p><p>（例）果物を～買い込んでくる／买回很多水果．</p><p>くっきり特别鲜明，显眼，清楚．</p><p>（例）青空に山が～見える／在蔚蓝的天空可以清楚地看见山峰．</p><p>N ＋につき<br>1） 关于…，就…。（→ について。）<br>世界の政治情勢―述べる。／关于世界的政治局势讲解。<br>2）由于，以…的理由。〔理由をのべる。…という理由で。…のために〕<br>祭日につき休業。／因节日歇业。<br>病気につき欠席する。／因病缺席。<br>3）每，对…。〔…あたり〕<br>5 人につきひとりの割合。／每五人有一人的比例</p><p>証拠（しょうこ）<br>大使（たいし）　大事（だいじ）　大臣（だいじん）</p><p>けっそく【結束】<br>（１）〔束ねる〕捆束，捆扎．<br>（２）〔団結する〕团结．</p><p>（例）～をかたくする／加强团结．<br>（例）～して敵に当たる／团结对敌．<br>（例）あの組織は～がかたい／那个组织团结紧密．</p><p>がち：侧重表达某种动作或状态出现的次数多，中文为“动不动就怎么了”，往往用于负面。含有“今～という状態である&#x2F;ない（现在是&#x2F;不是……状态）”的语感。<br>気味（ぎみ）：侧重表达感觉上有一点点不好的倾向。含有“今～という状態である（现在是……状态）”的语感 。<br>っぽい：主要表达具备某种事物的性质和特征，“看上去感觉怎么样”。 含有“今～という状態がよくわからない（现在是…状态不清楚）”的语感。</p><h3 id="unit-12（397-）"><a href="#unit-12（397-）" class="headerlink" title="unit 12（397-）"></a>unit 12（397-）</h3><p>過去（かこ）</p><p>ｖ可能形＋ものなら：如果能。。。的话，可能性很小的假设<br>ばかりに：正因为，就因为．<br>（例）大儲けした～に人生が狂った／正因为挣了大钱，人生才开始潦倒．<br>（例）寝過ごした～に試験を受けられなかった／只因为睡过了头，没能参加考试．</p><p>ばったり（と）<br>（１）〔倒れる〕物体突然倒下〔掉落，撞击〕〔，〕．<br>（例）貧血を起こして～倒れる／由于贫血而突然倒下．<br>（２）〔出会う〕突然相遇．<br>（例）昔の恋人と街で～出会った／和旧日的情人在街上突然相遇．<br>（３）〔とだえる〕突然停止．<br>（例）交通が～とだえる／在路上忽然不见车来往了．<br>（例）あの人は～来なくなった／那个人突然再也不来了．</p><p>じっくり<br>［ゆっくり］慢慢地；［細かく］仔细地；［あわてずに］不慌不忙；［着実に］踏踏实实．<br>（例）～考える／踏实地思考．<br>（例）～やるのがこつだ／诀窍是要稳扎稳打．<br>（例）あなたと～お話ししたい／想和你好好谈一谈．</p><p>ゆったり<br>（１）〔ゆとりがある〕宽敞舒适．<br>（例）～した服／宽舒的衣服．<br>（２）〔落ち着いた〕舒畅．<br>（例）家に帰ると～とした気分になる／一回到家里就觉着轻松舒畅．<br>（例）～とした気性の人／度量大的人．</p><p>ひとしい【等しい】：相等，相同，一样，等于．<br>（例）計算方法は異なるが，求められた解の数値は～／虽说计算方法不同，可得出的解数值相同．<br>（例）その行為は犯罪に～／那种行为等于犯罪．<br>（例）それでは何もしないのに～／那样就等于什么都不干．</p><p>植木（うえき）</p><p>「収める」、「納める」、「治める」和「修める」，发音均为「おさめる」。</p><p>１．「収める」用于收起物品、记录、获得、使…镇定等。<br>例：「財布に収める」（放进钱包里），「勝利を収める」（获得胜利），「丸く収める」（圆满收场）。</p><p>２．「納める」指上交义务上该交的金钱或物品，也有将物品存放于该放的位置或使…结束之意。<br>例：「税金を納める」（缴税），「遺骨を墓に納める」（将遗骸入墓），「仕事納め」（结束工作）。</p><p>３．「治める」有支配、镇压、缓解之意。<br>例：「国を治める」（治国），「痛みを治める」（缓解疼痛）。（一般来说，在使…镇定，使之恢复平静这一意思上，既可使用「治める」，也可使用「収める」。<br>例：「争いを治める&#x2F;収める（平战乱）」、「怒りを治める&#x2F;収める（平复愤怒）」）。‍</p><p>４．「修める」有修身，学习之意。<br>例：「身を修める」（修身），「学業を修める」（修习学业）。</p><p>単一（たんいつ）</p>]]></content>
    
    
    <categories>
      
      <category>日语学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>词汇</tag>
      
      <tag>语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git指令回顾</title>
    <link href="/unknown404.github.io/2022/04/27/gitCommand/"/>
    <url>/unknown404.github.io/2022/04/27/gitCommand/</url>
    
    <content type="html"><![CDATA[<p>最近 VsCode 图形化界面操作太过于习惯，一些 git 指令操作感觉有点生疏，所以回顾一下。</p><span id="more"></span><p>进入正题前可配合以下 VsCode 操作文章一起阅读，体会也许更深：<br>1）<a href="https://cloud.tencent.com/developer/article/1793472">VS Code 使用 Git 可视化管理源代码详细教程</a><br>2）<a href="https://almvm.devopshub.cn/labs/azuredevops/git/">Version Controlling with Git in Visual Studio Code and Azure DevOps</a><br>虽说界面化是挺好的，但万一哪天需要书写或修改部署文件时会比较头疼，所以还是要记录一点</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>git 是一个分布式版本控制软件。其工作流程如下图所示：<br><img src="/unknown404.github.io/img/gitCommand/git.jpeg"></p><p>涉及的基本工作区概念有：<br><strong>Workspace</strong>：工作区，平时开发时改动的地方<br><strong>Index</strong>：暂存区，执行<code>git add</code>指令后工作区的文件修改内容就会被推到暂存区<br><strong>Repository</strong>：本地仓库，位于自己的本地电脑，执行<code>git commit</code>指令后暂存区的文件修改内容就会被推到本地仓库<br><strong>Remote</strong>：远程仓库，用来托管代码的服务器，比较常见的包括 GitHub、Gitee、GitLab，可以被多个处于协作的本地仓库修改，执行<code>git push</code>指令后本地仓库的文件修改内容就会被推到远程仓库</p><p>一般来说 git 的开发流程主要包括以下步骤：</p><ol><li>使用<code>git clone</code>将远程仓库代码拉到本地</li><li>按照业务从 master 分支拉取新分支、使用<code>git branch &lt;branch-name&gt; </code>、<code>git checkout &lt;branch-name&gt; </code>在新分支上进行开发</li><li>本地开发完成使用<code>git add .</code>添加所有修改到暂存区</li><li>使用<code>git commit -m &lt;message&gt;</code>将修改提交到本地仓库</li><li>使用<code>git push</code>将修改推送到远程仓库</li></ol><h2 id="git-常用配置"><a href="#git-常用配置" class="headerlink" title="git 常用配置"></a>git 常用配置</h2><h3 id="全局配置用户名、用户邮箱"><a href="#全局配置用户名、用户邮箱" class="headerlink" title="全局配置用户名、用户邮箱"></a>全局配置用户名、用户邮箱</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;xxx&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;xxx@xx.com&quot;</span><br></code></pre></td></tr></table></figure><h3 id="配置-SSH-Key"><a href="#配置-SSH-Key" class="headerlink" title="配置 SSH Key"></a>配置 SSH Key</h3><p>SSH Key 允许本地电脑和远程仓库间建立一个安全链接。和 https 拉取远程代码的不同点是，https 方式需要手动输入用户名和密码，ssh 的方式配置完毕后 Git 都会使用你本地的私钥和远程仓库的公钥进行验证是否是一对秘钥，从而简化了操作流程。</p><h4 id="查看-SSH-Key"><a href="#查看-SSH-Key" class="headerlink" title="查看 SSH Key"></a>查看 SSH Key</h4><p>Windows 终端可输入如下指令：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">type</span> <span class="hljs-variable">%userprofile%</span>\.ssh\id_rsa.pub<br></code></pre></td></tr></table></figure><p>GNU&#x2F;Linux&#x2F;Mac&#x2F;PowerShell 则可以使用该指令：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">cat ~<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub<br></code></pre></td></tr></table></figure><p>如果返回开头为<code>ssh-rsa</code>一长串字符，可以跳过生成 SSH Key 过程</p><h4 id="生成-SSH-Key"><a href="#生成-SSH-Key" class="headerlink" title="生成 SSH Key"></a>生成 SSH Key</h4><p>使用指令：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;xxx@xxx.com&quot;</span><br></code></pre></td></tr></table></figure><p>后续关于文件名、passphrase 的设置最好直接回车采用默认值，以免影响自动调用 SSH Key 的流程。<br>如果之后需要修改 key 值，可以使用如下语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">ssh-keygen -p <span class="hljs-tag">&lt;<span class="hljs-name">keyname</span>&gt;</span><br></code></pre></td></tr></table></figure><p>完成后再使用如下指令查看 SSH Key：<br>Windows：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">type</span> <span class="hljs-variable">%userprofile%</span>\.ssh\id_rsa.pub<br></code></pre></td></tr></table></figure><p>GNU&#x2F;Linux&#x2F;Mac&#x2F;PowerShell：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">cat ~<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub<br></code></pre></td></tr></table></figure><h4 id="复制-SSH-Key"><a href="#复制-SSH-Key" class="headerlink" title="复制 SSH Key"></a>复制 SSH Key</h4><p>Windows 命令:</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">type %userprofile%\.ssh\id_rsa.pub | <span class="hljs-keyword">clip</span><br></code></pre></td></tr></table></figure><p>Windows PowerShell:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">cat ~<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub | <span class="hljs-built_in">clip</span><br></code></pre></td></tr></table></figure><p>Mac:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">pbcopy &lt; ~<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub<br></code></pre></td></tr></table></figure><p>GNU&#x2F;Linux (需要 xclip):</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">xclip -sel <span class="hljs-built_in">clip</span> &lt; ~<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub<br></code></pre></td></tr></table></figure><h4 id="添加-SSH-Key"><a href="#添加-SSH-Key" class="headerlink" title="添加 SSH Key"></a>添加 SSH Key</h4><p>打开 gitlab，在左侧栏找到 profile setting，点击 SSH Keys，将复制的 SSH Key 内容粘贴在 keys 一栏，点击<code>add key</code>完成。</p><h4 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h4><p>情景：使用 vscode 图形化界面克隆仓库时报错：没有权限。使用指令克隆代码时出现提示语<code>The authenticity of host &#39;code.xxx.com (xxx.xxx.xxx.xxx)&#39; can&#39;t be established.</code><br>原因：这是因为我从来没有连接过这个服务器<br>解决方法：根据指令窗的提示<code>Are you sure you want to continue connecting (yes/no/[fingerprint])? </code>选择 yes，会自动帮你把服务器域名加入 known_host 文件中<br>或者使用指令<code>ssh-keyscan -H $IP &gt;&gt; ~/.ssh/known_hosts</code>手动加服务器域名到 known_host。可以先用指令<code>ssh -T git@&lt;hostname&gt;</code>检查域名是否建立连接，正常会返回<code>Welcome to Gitlab,xxx</code>。<br>添加完成后可以使用指令<code>ssh-keygen -R &lt;hostname&gt;</code>确认</p><h3 id="查看-git-配置"><a href="#查看-git-配置" class="headerlink" title="查看 git 配置"></a>查看 git 配置</h3><p>使用指令<code>git config --list</code>可以查看当前配置所有项</p><h2 id="工作区常用-git-指令"><a href="#工作区常用-git-指令" class="headerlink" title="工作区常用 git 指令"></a>工作区常用 git 指令</h2><h3 id="新建本地仓库"><a href="#新建本地仓库" class="headerlink" title="新建本地仓库"></a>新建本地仓库</h3><h4 id="本地项目-git-管理"><a href="#本地项目-git-管理" class="headerlink" title="本地项目 git 管理"></a>本地项目 git 管理</h4><p>使用指令<code>git init</code>使项目 git 化</p><h4 id="远程仓库项目本地操作"><a href="#远程仓库项目本地操作" class="headerlink" title="远程仓库项目本地操作"></a>远程仓库项目本地操作</h4><p>使用指令<code>git clone &lt;url&gt;</code>，例如 <code>git clone git@gitee.com:unknown-four-hundred-and-four/unknown_404.git</code>。这里的 url 最好用 SSH 而非 HTTPS，避免手动输入用户名和密码的麻烦。<br>在克隆完每个远程仓库后，远程仓库默认为 origin。如果想用其他的主机名，需要用 git clone 命令的-o 选项指定。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone -o jQuery https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/jquery/</span>jquery.git<br></code></pre></td></tr></table></figure><h3 id="开发新业务"><a href="#开发新业务" class="headerlink" title="开发新业务"></a>开发新业务</h3><h4 id="查看当前仓库分支情况"><a href="#查看当前仓库分支情况" class="headerlink" title="查看当前仓库分支情况"></a>查看当前仓库分支情况</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">branch </span>查看本地仓库分支情况，*表示当前位于的分支<br>git <span class="hljs-keyword">branch </span>-a 查看本地和远程所有分支情况<br></code></pre></td></tr></table></figure><h4 id="创建业务分支开发"><a href="#创建业务分支开发" class="headerlink" title="创建业务分支开发"></a>创建业务分支开发</h4><p>使用指令<code>git checkout -b &lt;branchname&gt;</code>使工作区切到新建的分支上。该指令是<code>git branch &lt;branchname&gt;</code>和<code>git checkout &lt;branchname&gt;</code>合在一起的结果。</p><h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><p>1）使用指令<code>git add</code>将代码提交到暂存区。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">// 添加某个文件到暂存区，后面可以跟多个文件，以空格区分</span><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> xxx<br><span class="hljs-comment">// 添加当前更改的所有文件到暂存区。</span><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> .<br></code></pre></td></tr></table></figure><p><strong>提交时可能出现的问题</strong></p><ul><li><p><strong>问题</strong>：报错：error: &#39;&lt;filename&gt;&#39; does not have a commit checked out<br>fatal: adding files failed</p></li><li><p><strong>原因</strong>：报错的那个文件夹中包含.git 文件，可以在文件夹所在位置执行指令 rm -rf .git 将 git 文件删除、重新进入 vscode 即可</p></li></ul><p>2）使用指令<code>git commit</code>将代码提交到本地仓库。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 提交暂存的更改，会新开编辑器进行编辑<br>git commit<br><span class="hljs-regexp">//</span> 提交暂存的更改，并记录下备注<br>git commit -m <span class="hljs-string">&quot;you message&quot;</span><br><span class="hljs-regexp">//</span> 等同于 git add . &amp;&amp; git commit -m<br>git commit -am<br><span class="hljs-regexp">//</span> 对最近一次的提交的信息进行修改,此操作会修改commit的hash值<br>git commit --amend<br></code></pre></td></tr></table></figure><h4 id="提交规范补充"><a href="#提交规范补充" class="headerlink" title="提交规范补充"></a>提交规范补充</h4><p>commit 的内容规范不应该被轻视，一个调理清晰的 commit 记录有助于后面的人做维护工作。实际工作中可能常会遇到之前项目下掉的某功能需要重新恢复，如果能有清晰的 commit 说明维护人员就能很快定位功能代码位置做出调整；而如果提交记录只有类似 fix 、bugfix 的说明则会给维护工作造成麻烦。</p><p>目前广泛接受的 commit 格式规范是 angular 团队规范，它的 message 格式如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;<span class="hljs-regexp">//</span> header部分<br>&lt;BLANK LINE&gt;<span class="hljs-regexp">//</span> 空行<br>&lt;body&gt;<span class="hljs-regexp">//</span> body部分<br>&lt;BLANK LINE&gt;<span class="hljs-regexp">//</span> 空行<br>&lt;footer&gt;<span class="hljs-regexp">//</span> 注释footer部分<br></code></pre></td></tr></table></figure><p>主要分为三个部分：</p><h5 id="header-部分"><a href="#header-部分" class="headerlink" title="header 部分"></a>header 部分</h5><p>必填内容, 描述主要修改类型和内容。规范将 header 分为 type、scope、subject 三部分。<br><strong>type</strong>：提交的代码修改所属类型，必填项。应在以下几种中选择一种：</p><ul><li>feat: 一项新功能</li><li>fix: 一个错误修复</li><li>docs: 仅文档更改</li><li>style: 不影响代码含义的更改（空白，格式，缺少分号等）</li><li>refactor: 既不修正错误也不增加功能的代码更改（重构）</li><li>perf: 改进性能的代码更改</li><li>test: 添加缺失或更正现有测试</li><li>build: 影响构建系统或外部依赖项的更改（gulp，npm 等）</li><li>ci: 对 CI 配置文件和脚本的更改</li><li>chore: 更改构建过程或辅助工具和库，例如文档生成</li></ul><p><strong>scope</strong>：本次提交的影响范围，描述提交更改的位置如模块名或文件名。可选项<br><strong>subject</strong>：指本次提交的简要描述。</p><h5 id="body-部分"><a href="#body-部分" class="headerlink" title="body 部分"></a>body 部分</h5><p>选填部分。</p><h5 id="footer-部分"><a href="#footer-部分" class="headerlink" title="footer 部分"></a>footer 部分</h5><p>主要备注以下内容：</p><ul><li><strong>BREAKING CHANGE</strong>：当前修改是否发生了版本升级、接口参数减少、接口删除、迁移等破坏性调整。</li><li><strong>关闭 Issue</strong>：填写格式<code>Closes #ISSUE_ID, #ISSUE_ID</code></li></ul><p>当前使用比较广泛的规范化工具是<a href="https://www.npmjs.com/package/cz-conventional-changelog">commitizen</a>，具体操作可以参考<a href="https://blog.csdn.net/sky529063865/article/details/120159366">这篇文章</a>。</p><p>3）使用指令<code>git push</code>将代码提交到远程仓库。</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">git push <span class="hljs-attribute">&lt;远程主机名&gt;</span> <span class="hljs-attribute">&lt;本地分支名&gt;</span>:<span class="hljs-attribute">&lt;远程分支名&gt;</span><br></code></pre></td></tr></table></figure><p>如果省略远程分支名，则会将本地分支推送到对应名称的远程分支（两者有追踪关系），如果该远程分支不存在，则会被新建。<br>如果省略本地分支名，则是将空分支推到远程分支，等同于删除指定的远程分支。<br>如果省略本地分支和远程分支、且当前分支与远程分支之间存在追踪关系时，将当前分支推送到 origin 主机的对应分支；如果追踪关系只有一个可以直接<code>git push</code>。</p><h4 id="文件暂存"><a href="#文件暂存" class="headerlink" title="文件暂存"></a>文件暂存</h4><p>有的时候我们的功能开发了一半，因为某些原因我们需要 checkout 到其他的分支上查看代码或者是执行某个工作。这个时候由于功能并没有开发完成，所以并不希望提交代码，此时可以用<code>git stash</code>指令来将本地还没有提交的改动全部存储起来。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 保存改动并注释本次改动<br>git stash [save] &lt;message&gt;<br><span class="hljs-regexp">//</span> 将新创建并且还没有被 git 管理的文件也一并储藏起来<br>git stash  [--include-untracked/-u]<br><span class="hljs-regexp">//</span> 查看全部存储记录<br>git stash list<br><span class="hljs-regexp">//</span> 恢复，num是可选项，通过git stash list可查看具体值。只能恢复一次<br>git stash pop stash@&#123;num&#125;<br><span class="hljs-regexp">//</span>恢复，num是可选项，通过git stash list可查看具体值。能恢复多次<br>git stash apply stash@&#123;num&#125;<br><br></code></pre></td></tr></table></figure><p>git stash 在没有 add 之前才能执行。</p><h4 id="业务协作"><a href="#业务协作" class="headerlink" title="业务协作"></a>业务协作</h4><p>当同事开发的内容和自己在同一分支且对方已经提交代码的情况下，可以使用指令 git pull，git pull 等同于 git fetch &amp;&amp; git merge</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 拉取远程分支代码的更新,对当前工作区的代码没有影响<br>git fetch &lt;远程主机名(eg. origin)&gt; &lt;分支名&gt;<br><span class="hljs-regexp">//</span> 将当前分支与指定分支进行合并<br>git merge &lt;分支名&gt;<br><span class="hljs-regexp">//</span> 从远程仓库拉取代码并合并到本地<br>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;<br></code></pre></td></tr></table></figure><h5 id="辨析：git-merge-和-git-rebase-的区别"><a href="#辨析：git-merge-和-git-rebase-的区别" class="headerlink" title="辨析：git merge 和 git rebase 的区别"></a>辨析：git merge 和 git rebase 的区别</h5><p>相同点：两个指令都可以用于分支合并。<br>不同点：<br>1）提交记录里，merge 在非快速模式下会多一条 Merge branch ‘xxx’ into ‘xxx’的提交信息，而 rebase 不会<br>2）合并冲突时，merge 只需要处理一次冲突，rebase 需要解决一次又一次冲突<br>3）rebase 的交互模式可以将多次提交压缩成一次，具体步骤是：</p><ul><li>a）执行指令<code>git rebase -i &lt;base-commit&gt;</code>，参数 base-commit 就是指明操作的基点提交对象，基于这个基点进行 rebase 的操作</li><li>b）指令结束后会进入一个 vim 的交互式页面，将基点以后的节点都设置为了 pick，且后面会有指令提示，常用的指令包括</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">pick：使用该次提交<br>squash：将该<span class="hljs-keyword">commit</span>和前一个<span class="hljs-keyword">commit</span>合并<br></code></pre></td></tr></table></figure><p>通常将第一个提交的后面的 pick 改成 squash 即可。</p><ul><li>c）保存，退出编辑页面（点击 Esc 键后输入:wq），进入 commit message 页面。之后同样是输入 i 进入编辑界面，修改自己的 commit message</li><li>d）保存，退出。至此，git rebase 一个流程走完。<blockquote><p>特别注意，只能在自己使用的 feature 分支上进行 rebase 操作，不允许在集成分支上进行 rebase，因为这种操作会修改集成分支的历史记录。</p></blockquote></li></ul><h4 id="部分需求交付"><a href="#部分需求交付" class="headerlink" title="部分需求交付"></a>部分需求交付</h4><p>在开发新功能时因各种客观原因赶不上交付期限的時候，可能需要交付部分需求。针对这一情境，有两种指令可以解决具体的问题。</p><ul><li>1）git cherry-pick<br>使用格式：</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">git cherry-pick &lt;commit-<span class="hljs-built_in">id</span>&gt;<br></code></pre></td></tr></table></figure><p>commit-id 为某次提交的 hash 值。该指令可以理解为”挑拣”提交，和 merge 合并一个分支的所有提交不同的是，它会获取某一个分支的单次提交，并作为一个新的提交引入到你当前分支上。</p><p>当新需求分支里的 bug 修复代码要提前于需求上线时，可以使用 git cherry-pick 将 feature 分支上 bug 修复那次提交生成的 hash 码提取出来作为一个新的提交加在 master 分支上。过程中，如果出现冲突，需要解决冲突、之后进行 git add ，接着执行 git cherry-pick –continue。</p><p>如果存在多个提交需要同步到目标分支，可以简写为 <code>git cherry-pick &lt;first-commit-id&gt;...&lt;last-commit-id&gt;</code>，这是一个左开右闭的区间，也就时说 first-commit-id 提交带来的代码的改动不会被合并过去，如果需要合并过去，可以使用<code> git cherry-pick &lt;first-commit-id&gt;^...&lt;last-commit-id&gt;</code>。</p><ul><li>2）git revert<br>使用格式：</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">git revert &lt;commit-<span class="hljs-built_in">id</span>&gt;<br></code></pre></td></tr></table></figure><p>commit-id 为某次提交的 hash 值。该指令会创建一个新的提交来去除指定的某次 commit 的内容。</p><p>当新需求中某一项功能因为种种原因不能上线时可以使用该指令。这样既可以留下记录又不会导致其他人分支不同步。<br>revert 的时候会进入编辑器模式，如果没有指定编辑器，通常会默认使用系统的编辑器，即<code>vi</code>。界面提示”Please enter a commit message for your changes”。在该行之前输入<code>i</code>进入插入阶段，输入想要的内容后单击 esc 退出插入模式，输入<code>:wq</code>回车即可保存退出。</p><h3 id="仓库、分支迁移"><a href="#仓库、分支迁移" class="headerlink" title="仓库、分支迁移"></a>仓库、分支迁移</h3><p>因业务需求、工作交接等原因，有时需要对仓库或者分支内容迁移到别处。</p><h3 id="仓库迁移"><a href="#仓库迁移" class="headerlink" title="仓库迁移"></a>仓库迁移</h3><ul><li>1）将原仓库代码拉到本地</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">&lt;origin_address</span>&gt;<br></code></pre></td></tr></table></figure><ul><li>2）将原仓库 gitlab 地址替换成为目标仓库的 gitlab 地址</li></ul><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">git</span> <span class="hljs-string">remote</span> <span class="hljs-built_in">set-url</span> <span class="hljs-string">origin</span> &lt;<span class="hljs-string">target_address</span>&gt;<br></code></pre></td></tr></table></figure><ul><li>3）本地仓库推送到远程</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">git <span class="hljs-built_in">push</span> origin --<span class="hljs-built_in">all</span> 推送主干和分支<br><br>git <span class="hljs-built_in">push</span> --tags 推送标签<br></code></pre></td></tr></table></figure><h4 id="仓库迁移可能存在的问题"><a href="#仓库迁移可能存在的问题" class="headerlink" title="仓库迁移可能存在的问题"></a>仓库迁移可能存在的问题</h4><p>问题：上述操作完成之后由于目标仓库的部分分支被保护、原仓库同分支名的推送失败，导致原仓库的其他分支与该被保护分支之间历史不同，git merge 发生<code>fatal: refusing to merge unrelated histories</code>的报错。<br>解决方法：git merge 时增加–allow-unrelated-histories 让 git 允许提交不关联的历史代码。</p><h3 id="分支迁移"><a href="#分支迁移" class="headerlink" title="分支迁移"></a>分支迁移</h3><ul><li>1）将原仓库代码拉到本地</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">&lt;origin_address</span>&gt;<br></code></pre></td></tr></table></figure><ul><li>2）将目标仓库的 gitlab 地址添加进来并为仓库取一个新名字（下面的指令是将仓库命名为了 global）</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">git remote <span class="hljs-built_in">add</span> <span class="hljs-keyword">global</span> <span class="hljs-symbol">&lt;target_address&gt;</span><br></code></pre></td></tr></table></figure><ul><li>3）将当前分支内容推送到目标仓库的分支</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">git push <span class="hljs-keyword">global</span> &lt;branch-<span class="hljs-built_in">name</span>&gt;<br></code></pre></td></tr></table></figure><p>如果是本地初始化的工程可以先拉取远程仓库某一分支，使用 git merge 指令将本地工程的代码合到远程仓库。<br>根据网上资料可以使用<code>git pull --rebase global &lt;branch-name&gt;</code>解决将本地代码推到远程仓库时报错<code>error: failed to push some refs to XXX</code>。实际操作的时候出现了很多错误，不得不取消了 rebase 操作。究其原因应该是该方法只适用于远程库与本地库代码没有同步的情况，而不是本地代码和远程代码完全无关的情况。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>（1）<a href="https://juejin.cn/post/6934292467160514567#heading-0">commit 规范+commitlint+CHANGELOG 自动生成一条龙服务</a><br>（2）<a href="https://blog.csdn.net/M__L__/article/details/104573220">git rebase -i 合并多次提交</a><br>（3）<a href="https://juejin.cn/post/6844904191203213326">多年 Git 使用心得 &amp; 常见问题整理</a><br>（4）<a href="https://juejin.cn/post/6974184935804534815">我在工作中是如何使用 git 的</a><br>（5）<a href="https://ithelp.ithome.com.tw/articles/10244481">DAY11-git cherry-pick 和 revert</a><br>（6）<a href="https://stackoverflow.com/questions/73012357/please-enter-a-commit-message-for-your-changes">“Please enter a commit message for your changes”</a></p>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React Hooks学习笔记</title>
    <link href="/unknown404.github.io/2022/04/08/reactHooks/"/>
    <url>/unknown404.github.io/2022/04/08/reactHooks/</url>
    
    <content type="html"><![CDATA[<p>记录常用的 React 钩子的使用方法。</p><span id="more"></span><h2 id="React-Hook-规则"><a href="#React-Hook-规则" class="headerlink" title="React Hook 规则"></a>React Hook 规则</h2><p>（1）只在最顶层使用 Hook：不要在循环，条件或嵌套函数中调用 Hook<br>（2）只在 React 函数中调用 Hook：可以在 React 组件或自定义钩子中调用</p><h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><p>使用示例：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">[<span class="hljs-literal">self</span>State,<span class="hljs-built_in">set</span>SelfState]=useState(initialState)<br></code></pre></td></tr></table></figure><p>输入参数：初始状态 initialState。如果 initialState 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用。<br>返回参数：当前状态名 selfState 和更新状态函数名 setSelfState<br>setSelfState 可以传入新值来变更状态 setSelfState(newState)；如果需要根据先前的状态更新状态，也可以使用回调函数 setSelfState(prevState &#x3D;&gt; newState)</p><p><strong>辨析</strong>：setSelfState 直接传值和传函数的区别：<br>1）直接传值更新为指定值，传函数更新与当前状态值相关<br>2）传函数可处理多次调用的累加场景，直接传值不行<br>3）传函数可避免闭包</p><p>注意点：<br>（1）因为 state 只在组件首次渲染的时候被创建。在下一次重新渲染时，useState 返回给我们当前的 state。<br>（2）initialState 可以是数组或对象，不像 class 中的 this.setState，更新 state 变量总是替换它而不是合并它。<br>（3）过时状态问题：class 和 hooks 的写法里，异步操作的过程中如何改变 state 的值，最后打印的时候都是最初的值或者说异步操作开始定义的时候的 state 的值。如下面的函数组件中 setTimeout 取到的都是旧值，是因为 react 中一直遵循一个原则，即 state 指向的内容是不可变的，所以每一次 state 的更新都是指向变了。因为闭包的原因，setTimeout 中依然指向的原来的对象，所以旧的 state 没有释放，所以会取到旧值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">DelayedCount</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClickAsync</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">delay</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);<br>    &#125;, <span class="hljs-number">3000</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;count&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClickAsync&#125;</span>&gt;</span>Increase async<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码点击多次时不能正确记录点击次数。解决方法是使用 setCount(count &#x3D;&gt; count + 1)，这样不依赖外部变量、确保将最新状态值作为参数提供给更新状态函数，过时闭包的问题解决了。</p><h3 id="备注：React-闭包"><a href="#备注：React-闭包" class="headerlink" title="备注：React 闭包"></a>备注：React 闭包</h3><p>react hook 的存储结构为链表结构，react 组件的 hooks 会按照顺序存储在下面的链表结构中。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">Hook</span> = &#123;<br>  <span class="hljs-attr">memoizedState</span>: <span class="hljs-built_in">any</span>;<br>  <span class="hljs-attr">baseState</span>: <span class="hljs-built_in">any</span>;<br>  <span class="hljs-attr">baseQueue</span>: <span class="hljs-title class_">Update</span>&lt;<span class="hljs-built_in">any</span>, <span class="hljs-built_in">any</span>&gt; | <span class="hljs-literal">null</span>;<br>  <span class="hljs-attr">queue</span>: <span class="hljs-built_in">any</span>;<br>  <span class="hljs-attr">next</span>: <span class="hljs-title class_">Hook</span> | <span class="hljs-literal">null</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在下面这段代码中，尽管渲染出的 count 值在变化，但是控制台打印出来的却没有。组件的工作流程大致是：useEffect 函数在第一次渲染完成后触发内部函数，创建计时器、react 组件状态改变发生重渲染、计时器持续工作改变 count 的内容、渲染内容不断更新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> interval = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">setCount</span>(<span class="hljs-function">(<span class="hljs-params">count</span>) =&gt;</span> count + <span class="hljs-number">1</span>);<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count, <span class="hljs-string">&quot;count&quot;</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(interval);<br>  &#125;, []);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>count: &#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><p>然而在更新过程中，对于 useEffect 来说，因为它的依赖是空数组，只在组件初始化时执行，可以理解为 useEffect 对应的 hook 节点不需要更新，直接复用旧的 useEffect 对应的 hook 节点；在旧节点中 setInterval 里的回调函数对于 count 变量的使用也还是保持原样，所以形成了闭包。而 setCount 传入的是更新函数，可以自动获取 preState、没有使用闭包的变量 count，所以不影响渲染。这是因为 react 在 render 阶段会遍历 hook 上的 hook.queue 链表上保存的 update，调用 reducer 方法计算 newState</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> newState = current.<span class="hljs-property">baseState</span>;<span class="hljs-comment">//取上一次更新的state</span><br><span class="hljs-keyword">do</span> &#123;<br>    ...<span class="hljs-comment">//省略细节</span><br>    <span class="hljs-keyword">const</span> action = update.<span class="hljs-property">action</span>;<br>    newState = <span class="hljs-title function_">reducer</span>(newState, action);<br>    update = update.<span class="hljs-property">next</span>;<br>&#125; <span class="hljs-keyword">while</span> (update !== <span class="hljs-literal">null</span> &amp;&amp; update !== first);<br><span class="hljs-comment">//计算完成后更新memoizedState并返回</span><br>hook.<span class="hljs-property">memoizedState</span> = newState;<br>hook.<span class="hljs-property">baseState</span> = newBaseState;<br><span class="hljs-keyword">return</span> [hook.<span class="hljs-property">memoizedState</span>, dispatch];<br></code></pre></td></tr></table></figure><p>reducer 的计算逻辑如下所示，当传入的 action 是函数时，每次调用 reducer(newState, action)都会传入上一次计算得到的新的 newState 进去调用 action(state)返回新的结果;而如果传值的话则 newState 的结果只会是最后一个 update 对象的 action 的值。所以如果 setInterval 内部使用 setCount(count + 1)的话读取到的 count 都是本次 render 的值 0</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">basicStateReducer</span>(<span class="hljs-params">state, action</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> action === <span class="hljs-string">&quot;function&quot;</span> ? <span class="hljs-title function_">action</span>(state) : action;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：函数式组件每次渲染都会生成新的函数和新的状态值，但闭包函数会捕获当时的状态。</p><h4 id="闭包的解决方法"><a href="#闭包的解决方法" class="headerlink" title="闭包的解决方法"></a>闭包的解决方法</h4><ol><li><p>useEffect 添加依赖，保证每次更新时替换 hook 缓存的函数，读取到的是最新的 state.</p></li><li><p>使用 useRef 存储最新的 count。useRef 返回的始终是同一个 ref 对象，在组件的整个生命周期中是不变的，也就是地址是没变的；既然地址没变，通过 ref 对象的 current 属性存储最新的 state，就可以保证每次通过 ref.current 拿到的值就是最新的</p></li></ol><p>组件库 ahook 的 useLatest 就是利用 useRef 这一特性。其源码为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-comment">// 通过 useRef，保持每次获取到的都是最新的值</span><br><span class="hljs-keyword">function</span> useLatest&lt;T&gt;(<span class="hljs-attr">value</span>: T) &#123;<br>  <span class="hljs-keyword">const</span> ref = <span class="hljs-title function_">useRef</span>(value);<br>  ref.<span class="hljs-property">current</span> = value;<br>  <span class="hljs-keyword">return</span> ref;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useLatest;<br></code></pre></td></tr></table></figure><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>允许你在函数组件中执行一些副作用操作，比如数据获取、订阅事件、手动修改 DOM 等。</p><p>使用示例：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">useEffect(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    ...<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;&#125;<br>&#125;,[variable])<br></code></pre></td></tr></table></figure><p>第一参数的回调函数函数可以没有返回值，第二参数的书写不是必要的，如果设置了变量 variable，当且仅当 variable 改变时才会触发第一参数回调</p><h3 id="useEffect-与生命周期关系"><a href="#useEffect-与生命周期关系" class="headerlink" title="useEffect 与生命周期关系"></a>useEffect 与生命周期关系</h3><h4 id="useEffect-实现-componentDidMount"><a href="#useEffect-实现-componentDidMount" class="headerlink" title="useEffect 实现 componentDidMount"></a>useEffect 实现 componentDidMount</h4><p>useEffect 的第二个参数设置为一个空数组时，初始化调用一次之后不再执行回调，相当于周期 componentDidMount</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">useEffect</span><span class="hljs-params">(()</span></span> =&gt; &#123;<br>    console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br>&#125;, <span class="hljs-selector-attr">[]</span>)<br></code></pre></td></tr></table></figure><h4 id="useEffect-实现-componentDidMount-和-componentDidUpdate"><a href="#useEffect-实现-componentDidMount-和-componentDidUpdate" class="headerlink" title="useEffect 实现 componentDidMount 和 componentDidUpdate"></a>useEffect 实现 componentDidMount 和 componentDidUpdate</h4><p>当 useEffect 没有第二个参数时,组件的初始化和更新都会执行。<br>当 useEffect 有第二个参数时,组件的更新仅当 variable 改变时会执行。</p><h4 id="useEffect-实现-componentDidMount-和-componentWillMount"><a href="#useEffect-实现-componentDidMount-和-componentWillMount" class="headerlink" title="useEffect 实现 componentDidMount 和 componentWillMount"></a>useEffect 实现 componentDidMount 和 componentWillMount</h4><p>useEffect 设置返回一个函数，这个函数在组件卸载时会执行。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">use<span class="hljs-constructor">Effect(()</span> =&gt; &#123;<br>    <span class="hljs-keyword">function</span> handle<span class="hljs-constructor">StatusChange(<span class="hljs-params">status</span>)</span> &#123;<br>      set<span class="hljs-constructor">IsOnline(<span class="hljs-params">status</span>.<span class="hljs-params">isOnline</span>)</span>;<br>    &#125;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChatAPI</span>.</span></span>subscribe<span class="hljs-constructor">ToFriendStatus(<span class="hljs-params">props</span>.<span class="hljs-params">friend</span>.<span class="hljs-params">id</span>, <span class="hljs-params">handleStatusChange</span>)</span>;<br>    <span class="hljs-comment">// Specify how to clean up after this effect:</span><br>    return <span class="hljs-keyword">function</span> cleanup<span class="hljs-literal">()</span> &#123;<br>      <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChatAPI</span>.</span></span>unsubscribe<span class="hljs-constructor">FromFriendStatus(<span class="hljs-params">props</span>.<span class="hljs-params">friend</span>.<span class="hljs-params">id</span>, <span class="hljs-params">handleStatusChange</span>)</span>;<br>    &#125;;<br>&#125;,<span class="hljs-literal">[]</span>);<br></code></pre></td></tr></table></figure><h3 id="useEffect-无限循环陷阱"><a href="#useEffect-无限循环陷阱" class="headerlink" title="useEffect 无限循环陷阱"></a>useEffect 无限循环陷阱</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title function_">useState</span>(&#123; <span class="hljs-attr">hits</span>: [] &#125;);<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">axios</span>(<br>      <span class="hljs-string">&#x27;http://localhost/api/v1/search?query=redux&#x27;</span>,<br>    );<br><br>    <span class="hljs-title function_">setData</span>(result.<span class="hljs-property">data</span>);<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">      &#123;data.hits.map(item =&gt; (</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item.objectID&#125;</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&#123;item.url&#125;</span>&gt;</span>&#123;item.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">      ))&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><p>以该组件为例，初次渲染执行 useEffect 内部请求、返回数据后，由于使用了 setData 组件 state 改变，引起重新渲染，同时由于 useEffect 没有依赖项，再次渲染时仍然会触发内部的回调，因此出现了无限循环的问题。</p><p>解决方式：如果只希望在组件 mount 时执行请求，可以传递一个空数组作为 useEffect 的第二个参数</p><h3 id="useEffect-与-async-同时使用时的报错"><a href="#useEffect-与-async-同时使用时的报错" class="headerlink" title="useEffect 与 async 同时使用时的报错"></a>useEffect 与 async 同时使用时的报错</h3><p>async 函数会返回 promise，但 useEffect 只允许返回一个清除函数，所以在控制台可以看到警告提醒</p><div class="note note-info">            <p>Warning: useEffect function must return a cleanup function or nothing. Promises and useEffect(async () &#x3D;&gt; …) are not supported, but you can call an async function inside an effect</p>          </div><p>解决方式：async 函数的定义分离出 useEffect 回调函数，回调函数内部执行 async 函数。</p><h3 id="useEffect-vs-useLayoutEffect"><a href="#useEffect-vs-useLayoutEffect" class="headerlink" title="useEffect vs useLayoutEffect"></a>useEffect vs useLayoutEffect</h3><p>执行时期：useEffect 在全部渲染完毕后才会执行，useLayoutEffect 会在浏览器布局之后，绘制之前执行<br>执行方式：useEffect 异步，useLayoutEffect 同步</p><h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><p>使用示例：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const memo=useMemo(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    ...<br>    <span class="hljs-keyword">return</span> compute(props.v)<br>&#125;,[variable])<br></code></pre></td></tr></table></figure><p>传入 useMemo 的函数会在渲染期间执行。如果没有设置第二参数依赖变量，则每次渲染都会执行第一参数的函数来计算。类比生命周期就是 shouldComponentUpdate<br>适用场景：<br>（1）父组件将某个值传给子组件、且父组件有频繁更新的情况。父组件其他值变化时，子组件同样也会重新渲染。因此可以使用 useMemo、将依赖设置为父组件传递的值，只有当其发生变化时子组件才更新。<br>（2）组件内部计算成本比较高的逻辑。需要通过控制依赖来减少不必要的计算。<br>注意点：<br>（1）useMemo 内部不要使用 setState 相关操作，会导致无限循环<br>（2）包括后面的 useCallback，如果是用在父子组件传值的场景，子组件通常用高阶函数 React.memo 包裹<br><strong>辨析：React.memo 和 useMemo</strong><br>React.memo：高阶组件，基础思想：props 没有改变则无需渲染组件。使用方法：<code>React.memo(Component, [areEqual])</code>其中 areEqual 函数不是必须要有的，当 props 浅比较无法实现预计的更新逻辑时才需要传入自己手写的比较逻辑。</p><p>useMemo：组件初次渲染时，执行一次包裹的函数，把函数返回值缓存起来。当组件重新渲染时，通过浅比较检查依赖数组 dependencies 有没有变化。如果没有直接返回之前缓存的结果。</p><h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><p>使用示例：</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">const</span> <span class="hljs-function"><span class="hljs-keyword">fn</span>=<span class="hljs-title">useCallback</span><span class="hljs-params">(<span class="hljs-params">()</span>=&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    ...</span></span><br><span class="hljs-params"><span class="hljs-function">    doSomething<span class="hljs-params">(variable)</span></span></span><br><span class="hljs-params"><span class="hljs-function">&#125;,[variable])</span></span><br></code></pre></td></tr></table></figure><p>useCallback(fn, deps) 相当于 useMemo(() &#x3D;&gt; fn, deps)。类似生命周期 shouldComponentUpdate<br>适用场景：<br>（1）父组件将某个函数传给子组件、且父组件有频繁更新的情况。父组件其他值变化时，由于函数重新创建等原因子组件同样也会重新渲染。<br>（2）useEffect 中可能会有依赖函数的场景，需要使用 useCallback 缓存函数，避免 useEffect 的无限调用</p><h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><p>使用示例：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const refContainer <span class="hljs-operator">=</span> useRef(initialValue)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>输入参数 initialValue 将赋给 ref 的 current 属性。ref 作用于 HTML 元素时 ref 接收底层 DOM 元素作为其 current 属性；作用于组件时，ref 对象接收组件的挂载实例作为其 current 属性。<br>useRef() 和自建一个 {current: …} 对象的唯一区别是，useRef 会在每次渲染时返回同一个 ref 对象。<br>适用场景：<br>（1）引用如 input 等有参数频繁变动更新的 dom 元素。<br>（2）解决闭包问题，见 react 闭包的内容介绍<br>（3）自定义组件时提供了传入函数的入参、为防止自定义组件依赖入参函数的情况使用 useRef 包裹</p><h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h2><p>使用示例：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> initialState = &#123; count: <span class="hljs-number">0</span> &#125;;<br><br>function reducer(<span class="hljs-keyword">state</span>, action) &#123;<br>  switch (action.type) &#123;<br>    case &#x27;increment&#x27;:<br>      return &#123; count: <span class="hljs-keyword">state</span>.count + <span class="hljs-number">1</span> &#125;;<br>    case &#x27;decrement&#x27;:<br>      return &#123; count: <span class="hljs-keyword">state</span>.count - <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-keyword">default</span>:<br>      return <span class="hljs-keyword">state</span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> [<span class="hljs-keyword">state</span>, dispatch] = useReducer(reducer, initialState);<br></code></pre></td></tr></table></figure><p>适用场景：<br>包含多个子状态、单组件小范围使用</p><table><thead><tr><th>特性</th><th>useReducer</th><th>Redux</th></tr></thead><tbody><tr><td>定位</td><td>React 内部的局部状态管理工具</td><td>独立于 React 的全局状态管理工具</td></tr><tr><td>适用范围</td><td>组件树的局部状态，主要在单个组件或小范围内使用</td><td>跨组件树的全局状态，适合大型应用的状态管理</td></tr><tr><td>状态存储位置</td><td>状态存储在组件内，随组件生命周期销毁</td><td>状态存储在全局的 Redux Store 中</td></tr><tr><td>中间件支持</td><td>无内置中间件支持</td><td>支持如 redux-thunk、redux-saga 等中间件</td></tr><tr><td>异步操作</td><td>无内置机制，需要结合自定义逻辑处理</td><td>支持中间件优雅处理异步操作</td></tr></tbody></table><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/6952509261519781918#heading-0">useEffect 你真的会用吗？</a><br>（2）<a href="https://juejin.cn/post/7053695602370019335">React Hooks 及其性能优化之 React.memo,useCallBack,useMemo</a><br>（3）<a href="https://juejin.cn/post/7090820276547485709">解读 useMemo, useCallback 和 React.memo，不再盲目做优化</a><br>（4）<a href="https://juejin.cn/post/7239584269894189115?searchId=20230907171414B7126D9CD38D0536A22D">React 系列- 图解：React Hook 闭包问题</a><br>（5）<a href="https://juejin.cn/post/6952509261519781918#heading-0">useEffect 你真的会用吗？</a></p>]]></content>
    
    
    <categories>
      
      <category>前端技术体系</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/unknown404.github.io/2022/04/05/regexp/"/>
    <url>/unknown404.github.io/2022/04/05/regexp/</url>
    
    <content type="html"><![CDATA[<p>正则表达式构建相关知识点。</p><span id="more"></span> <h2 id="单字符匹配"><a href="#单字符匹配" class="headerlink" title="单字符匹配"></a>单字符匹配</h2><ol><li>数字、字母：直接书写</li><li>特殊字符（eg.空格、换行、*）：使用转义字符<code>\</code><br>需要记忆的特殊字符：<table><thead><tr><th align="center">特殊字符</th><th align="center">正则表达式</th></tr></thead><tbody><tr><td align="center">转行符</td><td align="center">\n</td></tr><tr><td align="center">空白符</td><td align="center">\s</td></tr><tr><td align="center">制表符</td><td align="center">\t</td></tr><tr><td align="center">回车符</td><td align="center">\r</td></tr></tbody></table></li></ol><h2 id="多字符匹配"><a href="#多字符匹配" class="headerlink" title="多字符匹配"></a>多字符匹配</h2><ol><li>[] eg.[a-z],[0-9]</li><li>简便正则表达式<table><thead><tr><th align="center">特殊字符</th><th align="center">正则表达式</th></tr></thead><tbody><tr><td align="center">除了换行符之外的任何字符</td><td align="center">.</td></tr><tr><td align="center">匹配空白符，包括空格、制表符、换页符和换行符</td><td align="center">\s</td></tr><tr><td align="center">匹配非空白字符([^ \t\v\n\r\f])</td><td align="center">\S</td></tr><tr><td align="center">单个数字, [0-9]</td><td align="center">\d</td></tr><tr><td align="center">除了0-9([^0-9])</td><td align="center">\D</td></tr><tr><td align="center">包括下划线在内的单个字符，[A-Za-z0-9_]</td><td align="center">\w</td></tr><tr><td align="center">非单个字符([^A-Za-z0-9_])</td><td align="center">\W</td></tr></tbody></table></li></ol><h2 id="重复次数"><a href="#重复次数" class="headerlink" title="重复次数"></a>重复次数</h2><table><thead><tr><th align="center">特殊字符</th><th align="center">重复次数</th></tr></thead><tbody><tr><td align="center">?</td><td align="center">0-1</td></tr><tr><td align="center">*</td><td align="center">0-n</td></tr><tr><td align="center">+</td><td align="center">1-n</td></tr><tr><td align="center">{n}</td><td align="center">n</td></tr><tr><td align="center">{min,max}</td><td align="center">min-max</td></tr></tbody></table><h3 id="贪婪匹配和惰性匹配"><a href="#贪婪匹配和惰性匹配" class="headerlink" title="贪婪匹配和惰性匹配"></a>贪婪匹配和惰性匹配</h3><p>贪婪匹配：重复次数不是固定而是一个范围时通常尽可能多的匹配。</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/\d&#123;2,5&#125;/g</span>;<br><span class="hljs-keyword">var</span> <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;12345&quot;</span>;<br><span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">string</span>.match(regex) ); <br><span class="hljs-comment">// =&gt; [&quot;12345&quot;]</span><br></code></pre></td></tr></table></figure><p>懒惰匹配：在上述表格的字符后面加上<code>?</code>，尽可能少的匹配。</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/\d&#123;2,5&#125;?/g</span>;<br><span class="hljs-keyword">var</span> <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;12345&quot;</span>;<br><span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">string</span>.match(regex) ); <br><span class="hljs-comment">// =&gt; [&quot;12&quot;,&quot;34&quot;]</span><br></code></pre></td></tr></table></figure><h2 id="分组与回溯引用"><a href="#分组与回溯引用" class="headerlink" title="分组与回溯引用"></a>分组与回溯引用</h2><p><strong>分组</strong>：括号()所包裹的表达式内容即为一个分组。</p><p><strong>回溯引用</strong>：模式的后面部分引用前面已经匹配到的子字符串。<br>示例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">var</span> regex = /\d&#123;<span class="hljs-number">4</span>&#125;(-|\/|\.)\d&#123;<span class="hljs-number">2</span>&#125;\<span class="hljs-number">1</span>\d&#123;<span class="hljs-number">2</span>&#125;/;<br></code></pre></td></tr></table></figure><p>在这个正则表达式中\1，表示的引用之前的那个分组<code>(-|\/|\.)</code>。不管它匹配到什么（比如-），\1都匹配那个同样的具体某个字符。<br>使用replace替换字符串时，涉及到的引用变量及其意义包括：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$1</span>,<span class="hljs-variable">$2</span>,...,<span class="hljs-variable">$99</span> 匹配第<span class="hljs-number">1</span>~<span class="hljs-number">99</span>个分组里捕获的文本<br><span class="hljs-variable">$&amp;</span> 匹配到的子串文本<br><span class="hljs-variable">$`</span> 匹配到的子串的左边文本<br><span class="hljs-variable">$&#x27;</span> 匹配到的子串的右边文本<br></code></pre></td></tr></table></figure><h3 id="非捕获分组-p"><a href="#非捕获分组-p" class="headerlink" title="非捕获分组(?:p)"></a>非捕获分组(?:p)</h3><p>该语法仅承担分组的作用而不参与引用，即既不在API里引用，也不在正则里反向引用。</p><h2 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h2><h3 id="位置特性"><a href="#位置特性" class="headerlink" title="位置特性"></a>位置特性</h3><p>位置是相邻字符之间的位置。例如：<br>“halo”&#x3D;&#x3D;“”+“h”+“”+“a”+“”+“l”+“”+“o”</p><h3 id="位置边界"><a href="#位置边界" class="headerlink" title="位置边界"></a>位置边界</h3><ol><li>单词边界：\b<br>示例：<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> result = <span class="hljs-string">&quot;[JS] Lesson_01.mp4&quot;</span>.<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/\b/g</span>, <span class="hljs-string">&#x27;#&#x27;</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(result); <br><span class="hljs-comment">// =&gt; &quot;[#JS#] #Lesson_01#.#mp4#&quot;</span><br></code></pre></td></tr></table></figure>可以看到\b匹配的位置都是由<code>\w</code>到<code>\W</code>或者<code>\W</code>到<code>\w</code>的位置</li><li>字符串边界：<code>^</code>开头匹配，<code>$</code>结尾匹配<h3 id="位置查找"><a href="#位置查找" class="headerlink" title="位置查找"></a>位置查找</h3><h4 id="前向查找-x3D-p"><a href="#前向查找-x3D-p" class="headerlink" title="前向查找(?&#x3D;p)"></a>前向查找(?&#x3D;p)</h4>匹配内容p前面的字符。<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> result = <span class="hljs-string">&quot;hello&quot;</span>.<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/(?=l)/g</span>, <span class="hljs-string">&#x27;#&#x27;</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(result); <br><span class="hljs-comment">// =&gt; &quot;he#l#lo&quot;</span><br></code></pre></td></tr></table></figure><h4 id="后向查找-lt-x3D-p"><a href="#后向查找-lt-x3D-p" class="headerlink" title="后向查找(?&lt;&#x3D;p)"></a>后向查找(?&lt;&#x3D;p)</h4>匹配内容p后面的字符。<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> result = <span class="hljs-string">&quot;hello&quot;</span>.<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/(?=l)/g</span>, <span class="hljs-string">&#x27;#&#x27;</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(result); <br><span class="hljs-comment">// =&gt; &quot;hel#l#o&quot;</span><br></code></pre></td></tr></table></figure><h4 id="前向负查找-p"><a href="#前向负查找-p" class="headerlink" title="前向负查找(?!p)"></a>前向负查找(?!p)</h4>不匹配内容p前面的字符。可以看作是前向查找的反面<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> result = <span class="hljs-string">&quot;hello&quot;</span>.<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/(?!l)/g</span>, <span class="hljs-string">&#x27;#&#x27;</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(result); <br><span class="hljs-comment">// =&gt; &quot;#h#ell#o#&quot;</span><br></code></pre></td></tr></table></figure><h4 id="后向负查找-lt-p"><a href="#后向负查找-lt-p" class="headerlink" title="后向负查找(?&lt;!p)"></a>后向负查找(?&lt;!p)</h4>不匹配内容p后面的字符。可以看作是后向查找的反面<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">var result = &quot;hello&quot;.replace(/(?<span class="hljs-meta">&lt;!l)/g, <span class="hljs-string">&#x27;#&#x27;</span>);</span><br><span class="hljs-meta"><span class="hljs-keyword">console</span>.log(<span class="hljs-keyword">result</span>); </span><br><span class="hljs-meta">// =&gt;</span> &quot;#h#e#llo#&quot;<br></code></pre></td></tr></table></figure><h2 id="正则表达式相关API"><a href="#正则表达式相关API" class="headerlink" title="正则表达式相关API"></a>正则表达式相关API</h2><h3 id="RegExp-对象方法"><a href="#RegExp-对象方法" class="headerlink" title="RegExp 对象方法"></a>RegExp 对象方法</h3><h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4>检索字符串中指定的值。返回找到的值及index，并确定其位置。<br>exec方法能接着上一次匹配后继续匹配。正则实例lastIndex属性，表示下一次匹配开始的位置。<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coq">const patternMatch = (<span class="hljs-built_in">pattern</span>, content) =&gt; &#123;<br>    var positions = []<br>    var <span class="hljs-keyword">match</span> = <span class="hljs-built_in">pattern</span>.exec(content)<br>    while (<span class="hljs-keyword">match</span>) &#123;<br>        positions.push(<span class="hljs-keyword">match</span>.index)<br>        <span class="hljs-keyword">match</span> = <span class="hljs-built_in">pattern</span>.exec(content)<br>    &#125;<br>    <span class="hljs-keyword">return</span> positions<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4>检索字符串中指定的值。返回 true 或 false。<h3 id="String-对象方法"><a href="#String-对象方法" class="headerlink" title="String 对象方法"></a>String 对象方法</h3>第1参数都支持正则和字符串<h4 id="match"><a href="#match" class="headerlink" title="match"></a>match</h4>找到一个或多个正则表达式的匹配。返回找到的值<br>当正则没有g时，使用match返回的信息比较多。但是有g后，就没有关键的信息index了。<h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4>检索与正则表达式相匹配的值。返回与指定查找的字符串或者正则表达式相匹配的 String 对象起始位置，没有则是-1。<h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4>替换与正则表达式匹配的子串。<br>replace第2个参数可以是一个普通的字符串或是一个回调函数。如果第2个参数是回调函数，每匹配到一个结果就回调一次，每次回调都会传递以下参数：<figure class="highlight wasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs wasm"><span class="hljs-keyword">result</span>: 本次匹配到的结果<br><br><span class="hljs-variable">$1</span>,...<span class="hljs-variable">$9</span>: 正则表达式中有几个<span class="hljs-punctuation">()</span>，就会传递几个参数，<span class="hljs-variable">$1</span>~<span class="hljs-variable">$9</span>分别代表本次匹配中每个<span class="hljs-punctuation">()</span>提取的结果，最多<span class="hljs-number">9</span>个<br><br><span class="hljs-keyword">offset</span>:记录本次匹配的开始位置<br><br>source:接受匹配的原始字符串<br></code></pre></td></tr></table></figure></li></ol><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>（1）js数字每三位加逗号间隔（除了toLocaleString方法）</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">num.<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/\d&#123;1,3&#125;(?=(\d&#123;3&#125;)+(\.\d*)?$)/g</span>,<span class="hljs-string">&#x27;$&amp;,&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>$&amp; </code>匹配到的子串文本</p><p>（2）驼峰变量名转下划线变量</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">str.<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/([a-z])([A-Z])/g</span>,<span class="hljs-string">&#x27;$1_$2&#x27;</span>)<br></code></pre></td></tr></table></figure><p>（3）下划线变量转驼峰变量名</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">str.<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/\_([a-z])/g</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">res,$<span class="hljs-number">1</span></span>)&#123;<span class="hljs-keyword">return</span> $<span class="hljs-number">1.</span>toUpperCase()&#125;)<br></code></pre></td></tr></table></figure><p>（4）成对html标签匹配</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/&lt;([^&gt;]+)&gt;[\d\D]*&lt;\/\1&gt;/</span>;<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/6844903845227659271#heading-0">正则表达式不要背</a><br>（2）<a href="https://juejin.cn/post/6844903487155732494#heading-38">JS正则表达式完整教程（略长）</a></p>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于登录拦截和history.back()的二三事</title>
    <link href="/unknown404.github.io/2022/03/31/login/"/>
    <url>/unknown404.github.io/2022/03/31/login/</url>
    
    <content type="html"><![CDATA[<p>记录一个维护老项目时发现的古早bug。</p><span id="more"></span> <h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>WAP项目首页通常有一个用户中心的图标供用户进入自己个人页面。当点击这个用户中心图标时后端会根据请求是否包含登录态来绝对是否重定向请求。例如说目标连接是user.domain.com，在这个域名下的代码由于没有拿到用户个人信息进行了302重定向，重定向后的连接为login.domain.com?to&#x3D;user.domain.com。但如果user.domain.com的代码找到了用户数据就会渲染前端页面。</p><img class="center clear login.jpg 登录逻辑"><p>目前为止看起来是不是毫无问题？</p><p>但如果重定向页面login.domain.com?to&#x3D;user.domain.com有回退按钮呢？前端回退通常使用的方法是history.back()，可以返回上一级页面，此时回退的话就会就会退回user.domain.com，该域名下的代码会再次执行判断登录态的逻辑，发现没有登录态依然会继续重定向，因此实际的页面效果看起来就像登录页面刷新，无法回退到首页。而到了Safari浏览器，由于该移动端浏览器不会重新执行返回的页面的代码，所以浏览器的url停留在user.domain.com，且没有渲染页面，看起来就像白屏故障一样。</p><img class="center clear login-problem.jpg 登录页回退逻辑"><h2 id="解决方式？"><a href="#解决方式？" class="headerlink" title="解决方式？"></a>解决方式？</h2><p>（1）后端的登录跳转逻辑调整（<del>具体怎么改是后端的事跟我有什么关系呢</del> ）</p><p>（2）前端用户中心跳转的链接随获取用户登录态接口的数据而调整</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://t.zoukankan.com/yanggb-p-11675315.html">javascript解决在safari浏览器中使用history.back()返回上一页后页面不会刷新的问题</a></p>]]></content>
    
    
    <categories>
      
      <category>踩坑经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
      <tag>WEB API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小程序海报绘制</title>
    <link href="/unknown404.github.io/2022/03/28/poster/"/>
    <url>/unknown404.github.io/2022/03/28/poster/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>小程序海报绘制目前主要的实现方法有两种：</p><ol><li>前端使用 canvas 绘图并生成</li><li>后端使用后端绘图库进行绘制，返回给小程序端</li></ol><p>第一种方法的主要问题是 canvas 和纯 html 布局相去甚远，不同设备、不同版本的情况下绘图效果不可预期。但第二种方法开发难度也不小，且服务器压力会增大，后端未必愿意接受。所以压力又来到了前端。。。<br>尽管目前前端已经有一些生成海报的插件，如<a href="https://github.com/Kujiale-Mobile/Painter">painter</a>，可以以 json 的格式将元素的定位及样式传给画板。但如果需求出现了较为个性化的要求，例如根据内容海报高度自适应、一行开头不可以有标点等，还是自己手写原生比较好。<br>由于开发使用的是 Taro 框架所以关于 API 的介绍使用也主要以 Taro 为主。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="单位换算"><a href="#单位换算" class="headerlink" title="单位换算"></a>单位换算</h3><p>canvas 绘制使用的是 px 单位，但不同设备的 px 是需要换算的，所以在组件中统一使用 rpx 单位，这里就涉及到单位怎么换算问题。<br>小程序默认屏幕宽度为 750rpx，通过 wx.getSystemInfoSync 获取设备屏幕尺寸宽度，就可以获得实际 px 单位与 rpx 之间的比例，以此做单位转换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">rpx2px</span>(<span class="hljs-params">distance</span>) &#123;<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isNaN</span>(distance)) &#123;<br>        result = wx.<span class="hljs-title function_">getSystemInfoSync</span>().<span class="hljs-property">windowWidth</span> * distance / <span class="hljs-number">750</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">px2rpx</span>(<span class="hljs-params">distance</span>) &#123;<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isNaN</span>(distance)) &#123;<br>        result = distance * <span class="hljs-number">750</span> / wx.<span class="hljs-title function_">getSystemInfoSync</span>().<span class="hljs-property">windowWidth</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="canvas-隐藏"><a href="#canvas-隐藏" class="headerlink" title="canvas 隐藏"></a>canvas 隐藏</h3><p>在绘制海报过程时，因为不想让用户看到 canvas，所以我们必须把 canvas 隐藏起来。实现方法为控制 canvas 的绝对定位，将其移出可视界面。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.poster-canvas</span> &#123;<br>  <span class="hljs-attribute">position</span>: fixed;<br>  <span class="hljs-attribute">top</span>: -<span class="hljs-number">10000</span>rpx;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="canvas初始化"><a href="#canvas初始化" class="headerlink" title="canvas初始化"></a>canvas初始化</h2><p>canvas的初始化操作本身并不难，在模版中添加一个canvas组件并命名，在点击生成海报按钮时拿到canvas实例并设置宽高。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">const</span> ctx = Taro.<span class="hljs-property">createCanvasContext</span>(<span class="hljs-string">&#x27;poster-canvas&#x27;</span>)<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-built_in">width</span>, <span class="hljs-built_in">height</span> &#125; = <span class="hljs-variable">this</span>.<span class="hljs-property">state</span><br><span class="hljs-comment">// 底版</span><br>ctx.<span class="hljs-property">width</span> = <span class="hljs-built_in">width</span><br>ctx.<span class="hljs-property">height</span> = <span class="hljs-built_in">height</span><br></code></pre></td></tr></table></figure><p>如果海报宽高固定，直接赋值即可。但如果希望完成海报高度随文字内容自适应变化的需求时，则需要多一步操作：可以先在渲染阶段制造一个DOM结构，将该DOM按照设计稿的需求绘制文字、外框间距等内容，在点击生成海报时利用createSelectorQuery获取海报中可变DOM元素(如海报正文DOM）的宽高，以及海报最外层DOM的宽高。注意该方法获取到的结果单位是px。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Taro.nextTick(() =&gt; &#123;<br>    <span class="hljs-keyword">const</span> query = Taro.createSelectorQuery()<br>    query.select(<span class="hljs-string">&#x27;.key-box&#x27;</span>).boundingClientRect()<br>    query.exec(res =&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">const</span> height = px2rpx(res[<span class="hljs-number">0</span>].height)<br>            <span class="hljs-keyword">const</span> width = px2rpx(res[<span class="hljs-number">0</span>].width)<br>            <span class="hljs-keyword">this</span>.setState(&#123; width, height &#125;)<br>            <span class="hljs-keyword">this</span>.drawPosterCanvas()<span class="hljs-comment">//绘制canvas</span><br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>            <span class="hljs-keyword">this</span>.failCb()<span class="hljs-comment">//错误处理</span><br><br>        &#125;<br>    &#125;)<br><br>&#125;)<br></code></pre></td></tr></table></figure><p>使用Taro框架时需注意查询DOM属于异步内容无法立即获取只能利用nextTick函数等待下一个时间片获取，获取到以后存储到state里便于绘图时取出。这里需要注意即使将查询内容放在nextTick里，也有少数未查到DOM结果的情况，需要进行错误处理。</p><h2 id="图形篇"><a href="#图形篇" class="headerlink" title="图形篇"></a>图形篇</h2><h3 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h3><p>由于小程序打包的大小有限制，因此图片建议使用 CDN 保存。在绘制图片前需要对远程的图片进行下载的操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">downloadSharePic = <span class="hljs-function">(<span class="hljs-params">url</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-title class_">Taro</span>.<span class="hljs-title function_">downloadFile</span>(&#123;<br>            url,<br>            <span class="hljs-title function_">success</span>(<span class="hljs-params">res</span>) &#123;<br>                <span class="hljs-keyword">if</span> (res.<span class="hljs-property">statusCode</span> === <span class="hljs-number">200</span>) &#123;<br>                    <span class="hljs-title function_">resolve</span>(res.<span class="hljs-property">tempFilePath</span>)<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-title function_">reject</span>(res)<br>                &#125;<br>            &#125;,<br>            <span class="hljs-title function_">fail</span>(<span class="hljs-params">err</span>) &#123;<br>                <span class="hljs-title function_">reject</span>(err)<br>            &#125;<br>        &#125;)<br>    &#125;)<br><br>&#125;<br></code></pre></td></tr></table></figure><p>下载成功后会获得一个临时文件路径，就可以调用 drawImage 函数来绘制了。注意点：下载图片属于异步操作，需要在等待返回值以后才可以绘制。<br>ctx.drawImage 有 3 种写法：</p><ul><li>drawImage(imageResource, dx, dy)</li><li>drawImage(imageResource, dx, dy, dWidth, dHeight)</li><li>drawImage(imageResource, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) 从 1.9.0 起支持<br>如果无法使用第三种方案、需要自己调整图片宽高按设计比例显示在 canvas 上的话，可以采用如下函数：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">getDrawImgParams = <span class="hljs-function">(<span class="hljs-params">src,defaultWidth,defaultHeight</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-title class_">Taro</span>.<span class="hljs-title function_">getImageInfo</span>(&#123;<br>            src,<br>            <span class="hljs-attr">success</span>: <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">const</span> &#123; width, height &#125; = res<br>                <span class="hljs-keyword">let</span> sx = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">let</span> sy = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">let</span> sWidth = width<br>                <span class="hljs-keyword">let</span> sHeight = height<br>                <span class="hljs-keyword">const</span> w2h = width / height<br>                <span class="hljs-keyword">const</span> defaultW2H = defaultWidth / defaultHeight<br>                <span class="hljs-keyword">if</span> (w2h &gt; defaultW2H) &#123; <span class="hljs-comment">// 更宽</span><br>                    sWidth = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(height * defaultW2H)<br>                    sx = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((width - sWidth) / <span class="hljs-number">2</span>)<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (w2h &lt; defaultW2H) &#123; <span class="hljs-comment">// 更高</span><br>                    sHeight = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(width / defaultW2H)<br>                    sy = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((height - sHeight) / <span class="hljs-number">2</span>)<br>                &#125;<br>                <span class="hljs-title function_">resolve</span>(&#123;<br>                    sx,<br>                    sWidth,<br>                    sy,<br>                    sHeight<br>                &#125;)<br>            &#125;,<br>            <span class="hljs-attr">fail</span>: <span class="hljs-function"><span class="hljs-params">rej</span> =&gt;</span> &#123;<br>                <span class="hljs-title function_">reject</span>(rej)<br>            &#125;<br>        &#125;)<br>    &#125;)<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="绘制圆形"><a href="#绘制圆形" class="headerlink" title="绘制圆形"></a>绘制圆形</h3><p>需要用到的函数是 canvasContext.arc，作用是绘制一条曲线。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">canvasContext.arc(x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>, r: <span class="hljs-built_in">number</span>, sAngle: <span class="hljs-built_in">number</span>, eAngle: <span class="hljs-built_in">number</span>, counterclockwise?: <span class="hljs-built_in">boolean</span>)<br></code></pre></td></tr></table></figure><p>x、y 对应圆心坐标，sAngle 是起始弧度，eAngle 是终止弧度。创建一个圆可以指定起始弧度为 0，终止弧度为 2 * Math.PI。<br>如果是画线框就使用 ctx.stroke();如果是画色块就使用 ctx.fill()。</p><h3 id="绘制圆角矩形"><a href="#绘制圆角矩形" class="headerlink" title="绘制圆角矩形"></a>绘制圆角矩形</h3><p>canvas 并没有提供绘制圆角矩形的方法，因此我们需要以另一种方法来实现它。方法的核心是将圆角矩形拆解成四个直角圆弧和四条直线连接的图形。具体的实现如下面的代码所示。圆弧的绘制除了上面提到的arc之外，还有一个叫 CanvasContext.arcTo 的方法，其特点是控制点和半径绘制圆弧路径。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">drawArcFrame = <span class="hljs-function">(<span class="hljs-params">ctx, x, y, r, w, h</span>) =&gt;</span> &#123;<br>    ctx.<span class="hljs-title function_">beginPath</span>()<br>    ctx.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&#x27;transparent&#x27;</span>;<br>    <span class="hljs-comment">// 左上角</span><br>    ctx.<span class="hljs-title function_">arc</span>(x + r, y + r, r, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">1.5</span>)<br><br>    <span class="hljs-comment">// border-top</span><br>    ctx.<span class="hljs-title function_">moveTo</span>(x + r, y)<br>    ctx.<span class="hljs-title function_">lineTo</span>(x + w - r, y)<br>    ctx.<span class="hljs-title function_">lineTo</span>(x + w, y + r)<br>    <span class="hljs-comment">// 右上角</span><br>    ctx.<span class="hljs-title function_">arc</span>(x + w - r, y + r, r, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">1.5</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>)<br><br>    <span class="hljs-comment">// border-right</span><br>    ctx.<span class="hljs-title function_">lineTo</span>(x + w, y + h - r)<br>    ctx.<span class="hljs-title function_">lineTo</span>(x + w - r, y + h)<br>    <span class="hljs-comment">// 右下角</span><br>    ctx.<span class="hljs-title function_">arc</span>(x + w - r, y + h - r, r, <span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">0.5</span>)<br><br>    <span class="hljs-comment">// border-bottom</span><br>    ctx.<span class="hljs-title function_">lineTo</span>(x + r, y + h)<br>    ctx.<span class="hljs-title function_">lineTo</span>(x, y + h - r)<br>    <span class="hljs-comment">// 左下角</span><br>    ctx.<span class="hljs-title function_">arc</span>(x + r, y + h - r, r, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">0.5</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>)<br><br>    <span class="hljs-comment">// border-left</span><br>    ctx.<span class="hljs-title function_">lineTo</span>(x, y + r)<br>    ctx.<span class="hljs-title function_">lineTo</span>(x + r, y)<br><br>    <span class="hljs-comment">// 这里是使用 fill 还是 stroke都可以，二选一即可，但是需要与上面对应</span><br>    ctx.<span class="hljs-title function_">fill</span>()<br>    <span class="hljs-comment">// ctx.stroke()</span><br>    ctx.<span class="hljs-title function_">closePath</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是绘制图片的外框，我们通常需要对原图进行剪切获得我们需要的样式。在我们调用 CanvasContext.clip()进行剪切时，之后的绘图都会被限制在被剪切的区域内（不能访问画布上的其他区域）。因此在使用 clip 方法前通过使用 save 方法对当前画布区域进行保存，在裁剪完图片后通过 restore 方法对其进行恢复。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">ctx.<span class="hljs-title function_">save</span>()<span class="hljs-comment">// 1)保存画布区域</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawArcFrame</span>(ctx, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">12</span>, width, height)<span class="hljs-comment">//2)绘制圆角</span><br>ctx.<span class="hljs-title function_">clip</span>()<span class="hljs-comment">//3）裁剪画板</span><br>ctx.<span class="hljs-title function_">setFillStyle</span>(<span class="hljs-string">&#x27;#F8F9FB&#x27;</span>)<br>ctx.<span class="hljs-title function_">fillRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height)<span class="hljs-comment">//4）在剪切后的画板绘图</span><br>ctx.<span class="hljs-title function_">restore</span>()<span class="hljs-comment">//5）恢复画板区域</span><br></code></pre></td></tr></table></figure><h3 id="绘制阴影"><a href="#绘制阴影" class="headerlink" title="绘制阴影"></a>绘制阴影</h3><p>微信小程序本体从基础库 1.9.90 开始支持设置。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 阴影的x偏移<br>ctx.shadowOffsetX = <span class="hljs-number">10</span>;<br><span class="hljs-regexp">//</span> 阴影的y偏移<br>ctx.shadowOffsetY = <span class="hljs-number">10</span>;<br><span class="hljs-regexp">//</span> 阴影颜色<br>ctx.shadowColor = <span class="hljs-string">&#x27;rgba(0,0,0,0.5)&#x27;</span>;<br><span class="hljs-regexp">//</span> 阴影的模糊半径<br>ctx.shadowBlur = <span class="hljs-number">10</span>;<br><span class="hljs-regexp">//</span> 绘制图形<br>ctx.fillStyle = <span class="hljs-string">&#x27;rgba(255,0,0,0.5)&#x27;</span><br>ctx.fillRect(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p>阴影的设置一定要在图形绘制前。</p><h3 id="圆形内阴影和圆角矩形内阴影"><a href="#圆形内阴影和圆角矩形内阴影" class="headerlink" title="圆形内阴影和圆角矩形内阴影"></a>圆形内阴影和圆角矩形内阴影</h3><p>大致思路：先绘制边框和阴影，再用clip把外阴影裁掉。</p><h2 id="文字篇"><a href="#文字篇" class="headerlink" title="文字篇"></a>文字篇</h2><h3 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h3><p>Taro 框架支持的关于字体的方法只有 setFontSize，用于修改字体大小。<br>但微信小程序本体从基础库 1.9.90 开始支持设置字体样式 canvasContext.font。涉及到的参数如下所示：</p><table><thead><tr><th align="center">属性</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">style</td><td align="center">字体样式。仅支持 italic, oblique, normal</td></tr><tr><td align="center">weight</td><td align="center">字体粗细。仅支持 normal, bold</td></tr><tr><td align="center">size</td><td align="center">字体大小</td></tr><tr><td align="center">family</td><td align="center">字体族名。注意确认各平台所支持的字体</td></tr></tbody></table><p>示例：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ctx.font</span> = <span class="hljs-string">&#x27;normal bold 40px sans-serif&#x27;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>关于字体粗细的问题据说安卓手机只 400 和 700 的 font-weight，如果设置其他的权重也无法实现效果。需要注意点是如果设置了加粗属性 bold，那么在后续文字书写中 weight 的属性值必须设置为 400 而不是 normal，否则在安卓机上后续绘制的文字仍然加粗，尽管开发者工具上正常。</p><h3 id="单行文字"><a href="#单行文字" class="headerlink" title="单行文字"></a>单行文字</h3><p>需要用到的函数是 canvasContext.fillText。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">canvasContext.fill<span class="hljs-constructor">Text(<span class="hljs-params">text</span>: <span class="hljs-params">string</span>, <span class="hljs-params">x</span>: <span class="hljs-params">number</span>, <span class="hljs-params">y</span>: <span class="hljs-params">number</span>, <span class="hljs-params">maxWidth</span>?: <span class="hljs-params">number</span>)</span><br></code></pre></td></tr></table></figure><p>x、y 对应文字左上角坐标。<br>需要注意的点是绘制文字前需要使用 setTextBaseline 函数确定文字竖直方向对齐方式，不设置的话似乎默认是 normal，而不同系统设备上各个基准都不太一样，绘制的效果可能达不到预期。通常设置 top 即可满足需求，如果设置了 middle 则 y 值应该为文字左上的 y 坐标+fontSize&#x2F;2。</p><h3 id="多行文字"><a href="#多行文字" class="headerlink" title="多行文字"></a>多行文字</h3><p>canvas 绘制文字时，只会一股脑的在单行上一直画下去而不会根据容器宽度自动换行。如果希望进行折行、分段，则可以使用 CanvasContext.measureText(string text)的方法，具体步骤包括：</p><ul><li>1）准备工作：去除文本里面和空格相关的字符，保留的话可能在安卓机上出现绘制异常</li><li>2）用tempText变量存储单行字段，逐字遍历文本，用measureText测截至当前字符的文段长度是否超过限定宽度，没有则将当前字符添加到tempText；注意设置阈值时要减去一个字宽，防止遍历到接近折行的位置已经存储的字段tempText已经接近于限制宽度、此时再加一个字符超过设计宽度的情况。</li><li>3）measureText测截至当前字符的文段长度超过限定宽度时将该字段推入数组中保存；同时清空tempText，用于下一行文字的测算。</li><li>4）循环结束后不要忘记将最后一行的结果推入数组row中</li><li>5）遍历行数组row，每行用fillText完成</li><li>6）如果考虑行数限制，可以在遍历row时增加判断条件，在绘制到最后一行时将最后一个字替换为省略号</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">processWord = <span class="hljs-function">(<span class="hljs-params">ctx, text, width,fontSize,lineHeight,maxLine</span>) =&gt;</span> &#123;<br>    text=text.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\s*/g</span>,<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">let</span> row = []<br>    <span class="hljs-keyword">let</span> tempText = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> wordIndex = <span class="hljs-number">0</span>; wordIndex &lt; text.<span class="hljs-property">length</span>; wordIndex++) &#123;<br>        <span class="hljs-keyword">if</span> (ctx.<span class="hljs-title function_">measureText</span>(tempText).<span class="hljs-property">width</span> &lt; width - fontSize) &#123;<br>            tempText += text[wordIndex]<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 折行位置</span><br>            wordIndex--<br>            row.<span class="hljs-title function_">push</span>(tempText)<br>            tempText = <span class="hljs-string">&#x27;&#x27;</span><br>        &#125;<br>    &#125;<br>    row.<span class="hljs-title function_">push</span>(tempText)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> rowNum = <span class="hljs-number">0</span>; rowNum &lt; row.<span class="hljs-property">length</span>&amp;&amp;rowNum&lt;maxLine; rowNum++) &#123;<br>        <span class="hljs-keyword">let</span> text = row[rowNum]<br>        <span class="hljs-keyword">if</span> (row.<span class="hljs-property">length</span> &gt; maxLine &amp;&amp; rowNum == maxLine-<span class="hljs-number">1</span>) &#123;<br>            text = text.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, text.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>) + <span class="hljs-string">&#x27;...&#x27;</span><br>        &#125;<br>        ctx.<span class="hljs-title function_">setTextBaseline</span>(<span class="hljs-string">&#x27;top&#x27;</span>)<br>        ctx.<span class="hljs-title function_">fillText</span>(text, <span class="hljs-number">70</span>, <span class="hljs-number">258</span> + rowNum * lineHeight)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="附加要求：标点不可以出现在首行"><a href="#附加要求：标点不可以出现在首行" class="headerlink" title="附加要求：标点不可以出现在首行"></a>附加要求：标点不可以出现在首行</h4><p>在上述算法的基础上在折行处增加while判断，如果字符是标点就加在当前行tempText，一直到下一个是汉字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> wordIndex = <span class="hljs-number">0</span>; wordIndex &lt; text.<span class="hljs-property">length</span>; wordIndex++) &#123;<br>    <span class="hljs-keyword">if</span> (ctx.<span class="hljs-title function_">measureText</span>(tempText).<span class="hljs-property">width</span> &lt; width - fontSize) &#123;<br>        tempText += text[wordIndex]<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 折行位置</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-regexp">/[，。”！？、：）》；]/</span>.<span class="hljs-title function_">test</span>(text[wordIndex])) &#123;<br>            tempText += text[wordIndex++]<br>        &#125;<br>        wordIndex--<br>        row.<span class="hljs-title function_">push</span>(tempText)<br>        tempText = <span class="hljs-string">&#x27;&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="绘制展示"><a href="#绘制展示" class="headerlink" title="绘制展示"></a>绘制展示</h2><h3 id="canvas转image"><a href="#canvas转image" class="headerlink" title="canvas转image"></a>canvas转image</h3><p>绘制完成后需要调用Taro.canvasToTempFilePath将canvas转为图片输出，需要注意的点包括：1）Taro.canvasToTempFilePath需要写在ctx.draw的回调中；2）draw的回调函数是异步的，canvasToTempFilePath需要在setTimeout中做一些延时，一般1s就可以了。<br>生成的临时url传入Image组件中就可以在屏幕中显示了。</p><h3 id="海报预览使用-scroll-view-展示时，该组件没有显示-css-样式的圆角"><a href="#海报预览使用-scroll-view-展示时，该组件没有显示-css-样式的圆角" class="headerlink" title="海报预览使用 scroll-view 展示时，该组件没有显示 css 样式的圆角"></a>海报预览使用 scroll-view 展示时，该组件没有显示 css 样式的圆角</h3><p>解决方法：在 scroll-view 元素上添加以下样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">overflow</span>: hidden;<br><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">0</span>);<br><span class="hljs-attribute">border-radius</span>: <span class="hljs-number">16</span>rpx;<br></code></pre></td></tr></table></figure><p>当海报的高度没有超过设计稿的可视高度时，scroll-view作为套在海报外层的组件也不应该有滚动条。可以在海报生成组件的state里再维护一个isScroll的变量，判断和赋值的位置可以在<a href="#canvas%E5%88%9D%E5%A7%8B%E5%8C%96">canvas初始化</a>执行。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="http://www.yanghuiqing.com/web/350">在Canvas中实现矩形、圆形、圆角矩形内阴影效果</a>  </li><li><a href="https://juejin.cn/post/6983574104167170061">手把手教你用canvas绘制小程序海报（一）</a>  </li><li><a href="https://juejin.cn/post/6844903663840788493#heading-0">轻松生成小程序分享海报</a>  </li><li><a href="https://juejin.cn/post/7039199842421178382#heading-1">微信小程序《海报生成》</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小程序</tag>
      
      <tag>canvas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript</title>
    <link href="/unknown404.github.io/2022/03/27/typescript/"/>
    <url>/unknown404.github.io/2022/03/27/typescript/</url>
    
    <content type="html"><![CDATA[<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>类型系统按照「是否允许隐式类型转换」来分类，可以分为强类型和弱类型。<br>JavaScript 就属于弱类型语言，灵活性强，但不利的一点是没有编译过程，语言的类型错误只有运行时才会发现（JavaScript 因此被称为动态语言）。而 TypeScript 可以弥补这一点：TypeScript 在运行前需要先编译为 JavaScript，而在编译阶段就会进行类型检查并报错（TypeScript 对应称为静态语言）。同时 TypeScript 增强了编辑器（IDE）的功能，包括代码补全、接口提示、跳转到定义、代码重构等，这在很大程度上提高了开发效率。</p><p>本文主要记录一些常用的 typescript 语法及一些需要辨析的注意点。</p><h2 id="anyScript-使用方法"><a href="#anyScript-使用方法" class="headerlink" title="anyScript 使用方法"></a>anyScript 使用方法</h2><p>用于代码标红但确实不知道如何声明的场景</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> @ts-nocheck 禁用整个文件的ts校验，置于文件头顶<br><span class="hljs-regexp">//</span> @ts-ignore 禁用单行ts校验，放在报错行的上方使用<br>any和unknown<br></code></pre></td></tr></table></figure><p>在遇到确实难以定义类型的场景下可以使用以上方法逃课，以后再思考可能的改进方式。</p><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><p>在 TypeScript 3.1 的文档里，基础类型包括：boolean,string,number,Array&lt;&gt;,Tuple,any,void,undefined,null,never<br>简单记录下使用偏少的类型它的特点。</p><p>辨析点：</p><h3 id="1）unknown-vs-any"><a href="#1）unknown-vs-any" class="headerlink" title="1）unknown vs any"></a>1）unknown vs any</h3><p>unknown 与 any 一样，所有类型都可以分配给 unknown，unknown 类型的值只能赋给 unknown 本身和 any 类型。但 unknown 仍然有静态检测能力，个人理解是 unknown 没有放弃类型的推断，并不是所有类型的内部方法 unknown 类型数据都可以随便调用</p><h3 id="2）void，null-和-undefined"><a href="#2）void，null-和-undefined" class="headerlink" title="2）void，null 和 undefined"></a>2）void，null 和 undefined</h3><p>相同点是这 3 个本身在声明变量的过程中用处不大。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-attr">unusable</span>: <span class="hljs-keyword">void</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">u</span>: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">n</span>: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>默认情况下 null 和 undefined 是所有类型的子类型。<br>undefined 也是 void 的一个子集。当你对函数返回值并不在意（number、boolean、undefined 都可以是返回值）时，使用 void 而不是 undefined。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型是一种在定义函数、接口或类的时候，不预先指定具体的类型，而是在使用的时候再指定类型的技术。</p><h2 id="接口与类型别名"><a href="#接口与类型别名" class="headerlink" title="接口与类型别名"></a>接口与类型别名</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>可用于对象类型命名和定义类型参数。<br>基本语法：<code>interface SquareConfig &#123;&#125;</code><br>接口名开头需大写，因为定义的是一种类型。</p><h4 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h4><p>使用写法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">interface SquareConfig &#123;<br>  <span class="hljs-attribute">color</span>?: string;<br>  <span class="hljs-attribute">width</span>?: number;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据使用经验，在调用该类型 SquareConfig 的变量其属性时编译等效于：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SquareConfig</span> &#123;<br>  <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span>｜<span class="hljs-literal">undefined</span>;<br>  <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>｜<span class="hljs-literal">undefined</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以假如使用变量的 color 属性调用 string 的默认方法或者赋值给一个 string 变量时就会报错</p><h4 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h4><p>一些对象属性只能在对象刚刚创建的时候修改其值。可以在属性名前用 readonly 来指定只读属性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">readonly</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-keyword">readonly</span> <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>辨析点：<br><strong>const vs readonly</strong>：const 可以防止变量的值被修改，readonly 可以防止变量的属性被修改。</p><h4 id="索引签名"><a href="#索引签名" class="headerlink" title="索引签名"></a>索引签名</h4><p>描述了对象索引的类型，还有相应的索引返回值类型。索引签名只支持以下两种：</p><ul><li>字符串索引签名</li><li>数字索引签名<br>一个接口中最多只能定义一个字符串索引签名，该签名会约束对象类型的所有属性类型。</li></ul><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">interface</span> NumberDictionary &#123;<br>  [<span class="hljs-built_in">index</span>: string]: <span class="hljs-keyword">number</span>;<br>  length: <span class="hljs-keyword">number</span>;    // 可以，length是<span class="hljs-keyword">number</span>类型<br>  <span class="hljs-keyword">name</span>: string       // 错误，`<span class="hljs-keyword">name</span>`的类型与索引类型返回值的类型不匹配<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名声明可以为 TypeScript 中任意类型命名<br>基本语法：<code>type AliasType=string｜boolean｜number</code></p><h3 id="interface-与-type-区别"><a href="#interface-与-type-区别" class="headerlink" title="interface 与 type 区别"></a>interface 与 type 区别</h3><ol><li>type 可以用于非对象类型，而接口只能用于对象类型</li><li>接口可以继承其他对象类型，type 不支持继承只能用交叉类型实现继承效果。</li></ol><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- type类型扩展方式 --&gt;</span></span><br><span class="language-xml">type Name = </span><span class="hljs-template-variable">&#123; name: string &#125;</span><span class="language-xml">;</span><br><span class="language-xml">type Person = Name &amp; </span><span class="hljs-template-variable">&#123; age: number &#125;</span><span class="language-xml">;</span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- interface类型扩展方式 --&gt;</span></span><br><span class="language-xml">interface IName </span><span class="hljs-template-variable">&#123; name: string &#125;</span><span class="language-xml">;</span><br><span class="language-xml">interface IPerson extends IName </span><span class="hljs-template-variable">&#123; age: number &#125;</span><span class="language-xml">;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>接口具有声明合并的行为，type 没有</li></ol><h2 id="运算符使用"><a href="#运算符使用" class="headerlink" title="运算符使用"></a>运算符使用</h2><h3 id="非空断言运算符"><a href="#非空断言运算符" class="headerlink" title="非空断言运算符 !"></a>非空断言运算符 !</h3><p>置于变量名后，用于强调元素不是 null 或 undefined。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">const</span> test=(<span class="hljs-keyword">func</span>:<span class="hljs-params">()</span>=&gt;<span class="hljs-title function_">void</span>)=&gt;&#123;<br>    <span class="hljs-keyword">func</span>!<span class="hljs-params">()</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="可选链运算符"><a href="#可选链运算符" class="headerlink" title="可选链运算符 ?."></a>可选链运算符 ?.</h3><p>ES11(ES2020)新增的特性。?.用来判断左侧的变量是否存在，不存在不会继续表达式运算。例如书写 a?.b 时实际上等效于</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">a === <span class="hljs-literal">null</span> || a === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : a.b;<br></code></pre></td></tr></table></figure><h3 id="空值合并运算符"><a href="#空值合并运算符" class="headerlink" title="空值合并运算符 ??"></a>空值合并运算符 ??</h3><p>ES11(ES2020)新增的特性。当左侧的操作数为 null 或者 undefined 时，返回其右侧操作数，否则返回左侧操作数。<br>let b &#x3D; a ?? 10 等效于</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">let</span> <span class="hljs-string">b</span> <span class="hljs-string">=</span> <span class="hljs-string">a</span> <span class="hljs-type">!==</span> <span class="hljs-literal">null</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">a</span> <span class="hljs-type">!==</span> <span class="hljs-string">void</span> <span class="hljs-number">0</span> <span class="hljs-string">?</span> <span class="hljs-attr">a :</span> <span class="hljs-number">10</span><span class="hljs-string">;</span><br></code></pre></td></tr></table></figure><h3 id="数字分割符"><a href="#数字分割符" class="headerlink" title="数字分割符_"></a>数字分割符_</h3><p>可以用于长数字分隔，方便阅读，不会编译进 JavaScript。个人理解类似计算器的数字每隔 3 位加一个逗号方便阅读的作用。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">let</span> num:number = <span class="hljs-number">12</span>_345.<span class="hljs-number">678</span>_9<br></code></pre></td></tr></table></figure><h2 id="内置工具类型"><a href="#内置工具类型" class="headerlink" title="内置工具类型"></a>内置工具类型</h2><h3 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial<T></h3><p>作用是将泛型 T 所有属性变为可选属性。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">Partial</span>&lt;<span class="hljs-type">T</span>&gt; = &#123;<br>[<span class="hljs-type">P</span> in keyof <span class="hljs-type">T</span>]?: <span class="hljs-type">T</span>[<span class="hljs-type">P</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required<T></h3><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elm">作用是将泛型<span class="hljs-type">T</span>所有属性变为必选属性。<br><span class="hljs-keyword">type</span> <span class="hljs-type">Required</span>&lt;<span class="hljs-type">T</span>&gt; = &#123;<br>  [<span class="hljs-type">P</span> in keyof <span class="hljs-type">T</span>]-?: <span class="hljs-type">T</span>[<span class="hljs-type">P</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Record-lt-K-T-gt"><a href="#Record-lt-K-T-gt" class="headerlink" title="Record&lt;K, T&gt;"></a>Record&lt;K, T&gt;</h3><p>作用是将 K 中所有属性值转化为 T 类型。K 提供对象属性名的联合类型，T 提供对象属性类型。<br>因为 K 是用作对象属性名设置，所以参数 K 必须能够赋值给 string ｜ number ｜ symbol 类型。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Record&lt;K</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">any</span>,<span class="hljs-title">T&gt;</span> </span>= &#123;<br>  [key in <span class="hljs-type">K</span>]: <span class="hljs-type">T</span><br>&#125;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">type</span> K=<span class="hljs-string">&#x27;x&#x27;</span>|<span class="hljs-string">&#x27;y&#x27;</span><br><span class="hljs-keyword">type</span> R=<span class="hljs-keyword">Record</span>&lt;K,number&gt;<br><span class="hljs-keyword">const</span> a:R=<span class="hljs-comment">&#123;x:0,y:0&#125;</span><br></code></pre></td></tr></table></figure><h3 id="Pick-lt-T-K-gt"><a href="#Pick-lt-T-K-gt" class="headerlink" title="Pick&lt;T, K&gt;"></a>Pick&lt;T, K&gt;</h3><p>作用是将 T 类型中的 K 键列表提取，K 必须为对象类型 T 存在的属性。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Pick&lt;T</span>, <span class="hljs-title">K</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">T&gt;</span> </span>= &#123;<br>  [<span class="hljs-type">P</span> in <span class="hljs-type">K</span>]: <span class="hljs-type">T</span>[<span class="hljs-type">P</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">interface <span class="hljs-built_in">Point</span>=&#123;<span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>,<span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>&#125;<br>type T=Pick&lt;<span class="hljs-built_in">Point</span>,<span class="hljs-string">&#x27;x&#x27;</span>|<span class="hljs-string">&#x27;y&#x27;</span>&gt;<span class="hljs-comment">//&#123;x:number,y:number&#125;</span><br></code></pre></td></tr></table></figure><h3 id="Omit-lt-T-K-gt"><a href="#Omit-lt-T-K-gt" class="headerlink" title="Omit&lt;T, K&gt;"></a>Omit&lt;T, K&gt;</h3><p>与<code>Pick&lt;T, K&gt;</code>互补。用于去除类型 T 中包含 K 的键值对。如果 K 为 T 不存在的属性则新类型等同于 T。</p><h3 id="Exclude-lt-T-U-gt"><a href="#Exclude-lt-T-U-gt" class="headerlink" title="Exclude&lt;T, U&gt;"></a>Exclude&lt;T, U&gt;</h3><p>在 T 类型中，去除 T 类型和 U 类型的交集。</p><h3 id="Extract-lt-T-U-gt"><a href="#Extract-lt-T-U-gt" class="headerlink" title="Extract&lt;T, U&gt;"></a>Extract&lt;T, U&gt;</h3><p>与<code>Exclude&lt;T, U&gt;</code>互补。获取 T 类型中所有能赋值给 U 的类型，没有返回 never。</p><h3 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType<T></h3><p>获取 T 类型(函数)对应的返回值类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> &#123; <span class="hljs-comment">/*..*/</span> &#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">FooType</span> = <span class="hljs-title class_">ReturnType</span>&lt;foo&gt;;  <span class="hljs-comment">// string | number</span><br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>（1）<a href="https://juejin.cn/post/6926794697553739784">TypeScript 高级用法</a><br>（2）<a href="https://juejin.cn/post/6981728323051192357#heading-0">一篇够用的 TypeScript 总结</a><br>（3）<a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html">TypeScript 文档</a></p>]]></content>
    
    
    <categories>
      
      <category>前端技术体系</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch查询语句使用</title>
    <link href="/unknown404.github.io/2022/03/14/esUseage/"/>
    <url>/unknown404.github.io/2022/03/14/esUseage/</url>
    
    <content type="html"><![CDATA[<p>es 中的查询请求有两种方式，一种是简易版的查询，另外一种是使用 JSON 完整的请求体，叫做结构化查询（DSL）。DSL 的查询方式是 POST 过去一个 json，由于 post 的请求是 json 格式的，所以存在很多灵活性，也有很多形式。笔者出于使用 nodejs 技术调用 es 查询的需求，因此主要搜集的资料是关于 DSL 的。</p><p>本文并不是查询方法的全列举，而是针对自己实际使用的几种方法进行比较辨析。如果日后尝试使用其他方法，也会在这里添加补充说明。</p><div class="note note-info">            <p>使用 DSL 查询语法时，由于使用 json 字符串时存在特殊符号例如<code>*,/,\</code>等影响解析，因此需要使用两个反斜杠<code>\\</code>进行转义</p>          </div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">calcQueryString</span>=(<span class="hljs-params">keyword:<span class="hljs-built_in">string</span></span>)=&gt;&#123;<br>    <span class="hljs-keyword">return</span> keyword.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/([-\/\\^$*+?.()|[\]&#123;&#125;])/g</span>, <span class="hljs-string">&#x27;\\$1&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="全文查询"><a href="#全文查询" class="headerlink" title="全文查询"></a>全文查询</h2><h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p>不需要完整的卢塞恩语法支持。在查询语句里任何一个词项与分词匹配都会返回该文档。如果要查询所有关键词的文档，可以使用 and 操作符连接。结果里关键词但次序无法保证。</p><p>查询结构示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;match&quot;: &#123;<br>        &quot;<span class="hljs-attribute">content</span>&quot; : <span class="hljs-string">&quot;小白的文件整理箱&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该查询语句可能根据分词规则分为“小白”、“白的”、“文”、“整理箱”等多种关键词，只要有匹配的字词就会被搜出来，例如“文无定法”、“文小白”等都有可能</p><h3 id="match-phrase"><a href="#match-phrase" class="headerlink" title="match_phrase"></a>match_phrase</h3><p>在执行短语匹配查询时，查询结果会满足两个条件：1）必须匹配短语中的所有分词 2）保证各个分词的相对位置不变。</p><p>以 match 的查询语句为例，查询结果不会出现“文小白”，但有可能出现“小白菜的 zip 文件垃圾整理行李箱”</p><h3 id="multi-match"><a href="#multi-match" class="headerlink" title="multi_match"></a>multi_match</h3><p>match 语法的升级，可用于多个字段。也可以用指数符指定多个字段的权重</p><p>查询结构示例：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;multi_match&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;query&quot;</span> : <span class="hljs-string">&quot;小白的文件整理箱&quot;</span>,<br>        <span class="hljs-string">&quot;fields&quot;</span>:[<span class="hljs-string">&quot;title^3&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="query-string"><a href="#query-string" class="headerlink" title="query_string"></a>query_string</h3><p>常见写法：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;query_string&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;query&quot;</span>: <span class="hljs-string">&quot;(new york city) OR (big apple)&quot;</span>,<br>      <span class="hljs-string">&quot;fields&quot;</span>: [<span class="hljs-string">&quot;content&quot;</span>]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>支持运算符 AND 和 OR，括号内的查询语句作为整个查询。<br>支持 wildcard 语法。</p><h2 id="词项查询"><a href="#词项查询" class="headerlink" title="词项查询"></a>词项查询</h2><h3 id="term"><a href="#term" class="headerlink" title="term"></a>term</h3><p>term 是代表完全匹配，返回的文件必须包含完整的关键词。</p><h3 id="terms"><a href="#terms" class="headerlink" title="terms"></a>terms</h3><p>term 的升级版，可以查询多个字词。例如查询 content 字段包含“小白”和“文件整理箱”的文档。</p><p>查询结构示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;terms&quot;: &#123;<br>        &quot;<span class="hljs-attribute">content</span>&quot; : [<span class="hljs-string">&quot;小白&quot;</span>,<span class="hljs-string">&quot;文件整理箱&quot;</span>]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="prefix"><a href="#prefix" class="headerlink" title="prefix"></a>prefix</h3><p>查询某个字段以固定前缀开始的文档。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;prefix&quot;: &#123;<br>        &quot;<span class="hljs-attribute">content</span>&quot; : <span class="hljs-string">&quot;小白&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该查询语句会返回“小白”、“小白菜”等所有以“小白”开头的 content 文档。</p><h3 id="wildcard"><a href="#wildcard" class="headerlink" title="wildcard"></a>wildcard</h3><p>支持通配符搜索，可以使用?替换单个字符，用*替换零个或多个字符。通配符的查询效率较低不是很推荐。</p><h3 id="regexp"><a href="#regexp" class="headerlink" title="regexp"></a>regexp</h3><p>可以支持更为复杂的匹配模式。<em>（个人体验感觉不佳，用于带转义字段的查询时往往查不到，不知道什么原因；不如 js 的正则好用）</em></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;regexp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;postcode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;W[0-9].+&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="查询语句-text-字段和-keyword-字段的区别"><a href="#查询语句-text-字段和-keyword-字段的区别" class="headerlink" title="查询语句 text 字段和 keyword 字段的区别"></a>查询语句 text 字段和 keyword 字段的区别</h2><p>ElasticSearch 5.0 以后，String 字段被拆分成两种新的数据类型: text 用于全文搜索，会分词,而 keyword 用于关键词搜索，不进行分词。对于字符串类型的字段，ES 默认会再生成一个 keyword 字段用于精确索引。</p><p>简单理解就是 text 字段会被分词，而 keyword 字段是要求不分词完整地查找全字段。</p><p>keyword 的查询语句如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br>  &quot;query&quot;: &#123;<br>    &quot;term&quot;: &#123;<br>        &quot;<span class="hljs-attribute">content</span><span class="hljs-selector-class">.keyword</span>&quot; : <span class="hljs-string">&quot;小白&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="查询字段时-term、match、match-phrase、query-string-的区别"><a href="#查询字段时-term、match、match-phrase、query-string-的区别" class="headerlink" title="查询字段时 term、match、match_phrase、query_string 的区别"></a>查询字段时 term、match、match_phrase、query_string 的区别</h2><h3 id="1-1-term"><a href="#1-1-term" class="headerlink" title="1.1 term"></a>1.1 term</h3><p>1）term 查询 keyword 字段。</p><p>term 不会分词。而 keyword 字段也不分词。需要完全匹配才可。</p><p>2）term 查询 text 字段</p><p>因为 text 字段会分词，而 term 不分词，所以 term 查询的条件必须是 text 字段分词后的某一个。</p><p>eg. brown big box 作为 text 字段会被分为[ brown, big, box ]的词组，当 term 的查询内容为 brown 时可返回该词条<br>当 term 的查询内容为 brown big 的时候则不会返回</p><h3 id="1-2-match"><a href="#1-2-match" class="headerlink" title="1.2 match"></a>1.2 match</h3><p>1）match 查询 keyword 字段</p><p>match 会被分词，而 keyword 不会被分词，match 的需要跟 keyword 的完全匹配可以。</p><p>其他的不完全匹配的都是失败的。</p><p>2）match 查询 text 字段</p><p>match 分词，text 也分词，只要 match 的分词结果和 text 的分词结果有相同的就匹配。</p><p>eg. brown big box 的词条，当 term 的查询内容为 fox 时也可返回该词条，因为存在“ox“这一相同内容</p><h3 id="1-3-match-phrase"><a href="#1-3-match-phrase" class="headerlink" title="1.3.match_phrase"></a>1.3.match_phrase</h3><p>1）match_phrase 匹配 keyword 字段。</p><p>这个同上必须跟 keyword 一致才可以。</p><p>2）match_phrase 匹配 text 字段。</p><p>match_phrase 是分词的，text 也是分词的。match_phrase 的分词结果必须在 text 字段分词中都包含，而且顺序必须相同，而且必须都是连续的。</p><p><em>（与 match 匹配 text 情况相比就多了顺序相同一个条件）</em></p><h3 id="1-4-query-string"><a href="#1-4-query-string" class="headerlink" title="1.4.query_string"></a>1.4.query_string</h3><p>1）query_string 查询 keyword 类型的字段。</p><p>网上有说法无法查询。但根据实际经验做长字符串的查询是可行的，可能是 Lucene 语法使用不当的问题。</p><p>query_string 查询 keyword 字段如果只是使用了局部字段查询的话需要在前后加“*”。</p><p>2）query_string 查询 text 类型的字段。</p><p>和 match_phrase 区别的是，不需要连续，顺序还可以调换。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>（1）<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html">Elasticsearch Guide</a><br>（2）《从 Lucene 到 ElasticSearch：全文检索实战》<br>（3）<a href="https://www.cnblogs.com/duanxz/p/3508338.html">ES 之五：关于 Elasticsearch 查找相关的问题汇总（match、match_phrase、query_string 和 term）</a><br>（4）<a href="https://www.cnblogs.com/yjf512/p/4897294.html">elasticsearch 查询（match 和 term）</a></p>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo搭建博客</title>
    <link href="/unknown404.github.io/2022/03/14/hexoBlog/"/>
    <url>/unknown404.github.io/2022/03/14/hexoBlog/</url>
    
    <content type="html"><![CDATA[<h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2><p>1）<a href="https://nodejs.org/zh-cn/">node.js</a><br>2) <a href="https://git-scm.com/">git</a></p><h2 id="本地建站流程"><a href="#本地建站流程" class="headerlink" title="本地建站流程"></a>本地建站流程</h2><p>1.在<a href="https://gitee.com/">Gitee</a>注册登录账号，点击右上角“+”按钮创建新的仓库。仓库名可随意设置。但注意初始化时不要加文件。<br><img src="/unknown404.github.io/img/gitee-init.png"></p><div class="note note-info">            <p>根据网上大多数博客的说法仓库名应该设置为用户名，否则 hexo 打包的 css 路径会找不到。但是实际操作中并没有遇到这样的问题推测有两个可能性。<br>1）这个问题只出现在 GitHub Page 开设的流程。<br>2）配置更新了，现在新版 hexo 的打包确保了相对路径的可查找性。</p>          </div> <p>2.将空仓库拉到本地，安装 hexo，安装指令如下：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install hexo-<span class="hljs-keyword">cli</span> -g<br><br></code></pre></td></tr></table></figure><p>3.使用指令<code>hexo init</code>初始化 hexo，注意如果仓库的文件夹不为空的话，初始化就会失败，可以考虑新建一个文件夹，在新文件夹的位置启动初始化指令。<br><em>（推荐将初始化生成的文件夹都放在仓库的另一个分支，master 分支保留给 hexo 打包博客文件）</em><br>初始化后当前文件夹内部结构如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<br>├── _config.yml <span class="hljs-regexp">//</span>网站的配置文件，可配置大部分参数<br>├── package.json<br>├── scaffolds  <span class="hljs-regexp">//</span>模版文件夹<br>├── source  <span class="hljs-regexp">//</span>资源文件夹，用户添加资源的位置<br>|   ├── _drafts  <span class="hljs-regexp">//</span>草稿<br>|   └── _posts   <span class="hljs-regexp">//</span>博文<br>└── themes  <span class="hljs-regexp">//</span>主题文件夹。Hexo 会根据主题来生成静态页面。<br></code></pre></td></tr></table></figure><p>4.初始化完成以后 package.json 新增了几个指令，包括</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hexo generate&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;clean&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hexo clean&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;deploy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hexo deploy&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;server&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hexo server&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>新增的 hexo 指令的意义是：</p><blockquote><p>hexo clean —— 清空已有 hexo 网站文件<br>hexo generate(or g) —— 依据网页文本与新的 CSS 样式生成新网站文件<br>hexo server(or s) —— 启动本地服务器，可以在 localhost:4000 查看网站修改效果<br>按上述顺序执行就可以在 localhost:4000 看到默认版式下的页面了。一般默认的是一个 landscape 主题。</p></blockquote><p>到此为止一个简单的博客就在本地建好了。我们可以通过调整 themes 文件夹的主题、修改_config.yml 文件来使自己的博客更加个性化。</p><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>hexo 有自己的<a href="https://hexo.io/themes/">主题网站</a>，可以选择自己感兴趣的主题点击进入其 github 主页进行下载，解压后添加到 themes 文件夹下。</p><p>虽然 hexo 的主题丰富，很容易找到合意的个性主题。但是第一次使用时最好找一个比较常用的模版，这样说明文档比较丰富、遇到问题网上搜索时也很容易找到答案 😭</p><p>个人比较推荐并以后打算尝试的模版包括<a href="https://github.com/theme-next/hexo-theme-next">Next</a> (大家都喜欢应该是有理由的吧)、<a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a> (文档看着真齐全)。</p><p>当前使用的主题是<a href="https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak">tranquilpeak</a>，看着比较美观。后续以该主题为例讲解配置修改。</p><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p>1）GitHub 网站上以 zip 方式下载<br>2）将解压后的文件夹命名为 tranquilpeak 添加到博客的 themes 文件夹下<br>3）打开博客仓库的终端进入到 tranquilpeak 文件夹位置执行<code>npm install &amp;&amp; npm run prod</code><br>4）调整博客仓库主文件夹下的<code>theme: tranquilpeak</code><br>5）使用指令 hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 即可看到新样式</p><h3 id="tranquilpeak-相关配置"><a href="#tranquilpeak-相关配置" class="headerlink" title="tranquilpeak 相关配置"></a>tranquilpeak 相关配置</h3><p>tranquilpeak 主题文件夹下也有_config.yml 配置文件，在我下载的当前版本 4.1.3 里，作者把配置分为了“Sidebar Configuration”、“Header configuration”、“Author“、“Customization”、“Comment systems”、“Integrated services”和“Sharing options”。<br><strong>Sidebar Configuration</strong>：提供了侧边栏的菜单配置，可以根据自己的需求增减项目、调整链接</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">sidebar:</span>                   <br><span class="hljs-symbol">         menu:</span>                 <br><span class="hljs-symbol">             home:</span>             <br><span class="hljs-symbol">                title:</span> Home    <span class="hljs-meta"># 链接标题</span><br><span class="hljs-symbol">                url:</span> /         <span class="hljs-meta"># 链接URL</span><br><span class="hljs-symbol">                icon:</span> home     <span class="hljs-meta"># Font Awesome 图标名,https:<span class="hljs-comment">//fontawesome.com/icons?d=gallery&amp;m=free 上可以找到合适的图标</span></span><br></code></pre></td></tr></table></figure><p><strong>Header configuration</strong>：用于编辑头部右上角链接<br><strong>Author</strong>：编辑作者信息，包括以下几个部分。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">author:</span><br><span class="hljs-symbol">    email:</span> <br><span class="hljs-symbol">    location:</span> <br><span class="hljs-symbol">    picture:</span> <br><span class="hljs-symbol">    twitter:</span><br><span class="hljs-symbol">    google_plus:</span><br><span class="hljs-symbol">    google_plus_business:</span><br></code></pre></td></tr></table></figure><p>其中location和picture的填写内容会显示在关于（作者）的页面上。而作者的其他信息例如座右铭、工作等则是在博客总文件夹下的语言选项选定以后，在<code>tranquilpeak\languages\</code>下寻找对应语言的模版，修改作者相关的信息。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">author:</span><br>    <span class="hljs-meta"># 你的个人简介 (支持 Markdown 和 HTML 语法)</span><br><span class="hljs-symbol">    bio:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-meta"># 你的工作简介</span><br><span class="hljs-symbol">    job:</span> <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p><strong>Customization</strong>：有关于侧边栏的展示方法（sidebar_behavior）、文章列表缩略图位置（thumbnail_image_position）、封面图（cover_image）等配置。</p><p>“Comment systems”、“Integrated services”和“Sharing options”等配置暂时没有用到，以后再研究。</p><h2 id="书写博文"><a href="#书写博文" class="headerlink" title="书写博文"></a>书写博文</h2><p>1）可在终端执行如下指令完成页面新建</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">hexo <span class="hljs-keyword">new</span> [layout] &lt;<span class="hljs-built_in">title</span>&gt;<br></code></pre></td></tr></table></figure><p>layout变量可以有三种选择：post、page 和 draft。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 post 相同，都将储存到 source&#x2F;_posts 文件夹。</p><table><thead><tr><th align="center">layout选项</th><th align="center">生成文件路径</th></tr></thead><tbody><tr><td align="center">post</td><td align="center">source&#x2F;_posts</td></tr><tr><td align="center">page</td><td align="center">source</td></tr><tr><td align="center">draft</td><td align="center">source&#x2F;_drafts</td></tr></tbody></table><p>title是文章的名称，执行完指令后会在layout对应的路径下生成<code>&lt;title&gt;.md</code>文件。如果工程文件夹下的_config.yml 文件里<code>post_asset_folder</code>这一选项置为true的话则还会生成一个title的文件夹，可以存放引用资源。</p><p>2）调整文章内容<br>生成的文件头部通常会包含以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <br><span class="hljs-attr">date:</span> <br><span class="hljs-attr">tags:</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>如果是草稿则没有自动生成的date变量，执行语句<code>hexo publish draft  &lt;title&gt;</code>、移动到source&#x2F;_posts 文件夹时应该会出现。<br>根据自己的需要，可以在文件头部增加内容。以tranquilpeak为例，该样式支持categories、thumbnailImage、excerpt等配置。配置categories可以在分类页面看到自己这篇文章的归类情况；配置thumbnailImage时会在文章列表增加缩略图，但本地是看不到效果的，只有打包上传到gitee后才可以；配置excerpt时首页文章列表不会展示全文而只会展示摘要。<br>tranquilpeak模版还支持两个标签语法：<code>&lt;!-- more --&gt;</code>和&#96;&#96;。前者是将标志之前的内容将会自动生成首页的概览，后者则是自动生成文章目录。<br>具体的内容书写可以参考markdown语法。</p><h2 id="推送到gitee"><a href="#推送到gitee" class="headerlink" title="推送到gitee"></a>推送到gitee</h2><p>1）首先需要安装推送工具hexo-deployer-git。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>2）在博客工程文件夹下的_config.yml找到URL和deploy的配置。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># URL</span><br><span class="hljs-comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><br>url: https:<span class="hljs-regexp">//u</span>nknown-four-hundred-and-four.gitee.io/unknown_404<br><br>...<br><br>deploy:<br>  type: git<br>  repository: https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/unknown-four-hundred-and-four/u</span>nknown_404.git<br>  branch: master<br></code></pre></td></tr></table></figure><p>这里URL需要改成静态资源最后部署的域名，按照配置文件的说明，应该是<code>https://&#123;username&#125;.github.io/&#123;project&#125;</code>的格式，username是GitHub用户名，在GitHub上仓库名和用户名是相同，但在gitee上可以不一样，所以要注意实际上需要填入的是仓库名。project对应当前博客的工程名。<br>deploy选项里repository对应博客仓库的git地址，branch可根据需要修改，部署到page时注意一致性即可。<br>3）文件生成成功后执行<code>hexo deploy</code>指令，将文件推到远程仓库的master分支上。<br><img src="/unknown404.github.io/img/gitee-master.png"></p><h2 id="gitee-page服务启动"><a href="#gitee-page服务启动" class="headerlink" title="gitee page服务启动"></a>gitee page服务启动</h2><p>1）在gitee仓库首页选择“服务-Gitee Page”<br><img src="/unknown404.github.io/img/gitee-page.png"></p><p>2）如果没有实名认证的话开启Page服务需要验证，还需要绑定手机号。<br>3）进入到Gitee Pages 服务页面，选择部署分支，注意和工程文件夹下的_config.yml的deploy配置一致，如果选择了强制使用https，则工程文件夹下_config.yml的url配置也必须是https。<br><img src="/unknown404.github.io/img/gitee-start.png"></p><h2 id="其他客户端拉取代码的注意事项"><a href="#其他客户端拉取代码的注意事项" class="headerlink" title="其他客户端拉取代码的注意事项"></a>其他客户端拉取代码的注意事项</h2><p>本博客使用的主题tranquilpeak其资源assets是被列入忽略文件夹的内容，因此拉下来的代码不会包括这部分资源，如果直接启动无法正常看到页面样式。需要使用者在拉取代码以后进入主题的文件夹下按要求操作<code>npm install &amp;&amp; npm run prod</code>才可在本地看到正常的样式。如果之前将头像等资源放在assets文件夹下的话也需要在新生成的assets文件夹下重新加入。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>（1）<a href="https://cungudafa.blog.csdn.net/article/details/104260494?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~LandingCtr~Rate-1.queryctrv4&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~LandingCtr~Rate-1.queryctrv4&utm_relevant_index=1">基于Gitee+Hexo搭建个人博客</a><br>（2）<a href="https://hexo.io/zh-cn/docs/writing">Hexo中文文档</a><br>（3）<a href="https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak/blob/master/DOCUMENTATION.md">tranquilpeak配置</a></p>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>markdown笔记</title>
    <link href="/unknown404.github.io/2022/03/13/markdown%E7%AC%94%E8%AE%B0/"/>
    <url>/unknown404.github.io/2022/03/13/markdown%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。<br>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。<br>Markdown 编写的文档后缀为 .md, .markdown。</p></blockquote><h2 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h2><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h3><p>使用 # 号可表示 1-6 级标题，一级标题对应一个 <code>#</code>号，二级标题对应两个 <code>#</code> 号，以此类推。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean"># 这是一级标题<br>## 这是二级标题<br>### 这是三级标题<br>#### 这是四级标题<br>##### 这是五级标题<br>###### 这是六级标题<br></code></pre></td></tr></table></figure><p>效果：</p><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><h3 id="2-文字"><a href="#2-文字" class="headerlink" title="2.文字"></a>2.文字</h3><p>Markdown支持文字加粗、斜体、下划线、删除线等。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">*斜体文本*</span><br><span class="hljs-emphasis">_斜体文本_</span><br><span class="hljs-strong">**粗体文本**</span><br><span class="hljs-emphasis">__粗体文本__</span><br><span class="hljs-strong">***粗斜体文本**</span>*<br><span class="hljs-emphasis">___粗斜体文本__</span>_<br>&lt;u&gt;带下划线文本&lt;/u&gt;  <br>~~删除线文本~~<br>创建脚注格式类似这样 [^RUNOOB]。<br><br>[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！<br></code></pre></td></tr></table></figure><p>效果：<br><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><em><strong>粗斜体文本</strong></em><br><em><strong>粗斜体文本</strong></em><br><u>带下划线文本</u><br><del>删除线文本</del><br>创建脚注格式类似这样 [^RUNOOB]。</p><p>[^RUNOOB]: 菜鸟教程 – 学的不仅是技术，更是梦想！！！</p><h3 id="3-段落"><a href="#3-段落" class="headerlink" title="3.段落"></a>3.段落</h3><p><strong>分割线</strong>：三个或者三个以上的 - 或者 * 都可以。显示效果是一样的。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">---</span><br><span class="hljs-section">----</span><br><span class="hljs-bullet">***</span><br><span class="hljs-bullet"></span><span class="hljs-strong">*****</span><br></code></pre></td></tr></table></figure><h2 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h2><hr><hr><hr><p><strong>换行</strong>：使用两个以上空格加上回车，或者在段落后面使用一个空行来表示重新开始一个段落。</p><h3 id="4-链接与图片"><a href="#4-链接与图片" class="headerlink" title="4.链接与图片"></a>4.链接与图片</h3><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">1</span>）[超链接名](超链接地址 <span class="hljs-string">&quot;超链接title（optional）&quot;</span>)<br><span class="hljs-number">2</span>）&lt;<span class="hljs-keyword">https</span>://www.runoob.com&gt;直接使用链接地址<br><span class="hljs-number">3</span>）&lt;<span class="hljs-keyword">a</span> href=<span class="hljs-string">&quot;https://www.runoob.com&quot;</span> target=<span class="hljs-string">&quot;_blank&quot;</span>&gt;菜鸟教程&lt;/<span class="hljs-keyword">a</span>&gt;支持在新页面打开<br></code></pre></td></tr></table></figure><p>效果：<br><a href="https://www.runoob.com/">菜鸟教程</a><br><a href="https://www.runoob.com/">https://www.runoob.com</a><br><a href="https://www.runoob.com" target="_blank">菜鸟教程</a>  </p><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p>示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">格式：![alt 属性文本](图片地址 <span class="hljs-string">&quot;可选标题&quot;</span>)<br><br>![RUNOOB 图标](http:<span class="hljs-regexp">//</span>static.runoob.com<span class="hljs-regexp">/images/</span>runoob-logo.png <span class="hljs-string">&quot;RUNOOB&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标" title="RUNOOB"></p><h3 id="5-区块与代码"><a href="#5-区块与代码" class="headerlink" title="5.区块与代码"></a>5.区块与代码</h3><h4 id="区块："><a href="#区块：" class="headerlink" title="区块："></a>区块：</h4><p>区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号<br><em>区块嵌套</em> ：一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><p>单行代码：代码之间分别用一个反引号包起来<br>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p><h3 id="6-列表"><a href="#6-列表" class="headerlink" title="6.列表"></a>6.列表</h3><h4 id="无序列表："><a href="#无序列表：" class="headerlink" title="无序列表："></a>无序列表：</h4><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 列表内容<br><span class="hljs-bullet">+</span> 列表内容<br><span class="hljs-bullet">*</span> 列表内容<br><br>注意：- + <span class="hljs-emphasis">* 跟内容之间都要有一个空格</span><br></code></pre></td></tr></table></figure><p>效果：  </p><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ul><li>列表内容  <h4 id="有序列表："><a href="#有序列表：" class="headerlink" title="有序列表："></a>有序列表：</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 列表内容<br><span class="hljs-bullet">2.</span> 列表内容<br><span class="hljs-bullet">3.</span> 列表内容<br><br>注意：序号跟内容之间要有空格<br></code></pre></td></tr></table></figure>效果：</li></ul><ol><li>列表内容  </li><li>列表内容  </li><li>列表内容</li></ol><p><em>列表嵌套</em>：上一级和下一级之间敲三个空格即可</p><h3 id="7-表格"><a href="#7-表格" class="headerlink" title="7.表格"></a>7.表格</h3><p><code>|</code>来分隔不同的单元格，使用 <code>-</code>来分隔表头和其他行。</p><h4 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h4><p>我们可以设置表格的对齐方式：</p><ul><li>-: 设置内容和标题栏居右对齐。</li><li>:- 设置内容和标题栏居左对齐。</li><li>:-: 设置内容和标题栏居中对齐。<br>示例：<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> 左对齐 </span>|<span class="hljs-string"> 右对齐 </span>|<span class="hljs-string"> 居中对齐 </span>|<br>|<span class="hljs-string"> :-----</span>|<span class="hljs-string"> ----: </span>|<span class="hljs-string"> :----: </span>|<br>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<br>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table></li></ul><h2 id="Markdown效果预览"><a href="#Markdown效果预览" class="headerlink" title="Markdown效果预览"></a>Markdown效果预览</h2><p>VsCode：快捷键command+shift+v</p><h2 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h2><ol><li><a href="https://www.runoob.com/markdown/md-table.html">菜鸟教程</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
