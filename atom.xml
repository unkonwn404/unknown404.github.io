<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小白的文件整理箱</title>
  
  
  <link href="https://unknown-four-hundred-and-four.gitee.io/unknown_404/atom.xml" rel="self"/>
  
  <link href="https://unknown-four-hundred-and-four.gitee.io/unknown_404/"/>
  <updated>2022-05-12T03:25:39.090Z</updated>
  <id>https://unknown-four-hundred-and-four.gitee.io/unknown_404/</id>
  
  <author>
    <name>小白的文件整理箱</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git指令回顾</title>
    <link href="https://unknown-four-hundred-and-four.gitee.io/unknown_404/2022/04/27/gitCommand/"/>
    <id>https://unknown-four-hundred-and-four.gitee.io/unknown_404/2022/04/27/gitCommand/</id>
    <published>2022-04-27T09:55:23.000Z</published>
    <updated>2022-05-12T03:25:39.090Z</updated>
    
    <content type="html"><![CDATA[<p>最近VsCode图形化界面操作太过于习惯，一些git指令操作感觉有点生疏，所以回顾一下。</p><span id="more"></span> <p>进入正题前可配合以下VsCode操作文章一起阅读，体会也许更深：<br>1）<a href="https://cloud.tencent.com/developer/article/1793472">VS Code使用Git可视化管理源代码详细教程</a><br>2）<a href="https://almvm.devopshub.cn/labs/azuredevops/git/">Version Controlling with Git in Visual Studio Code and Azure DevOps</a><br>虽说界面化是挺好的，但万一哪天需要书写或修改部署文件时会比较头疼，所以还是要记录一点</p><!-- toc --><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>git是一个分布式版本控制软件。其工作流程如下图所示：</p><div class="figure center" style="width:;"><img class="fig-img" src="git.jpeg" alt=""></div><div style="clear:both;"></div><p>涉及的基本工作区概念有：<br><strong>Workspace</strong>：工作区，平时开发时改动的地方<br><strong>Index</strong>：暂存区，执行<code>git add</code>指令后工作区的文件修改内容就会被推到暂存区<br><strong>Repository</strong>：本地仓库，位于自己的本地电脑，执行<code>git commit</code>指令后暂存区的文件修改内容就会被推到本地仓库<br><strong>Remote</strong>：远程仓库，用来托管代码的服务器，比较常见的包括GitHub、Gitee、GitLab，可以被多个处于协作的本地仓库修改，执行<code>git push</code>指令后本地仓库的文件修改内容就会被推到远程仓库</p><p>一般来说git的开发流程主要包括以下步骤：</p><ol><li>使用<code>git clone</code>将远程仓库代码拉到本地</li><li>按照业务从master分支拉取新分支、使用<code>git branch &lt;branch-name&gt; </code>、<code>git checkout &lt;branch-name&gt; </code>在新分支上进行开发</li><li>本地开发完成使用<code>git add .</code>添加所有修改到暂存区</li><li>使用<code>git commit -m &lt;message&gt;</code>将修改提交到本地仓库</li><li>使用<code>git push</code>将修改推送到远程仓库</li></ol><h2 id="git常用配置"><a href="#git常用配置" class="headerlink" title="git常用配置"></a>git常用配置</h2><h3 id="全局配置用户名、用户邮箱"><a href="#全局配置用户名、用户邮箱" class="headerlink" title="全局配置用户名、用户邮箱"></a>全局配置用户名、用户邮箱</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;xxx&quot;</span><br><span class="line">git config --global user.email &quot;xxx@xx.com&quot;</span><br></pre></td></tr></table></figure><h3 id="配置SSH-Key"><a href="#配置SSH-Key" class="headerlink" title="配置SSH Key"></a>配置SSH Key</h3><p>SSH Key允许本地电脑和远程仓库间建立一个安全链接。和 https 拉取远程代码的不同点是，https 方式需要手动输入用户名和密码，ssh 的方式配置完毕后 Git 都会使用你本地的私钥和远程仓库的公钥进行验证是否是一对秘钥，从而简化了操作流程。</p><h4 id="查看SSH-Key"><a href="#查看SSH-Key" class="headerlink" title="查看SSH Key"></a>查看SSH Key</h4><p>Windows终端可输入如下指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type %userprofile%\.ssh\id_rsa.pub</span><br></pre></td></tr></table></figure><p>GNU&#x2F;Linux&#x2F;Mac&#x2F;PowerShell则可以使用该指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>如果返回开头为<code>ssh-rsa</code>一长串字符，可以跳过生成SSH Key过程</p><h4 id="生成SSH-Key"><a href="#生成SSH-Key" class="headerlink" title="生成SSH Key"></a>生成SSH Key</h4><p>使用指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;xxx@xxx.com&quot;</span><br></pre></td></tr></table></figure><p>后续关于文件名、passphrase的设置最好直接回车采用默认值，以免影响自动调用SSH Key的流程。<br>如果之后需要修改key值，可以使用如下语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -p &lt;keyname&gt;</span><br></pre></td></tr></table></figure><p>完成后再使用如下指令查看SSH Key：<br>Windows：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type %userprofile%\.ssh\id_rsa.pub</span><br></pre></td></tr></table></figure><p>GNU&#x2F;Linux&#x2F;Mac&#x2F;PowerShell：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><h4 id="复制SSH-Key"><a href="#复制SSH-Key" class="headerlink" title="复制SSH Key"></a>复制SSH Key</h4><p>Windows 命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type %userprofile%\.ssh\id_rsa.pub | clip</span><br></pre></td></tr></table></figure><p>Windows PowerShell:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub | clip</span><br></pre></td></tr></table></figure><p>Mac:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pbcopy &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>GNU&#x2F;Linux (需要 xclip):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xclip -sel clip &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><h4 id="添加SSH-Key"><a href="#添加SSH-Key" class="headerlink" title="添加SSH Key"></a>添加SSH Key</h4><p>打开gitlab，在左侧栏找到profile setting，点击SSH Keys，将复制的SSH Key内容粘贴在keys一栏，点击<code>add key</code>完成。</p><h3 id="查看git配置"><a href="#查看git配置" class="headerlink" title="查看git配置"></a>查看git配置</h3><p>使用指令<code>git config --list</code>可以查看当前配置所有项</p><h2 id="工作区常用git指令"><a href="#工作区常用git指令" class="headerlink" title="工作区常用git指令"></a>工作区常用git指令</h2><h3 id="新建本地仓库"><a href="#新建本地仓库" class="headerlink" title="新建本地仓库"></a>新建本地仓库</h3><h4 id="本地项目git管理"><a href="#本地项目git管理" class="headerlink" title="本地项目git管理"></a>本地项目git管理</h4><p>使用指令<code>git init</code>使项目git化</p><h4 id="远程仓库项目本地操作"><a href="#远程仓库项目本地操作" class="headerlink" title="远程仓库项目本地操作"></a>远程仓库项目本地操作</h4><p>使用指令<code>git clone &lt;url&gt;</code>，例如 <code>git clone git@gitee.com:unknown-four-hundred-and-four/unknown_404.git</code>。这里的url最好用SSH而非HTTPS，避免手动输入用户名和密码的麻烦。<br>在克隆完每个远程仓库后，远程仓库默认为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -o jQuery https://github.com/jquery/jquery.git</span><br></pre></td></tr></table></figure><h3 id="开发新业务"><a href="#开发新业务" class="headerlink" title="开发新业务"></a>开发新业务</h3><h4 id="查看当前仓库分支情况"><a href="#查看当前仓库分支情况" class="headerlink" title="查看当前仓库分支情况"></a>查看当前仓库分支情况</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch 查看本地仓库分支情况，*表示当前位于的分支</span><br><span class="line">git branch -a 查看本地和远程所有分支情况</span><br></pre></td></tr></table></figure><h4 id="创建业务分支开发"><a href="#创建业务分支开发" class="headerlink" title="创建业务分支开发"></a>创建业务分支开发</h4><p>使用指令<code>git checkout -b &lt;branchname&gt;</code>使工作区切到新建的分支上。该指令是<code>git branch &lt;branchname&gt;</code>和<code>git checkout &lt;branchname&gt;</code>合在一起的结果。</p><h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><p>1）使用指令<code>git add</code>将代码提交到暂存区。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 添加某个文件到暂存区，后面可以跟多个文件，以空格区分</span><br><span class="line">git add xxx</span><br><span class="line">// 添加当前更改的所有文件到暂存区。</span><br><span class="line">git add .</span><br></pre></td></tr></table></figure><p>2）使用指令<code>git commit</code>将代码提交到本地仓库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 提交暂存的更改，会新开编辑器进行编辑</span><br><span class="line">git commit </span><br><span class="line">// 提交暂存的更改，并记录下备注</span><br><span class="line">git commit -m &quot;you message&quot;</span><br><span class="line">// 等同于 git add . &amp;&amp; git commit -m</span><br><span class="line">git commit -am</span><br><span class="line">// 对最近一次的提交的信息进行修改,此操作会修改commit的hash值</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><h4 id="提交规范补充"><a href="#提交规范补充" class="headerlink" title="提交规范补充"></a>提交规范补充</h4><p>commit的内容规范不应该被轻视，一个调理清晰的commit记录有助于后面的人做维护工作。实际工作中可能常会遇到之前项目下掉的某功能需要重新恢复，如果能有清晰的commit说明维护人员就能很快定位功能代码位置做出调整；而如果提交记录只有类似fix 、bugfix的说明则会给维护工作造成麻烦。</p><p>目前广泛接受的commit格式规范是angular团队规范，它的message格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;// header部分</span><br><span class="line">&lt;BLANK LINE&gt;// 空行</span><br><span class="line">&lt;body&gt;// body部分</span><br><span class="line">&lt;BLANK LINE&gt;// 空行</span><br><span class="line">&lt;footer&gt;// 注释footer部分</span><br></pre></td></tr></table></figure><p>主要分为三个部分：</p><h5 id="header部分"><a href="#header部分" class="headerlink" title="header部分"></a>header部分</h5><p>必填内容, 描述主要修改类型和内容。规范将 header 分为 type、scope、subject 三部分。<br><strong>type</strong>：提交的代码修改所属类型，必填项。应在以下几种中选择一种：</p><ul><li>feat: 一项新功能</li><li>fix: 一个错误修复</li><li>docs: 仅文档更改</li><li>style: 不影响代码含义的更改（空白，格式，缺少分号等）</li><li>refactor: 既不修正错误也不增加功能的代码更改（重构）</li><li>perf: 改进性能的代码更改</li><li>test: 添加缺失或更正现有测试</li><li>build: 影响构建系统或外部依赖项的更改（gulp，npm等）</li><li>ci: 对CI配置文件和脚本的更改</li><li>chore: 更改构建过程或辅助工具和库，例如文档生成</li></ul><p><strong>scope</strong>：本次提交的影响范围，描述提交更改的位置如模块名或文件名。可选项<br><strong>subject</strong>：指本次提交的简要描述。</p><h5 id="body部分"><a href="#body部分" class="headerlink" title="body部分"></a>body部分</h5><p>选填部分。</p><h5 id="footer部分"><a href="#footer部分" class="headerlink" title="footer部分"></a>footer部分</h5><p>主要备注以下内容：</p><ul><li><strong>BREAKING CHANGE</strong>：当前修改是否发生了版本升级、接口参数减少、接口删除、迁移等破坏性调整。</li><li><strong>关闭Issue</strong>：填写格式<code>Closes #ISSUE_ID, #ISSUE_ID</code></li></ul><p>当前使用比较广泛的规范化工具是<a href="https://www.npmjs.com/package/cz-conventional-changelog">commitizen</a>。</p><p>3）使用指令<code>git push</code>将代码提交到远程仓库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure><p>如果省略远程分支名，则会将本地分支推送到对应名称的远程分支（两者有追踪关系），如果该远程分支不存在，则会被新建。<br>如果省略本地分支名，则是将空分支推到远程分支，等同于删除指定的远程分支。<br>如果省略本地分支和远程分支、且当前分支与远程分支之间存在追踪关系时，将当前分支推送到origin主机的对应分支；如果追踪关系只有一个可以直接<code>git push</code>。</p><h4 id="文件暂存"><a href="#文件暂存" class="headerlink" title="文件暂存"></a>文件暂存</h4><p>有的时候我们的功能开发了一半，因为某些原因我们需要 checkout 到其他的分支上查看代码或者是执行某个工作。这个时候由于功能并没有开发完成，所以并不希望提交代码，此时可以用<code>git stash</code>指令来将本地还没有提交的改动全部存储起来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 保存改动并注释本次改动</span><br><span class="line">git stash [save] &lt;message&gt;</span><br><span class="line">// 将新创建并且还没有被 git 管理的文件也一并储藏起来</span><br><span class="line">git stash  [--include-untracked/-u]</span><br><span class="line">// 查看全部存储记录</span><br><span class="line">git stash list</span><br><span class="line">// 恢复，num是可选项，通过git stash list可查看具体值。只能恢复一次</span><br><span class="line">git stash pop stash@&#123;num&#125;</span><br><span class="line">//恢复，num是可选项，通过git stash list可查看具体值。能恢复多次</span><br><span class="line">git stash apply stash@&#123;num&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>git stash在没有add之前才能执行。</p><h4 id="业务协作"><a href="#业务协作" class="headerlink" title="业务协作"></a>业务协作</h4><p>当同事开发的内容和自己在同一分支且对方已经提交代码的情况下，可以使用指令git pull，git pull 等同于 git fetch &amp;&amp; git merge</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 拉取远程分支代码的更新,对当前工作区的代码没有影响</span><br><span class="line">git fetch &lt;远程主机名(eg. origin)&gt; &lt;分支名&gt;</span><br><span class="line">// 将当前分支与指定分支进行合并</span><br><span class="line">git merge &lt;分支名&gt;</span><br><span class="line">// 从远程仓库拉取代码并合并到本地</span><br><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><h5 id="辨析：git-merge和git-rebase的区别"><a href="#辨析：git-merge和git-rebase的区别" class="headerlink" title="辨析：git merge和git rebase的区别"></a>辨析：git merge和git rebase的区别</h5><p>相同点：两个指令都可以用于分支合并。<br>不同点：<br>1）提交记录里，merge在非快速模式下会多一条Merge branch ‘xxx’ into ‘xxx’的提交信息，而rebase不会<br>2）合并冲突时，merge只需要处理一次冲突，rebase需要解决一次又一次冲突<br>3）rebase的交互模式可以将多次提交压缩成一次，具体步骤是：</p><ul><li>a）执行指令<code>git rebase -i &lt;base-commit&gt;</code>，参数base-commit就是指明操作的基点提交对象，基于这个基点进行 rebase 的操作</li><li>b）指令结束后会进入一个 vim 的交互式页面，将基点以后的节点都设置为了pick，且后面会有指令提示，常用的指令包括<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pick：使用该次提交</span><br><span class="line">squash：将该commit和前一个commit合并</span><br></pre></td></tr></table></figure>通常将第一个提交的后面的pick改成squash即可。</li><li>c）保存，退出编辑页面（点击Esc键后输入:wq），进入commit message页面。之后同样是输入i进入编辑界面，修改自己的commit message</li><li>d）保存，退出。至此，git rebase一个流程走完。<blockquote><p>特别注意，只能在自己使用的 feature 分支上进行 rebase 操作，不允许在集成分支上进行 rebase，因为这种操作会修改集成分支的历史记录。</p></blockquote><h4 id="部分需求交付"><a href="#部分需求交付" class="headerlink" title="部分需求交付"></a>部分需求交付</h4><p>在开发新功能时因各种客观原因赶不上交付期限的時候，可能需要交付部分需求。针对这一情境，有两种指令可以解决具体的问题。</p></li><li>1）git cherry-pick<br>使用格式：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick &lt;commit-id&gt;</span><br></pre></td></tr></table></figure>commit-id为某次提交的hash值。该指令可以理解为”挑拣”提交，和 merge 合并一个分支的所有提交不同的是，它会获取某一个分支的单次提交，并作为一个新的提交引入到你当前分支上。</li></ul><p>当新需求分支里的bug修复代码要提前于需求上线时，可以使用git cherry-pick将feature分支上bug修复那次提交生成的hash码提取出来作为一个新的提交加在master分支上。过程中，如果出现冲突，需要解决冲突、之后进行 git add ，接着执行 git cherry-pick –continue。</p><p>如果存在多个提交需要同步到目标分支，可以简写为 <code>git cherry-pick &lt;first-commit-id&gt;...&lt;last-commit-id&gt;</code>，这是一个左开右闭的区间，也就时说 first-commit-id 提交带来的代码的改动不会被合并过去，如果需要合并过去，可以使用<code> git cherry-pick &lt;first-commit-id&gt;^...&lt;last-commit-id&gt;</code>。</p><ul><li>2）git revert<br>使用格式：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit-id&gt;</span><br></pre></td></tr></table></figure>commit-id为某次提交的hash值。该指令会创建一个新的提交来去除指定的某次commit的内容。</li></ul><p>当新需求中某一项功能因为种种原因不能上线时可以使用该指令。这样既可以留下记录又不会导致其他人分支不同步。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>（1）<a href="https://juejin.cn/post/6934292467160514567#heading-0">commit规范+commitlint+CHANGELOG自动生成一条龙服务</a><br>（2）<a href="https://blog.csdn.net/M__L__/article/details/104573220">git rebase -i 合并多次提交</a><br>（3）<a href="https://juejin.cn/post/6844904191203213326">多年 Git 使用心得 &amp; 常见问题整理</a><br>（4）<a href="https://juejin.cn/post/6974184935804534815">我在工作中是如何使用 git 的</a><br>（5）<a href="https://ithelp.ithome.com.tw/articles/10244481">DAY11-git cherry-pick和revert</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近VsCode图形化界面操作太过于习惯，一些git指令操作感觉有点生疏，所以回顾一下。&lt;/p&gt;</summary>
    
    
    
    <category term="技术学习" scheme="https://unknown-four-hundred-and-four.gitee.io/unknown_404/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="git" scheme="https://unknown-four-hundred-and-four.gitee.io/unknown_404/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>React Hooks学习笔记</title>
    <link href="https://unknown-four-hundred-and-four.gitee.io/unknown_404/2022/04/08/reactHooks/"/>
    <id>https://unknown-four-hundred-and-four.gitee.io/unknown_404/2022/04/08/reactHooks/</id>
    <published>2022-04-08T06:47:53.000Z</published>
    <updated>2022-05-10T03:06:05.056Z</updated>
    
    <content type="html"><![CDATA[<p>记录常用的React钩子的使用方法。</p><span id="more"></span> <!-- toc --><h2 id="React-Hook规则"><a href="#React-Hook规则" class="headerlink" title="React Hook规则"></a>React Hook规则</h2><p>（1）只在最顶层使用 Hook：不要在循环，条件或嵌套函数中调用 Hook<br>（2）只在 React 函数中调用 Hook：可以在React组件或自定义钩子中调用</p><h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><p>使用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[selfState,setSelfState]=useState(initialState)</span><br></pre></td></tr></table></figure><p>输入参数：初始状态initialState。如果initialState需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用。<br>返回参数：当前状态名selfState和更新状态函数名setSelfState<br>setSelfState可以传入新值来变更状态setSelfState(newState)；如果需要根据先前的状态更新状态，也可以使用回调函数setSelfState(prevState &#x3D;&gt; newState)<br>注意点：<br>（1）因为 state 只在组件首次渲染的时候被创建。在下一次重新渲染时，useState 返回给我们当前的 state。<br>（2）initialState可以是数组或对象，不像 class 中的 this.setState，更新 state 变量总是替换它而不是合并它。<br>（3）过时状态问题：class和hooks的写法里，异步操作的过程中如何改变 state 的值，最后打印的时候都是最初的值或者说异步操作开始定义的时候的 state 的值。如下面的函数组件中setTimeout 取到的都是旧值，是因为 react 中一直遵循一个原则，即 state 指向的内容是不可变的，所以每一次 state 的更新都是指向变了。因为闭包的原因，setTimeout中依然指向的原来的对象，所以旧的state没有释放，所以会取到旧值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function DelayedCount() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">  const handleClickAsync = () =&gt; &#123;</span><br><span class="line">    setTimeout(function delay() &#123;</span><br><span class="line">      setCount(count + 1);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;count&#125;</span><br><span class="line">      &lt;button onClick=&#123;handleClickAsync&#125;&gt;Increase async&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码点击多次时不能正确记录点击次数。解决方法是使用setCount(count &#x3D;&gt; count + 1)，这样不依赖外部变量、确保将最新状态值作为参数提供给更新状态函数，过时闭包的问题解决了。</p><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>使用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">useEffect(()=&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">    return ()=&gt;&#123;&#125;</span><br><span class="line">&#125;,[variable])</span><br></pre></td></tr></table></figure><p>第一参数的回调函数函数可以没有返回值，第二参数的书写不是必要的，如果设置了变量variable，当且仅当variable改变时才会触发第一参数回调</p><h3 id="useEffect与生命周期关系"><a href="#useEffect与生命周期关系" class="headerlink" title="useEffect与生命周期关系"></a>useEffect与生命周期关系</h3><h4 id="useEffect实现componentDidMount"><a href="#useEffect实现componentDidMount" class="headerlink" title="useEffect实现componentDidMount"></a>useEffect实现componentDidMount</h4><p>useEffect的第二个参数设置为一个空数组时，初始化调用一次之后不再执行回调，相当于周期componentDidMount</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;hello world&#x27;)</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure><h4 id="useEffect实现componentDidMount和componentDidUpdate"><a href="#useEffect实现componentDidMount和componentDidUpdate" class="headerlink" title="useEffect实现componentDidMount和componentDidUpdate"></a>useEffect实现componentDidMount和componentDidUpdate</h4><p>当useEffect没有第二个参数时,组件的初始化和更新都会执行。<br>当useEffect有第二个参数时,组件的更新仅当variable改变时会执行。</p><h4 id="useEffect实现componentDidMount和componentWillMount"><a href="#useEffect实现componentDidMount和componentWillMount" class="headerlink" title="useEffect实现componentDidMount和componentWillMount"></a>useEffect实现componentDidMount和componentWillMount</h4><p>useEffect设置返回一个函数，这个函数在组件卸载时会执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    function handleStatusChange(status) &#123;</span><br><span class="line">      setIsOnline(status.isOnline);</span><br><span class="line">    &#125;</span><br><span class="line">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    // Specify how to clean up after this effect:</span><br><span class="line">    return function cleanup() &#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;,[]);</span><br></pre></td></tr></table></figure><h3 id="useEffect无限循环陷阱"><a href="#useEffect无限循环陷阱" class="headerlink" title="useEffect无限循环陷阱"></a>useEffect无限循环陷阱</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &#x27;react&#x27;;</span><br><span class="line">import axios from &#x27;axios&#x27;;</span><br><span class="line"> </span><br><span class="line">function App() &#123;</span><br><span class="line">  const [data, setData] = useState(&#123; hits: [] &#125;);</span><br><span class="line"> </span><br><span class="line">  useEffect(async () =&gt; &#123;</span><br><span class="line">    const result = await axios(</span><br><span class="line">      &#x27;http://localhost/api/v1/search?query=redux&#x27;,</span><br><span class="line">    );</span><br><span class="line"> </span><br><span class="line">    setData(result.data);</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;data.hits.map(item =&gt; (</span><br><span class="line">        &lt;li key=&#123;item.objectID&#125;&gt;</span><br><span class="line">          &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>以该组件为例，初次渲染执行useEffect内部请求、返回数据后，由于使用了setData组件state改变，引起重新渲染，同时由于useEffect没有依赖项，再次渲染时仍然会触发内部的回调，因此出现了无限循环的问题。</p><p>解决方式：如果只希望在组件mount时执行请求，可以传递一个空数组作为useEffect的第二个参数</p><h3 id="useEffect与async同时使用时的报错"><a href="#useEffect与async同时使用时的报错" class="headerlink" title="useEffect与async同时使用时的报错"></a>useEffect与async同时使用时的报错</h3><p>async函数会返回promise，但useEffect只允许返回一个清除函数，所以在控制台可以看到警告提醒</p><div class="alert info"><p>Warning: useEffect function must return a cleanup function or nothing. Promises and useEffect(async () &#x3D;&gt; …) are not supported, but you can call an async function inside an effect</p></div> <p>解决方式：async函数的定义分离出useEffect回调函数，回调函数内部执行async函数。</p><h3 id="useEffect-vs-useLayoutEffect"><a href="#useEffect-vs-useLayoutEffect" class="headerlink" title="useEffect vs useLayoutEffect"></a>useEffect vs useLayoutEffect</h3><p>执行时期：useEffect 在全部渲染完毕后才会执行，useLayoutEffect 会在浏览器布局之后，绘制之前执行<br>执行方式：useEffect异步，useLayoutEffect同步</p><h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><p>使用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const memo=useMemo(()=&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">    return compute(props.v)</span><br><span class="line">&#125;,[variable])</span><br></pre></td></tr></table></figure><p>传入 useMemo 的函数会在渲染期间执行。如果没有设置第二参数依赖变量，则每次渲染都会执行第一参数的函数来计算。类比生命周期就是shouldComponentUpdate<br>适用场景：<br>（1）父组件将某个值传给子组件、且父组件有频繁更新的情况。父组件其他值变化时，子组件同样也会重新渲染。因此可以使用useMemo、将依赖设置为父组件传递的值，只有当其发生变化时子组件才更新。<br>（2）组件内部计算成本比较高的逻辑。需要通过控制依赖来减少不必要的计算。<br>注意点：<br>（1）useMemo内部不要使用setState相关操作，会导致无限循环<br>（2）包括后面的useCallback，如果是用在父子组件传值的场景，子组件通常用高阶函数React.memo包裹</p><h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><p>使用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const fn=useCallback(()=&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">    doSomething(variable)</span><br><span class="line">&#125;,[variable])</span><br></pre></td></tr></table></figure><p>useCallback(fn, deps) 相当于 useMemo(() &#x3D;&gt; fn, deps)。类似生命周期shouldComponentUpdate<br>适用场景：<br>（1）父组件将某个函数传给子组件、且父组件有频繁更新的情况。父组件其他值变化时，由于函数重新创建等原因子组件同样也会重新渲染。</p><h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><p>使用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const refContainer = useRef(initialValue);</span><br></pre></td></tr></table></figure><p>输入参数initialValue将赋给ref的current属性。ref作用于HTML元素时 ref 接收底层 DOM 元素作为其 current 属性；作用于组件时，ref 对象接收组件的挂载实例作为其 current 属性。<br>useRef() 和自建一个 {current: …} 对象的唯一区别是，useRef 会在每次渲染时返回同一个 ref 对象。<br>适用场景：<br>（1）引用如input等有参数频繁变动更新的 dom 元素。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/6952509261519781918#heading-0">useEffect你真的会用吗？</a><br>（2）<a href="https://juejin.cn/post/7053695602370019335">React Hooks 及其性能优化之React.memo,useCallBack,useMemo</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录常用的React钩子的使用方法。&lt;/p&gt;</summary>
    
    
    
    <category term="技术学习" scheme="https://unknown-four-hundred-and-four.gitee.io/unknown_404/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="前端基础" scheme="https://unknown-four-hundred-and-four.gitee.io/unknown_404/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="React" scheme="https://unknown-four-hundred-and-four.gitee.io/unknown_404/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://unknown-four-hundred-and-four.gitee.io/unknown_404/2022/04/05/regexp/"/>
    <id>https://unknown-four-hundred-and-four.gitee.io/unknown_404/2022/04/05/regexp/</id>
    <published>2022-04-05T12:35:30.000Z</published>
    <updated>2022-04-06T16:22:02.398Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式构建相关知识点。</p><span id="more"></span> <!-- toc --><h2 id="单字符匹配"><a href="#单字符匹配" class="headerlink" title="单字符匹配"></a>单字符匹配</h2><ol><li>数字、字母：直接书写</li><li>特殊字符（eg.空格、换行、*）：使用转义字符<code>\</code><br>需要记忆的特殊字符：<table><thead><tr><th align="center">特殊字符</th><th align="center">正则表达式</th></tr></thead><tbody><tr><td align="center">转行符</td><td align="center">&#x2F;n</td></tr><tr><td align="center">空白符</td><td align="center">&#x2F;s</td></tr><tr><td align="center">制表符</td><td align="center">&#x2F;t</td></tr><tr><td align="center">回车符</td><td align="center">&#x2F;r</td></tr></tbody></table></li></ol><h2 id="多字符匹配"><a href="#多字符匹配" class="headerlink" title="多字符匹配"></a>多字符匹配</h2><ol><li>[] eg.[a-z],[0-9]</li><li>简便正则表达式<table><thead><tr><th align="center">特殊字符</th><th align="center">正则表达式</th></tr></thead><tbody><tr><td align="center">除了换行符之外的任何字符</td><td align="center">.</td></tr><tr><td align="center">匹配空白符，包括空格、制表符、换页符和换行符</td><td align="center">&#x2F;s</td></tr><tr><td align="center">匹配非空白字符([^ \t\v\n\r\f])</td><td align="center">&#x2F;S</td></tr><tr><td align="center">单个数字, [0-9]</td><td align="center">&#x2F;d</td></tr><tr><td align="center">除了0-9([^0-9])</td><td align="center">&#x2F;D</td></tr><tr><td align="center">包括下划线在内的单个字符，[A-Za-z0-9_]</td><td align="center">&#x2F;w</td></tr><tr><td align="center">非单个字符([^A-Za-z0-9_])</td><td align="center">&#x2F;W</td></tr></tbody></table></li></ol><h2 id="重复次数"><a href="#重复次数" class="headerlink" title="重复次数"></a>重复次数</h2><table><thead><tr><th align="center">特殊字符</th><th align="center">重复次数</th></tr></thead><tbody><tr><td align="center">?</td><td align="center">0-1</td></tr><tr><td align="center">*</td><td align="center">0-n</td></tr><tr><td align="center">+</td><td align="center">1-n</td></tr><tr><td align="center">{n}</td><td align="center">n</td></tr><tr><td align="center">{min,max}</td><td align="center">min-max</td></tr></tbody></table><h3 id="贪婪匹配和惰性匹配"><a href="#贪婪匹配和惰性匹配" class="headerlink" title="贪婪匹配和惰性匹配"></a>贪婪匹配和惰性匹配</h3><p>贪婪匹配：重复次数不是固定而是一个范围时通常尽可能多的匹配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\d&#123;2,5&#125;/g;</span><br><span class="line">var string = &quot;12345&quot;;</span><br><span class="line">console.log( string.match(regex) ); </span><br><span class="line">// =&gt; [&quot;12345&quot;]</span><br></pre></td></tr></table></figure><p>懒惰匹配：在上述表格的字符后面加上<code>?</code>，尽可能少的匹配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\d&#123;2,5&#125;?/g;</span><br><span class="line">var string = &quot;12345&quot;;</span><br><span class="line">console.log( string.match(regex) ); </span><br><span class="line">// =&gt; [&quot;12&quot;,&quot;34&quot;]</span><br></pre></td></tr></table></figure><h2 id="分组与回溯引用"><a href="#分组与回溯引用" class="headerlink" title="分组与回溯引用"></a>分组与回溯引用</h2><p><strong>分组</strong>：括号()所包裹的表达式内容即为一个分组。</p><p><strong>回溯引用</strong>：模式的后面部分引用前面已经匹配到的子字符串。<br>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;\1\d&#123;2&#125;/;</span><br></pre></td></tr></table></figure><p>在这个正则表达式中\1，表示的引用之前的那个分组<code>(-|\/|\.)</code>。不管它匹配到什么（比如-），\1都匹配那个同样的具体某个字符。<br>使用replace替换字符串时，涉及到的引用变量及其意义包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$1,$2,...,$99 匹配第1~99个分组里捕获的文本</span><br><span class="line">$&amp; 匹配到的子串文本</span><br><span class="line">$` 匹配到的子串的左边文本</span><br><span class="line">$&#x27; 匹配到的子串的右边文本</span><br></pre></td></tr></table></figure><h3 id="非捕获分组-p"><a href="#非捕获分组-p" class="headerlink" title="非捕获分组(?:p)"></a>非捕获分组(?:p)</h3><p>该语法仅承担分组的作用而不参与引用，即既不在API里引用，也不在正则里反向引用。</p><h2 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h2><h3 id="位置特性"><a href="#位置特性" class="headerlink" title="位置特性"></a>位置特性</h3><p>位置是相邻字符之间的位置。例如：<br>“halo”&#x3D;&#x3D;“”+“h”+“”+“a”+“”+“l”+“”+“o”</p><h3 id="位置边界"><a href="#位置边界" class="headerlink" title="位置边界"></a>位置边界</h3><ol><li>单词边界：\b<br>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result = &quot;[JS] Lesson_01.mp4&quot;.replace(/\b/g, &#x27;#&#x27;);</span><br><span class="line">console.log(result); </span><br><span class="line">// =&gt; &quot;[#JS#] #Lesson_01#.#mp4#&quot;</span><br></pre></td></tr></table></figure>可以看到\b匹配的位置都是由<code>\w</code>到<code>\W</code>或者<code>\W</code>到<code>\w</code>的位置</li><li>字符串边界：<code>^</code>开头匹配，<code>$</code>结尾匹配<h3 id="位置查找"><a href="#位置查找" class="headerlink" title="位置查找"></a>位置查找</h3><h4 id="前向查找-x3D-p"><a href="#前向查找-x3D-p" class="headerlink" title="前向查找(?&#x3D;p)"></a>前向查找(?&#x3D;p)</h4>匹配内容p前面的字符。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result = &quot;hello&quot;.replace(/(?=l)/g, &#x27;#&#x27;);</span><br><span class="line">console.log(result); </span><br><span class="line">// =&gt; &quot;he#l#lo&quot;</span><br></pre></td></tr></table></figure><h4 id="后向查找-lt-x3D-p"><a href="#后向查找-lt-x3D-p" class="headerlink" title="后向查找(?&lt;&#x3D;p)"></a>后向查找(?&lt;&#x3D;p)</h4>匹配内容p后面的字符。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result = &quot;hello&quot;.replace(/(?=l)/g, &#x27;#&#x27;);</span><br><span class="line">console.log(result); </span><br><span class="line">// =&gt; &quot;hel#l#o&quot;</span><br></pre></td></tr></table></figure><h4 id="前向负查找-p"><a href="#前向负查找-p" class="headerlink" title="前向负查找(?!p)"></a>前向负查找(?!p)</h4>不匹配内容p前面的字符。可以看作是前向查找的反面<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result = &quot;hello&quot;.replace(/(?!l)/g, &#x27;#&#x27;);</span><br><span class="line">console.log(result); </span><br><span class="line">// =&gt; &quot;#h#ell#o#&quot;</span><br></pre></td></tr></table></figure><h4 id="后向负查找-lt-p"><a href="#后向负查找-lt-p" class="headerlink" title="后向负查找(?&lt;!p)"></a>后向负查找(?&lt;!p)</h4>不匹配内容p后面的字符。可以看作是后向查找的反面<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result = &quot;hello&quot;.replace(/(?&lt;!l)/g, &#x27;#&#x27;);</span><br><span class="line">console.log(result); </span><br><span class="line">// =&gt; &quot;#h#e#llo#&quot;</span><br></pre></td></tr></table></figure><h2 id="正则表达式相关API"><a href="#正则表达式相关API" class="headerlink" title="正则表达式相关API"></a>正则表达式相关API</h2><h3 id="RegExp-对象方法"><a href="#RegExp-对象方法" class="headerlink" title="RegExp 对象方法"></a>RegExp 对象方法</h3><h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4>检索字符串中指定的值。返回找到的值及index，并确定其位置。<br>exec方法能接着上一次匹配后继续匹配。正则实例lastIndex属性，表示下一次匹配开始的位置。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const patternMatch = (pattern, content) =&gt; &#123;</span><br><span class="line">    var positions = []</span><br><span class="line">    var match = pattern.exec(content)</span><br><span class="line">    while (match) &#123;</span><br><span class="line">        positions.push(match.index)</span><br><span class="line">        match = pattern.exec(content)</span><br><span class="line">    &#125;</span><br><span class="line">    return positions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4>检索字符串中指定的值。返回 true 或 false。<h3 id="String-对象方法"><a href="#String-对象方法" class="headerlink" title="String 对象方法"></a>String 对象方法</h3>第1参数都支持正则和字符串<h4 id="match"><a href="#match" class="headerlink" title="match"></a>match</h4>找到一个或多个正则表达式的匹配。返回找到的值<br>当正则没有g时，使用match返回的信息比较多。但是有g后，就没有关键的信息index了。<h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4>检索与正则表达式相匹配的值。返回与指定查找的字符串或者正则表达式相匹配的 String 对象起始位置，没有则是-1。<h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4>替换与正则表达式匹配的子串。<br>replace第2个参数可以是一个普通的字符串或是一个回调函数。如果第2个参数是回调函数，每匹配到一个结果就回调一次，每次回调都会传递以下参数：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">result: 本次匹配到的结果</span><br><span class="line"></span><br><span class="line">$1,...$9: 正则表达式中有几个()，就会传递几个参数，$1~$9分别代表本次匹配中每个()提取的结果，最多9个</span><br><span class="line"></span><br><span class="line">offset:记录本次匹配的开始位置</span><br><span class="line"></span><br><span class="line">source:接受匹配的原始字符串</span><br></pre></td></tr></table></figure></li></ol><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>（1）js数字每三位加逗号间隔（除了toLocaleString方法）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num.replace(/\d&#123;1,3&#125;(?=(\d&#123;3&#125;)+(\.\d*)?$)/g,&#x27;$&amp;,&#x27;)</span><br></pre></td></tr></table></figure><p><code>$&amp; </code>匹配到的子串文本</p><p>（2）驼峰变量名转下划线变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.replace(/([a-z])([A-Z])/g,&#x27;$1_$2&#x27;)</span><br></pre></td></tr></table></figure><p>（3）下划线变量转驼峰变量名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.replace(/\_([a-z])/g,function(res,$1)&#123;return $1.toUpperCase()&#125;)</span><br></pre></td></tr></table></figure><p>（4）成对html标签匹配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var regex = /&lt;([^&gt;]+)&gt;[\d\D]*&lt;\/\1&gt;/;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/6844903845227659271#heading-0">正则表达式不要背</a><br>（2）<a href="https://juejin.cn/post/6844903487155732494#heading-38">JS正则表达式完整教程（略长）</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;正则表达式构建相关知识点。&lt;/p&gt;</summary>
    
    
    
    <category term="前端基础" scheme="https://unknown-four-hundred-and-four.gitee.io/unknown_404/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="正则表达式" scheme="https://unknown-four-hundred-and-four.gitee.io/unknown_404/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>关于登录拦截和history.back()的二三事</title>
    <link href="https://unknown-four-hundred-and-four.gitee.io/unknown_404/2022/03/31/login/"/>
    <id>https://unknown-four-hundred-and-four.gitee.io/unknown_404/2022/03/31/login/</id>
    <published>2022-03-31T02:13:02.000Z</published>
    <updated>2022-04-05T04:19:12.913Z</updated>
    
    <content type="html"><![CDATA[<p>记录一个维护老项目时发现的古早bug。</p><span id="more"></span> <h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>WAP项目首页通常有一个用户中心的图标供用户进入自己个人页面。当点击这个用户中心图标时后端会根据请求是否包含登录态来绝对是否重定向请求。例如说目标连接是user.domain.com，在这个域名下的代码由于没有拿到用户个人信息进行了302重定向，重定向后的连接为login.domain.com?to&#x3D;user.domain.com。但如果user.domain.com的代码找到了用户数据就会渲染前端页面。</p><div class="figure center" style="width:;"><img class="fig-img" src="login.jpg" alt="登录逻辑"><span class="caption">登录逻辑</span></div><div style="clear:both;"></div><p>目前为止看起来是不是毫无问题？</p><p>但如果重定向页面login.domain.com?to&#x3D;user.domain.com有回退按钮呢？前端回退通常使用的方法是history.back()，可以返回上一级页面，此时回退的话就会就会退回user.domain.com，该域名下的代码会再次执行判断登录态的逻辑，发现没有登录态依然会继续重定向，因此实际的页面效果看起来就像登录页面刷新，无法回退到首页。而到了Safari浏览器，由于该移动端浏览器不会重新执行返回的页面的代码，所以浏览器的url停留在user.domain.com，且没有渲染页面，看起来就像白屏故障一样。</p><div class="figure center" style="width:;"><img class="fig-img" src="login-problem.jpg" alt="登录页回退逻辑"><span class="caption">登录页回退逻辑</span></div><div style="clear:both;"></div><h2 id="解决方式？"><a href="#解决方式？" class="headerlink" title="解决方式？"></a>解决方式？</h2><p>（1）后端的登录跳转逻辑调整（<del>具体怎么改是后端的事跟我有什么关系呢</del> ）</p><p>（2）前端用户中心跳转的链接随获取用户登录态接口的数据而调整</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://t.zoukankan.com/yanggb-p-11675315.html">javascript解决在safari浏览器中使用history.back()返回上一页后页面不会刷新的问题</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一个维护老项目时发现的古早bug。&lt;/p&gt;</summary>
    
    
    
    <category term="踩坑经历" scheme="https://unknown-four-hundred-and-four.gitee.io/unknown_404/categories/%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="浏览器" scheme="https://unknown-four-hundred-and-four.gitee.io/unknown_404/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="WEB API" scheme="https://unknown-four-hundred-and-four.gitee.io/unknown_404/tags/WEB-API/"/>
    
  </entry>
  
  <entry>
    <title>小程序海报绘制</title>
    <link href="https://unknown-four-hundred-and-four.gitee.io/unknown_404/2022/03/28/poster/"/>
    <id>https://unknown-four-hundred-and-four.gitee.io/unknown_404/2022/03/28/poster/</id>
    <published>2022-03-28T12:33:20.000Z</published>
    <updated>2022-03-29T13:08:20.395Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>小程序海报绘制目前主要的实现方法有两种：</p><ol><li>前端使用 canvas 绘图并生成</li><li>后端使用后端绘图库进行绘制，返回给小程序端</li></ol><p>第一种方法的主要问题是 canvas 和纯 html 布局相去甚远，不同设备、不同版本的情况下绘图效果不可预期。但第二种方法开发难度也不小，且服务器压力会增大，后端未必愿意接受。所以压力又来到了前端。。。<br>尽管目前前端已经有一些生成海报的插件，如<a href="https://github.com/Kujiale-Mobile/Painter">painter</a>，可以以 json 的格式将元素的定位及样式传给画板。但如果需求出现了较为个性化的要求，例如根据内容海报高度自适应、一行开头不可以有标点等，还是自己手写原生比较好。<br>由于开发使用的是 Taro 框架所以关于 API 的介绍使用也主要以 Taro 为主。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="单位换算"><a href="#单位换算" class="headerlink" title="单位换算"></a>单位换算</h3><p>canvas 绘制使用的是 px 单位，但不同设备的 px 是需要换算的，所以在组件中统一使用 rpx 单位，这里就涉及到单位怎么换算问题。<br>小程序默认屏幕宽度为 750rpx，通过 wx.getSystemInfoSync 获取设备屏幕尺寸宽度，就可以获得实际 px 单位与 rpx 之间的比例，以此做单位转换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">rpx2px</span>(<span class="params">distance</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(distance)) &#123;</span><br><span class="line">        result = wx.<span class="title function_">getSystemInfoSync</span>().<span class="property">windowWidth</span> * distance / <span class="number">750</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">px2rpx</span>(<span class="params">distance</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(distance)) &#123;</span><br><span class="line">        result = distance * <span class="number">750</span> / wx.<span class="title function_">getSystemInfoSync</span>().<span class="property">windowWidth</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="canvas-隐藏"><a href="#canvas-隐藏" class="headerlink" title="canvas 隐藏"></a>canvas 隐藏</h3><p>在绘制海报过程时，因为不想让用户看到 canvas，所以我们必须把 canvas 隐藏起来。实现方法为控制 canvas 的绝对定位，将其移出可视界面。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.poster-canvas</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">10000</span>rpx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="canvas初始化"><a href="#canvas初始化" class="headerlink" title="canvas初始化"></a>canvas初始化</h2><p>canvas的初始化操作本身并不难，在模版中添加一个canvas组件并命名，在点击生成海报按钮时拿到canvas实例并设置宽高。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const ctx = Taro.createCanvasContext(&#x27;poster-canvas&#x27;)</span><br><span class="line">const &#123; width, height &#125; = this.state</span><br><span class="line">// 底版</span><br><span class="line">ctx.width = width</span><br><span class="line">ctx.height = height</span><br></pre></td></tr></table></figure><p>如果海报宽高固定，直接赋值即可。但如果希望完成海报高度随文字内容自适应变化的需求时，则需要多一步操作：可以先在渲染阶段制造一个DOM结构，将该DOM按照设计稿的需求绘制文字、外框间距等内容，在点击生成海报时利用createSelectorQuery获取海报中可变DOM元素(如海报正文DOM）的宽高，以及海报最外层DOM的宽高。注意该方法获取到的结果单位是px。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Taro.nextTick(() =&gt; &#123;</span><br><span class="line">    const query = Taro.createSelectorQuery()</span><br><span class="line">    query.select(&#x27;.key-box&#x27;).boundingClientRect()</span><br><span class="line">    query.exec(res =&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            const height = px2rpx(res[0].height)</span><br><span class="line">            const width = px2rpx(res[0].width)</span><br><span class="line">            this.setState(&#123; width, height &#125;)</span><br><span class="line">            this.drawPosterCanvas()//绘制canvas</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            this.failCb()//错误处理</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用Taro框架时需注意查询DOM属于异步内容无法立即获取只能利用nextTick函数等待下一个时间片获取，获取到以后存储到state里便于绘图时取出。这里需要注意即使将查询内容放在nextTick里，也有少数未查到DOM结果的情况，需要进行错误处理。</p><h2 id="图形篇"><a href="#图形篇" class="headerlink" title="图形篇"></a>图形篇</h2><h3 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h3><p>由于小程序打包的大小有限制，因此图片建议使用 CDN 保存。在绘制图片前需要对远程的图片进行下载的操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">downloadSharePic = <span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title class_">Taro</span>.<span class="title function_">downloadFile</span>(&#123;</span><br><span class="line">            url,</span><br><span class="line">            <span class="title function_">success</span>(<span class="params">res</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (res.<span class="property">statusCode</span> === <span class="number">200</span>) &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(res.<span class="property">tempFilePath</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="title function_">reject</span>(res)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">fail</span>(<span class="params">err</span>) &#123;</span><br><span class="line">                <span class="title function_">reject</span>(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下载成功后会获得一个临时文件路径，就可以调用 drawImage 函数来绘制了。注意点：下载图片属于异步操作，需要在等待返回值以后才可以绘制。<br>ctx.drawImage 有 3 种写法：</p><ul><li>drawImage(imageResource, dx, dy)</li><li>drawImage(imageResource, dx, dy, dWidth, dHeight)</li><li>drawImage(imageResource, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) 从 1.9.0 起支持<br>如果无法使用第三种方案、需要自己调整图片宽高按设计比例显示在 canvas 上的话，可以采用如下函数：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">getDrawImgParams = <span class="function">(<span class="params">src,defaultWidth,defaultHeight</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title class_">Taro</span>.<span class="title function_">getImageInfo</span>(&#123;</span><br><span class="line">            src,</span><br><span class="line">            <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> &#123; width, height &#125; = res</span><br><span class="line">                <span class="keyword">let</span> sx = <span class="number">0</span></span><br><span class="line">                <span class="keyword">let</span> sy = <span class="number">0</span></span><br><span class="line">                <span class="keyword">let</span> sWidth = width</span><br><span class="line">                <span class="keyword">let</span> sHeight = height</span><br><span class="line">                <span class="keyword">const</span> w2h = width / height</span><br><span class="line">                <span class="keyword">const</span> defaultW2H = defaultWidth / defaultHeight</span><br><span class="line">                <span class="keyword">if</span> (w2h &gt; defaultW2H) &#123; <span class="comment">// 更宽</span></span><br><span class="line">                    sWidth = <span class="title class_">Math</span>.<span class="title function_">floor</span>(height * defaultW2H)</span><br><span class="line">                    sx = <span class="title class_">Math</span>.<span class="title function_">floor</span>((width - sWidth) / <span class="number">2</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (w2h &lt; defaultW2H) &#123; <span class="comment">// 更高</span></span><br><span class="line">                    sHeight = <span class="title class_">Math</span>.<span class="title function_">floor</span>(width / defaultW2H)</span><br><span class="line">                    sy = <span class="title class_">Math</span>.<span class="title function_">floor</span>((height - sHeight) / <span class="number">2</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title function_">resolve</span>(&#123;</span><br><span class="line">                    sx,</span><br><span class="line">                    sWidth,</span><br><span class="line">                    sy,</span><br><span class="line">                    sHeight</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">fail</span>: <span class="function"><span class="params">rej</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(rej)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绘制圆形"><a href="#绘制圆形" class="headerlink" title="绘制圆形"></a>绘制圆形</h3><p>需要用到的函数是 canvasContext.arc，作用是绘制一条曲线。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canvasContext.arc(x: number, y: number, r: number, sAngle: number, eAngle: number, counterclockwise?: boolean)</span><br></pre></td></tr></table></figure><p>x、y 对应圆心坐标，sAngle 是起始弧度，eAngle 是终止弧度。创建一个圆可以指定起始弧度为 0，终止弧度为 2 * Math.PI。<br>如果是画线框就使用 ctx.stroke();如果是画色块就使用 ctx.fill()。</p><h3 id="绘制圆角矩形"><a href="#绘制圆角矩形" class="headerlink" title="绘制圆角矩形"></a>绘制圆角矩形</h3><p>canvas 并没有提供绘制圆角矩形的方法，因此我们需要以另一种方法来实现它。方法的核心是将圆角矩形拆解成四个直角圆弧和四条直线连接的图形。具体的实现如下面的代码所示。圆弧的绘制除了上面提到的arc之外，还有一个叫 CanvasContext.arcTo 的方法，其特点是控制点和半径绘制圆弧路径。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">drawArcFrame = <span class="function">(<span class="params">ctx, x, y, r, w, h</span>) =&gt;</span> &#123;</span><br><span class="line">    ctx.<span class="title function_">beginPath</span>()</span><br><span class="line">    ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;transparent&#x27;</span>;</span><br><span class="line">    <span class="comment">// 左上角</span></span><br><span class="line">    ctx.<span class="title function_">arc</span>(x + r, y + r, r, <span class="title class_">Math</span>.<span class="property">PI</span>, <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="number">1.5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// border-top</span></span><br><span class="line">    ctx.<span class="title function_">moveTo</span>(x + r, y)</span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(x + w - r, y)</span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(x + w, y + r)</span><br><span class="line">    <span class="comment">// 右上角</span></span><br><span class="line">    ctx.<span class="title function_">arc</span>(x + w - r, y + r, r, <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="number">1.5</span>, <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// border-right</span></span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(x + w, y + h - r)</span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(x + w - r, y + h)</span><br><span class="line">    <span class="comment">// 右下角</span></span><br><span class="line">    ctx.<span class="title function_">arc</span>(x + w - r, y + h - r, r, <span class="number">0</span>, <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// border-bottom</span></span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(x + r, y + h)</span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(x, y + h - r)</span><br><span class="line">    <span class="comment">// 左下角</span></span><br><span class="line">    ctx.<span class="title function_">arc</span>(x + r, y + h - r, r, <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="number">0.5</span>, <span class="title class_">Math</span>.<span class="property">PI</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// border-left</span></span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(x, y + r)</span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(x + r, y)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是使用 fill 还是 stroke都可以，二选一即可，但是需要与上面对应</span></span><br><span class="line">    ctx.<span class="title function_">fill</span>()</span><br><span class="line">    <span class="comment">// ctx.stroke()</span></span><br><span class="line">    ctx.<span class="title function_">closePath</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是绘制图片的外框，我们通常需要对原图进行剪切获得我们需要的样式。在我们调用 CanvasContext.clip()进行剪切时，之后的绘图都会被限制在被剪切的区域内（不能访问画布上的其他区域）。因此在使用 clip 方法前通过使用 save 方法对当前画布区域进行保存，在裁剪完图片后通过 restore 方法对其进行恢复。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="title function_">save</span>()<span class="comment">// 1)保存画布区域</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">drawArcFrame</span>(ctx, <span class="number">0</span>, <span class="number">0</span>, <span class="number">12</span>, width, height)<span class="comment">//2)绘制圆角</span></span><br><span class="line">ctx.<span class="title function_">clip</span>()<span class="comment">//3）裁剪画板</span></span><br><span class="line">ctx.<span class="title function_">setFillStyle</span>(<span class="string">&#x27;#F8F9FB&#x27;</span>)</span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>, <span class="number">0</span>, width, height)<span class="comment">//4）在剪切后的画板绘图</span></span><br><span class="line">ctx.<span class="title function_">restore</span>()<span class="comment">//5）恢复画板区域</span></span><br></pre></td></tr></table></figure><h3 id="绘制阴影"><a href="#绘制阴影" class="headerlink" title="绘制阴影"></a>绘制阴影</h3><p>微信小程序本体从基础库 1.9.90 开始支持设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 阴影的x偏移</span><br><span class="line">ctx.shadowOffsetX = 10;</span><br><span class="line">// 阴影的y偏移</span><br><span class="line">ctx.shadowOffsetY = 10;</span><br><span class="line">// 阴影颜色</span><br><span class="line">ctx.shadowColor = &#x27;rgba(0,0,0,0.5)&#x27;;</span><br><span class="line">// 阴影的模糊半径</span><br><span class="line">ctx.shadowBlur = 10;</span><br><span class="line">// 绘制图形</span><br><span class="line">ctx.fillStyle = &#x27;rgba(255,0,0,0.5)&#x27;</span><br><span class="line">ctx.fillRect(100, 100, 100, 100);</span><br></pre></td></tr></table></figure><p>阴影的设置一定要在图形绘制前。</p><h3 id="圆形内阴影和圆角矩形内阴影"><a href="#圆形内阴影和圆角矩形内阴影" class="headerlink" title="圆形内阴影和圆角矩形内阴影"></a>圆形内阴影和圆角矩形内阴影</h3><p>大致思路：先绘制边框和阴影，再用clip把外阴影裁掉。</p><h2 id="文字篇"><a href="#文字篇" class="headerlink" title="文字篇"></a>文字篇</h2><h3 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h3><p>Taro 框架支持的关于字体的方法只有 setFontSize，用于修改字体大小。<br>但微信小程序本体从基础库 1.9.90 开始支持设置字体样式 canvasContext.font。涉及到的参数如下所示：</p><table><thead><tr><th align="center">属性</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">style</td><td align="center">字体样式。仅支持 italic, oblique, normal</td></tr><tr><td align="center">weight</td><td align="center">字体粗细。仅支持 normal, bold</td></tr><tr><td align="center">size</td><td align="center">字体大小</td></tr><tr><td align="center">family</td><td align="center">字体族名。注意确认各平台所支持的字体</td></tr></tbody></table><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.font = &#x27;normal bold 40px sans-serif&#x27;;</span><br></pre></td></tr></table></figure><p>关于字体粗细的问题据说安卓手机只 400 和 700 的 font-weight，如果设置其他的权重也无法实现效果。需要注意点是如果设置了加粗属性 bold，那么在后续文字书写中 weight 的属性值必须设置为 400 而不是 normal，否则在安卓机上后续绘制的文字仍然加粗，尽管开发者工具上正常。</p><h3 id="单行文字"><a href="#单行文字" class="headerlink" title="单行文字"></a>单行文字</h3><p>需要用到的函数是 canvasContext.fillText。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canvasContext.fillText(text: string, x: number, y: number, maxWidth?: number)</span><br></pre></td></tr></table></figure><p>x、y 对应文字左上角坐标。<br>需要注意的点是绘制文字前需要使用 setTextBaseline 函数确定文字竖直方向对齐方式，不设置的话似乎默认是 normal，而不同系统设备上各个基准都不太一样，绘制的效果可能达不到预期。通常设置 top 即可满足需求，如果设置了 middle 则 y 值应该为文字左上的 y 坐标+fontSize&#x2F;2。</p><h3 id="多行文字"><a href="#多行文字" class="headerlink" title="多行文字"></a>多行文字</h3><p>canvas 绘制文字时，只会一股脑的在单行上一直画下去而不会根据容器宽度自动换行。如果希望进行折行、分段，则可以使用 CanvasContext.measureText(string text)的方法，具体步骤包括：</p><ul><li>1）准备工作：去除文本里面和空格相关的字符，保留的话可能在安卓机上出现绘制异常</li><li>2）用tempText变量存储单行字段，逐字遍历文本，用measureText测截至当前字符的文段长度是否超过限定宽度，没有则将当前字符添加到tempText；注意设置阈值时要减去一个字宽，防止遍历到接近折行的位置已经存储的字段tempText已经接近于限制宽度、此时再加一个字符超过设计宽度的情况。</li><li>3）measureText测截至当前字符的文段长度超过限定宽度时将该字段推入数组中保存；同时清空tempText，用于下一行文字的测算。</li><li>4）循环结束后不要忘记将最后一行的结果推入数组row中</li><li>5）遍历行数组row，每行用fillText完成</li><li>6）如果考虑行数限制，可以在遍历row时增加判断条件，在绘制到最后一行时将最后一个字替换为省略号</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">processWord = <span class="function">(<span class="params">ctx, text, width,fontSize,lineHeight,maxLine</span>) =&gt;</span> &#123;</span><br><span class="line">    text=text.<span class="title function_">replace</span>(<span class="regexp">/\s*/g</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> row = []</span><br><span class="line">    <span class="keyword">let</span> tempText = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> wordIndex = <span class="number">0</span>; wordIndex &lt; text.<span class="property">length</span>; wordIndex++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ctx.<span class="title function_">measureText</span>(tempText).<span class="property">width</span> &lt; width - fontSize) &#123;</span><br><span class="line">            tempText += text[wordIndex]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 折行位置</span></span><br><span class="line">            wordIndex--</span><br><span class="line">            row.<span class="title function_">push</span>(tempText)</span><br><span class="line">            tempText = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    row.<span class="title function_">push</span>(tempText)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> rowNum = <span class="number">0</span>; rowNum &lt; row.<span class="property">length</span>&amp;&amp;rowNum&lt;maxLine; rowNum++) &#123;</span><br><span class="line">        <span class="keyword">let</span> text = row[rowNum]</span><br><span class="line">        <span class="keyword">if</span> (row.<span class="property">length</span> &gt; maxLine &amp;&amp; rowNum == maxLine-<span class="number">1</span>) &#123;</span><br><span class="line">            text = text.<span class="title function_">substring</span>(<span class="number">0</span>, text.<span class="property">length</span> - <span class="number">1</span>) + <span class="string">&#x27;...&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        ctx.<span class="title function_">setTextBaseline</span>(<span class="string">&#x27;top&#x27;</span>)</span><br><span class="line">        ctx.<span class="title function_">fillText</span>(text, <span class="number">70</span>, <span class="number">258</span> + rowNum * lineHeight)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="附加要求：标点不可以出现在首行"><a href="#附加要求：标点不可以出现在首行" class="headerlink" title="附加要求：标点不可以出现在首行"></a>附加要求：标点不可以出现在首行</h4><p>在上述算法的基础上在折行处增加while判断，如果字符是标点就加在当前行tempText，一直到下一个是汉字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> wordIndex = <span class="number">0</span>; wordIndex &lt; text.<span class="property">length</span>; wordIndex++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.<span class="title function_">measureText</span>(tempText).<span class="property">width</span> &lt; width - fontSize) &#123;</span><br><span class="line">        tempText += text[wordIndex]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 折行位置</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="regexp">/[，。”！？、：）》；]/</span>.<span class="title function_">test</span>(text[wordIndex])) &#123;</span><br><span class="line">            tempText += text[wordIndex++]</span><br><span class="line">        &#125;</span><br><span class="line">        wordIndex--</span><br><span class="line">        row.<span class="title function_">push</span>(tempText)</span><br><span class="line">        tempText = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绘制展示"><a href="#绘制展示" class="headerlink" title="绘制展示"></a>绘制展示</h2><h3 id="canvas转image"><a href="#canvas转image" class="headerlink" title="canvas转image"></a>canvas转image</h3><p>绘制完成后需要调用Taro.canvasToTempFilePath将canvas转为图片输出，需要注意的点包括：1）Taro.canvasToTempFilePath需要写在ctx.draw的回调中；2）draw的回调函数是异步的，canvasToTempFilePath需要在setTimeout中做一些延时，一般1s就可以了。<br>生成的临时url传入Image组件中就可以在屏幕中显示了。</p><h3 id="海报预览使用-scroll-view-展示时，该组件没有显示-css-样式的圆角"><a href="#海报预览使用-scroll-view-展示时，该组件没有显示-css-样式的圆角" class="headerlink" title="海报预览使用 scroll-view 展示时，该组件没有显示 css 样式的圆角"></a>海报预览使用 scroll-view 展示时，该组件没有显示 css 样式的圆角</h3><p>解决方法：在 scroll-view 元素上添加以下样式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">overflow: hidden;</span><br><span class="line">transform: translateY(0);</span><br><span class="line">border-radius: 16rpx;</span><br></pre></td></tr></table></figure><p>当海报的高度没有超过设计稿的可视高度时，scroll-view作为套在海报外层的组件也不应该有滚动条。可以在海报生成组件的state里再维护一个isScroll的变量，判断和赋值的位置可以在<a href="#canvas%E5%88%9D%E5%A7%8B%E5%8C%96">canvas初始化</a>执行。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="http://www.yanghuiqing.com/web/350">在Canvas中实现矩形、圆形、圆角矩形内阴影效果</a>  </li><li><a href="hhttps://juejin.cn/post/6983574104167170061">手把手教你用canvas绘制小程序海报（一）</a>  </li><li><a href="https://juejin.cn/post/6844903663840788493#heading-0">轻松生成小程序分享海报</a>  </li><li><a href="https://juejin.cn/post/7039199842421178382#heading-1">微信小程序《海报生成》</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录下自己在实现海报绘制时遇到的问题及解决的方案。&lt;/p&gt;</summary>
    
    
    
    <category term="技术学习" scheme="https://unknown-four-hundred-and-four.gitee.io/unknown_404/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="小程序" scheme="https://unknown-four-hundred-and-four.gitee.io/unknown_404/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    <category term="canvas" scheme="https://unknown-four-hundred-and-four.gitee.io/unknown_404/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript</title>
    <link href="https://unknown-four-hundred-and-four.gitee.io/unknown_404/2022/03/27/typescript/"/>
    <id>https://unknown-four-hundred-and-four.gitee.io/unknown_404/2022/03/27/typescript/</id>
    <published>2022-03-27T11:05:48.000Z</published>
    <updated>2022-03-27T11:05:49.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>类型系统按照「是否允许隐式类型转换」来分类，可以分为强类型和弱类型。<br>JavaScript就属于弱类型语言，灵活性强，但不利的一点是没有编译过程，语言的类型错误只有运行时才会发现（JavaScript因此被称为动态语言）。而TypeScript可以弥补这一点：TypeScript 在运行前需要先编译为 JavaScript，而在编译阶段就会进行类型检查并报错（TypeScript对应称为静态语言）。同时TypeScript 增强了编辑器（IDE）的功能，包括代码补全、接口提示、跳转到定义、代码重构等，这在很大程度上提高了开发效率。</p><p>本文主要记录一些常用的typescript语法及一些需要辨析的注意点。</p><h2 id="anyScript使用方法"><a href="#anyScript使用方法" class="headerlink" title="anyScript使用方法"></a>anyScript使用方法</h2><p>用于代码标红但确实不知道如何声明的场景</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// @ts-nocheck 禁用整个文件的ts校验，置于文件头顶</span><br><span class="line">// @ts-ignore 禁用单行ts校验，放在报错行的上方使用</span><br><span class="line">any和unknown</span><br></pre></td></tr></table></figure><p>在遇到确实难以定义类型的场景下可以使用以上方法逃课，以后再思考可能的改进方式。</p><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><p>在TypeScript 3.1的文档里，基础类型包括：boolean,string,number,Array&lt;&gt;,Tuple,any,void,undefined,null,never<br>简单记录下使用偏少的类型它的特点。</p><p>辨析点：</p><h3 id="1）unknown-vs-any"><a href="#1）unknown-vs-any" class="headerlink" title="1）unknown vs any"></a>1）unknown vs any</h3><p>unknown与any一样，所有类型都可以分配给unknown，unknown 类型的值只能赋给 unknown 本身和 any 类型。但unknown仍然有静态检测能力，个人理解是unknown没有放弃类型的推断，并不是所有类型的内部方法unknown类型数据都可以随便调用</p><h3 id="2）void，null和undefined"><a href="#2）void，null和undefined" class="headerlink" title="2）void，null和undefined"></a>2）void，null和undefined</h3><p>相同点是这3个本身在声明变量的过程中用处不大。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let unusable: void = undefined;</span><br><span class="line">let u: undefined = undefined;</span><br><span class="line">let n: null = null;</span><br></pre></td></tr></table></figure><p>默认情况下null和undefined是所有类型的子类型。<br>undefined 也是 void 的一个子集。当你对函数返回值并不在意（number、boolean、undefined都可以是返回值）时，使用 void 而不是 undefined。</p><h2 id="接口与类型别名"><a href="#接口与类型别名" class="headerlink" title="接口与类型别名"></a>接口与类型别名</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>可用于对象类型命名和定义类型参数。<br>基本语法：<code>interface SquareConfig &#123;&#125;</code><br>接口名开头需大写，因为定义的是一种类型。</p><h4 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h4><p>使用写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">  color?: string;</span><br><span class="line">  width?: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据使用经验，在调用该类型SquareConfig的变量其属性时编译等效于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">  color: string｜undefined;</span><br><span class="line">  width: number｜undefined;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以假如使用变量的color属性调用string的默认方法或者赋值给一个string变量时就会报错</p><h4 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h4><p>一些对象属性只能在对象刚刚创建的时候修改其值。可以在属性名前用 readonly来指定只读属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">    readonly x: number;</span><br><span class="line">    readonly y: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>辨析点：<br><strong>const vs readonly</strong>：const可以防止变量的值被修改，readonly可以防止变量的属性被修改。</p><h4 id="索引签名"><a href="#索引签名" class="headerlink" title="索引签名"></a>索引签名</h4><p>描述了对象索引的类型，还有相应的索引返回值类型。索引签名只支持以下两种：</p><ul><li>字符串索引签名</li><li>数字索引签名<br>一个接口中最多只能定义一个字符串索引签名，该签名会约束对象类型的所有属性类型。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface NumberDictionary &#123;</span><br><span class="line">  [index: string]: number;</span><br><span class="line">  length: number;    // 可以，length是number类型</span><br><span class="line">  name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3>类型别名声明可以为TypeScript中任意类型命名<br>基本语法：<code>type AliasType=string｜boolean｜number</code><h3 id="interface与type区别"><a href="#interface与type区别" class="headerlink" title="interface与type区别"></a>interface与type区别</h3></li></ul><ol><li>type可以用于非对象类型，而接口只能用于对象类型</li><li>接口可以继承其他对象类型，type不支持继承只能用交叉类型实现继承效果。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- type类型扩展方式 --&gt;</span><br><span class="line">type Name = &#123; name: string &#125;;</span><br><span class="line">type Person = Name &amp; &#123; age: number &#125;;</span><br><span class="line">&lt;!-- interface类型扩展方式 --&gt;</span><br><span class="line">interface IName &#123; name: string &#125;;</span><br><span class="line">interface IPerson extends IName &#123; age: number &#125;;</span><br></pre></td></tr></table></figure></li><li>接口具有声明合并的行为，type没有</li></ol><h2 id="运算符使用"><a href="#运算符使用" class="headerlink" title="运算符使用"></a>运算符使用</h2><h3 id="非空断言运算符"><a href="#非空断言运算符" class="headerlink" title="非空断言运算符 !"></a>非空断言运算符 !</h3><p>置于变量名后，用于强调元素不是null或undefined。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const test=(func:()=&gt;void)=&gt;&#123;</span><br><span class="line">    func!()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可选链运算符"><a href="#可选链运算符" class="headerlink" title="可选链运算符 ?."></a>可选链运算符 ?.</h3><p>ES11(ES2020)新增的特性。?.用来判断左侧的变量是否存在，不存在不会继续表达式运算。例如书写a?.b时实际上等效于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a === null || a === void 0 ? void 0 : a.b;</span><br></pre></td></tr></table></figure><h3 id="空值合并运算符"><a href="#空值合并运算符" class="headerlink" title="空值合并运算符 ??"></a>空值合并运算符 ??</h3><p>ES11(ES2020)新增的特性。当左侧的操作数为 null 或者 undefined 时，返回其右侧操作数，否则返回左侧操作数。<br>let b &#x3D; a ?? 10等效于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let b = a !== null &amp;&amp; a !== void 0 ? a : 10;</span><br></pre></td></tr></table></figure><h3 id="数字分割符"><a href="#数字分割符" class="headerlink" title="数字分割符_"></a>数字分割符_</h3><p>可以用于长数字分隔，方便阅读，不会编译进JavaScript。个人理解类似计算器的数字每隔3位加一个逗号方便阅读的作用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let num:number = 12_345.678_9</span><br></pre></td></tr></table></figure><h2 id="内置工具类型"><a href="#内置工具类型" class="headerlink" title="内置工具类型"></a>内置工具类型</h2><h3 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial<T></h3><p>作用是将泛型T所有属性变为可选属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Partial&lt;T&gt; = &#123;</span><br><span class="line">[P in keyof T]?: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required<T></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">作用是将泛型T所有属性变为必选属性。</span><br><span class="line">type Required&lt;T&gt; = &#123;</span><br><span class="line">  [P in keyof T]-?: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Record-lt-K-T-gt"><a href="#Record-lt-K-T-gt" class="headerlink" title="Record&lt;K, T&gt;"></a>Record&lt;K, T&gt;</h3><p>作用是将 K 中所有属性值转化为 T 类型。K提供对象属性名的联合类型，T提供对象属性类型。<br>因为K是用作对象属性名设置，所以参数K必须能够赋值给string｜number｜symbol类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Record&lt;K extends keyof any,T&gt; = &#123;</span><br><span class="line">  [key in K]: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type K=&#x27;x&#x27;|&#x27;y&#x27;</span><br><span class="line">type R=Record&lt;K,number&gt;</span><br><span class="line">const a:R=&#123;x:0,y:0&#125;</span><br></pre></td></tr></table></figure><h3 id="Pick-lt-T-K-gt"><a href="#Pick-lt-T-K-gt" class="headerlink" title="Pick&lt;T, K&gt;"></a>Pick&lt;T, K&gt;</h3><p>作用是将 T 类型中的 K 键列表提取，K必须为对象类型T存在的属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Pick&lt;T, K extends keyof T&gt; = &#123;</span><br><span class="line">  [P in K]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interface Point=&#123;x:number,y:number&#125;</span><br><span class="line">type T=Pick&lt;Point,&#x27;x&#x27;|&#x27;y&#x27;&gt;//&#123;x:number,y:number&#125;</span><br></pre></td></tr></table></figure><h3 id="Omit-lt-T-K-gt"><a href="#Omit-lt-T-K-gt" class="headerlink" title="Omit&lt;T, K&gt;"></a>Omit&lt;T, K&gt;</h3><p>与<code>Pick&lt;T, K&gt;</code>互补。用于去除类型 T 中包含 K 的键值对。如果K为T不存在的属性则新类型等同于T。</p><h3 id="Exclude-lt-T-U-gt"><a href="#Exclude-lt-T-U-gt" class="headerlink" title="Exclude&lt;T, U&gt;"></a>Exclude&lt;T, U&gt;</h3><p>在 T 类型中，去除 T 类型和 U 类型的交集。</p><h3 id="Extract-lt-T-U-gt"><a href="#Extract-lt-T-U-gt" class="headerlink" title="Extract&lt;T, U&gt;"></a>Extract&lt;T, U&gt;</h3><p>与<code>Exclude&lt;T, U&gt;</code>互补。获取T类型中所有能赋值给U的类型，没有返回never。</p><h3 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType<T></h3><p>获取 T 类型(函数)对应的返回值类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function foo(x: string | number): string | number &#123; /*..*/ &#125;</span><br><span class="line">type FooType = ReturnType&lt;foo&gt;;  // string | number</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>（1）<a href="https://juejin.cn/post/6926794697553739784">TypeScript 高级用法</a><br>（2）<a href="https://juejin.cn/post/6981728323051192357#heading-0">一篇够用的TypeScript总结</a><br>（3）<a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html">TypeScript文档</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;TypeScript一些特性记录和辨析，方便自己记忆，为日后使用准备。&lt;/p&gt;</summary>
    
    
    
    <category term="前端技术体系" scheme="https://unknown-four-hundred-and-four.gitee.io/unknown_404/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="TypeScript" scheme="https://unknown-four-hundred-and-four.gitee.io/unknown_404/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch查询语句使用</title>
    <link href="https://unknown-four-hundred-and-four.gitee.io/unknown_404/2022/03/14/esUseage/"/>
    <id>https://unknown-four-hundred-and-four.gitee.io/unknown_404/2022/03/14/esUseage/</id>
    <published>2022-03-14T12:43:59.000Z</published>
    <updated>2022-03-18T10:45:49.166Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><p>es 中的查询请求有两种方式，一种是简易版的查询，另外一种是使用 JSON 完整的请求体，叫做结构化查询（DSL）。DSL 的查询方式是 POST 过去一个 json，由于 post 的请求是 json 格式的，所以存在很多灵活性，也有很多形式。笔者出于使用 nodejs 技术调用 es 查询的需求，因此主要搜集的资料是关于 DSL 的。</p><p>本文并不是查询方法的全列举，而是针对自己实际使用的几种方法进行比较辨析。如果日后尝试使用其他方法，也会在这里添加补充说明。</p><div class="alert info"><p>使用 DSL 查询语法时，由于使用 json 字符串时存在特殊符号例如<code>*,/,\</code>等影响解析，因此需要使用两个反斜杠<code>\\</code>进行转义</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">calcQueryString</span>=(<span class="params">keyword:<span class="built_in">string</span></span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> keyword.<span class="title function_">replace</span>(<span class="regexp">/([-\/\\^$*+?.()|[\]&#123;&#125;])/g</span>, <span class="string">&#x27;\\$1&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全文查询"><a href="#全文查询" class="headerlink" title="全文查询"></a>全文查询</h2><h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p>不需要完整的卢塞恩语法支持。在查询语句里任何一个词项与分词匹配都会返回该文档。如果要查询所有关键词的文档，可以使用 and 操作符连接。结果里关键词但次序无法保证。</p><p>查询结构示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">        &quot;content&quot; : &quot;小白的文件整理箱&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该查询语句可能根据分词规则分为“小白”、“白的”、“文”、“整理箱”等多种关键词，只要有匹配的字词就会被搜出来，例如“文无定法”、“文小白”等都有可能</p><h3 id="match-phrase"><a href="#match-phrase" class="headerlink" title="match_phrase"></a>match_phrase</h3><p>在执行短语匹配查询时，查询结果会满足两个条件：1）必须匹配短语中的所有分词 2）保证各个分词的相对位置不变。</p><p>以 match 的查询语句为例，查询结果不会出现“文小白”，但有可能出现“小白菜的 zip 文件垃圾整理行李箱”</p><h3 id="multi-match"><a href="#multi-match" class="headerlink" title="multi_match"></a>multi_match</h3><p>match 语法的升级，可用于多个字段。也可以用指数符指定多个字段的权重</p><p>查询结构示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">        &quot;query&quot; : &quot;小白的文件整理箱&quot;,</span><br><span class="line">        &quot;fields&quot;:[&quot;title^3&quot;,&quot;content&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="query-string"><a href="#query-string" class="headerlink" title="query_string"></a>query_string</h3><p>常见写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;query_string&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &quot;(new york city) OR (big apple)&quot;,</span><br><span class="line">      &quot;fields&quot;: [&quot;content&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>支持运算符 AND 和 OR，括号内的查询语句作为整个查询。<br>支持 wildcard 语法。</p><h2 id="词项查询"><a href="#词项查询" class="headerlink" title="词项查询"></a>词项查询</h2><h3 id="term"><a href="#term" class="headerlink" title="term"></a>term</h3><p>term 是代表完全匹配，返回的文件必须包含完整的关键词。</p><h3 id="terms"><a href="#terms" class="headerlink" title="terms"></a>terms</h3><p>term 的升级版，可以查询多个字词。例如查询 content 字段包含“小白”和“文件整理箱”的文档。</p><p>查询结构示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;content&quot; : [&quot;小白&quot;,&quot;文件整理箱&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="prefix"><a href="#prefix" class="headerlink" title="prefix"></a>prefix</h3><p>查询某个字段以固定前缀开始的文档。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;prefix&quot;: &#123;</span><br><span class="line">        &quot;content&quot; : &quot;小白&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该查询语句会返回“小白”、“小白菜”等所有以“小白”开头的content文档。</p><h3 id="wildcard"><a href="#wildcard" class="headerlink" title="wildcard"></a>wildcard</h3><p>支持通配符搜索，可以使用?替换单个字符，用*替换零个或多个字符。通配符的查询效率较低不是很推荐。</p><h3 id="regexp"><a href="#regexp" class="headerlink" title="regexp"></a>regexp</h3><p>可以支持更为复杂的匹配模式。<em>（个人体验感觉不佳，用于带转义字段的查询时往往查不到，不知道什么原因；不如js的正则好用）</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;regexp&quot;: &#123;</span><br><span class="line">            &quot;postcode&quot;: &quot;W[0-9].+&quot; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询语句text字段和keyword字段的区别"><a href="#查询语句text字段和keyword字段的区别" class="headerlink" title="查询语句text字段和keyword字段的区别"></a>查询语句text字段和keyword字段的区别</h2><p>ElasticSearch 5.0以后，String字段被拆分成两种新的数据类型: text用于全文搜索，会分词,而keyword用于关键词搜索，不进行分词。对于字符串类型的字段，ES默认会再生成一个keyword字段用于精确索引。</p><p>简单理解就是text字段会被分词，而keyword字段是要求不分词完整地查找全字段。</p><p>keyword的查询语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">        &quot;content.keyword&quot; : &quot;小白&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询字段时-term、match、match-phrase、query-string-的区别"><a href="#查询字段时-term、match、match-phrase、query-string-的区别" class="headerlink" title="查询字段时 term、match、match_phrase、query_string 的区别"></a>查询字段时 term、match、match_phrase、query_string 的区别</h2><h3 id="1-1-term"><a href="#1-1-term" class="headerlink" title="1.1 term"></a>1.1 term</h3><p>1）term 查询 keyword 字段。</p><p>term 不会分词。而 keyword 字段也不分词。需要完全匹配才可。</p><p>2）term 查询 text 字段</p><p>因为 text 字段会分词，而 term 不分词，所以 term 查询的条件必须是 text 字段分词后的某一个。</p><p>eg. brown big box 作为 text 字段会被分为[ brown, big, box ]的词组，当 term 的查询内容为 brown 时可返回该词条<br>当 term 的查询内容为 brown big 的时候则不会返回</p><h3 id="1-2-match"><a href="#1-2-match" class="headerlink" title="1.2 match"></a>1.2 match</h3><p>1）match 查询 keyword 字段</p><p>match 会被分词，而 keyword 不会被分词，match 的需要跟 keyword 的完全匹配可以。</p><p>其他的不完全匹配的都是失败的。</p><p>2）match 查询 text 字段</p><p>match 分词，text 也分词，只要 match 的分词结果和 text 的分词结果有相同的就匹配。</p><p>eg. brown big box 的词条，当 term 的查询内容为 fox 时也可返回该词条，因为存在“ox“这一相同内容</p><h3 id="1-3-match-phrase"><a href="#1-3-match-phrase" class="headerlink" title="1.3.match_phrase"></a>1.3.match_phrase</h3><p>1）match_phrase 匹配 keyword 字段。</p><p>这个同上必须跟 keyword 一致才可以。</p><p>2）match_phrase 匹配 text 字段。</p><p>match_phrase 是分词的，text 也是分词的。match_phrase 的分词结果必须在 text 字段分词中都包含，而且顺序必须相同，而且必须都是连续的。</p><p><em>（与 match 匹配 text 情况相比就多了顺序相同一个条件）</em></p><h3 id="1-4-query-string"><a href="#1-4-query-string" class="headerlink" title="1.4.query_string"></a>1.4.query_string</h3><p>1）query_string 查询 keyword 类型的字段。</p><p>网上有说法无法查询。但根据实际经验做长字符串的查询是可行的，可能是 Lucene 语法使用不当的问题。  </p><p>query_string 查询 keyword 字段如果只是使用了局部字段查询的话需要在前后加“*”。</p><p>2）query_string 查询 text 类型的字段。</p><p>和 match_phrase 区别的是，不需要连续，顺序还可以调换。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>（1）<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html">Elasticsearch Guide</a><br>（2）《从Lucene到ElasticSearch：全文检索实战》<br>（3）<a href="https://www.cnblogs.com/duanxz/p/3508338.html">ES之五：关于Elasticsearch查找相关的问题汇总（match、match_phrase、query_string和term）</a><br>（4）<a href="https://www.cnblogs.com/yjf512/p/4897294.html">elasticsearch 查询（match和term）</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;摸索Elasticsearch查询语句时搜索和实践体验到的知识点&lt;/p&gt;</summary>
    
    
    
    <category term="技术学习" scheme="https://unknown-four-hundred-and-four.gitee.io/unknown_404/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Elasticsearch" scheme="https://unknown-four-hundred-and-four.gitee.io/unknown_404/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建博客</title>
    <link href="https://unknown-four-hundred-and-four.gitee.io/unknown_404/2022/03/14/hexoBlog/"/>
    <id>https://unknown-four-hundred-and-four.gitee.io/unknown_404/2022/03/14/hexoBlog/</id>
    <published>2022-03-14T06:05:43.000Z</published>
    <updated>2022-04-07T03:59:45.698Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2><p>1）<a href="https://nodejs.org/zh-cn/">node.js</a><br>2) <a href="https://git-scm.com/">git</a></p><h2 id="本地建站流程"><a href="#本地建站流程" class="headerlink" title="本地建站流程"></a>本地建站流程</h2><p>1.在<a href="https://gitee.com/">Gitee</a>注册登录账号，点击右上角“+”按钮创建新的仓库。仓库名可随意设置。但注意初始化时不要加文件。</p><div class="figure center" style="width:;"><img class="fig-img" src="gitee-init.png" alt=""></div><div style="clear:both;"></div><div class="alert info"><p>根据网上大多数博客的说法仓库名应该设置为用户名，否则 hexo 打包的 css 路径会找不到。但是实际操作中并没有遇到这样的问题推测有两个可能性。<br>1）这个问题只出现在 GitHub Page 开设的流程。<br>2）配置更新了，现在新版 hexo 的打包确保了相对路径的可查找性。</p></div> <p>2.将空仓库拉到本地，安装 hexo，安装指令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.使用指令<code>hexo init</code>初始化 hexo，注意如果仓库的文件夹不为空的话，初始化就会失败，可以考虑新建一个文件夹，在新文件夹的位置启动初始化指令。<br><em>（推荐将初始化生成的文件夹都放在仓库的另一个分支，master 分支保留给 hexo 打包博客文件）</em><br>初始化后当前文件夹内部结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml //网站的配置文件，可配置大部分参数</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds  //模版文件夹</span><br><span class="line">├── source  //资源文件夹，用户添加资源的位置</span><br><span class="line">|   ├── _drafts  //草稿</span><br><span class="line">|   └── _posts   //博文</span><br><span class="line">└── themes  //主题文件夹。Hexo 会根据主题来生成静态页面。</span><br></pre></td></tr></table></figure><p>4.初始化完成以后 package.json 新增了几个指令，包括</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build&quot;: &quot;hexo generate&quot;,</span><br><span class="line">    &quot;clean&quot;: &quot;hexo clean&quot;,</span><br><span class="line">    &quot;deploy&quot;: &quot;hexo deploy&quot;,</span><br><span class="line">    &quot;server&quot;: &quot;hexo server&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>新增的 hexo 指令的意义是：</p><blockquote><p>hexo clean —— 清空已有 hexo 网站文件<br>hexo generate(or g) —— 依据网页文本与新的 CSS 样式生成新网站文件<br>hexo server(or s) —— 启动本地服务器，可以在 localhost:4000 查看网站修改效果<br>按上述顺序执行就可以在 localhost:4000 看到默认版式下的页面了。一般默认的是一个 landscape 主题。</p></blockquote><p>到此为止一个简单的博客就在本地建好了。我们可以通过调整 themes 文件夹的主题、修改_config.yml 文件来使自己的博客更加个性化。</p><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>hexo 有自己的<a href="https://hexo.io/themes/">主题网站</a>，可以选择自己感兴趣的主题点击进入其 github 主页进行下载，解压后添加到 themes 文件夹下。</p><p>虽然 hexo 的主题丰富，很容易找到合意的个性主题。但是第一次使用时最好找一个比较常用的模版，这样说明文档比较丰富、遇到问题网上搜索时也很容易找到答案 😭</p><p>个人比较推荐并以后打算尝试的模版包括<a href="https://github.com/theme-next/hexo-theme-next">Next</a> (大家都喜欢应该是有理由的吧)、<a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a> (文档看着真齐全)。</p><p>当前使用的主题是<a href="https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak">tranquilpeak</a>，看着比较美观。后续以该主题为例讲解配置修改。</p><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p>1）GitHub 网站上以 zip 方式下载<br>2）将解压后的文件夹命名为 tranquilpeak 添加到博客的 themes 文件夹下<br>3）打开博客仓库的终端进入到 tranquilpeak 文件夹位置执行<code>npm install &amp;&amp; npm run prod</code><br>4）调整博客仓库主文件夹下的<code>theme: tranquilpeak</code><br>5）使用指令 hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 即可看到新样式</p><h3 id="tranquilpeak-相关配置"><a href="#tranquilpeak-相关配置" class="headerlink" title="tranquilpeak 相关配置"></a>tranquilpeak 相关配置</h3><p>tranquilpeak 主题文件夹下也有_config.yml 配置文件，在我下载的当前版本 4.1.3 里，作者把配置分为了“Sidebar Configuration”、“Header configuration”、“Author“、“Customization”、“Comment systems”、“Integrated services”和“Sharing options”。<br><strong>Sidebar Configuration</strong>：提供了侧边栏的菜单配置，可以根据自己的需求增减项目、调整链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sidebar:                   </span><br><span class="line">         menu:                 </span><br><span class="line">             home:             </span><br><span class="line">                title: Home    # 链接标题</span><br><span class="line">                url: /         # 链接URL</span><br><span class="line">                icon: home     # Font Awesome 图标名,https://fontawesome.com/icons?d=gallery&amp;m=free 上可以找到合适的图标</span><br></pre></td></tr></table></figure><p><strong>Header configuration</strong>：用于编辑头部右上角链接<br><strong>Author</strong>：编辑作者信息，包括以下几个部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">author:</span><br><span class="line">    email: </span><br><span class="line">    location: </span><br><span class="line">    picture: </span><br><span class="line">    twitter:</span><br><span class="line">    google_plus:</span><br><span class="line">    google_plus_business:</span><br></pre></td></tr></table></figure><p>其中location和picture的填写内容会显示在关于（作者）的页面上。而作者的其他信息例如座右铭、工作等则是在博客总文件夹下的语言选项选定以后，在<code>tranquilpeak\languages\</code>下寻找对应语言的模版，修改作者相关的信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">author:</span><br><span class="line">    # 你的个人简介 (支持 Markdown 和 HTML 语法)</span><br><span class="line">    bio: &quot;&quot;</span><br><span class="line">    # 你的工作简介</span><br><span class="line">    job: &quot;&quot;</span><br></pre></td></tr></table></figure><p><strong>Customization</strong>：有关于侧边栏的展示方法（sidebar_behavior）、文章列表缩略图位置（thumbnail_image_position）、封面图（cover_image）等配置。</p><p>“Comment systems”、“Integrated services”和“Sharing options”等配置暂时没有用到，以后再研究。</p><h2 id="书写博文"><a href="#书写博文" class="headerlink" title="书写博文"></a>书写博文</h2><p>1）可在终端执行如下指令完成页面新建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>layout变量可以有三种选择：post、page 和 draft。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 post 相同，都将储存到 source&#x2F;_posts 文件夹。</p><table><thead><tr><th align="center">layout选项</th><th align="center">生成文件路径</th></tr></thead><tbody><tr><td align="center">post</td><td align="center">source&#x2F;_posts</td></tr><tr><td align="center">page</td><td align="center">source</td></tr><tr><td align="center">draft</td><td align="center">source&#x2F;_drafts</td></tr></tbody></table><p>title是文章的名称，执行完指令后会在layout对应的路径下生成<code>&lt;title&gt;.md</code>文件。如果工程文件夹下的_config.yml 文件里<code>post_asset_folder</code>这一选项置为true的话则还会生成一个title的文件夹，可以存放引用资源。</p><p>2）调整文章内容<br>生成的文件头部通常会包含以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: </span><br><span class="line">date: </span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>如果是草稿则没有自动生成的date变量，执行语句<code>hexo publish draft  &lt;title&gt;</code>、移动到source&#x2F;_posts 文件夹时应该会出现。<br>根据自己的需要，可以在文件头部增加内容。以tranquilpeak为例，该样式支持categories、thumbnailImage、excerpt等配置。配置categories可以在分类页面看到自己这篇文章的归类情况；配置thumbnailImage时会在文章列表增加缩略图，但本地是看不到效果的，只有打包上传到gitee后才可以；配置excerpt时首页文章列表不会展示全文而只会展示摘要。<br>tranquilpeak模版还支持两个标签语法：<code>&lt;!-- more --&gt;</code>和<code>&lt;!-- toc --&gt;</code>。前者是将标志之前的内容将会自动生成首页的概览，后者则是自动生成文章目录。<br>具体的内容书写可以参考markdown语法。</p><h2 id="推送到gitee"><a href="#推送到gitee" class="headerlink" title="推送到gitee"></a>推送到gitee</h2><p>1）首先需要安装推送工具hexo-deployer-git。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>2）在博客工程文件夹下的_config.yml找到URL和deploy的配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><br><span class="line">url: https://unknown-four-hundred-and-four.gitee.io/unknown_404</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://gitee.com/unknown-four-hundred-and-four/unknown_404.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>这里URL需要改成静态资源最后部署的域名，按照配置文件的说明，应该是<code>https://&#123;username&#125;.github.io/&#123;project&#125;</code>的格式，username是GitHub用户名，在GitHub上仓库名和用户名是相同，但在gitee上可以不一样，所以要注意实际上需要填入的是仓库名。project对应当前博客的工程名。<br>deploy选项里repository对应博客仓库的git地址，branch可根据需要修改，部署到page时注意一致性即可。<br>3）文件生成成功后执行<code>hexo deploy</code>指令，将文件推到远程仓库的master分支上。</p><div class="figure center" style="width:;"><img class="fig-img" src="gitee-master.png" alt=""></div><div style="clear:both;"></div><h2 id="gitee-page服务启动"><a href="#gitee-page服务启动" class="headerlink" title="gitee page服务启动"></a>gitee page服务启动</h2><p>1）在gitee仓库首页选择“服务-Gitee Page”</p><div class="figure center" style="width:;"><img class="fig-img" src="gitee-page.png" alt=""></div><div style="clear:both;"></div><p>2）如果没有实名认证的话开启Page服务需要验证，还需要绑定手机号。<br>3）进入到Gitee Pages 服务页面，选择部署分支，注意和工程文件夹下的_config.yml的deploy配置一致，如果选择了强制使用https，则工程文件夹下_config.yml的url配置也必须是https。</p><div class="figure center" style="width:;"><img class="fig-img" src="gitee-start.png" alt=""></div><div style="clear:both;"></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>（1）<a href="https://cungudafa.blog.csdn.net/article/details/104260494?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~LandingCtr~Rate-1.queryctrv4&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~LandingCtr~Rate-1.queryctrv4&utm_relevant_index=1">基于Gitee+Hexo搭建个人博客</a><br>（2）<a href="https://hexo.io/zh-cn/docs/writing">Hexo中文文档</a><br>（3）<a href="https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak/blob/master/DOCUMENTATION.md">tranquilpeak配置</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录自己使用hexo搭建个人博客并部署到gitee的流程。&lt;/p&gt;</summary>
    
    
    
    <category term="技术学习" scheme="https://unknown-four-hundred-and-four.gitee.io/unknown_404/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Hexo" scheme="https://unknown-four-hundred-and-four.gitee.io/unknown_404/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>markdown笔记</title>
    <link href="https://unknown-four-hundred-and-four.gitee.io/unknown_404/2022/03/13/markdown%E7%AC%94%E8%AE%B0/"/>
    <id>https://unknown-four-hundred-and-four.gitee.io/unknown_404/2022/03/13/markdown%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-13T08:28:58.000Z</published>
    <updated>2022-03-18T06:15:17.365Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。<br>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。<br>Markdown 编写的文档后缀为 .md, .markdown。</p></blockquote><h2 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h2><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h3><p>使用 # 号可表示 1-6 级标题，一级标题对应一个 <code>#</code>号，二级标题对应两个 <code>#</code> 号，以此类推。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure><p>效果：</p><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><h3 id="2-文字"><a href="#2-文字" class="headerlink" title="2.文字"></a>2.文字</h3><p>Markdown支持文字加粗、斜体、下划线、删除线等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*斜体文本*</span><br><span class="line">_斜体文本_</span><br><span class="line">**粗体文本**</span><br><span class="line">__粗体文本__</span><br><span class="line">***粗斜体文本***</span><br><span class="line">___粗斜体文本___</span><br><span class="line">&lt;u&gt;带下划线文本&lt;/u&gt;  </span><br><span class="line">~~删除线文本~~</span><br><span class="line">创建脚注格式类似这样 [^RUNOOB]。</span><br><span class="line"></span><br><span class="line">[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！</span><br></pre></td></tr></table></figure><p>效果：<br><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><em><strong>粗斜体文本</strong></em><br><em><strong>粗斜体文本</strong></em><br><u>带下划线文本</u><br><del>删除线文本</del><br>创建脚注格式类似这样 [^RUNOOB]。</p><p>[^RUNOOB]: 菜鸟教程 – 学的不仅是技术，更是梦想！！！</p><h3 id="3-段落"><a href="#3-段落" class="headerlink" title="3.段落"></a>3.段落</h3><p><strong>分割线</strong>：三个或者三个以上的 - 或者 * 都可以。显示效果是一样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><h2 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h2><hr><hr><hr><p><strong>换行</strong>：使用两个以上空格加上回车，或者在段落后面使用一个空行来表示重新开始一个段落。</p><h3 id="4-链接与图片"><a href="#4-链接与图片" class="headerlink" title="4.链接与图片"></a>4.链接与图片</h3><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）[超链接名](超链接地址 &quot;超链接title（optional）&quot;)</span><br><span class="line">2）&lt;https://www.runoob.com&gt;直接使用链接地址</span><br><span class="line">3）&lt;a href=&quot;https://www.runoob.com&quot; target=&quot;_blank&quot;&gt;菜鸟教程&lt;/a&gt;支持在新页面打开</span><br></pre></td></tr></table></figure><p>效果：<br><a href="https://www.runoob.com/">菜鸟教程</a><br><a href="https://www.runoob.com/">https://www.runoob.com</a><br><a href="https://www.runoob.com" target="_blank">菜鸟教程</a>  </p><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式：![alt 属性文本](图片地址 &quot;可选标题&quot;)</span><br><span class="line"></span><br><span class="line">![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png &quot;RUNOOB&quot;)</span><br></pre></td></tr></table></figure><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标" title="RUNOOB"></p><h3 id="5-区块与代码"><a href="#5-区块与代码" class="headerlink" title="5.区块与代码"></a>5.区块与代码</h3><h4 id="区块："><a href="#区块：" class="headerlink" title="区块："></a>区块：</h4><p>区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号<br><em>区块嵌套</em> ：一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><p>单行代码：代码之间分别用一个反引号包起来<br>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p><h3 id="6-列表"><a href="#6-列表" class="headerlink" title="6.列表"></a>6.列表</h3><h4 id="无序列表："><a href="#无序列表：" class="headerlink" title="无序列表："></a>无序列表：</h4><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure><p>效果：  </p><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ul><li>列表内容  <h4 id="有序列表："><a href="#有序列表：" class="headerlink" title="有序列表："></a>有序列表：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure>效果：</li></ul><ol><li>列表内容  </li><li>列表内容  </li><li>列表内容</li></ol><p><em>列表嵌套</em>：上一级和下一级之间敲三个空格即可</p><h3 id="7-表格"><a href="#7-表格" class="headerlink" title="7.表格"></a>7.表格</h3><p><code>|</code>来分隔不同的单元格，使用 <code>-</code>来分隔表头和其他行。</p><h4 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h4><p>我们可以设置表格的对齐方式：</p><ul><li>-: 设置内容和标题栏居右对齐。</li><li>:- 设置内容和标题栏居左对齐。</li><li>:-: 设置内容和标题栏居中对齐。<br>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table></li></ul><h2 id="Markdown效果预览"><a href="#Markdown效果预览" class="headerlink" title="Markdown效果预览"></a>Markdown效果预览</h2><p>VsCode：快捷键command+shift+v</p><h2 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h2><ol><li><a href="https://www.runoob.com/markdown/md-table.html">菜鸟教程</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录下markdown格式常用的几种语法，方便以后自己书写时使用。&lt;i&gt;备注：部分markdown语法似乎没有在该模版很好的展示&lt;/i&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="技术学习" scheme="https://unknown-four-hundred-and-four.gitee.io/unknown_404/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Markdown" scheme="https://unknown-four-hundred-and-four.gitee.io/unknown_404/tags/Markdown/"/>
    
  </entry>
  
</feed>
