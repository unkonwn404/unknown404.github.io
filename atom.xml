<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小白的文件整理箱</title>
  
  
  <link href="https://unknown404.github.io/unkown404.github.io/atom.xml" rel="self"/>
  
  <link href="https://unknown404.github.io/unkown404.github.io/"/>
  <updated>2023-02-27T14:57:28.959Z</updated>
  <id>https://unknown404.github.io/unkown404.github.io/</id>
  
  <author>
    <name>小白的文件整理箱</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信小程序基础知识</title>
    <link href="https://unknown404.github.io/unkown404.github.io/2023/02/27/applet/"/>
    <id>https://unknown404.github.io/unkown404.github.io/2023/02/27/applet/</id>
    <published>2023-02-27T13:42:19.000Z</published>
    <updated>2023-02-27T14:57:28.959Z</updated>
    
    <content type="html"><![CDATA[<p>小程序基础知识汇总。</p><span id="more"></span><h2 id="微信小程序结构"><a href="#微信小程序结构" class="headerlink" title="微信小程序结构"></a>微信小程序结构</h2><p>小程序的运行环境分成渲染层和逻辑层，其中 WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。视图层和逻辑层通过 Native 层进行进行通信，并且通过 Native 层获得原生能力。<br>逻辑层和视图层之间的工作方式为：数据变更通过 setData 驱动视图更新；视图层交互触发事件，然后触发逻辑层的事件响应函数，函数中修改数据再次触发视图更新。</p><h2 id="小程序框架"><a href="#小程序框架" class="headerlink" title="小程序框架"></a>小程序框架</h2><p>常见框架：mpvue、taro、uni-app<br>实现流程：</p><ul><li>编译阶段：将其他 DSL（domain-specific language） 转换为符合小程序语法的 WXML、WXSS、JS、JSON；</li><li>运行阶段：数据、事件、生命周期等部分的处理和对接；</li></ul><h3 id="mpvue"><a href="#mpvue" class="headerlink" title="mpvue"></a>mpvue</h3><p>特点：将 Vue 实例和小程序页面实例简单粗暴地做了关联，以达到使用 Vue 开发小程序的目的。</p><h3 id="taro"><a href="#taro" class="headerlink" title="taro"></a>taro</h3><p>特点：</p><ul><li>无 DSL 限制：无论是你们团队是 React 还是 Vue 技术栈，都能够使用 Taro 开发。</li><li>新特性无缝支持：由于 Taro Next 本质上是将 React&#x2F;Vue 运行在小程序上，因此，各种新特性也就无缝支持了。</li></ul><h3 id="uni-app"><a href="#uni-app" class="headerlink" title="uni-app"></a>uni-app</h3><p>特点：</p><ul><li>支持组件局部更新：mpvue 时小程序不支持自定义组件，所以组件编进 Page，更新也是 Page 级</li><li>setData 优化：将数据进行 diff，然后通过 setData 进行路径级别的更新</li></ul><h2 id="微信小程序生命周期"><a href="#微信小程序生命周期" class="headerlink" title="微信小程序生命周期"></a>微信小程序生命周期</h2><p>全局文件 app.js 中定义了一些声明周期的方法</p><p>onLaunch() 监听小程序初始化 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）<br>onShow() 监听小程序显示 当小程序启动，或从后台进入前台显示，会触发 onShow<br>onHide() 监听小程序隐藏 当小程序从前台进入后台，会触发 onHide</p><p>这是每个 page 页面的周期函数</p><p>onLoad() 页面加载时触发，全局只会调用一次，在该周期内可获取当前页面路径的参数<br>onShow() 页面显示时触发或者切入前台时触发，也就是在该周期内可以获取请求数据<br>onReady() 页面初次渲染完成时触发，只会调用一次，代表页面已经可以和视图层进行交互<br>onHide() 页面隐藏或者切入后台时触发，如底部 tab 切换到其他页面或小程序切入后台时触发。<br>onUnload() 页面卸载时触发</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;小程序基础知识汇总。&lt;/p&gt;</summary>
    
    
    
    <category term="前端基础" scheme="https://unknown404.github.io/unkown404.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="小程序" scheme="https://unknown404.github.io/unkown404.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>英语笔记</title>
    <link href="https://unknown404.github.io/unkown404.github.io/2023/02/26/EnglishNotes/"/>
    <id>https://unknown404.github.io/unkown404.github.io/2023/02/26/EnglishNotes/</id>
    <published>2023-02-26T09:53:37.000Z</published>
    <updated>2023-02-27T01:50:52.561Z</updated>
    
    <content type="html"><![CDATA[<p>虽然自己现在不需要考证了，不过遇到有意思的演讲、文章还是记录一下自己不熟的词汇之类的，以防水平退步。</p><span id="more"></span><p>adrift adj. 漂流的，随波逐流的；松动的；<br>The survivors were adrift in a lifeboat for six days. 幸存者在救生艇上漂流了六天。<br>young people adrift in the big city 在大城市漂泊的年轻人</p><p>conceivable adj. 可想象的；可信的（possible）<br>It is conceivable that I’ll see her tomorrow. 我可能明天会见到她。</p><p>objective<br>n. 目标；目的<br>meet&#x2F;achieve your objectives 达到 ╱ 实现你的目标<br>adj. 客观的；(objectively adv.)</p><p>gnaw v.咬；啃；啮<br>She gnawed at her fingernails. 她咬手指甲。<br>Self-doubt began to gnaw away at her confidence. 对自己的怀疑渐渐吞噬了她的自信心。</p><p>resilient adj. 可迅速恢复的；有适应力的</p><p>renowned adj.~ (as&#x2F;for sth)有名的；闻名的；受尊敬的<br>It is renowned as one of the region’s best restaurants. 这是本地区最好的饭店之一。<br>She is renowned for her patience. 她的耐心是出了名的。</p><p>flounder<br>v.不知所措;艰苦挣扎<br>She was floundering around in the deep end of the swimming pool. 她在游泳池深水区挣扎着。<br>At that time the industry was floundering. 那时这个行业举步维艰。</p><p>transcendent adj. 卓越的；超常的；出类拔萃的<br>…the idea of a transcendent God who stood apart from mankind. …超越于人类之上的上帝的观点。</p><p>redeem v.补救，掩饰……之不足；挽回（声誉）;偿清；遵守（诺言）<br>The only redeeming feature of the job (&#x3D; good thing about it) is the salary. 这份工作唯一的可取之处就是它的工资。<br>redeem a loan&#x2F;mortgage 清偿贷款╱按揭贷款<br>redeem a pledge&#x2F;promise 遵守诺言</p><p>redemption n.拯救；救赎<br>BEYOND&#x2F;PAST REDEMPTION(too bad to be saved or improved) 无法挽救；不可救药</p><p>smug adj.沾沾自喜的；自鸣得意的</p><p>gist n. ~ (of sth)要点；主旨；大意<br>get (&#x3D; understand) the gist of an argument 理解辩论的主旨</p><p>banal adj.  平庸的；</p><p>cliché n.   陈词滥调；<br>She trotted out the old cliché that ‘a trouble shared is a trouble halved.’ 她又重复了“与人说愁愁减半”的陈词滥调。</p><p>malfunction n. 运转失常；失灵；出现故障</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;虽然自己现在不需要考证了，不过遇到有意思的演讲、文章还是记录一下自己不熟的词汇之类的，以防水平退步。&lt;/p&gt;</summary>
    
    
    
    <category term="英语学习" scheme="https://unknown404.github.io/unkown404.github.io/categories/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="词汇" scheme="https://unknown404.github.io/unkown404.github.io/tags/%E8%AF%8D%E6%B1%87/"/>
    
  </entry>
  
  <entry>
    <title>node.js</title>
    <link href="https://unknown404.github.io/unkown404.github.io/2023/02/26/nodeJs/"/>
    <id>https://unknown404.github.io/unkown404.github.io/2023/02/26/nodeJs/</id>
    <published>2023-02-26T08:50:00.000Z</published>
    <updated>2023-02-27T01:50:52.561Z</updated>
    
    <content type="html"><![CDATA[<p>node 基础知识记录</p><span id="more"></span><h2 id="node-模块机制"><a href="#node-模块机制" class="headerlink" title="node 模块机制"></a>node 模块机制</h2><h3 id="require-的模块加载机制"><a href="#require-的模块加载机制" class="headerlink" title="require 的模块加载机制"></a>require 的模块加载机制</h3><ol><li>先计算模块路径</li><li>如果模块在缓存里面，取出缓存</li><li>加载模块</li><li>输出模块的 exports 属性即可</li></ol><h3 id="module-exports-vs-exports"><a href="#module-exports-vs-exports" class="headerlink" title="module.exports vs exports"></a>module.exports vs exports</h3><ul><li>exports 其实就是 module.exports，引用相同（module.exports 默认提供了空对象）</li><li>module.exports 可以直接赋值，exports 不可以，只能以增加健值的方式（模块加载时返回的是 module.exports 的内容）</li><li>如果要输出一个函数或数组，必须直接对 module.exports 对象赋值</li></ul><h3 id="npm-run-XXX-的流程"><a href="#npm-run-XXX-的流程" class="headerlink" title="npm run XXX 的流程"></a>npm run XXX 的流程</h3><ul><li>运行 npm run xxx 的时候，npm 会先在当前目录的 node_modules&#x2F;.bin 查找要执行的程序，如果找到则运行；</li><li>没有找到则从全局的 node_modules&#x2F;.bin 中查找，npm i -g xxx 就是安装到到全局目录；</li><li>如果全局目录还是没找到，那么就从 path 环境变量中查找有没有其他同名的可执行程序。</li></ul><h2 id="node-进程和线程"><a href="#node-进程和线程" class="headerlink" title="node 进程和线程"></a>node 进程和线程</h2><h3 id="进程和线程辨析"><a href="#进程和线程辨析" class="headerlink" title="进程和线程辨析"></a>进程和线程辨析</h3><p>进程：资源分配的最小单位，进程是线程的容器。<br>线程：操作系统能够进行运算调度的最小单位。线程是隶属于进程的，被包含于进程之中。一个线程只能隶属于一个进程，但是一个进程是可以拥有多个线程的。</p><h3 id="node-多进程架构"><a href="#node-多进程架构" class="headerlink" title="node 多进程架构"></a>node 多进程架构</h3><p>使用 child_process 开启多个进程实现多进程单线程模式，使 CPU 的利用率提升。子进程独立于父进程</p><h3 id="创建子进程方法"><a href="#创建子进程方法" class="headerlink" title="创建子进程方法"></a>创建子进程方法</h3><p>模块 child_process 具有以下方法：</p><ul><li>spawn()： 启动一个子进程来执行命令</li><li>exec(): 启动一个子进程来执行命令，与 spawn()不同的是其接口不同，它有一个回调函数获知子进程的状况</li><li>execFlie(): 启动一个子进程来执行可执行文件</li><li>fork(): 与 spawn()类似，不同在于它创建 Node 子进程需要执行 js 文件</li></ul><h2 id="express-vs-koa"><a href="#express-vs-koa" class="headerlink" title="express vs koa"></a>express vs koa</h2><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>Express 中间件实现是基于 Callback 回调函数同步的，它不会去等待异步（Promise）完成<br>Koa 的中间件机制中使用 Async&#x2F;Await（背后全是 Promise）以同步的方式来管理异步代码</p><h3 id="洋葱模型实现"><a href="#洋葱模型实现" class="headerlink" title="洋葱模型实现"></a>洋葱模型实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 中间件组合函数，可以参考 https://github.com/koajs/compose/blob/master/index.js</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> Array </span>&#125; middlewares </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span>(<span class="hljs-params">ctx, middlewares</span>) &#123;<br>  <span class="hljs-comment">// &#123;1&#125;</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(middlewares)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Middlewares stack must be an array!&#x27;</span>)<br>  <br>  <span class="hljs-comment">// &#123;2&#125;</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> fn <span class="hljs-keyword">of</span> middlewares) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Middleware must be composed of functions!&#x27;</span>)<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> len = middlewares.<span class="hljs-property">length</span>; <span class="hljs-comment">// &#123;3&#125; 获取数组长度</span><br>    <span class="hljs-keyword">const</span> dispatch = <span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) &#123; <span class="hljs-comment">// &#123;4&#125; 这里是我们实现的关键</span><br>      <span class="hljs-keyword">if</span> (len === i) &#123; <span class="hljs-comment">// &#123;5&#125; 中间件执行完毕</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">const</span> fn = middlewares[i]; <span class="hljs-comment">// &#123;6&#125;</span><br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// &#123;7&#125; 这里一定要 bind 下，不要立即执行</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">fn</span>(ctx, dispatch.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, (i + <span class="hljs-number">1</span>))));<br>        &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>          <span class="hljs-comment">// &#123;8&#125; 返回错误</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(err);<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> fn = <span class="hljs-title function_">compose</span>(ctx, middlewares);<br><br><span class="hljs-title function_">fn</span>();<br><br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>(1)<a href="https://juejin.cn/post/6844903951742025736">NodeJS 有难度的面试题，你能答对几个？</a><br>(2)<a href="https://juejin.cn/post/6844904071501971469">挑战一轮大厂后的面试总结 (含六个方向) - nodejs 篇</a><br>(3)<a href="https://juejin.cn/post/7078924628525056007">三面面试官：运行 npm run xxx 的时候发生了什么？</a><br>(4)<a href="https://juejin.cn/post/6844904099767386126">多维度分析 Express、Koa 之间的区别</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;node 基础知识记录&lt;/p&gt;</summary>
    
    
    
    <category term="前端基础" scheme="https://unknown404.github.io/unkown404.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="node.js" scheme="https://unknown404.github.io/unkown404.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>webpack</title>
    <link href="https://unknown404.github.io/unkown404.github.io/2023/02/19/webpack/"/>
    <id>https://unknown404.github.io/unkown404.github.io/2023/02/19/webpack/</id>
    <published>2023-02-19T06:44:52.000Z</published>
    <updated>2023-02-19T07:14:09.022Z</updated>
    
    <content type="html"><![CDATA[<p>前端 webpack 打包工具方面知识整理。</p><span id="more"></span><h2 id="webpack-基本概念"><a href="#webpack-基本概念" class="headerlink" title="webpack 基本概念"></a>webpack 基本概念</h2><h3 id="webpack-作用"><a href="#webpack-作用" class="headerlink" title="webpack 作用"></a>webpack 作用</h3><p>静态模块打包工具。主要作用：</p><ul><li>模块打包。可以将不同模块的文件打包整合在一起，并且保证它们之间的引用正确，执行有序。</li><li>编译兼容。通过 webpack 的 Loader 机制，编译转换诸如.less，.vue，.jsx 这类在浏览器无法识别的格式文件</li><li>能力扩展。通过 webpack 的 Plugin 机制，我可以进一步实现诸如按需加载，代码压缩等一系列功能</li></ul><h3 id="webpack-构建流程"><a href="#webpack-构建流程" class="headerlink" title="webpack 构建流程"></a>webpack 构建流程</h3><p>初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler<br>编译：从 entry 出发，针对每个 Module 串行调用对应的 loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理<br>输出：将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中</p><h3 id="loader-和-plugin-区别"><a href="#loader-和-plugin-区别" class="headerlink" title="loader 和 plugin 区别"></a>loader 和 plugin 区别</h3><ul><li>功能方面：loader 是文件加载器，能够加载资源文件，并对这些文件进行一些处理；plugin 可以扩展 Webpack 的功能，监听在 Webpack 运行的生命周期中会广播出的许多事件并做处理，解决 loader 无法实现的其他事。</li><li>运行时机方面：loader 运行在打包文件之前；plugin 则是在整个编译周期都起作用。</li><li>配置书写方面：loader 在 module.rules 中配置，作为模块的解析规则，类型为数组，内部包含了 test(类型文件)、loader、options (参数)等属性需要配置。plugin 在 plugins 中单独配置，类型为数组，每一项是一个 plugin 的实例，参数都通过构造函数传入。</li></ul><h3 id="webpack-热更新原理"><a href="#webpack-热更新原理" class="headerlink" title="webpack 热更新原理"></a>webpack 热更新原理</h3><p>webpack-dev-server 与浏览器之间维护了一个 websocket，当本地资源发生变化时，webpack-dev-server 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 webpack-dev-server 发起 Ajax 请求来获取更改内容。后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由 HotModulePlugin 来完成</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/7196630860811075642">2023 前端面试系列– webpack &amp; Git 篇</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前端 webpack 打包工具方面知识整理。&lt;/p&gt;</summary>
    
    
    
    <category term="前端基础" scheme="https://unknown404.github.io/unkown404.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="webpack" scheme="https://unknown404.github.io/unkown404.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>vscode调试Node代码</title>
    <link href="https://unknown404.github.io/unkown404.github.io/2023/02/17/vscodeRunNode/"/>
    <id>https://unknown404.github.io/unkown404.github.io/2023/02/17/vscodeRunNode/</id>
    <published>2023-02-17T01:46:55.000Z</published>
    <updated>2023-02-19T05:12:04.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现操作"><a href="#实现操作" class="headerlink" title="实现操作"></a>实现操作</h2><ol><li>点击vscode左侧边栏的三角形状加🐛的符号，如果直接调试当前文件可以先打好断点、点击按钮Run and Debug；如果需要自定义然后点击create a launch.json file</li><li>编辑launch.json<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123;<br>    <span class="hljs-regexp">//</span> 使用 IntelliSense 了解相关属性。 <br>    <span class="hljs-regexp">//</span> 悬停以查看现有属性的描述。<br>    <span class="hljs-regexp">//</span> 欲了解更多信息，请访问: https:<span class="hljs-regexp">//g</span>o.microsoft.com<span class="hljs-regexp">/fwlink/</span>?linkid=<span class="hljs-number">830387</span><br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.2.0&quot;</span>,<br>    <span class="hljs-string">&quot;configurations&quot;</span>: [<br>        &#123;<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;node&quot;</span>,<br>            <span class="hljs-string">&quot;request&quot;</span>: <span class="hljs-string">&quot;launch&quot;</span>,<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;启动程序&quot;</span>,<br>            <span class="hljs-string">&quot;skipFiles&quot;</span>: [<br>                <span class="hljs-string">&quot;&lt;node_internals&gt;/**&quot;</span><br>            ],<br>            <span class="hljs-string">&quot;program&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ul><li>执行单一文件时：修改program的内容，改为要运行的可执行文件或源代码的路径</li><li>调试服务器时：将配置文件修改为如下内容：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;attach&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Attach NestJS WS&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9229</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;restart&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;stopOnEntry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;protocol&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;inspector&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure>request由launch改为了attach，目的是为了将Visual Studio Code的调试器绑定到一个已经处于运行状态的应用。这个配置文件的含义是告诉Visual Studio Code的调试进程，去连接127.0.0.1:9229上的应用调试进程去调试。</li></ul><ol start="3"><li>配置完后点击调试栏的运行，如果是调试服务器接口需要先执行debug指令运行起服务器，以eggjs为例是<code>egg-bin debug</code>；以nest为例是<code>nest start --debug --watch</code>。此时会启动127.0.0.1:9229的调试进程，如果事先打好断点，在postman上调试本地接口时会在对应接口的逻辑断点前停止运行。<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2>（1）<a href="https://juejin.cn/post/6981820158046109703">让你 nodejs 水平暴增的 debugger 技巧</a><br>（2）<a href="https://juejin.cn/post/6844903838864900110">如何用Visual Studio Code远程调试运行在服务器上的nodejs应用</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实现操作&quot;&gt;&lt;a href=&quot;#实现操作&quot; class=&quot;headerlink&quot; title=&quot;实现操作&quot;&gt;&lt;/a&gt;实现操作&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;点击vscode左侧边栏的三角形状加🐛的符号，如果直接调试当前文件可以先打好断点、点击按钮Run and De</summary>
      
    
    
    
    <category term="工作技巧" scheme="https://unknown404.github.io/unkown404.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="node.js" scheme="https://unknown404.github.io/unkown404.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>面试技巧</title>
    <link href="https://unknown404.github.io/unkown404.github.io/2023/02/15/interviewSkill/"/>
    <id>https://unknown404.github.io/unkown404.github.io/2023/02/15/interviewSkill/</id>
    <published>2023-02-15T14:15:30.000Z</published>
    <updated>2023-02-19T03:40:53.749Z</updated>
    
    <content type="html"><![CDATA[<ol><li>项目中你遇到的难解决的问题有哪些，最后怎么处理的这种问题<br>难解决的问题分为两种：1.业务问题，需求不清。这时需要拉上懂业务的同事理清需求，必要的时候需要调整设计。同时自主学习，增强对业务的了解。2.技术问题，可能是由于之前技术栈限制导致需求难以实现，或者说现有技术导致实现需求会有性能、可维护性问题，或者是自身储备或者周边资源不足(比如说没有现成的组件库)导致工期比预想长。可以通过最小限度实现需求、请教公司或同项目组的同事寻找合适的工具、交叉集成其他框架等方式解决，但最重要的是及早沟通。</li></ol>]]></content>
    
    
    <summary type="html">面试中常见问题记录</summary>
    
    
    
    <category term="工作技巧" scheme="https://unknown404.github.io/unkown404.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="面试" scheme="https://unknown404.github.io/unkown404.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端使用shell指令</title>
    <link href="https://unknown404.github.io/unkown404.github.io/2023/01/16/shelljs/"/>
    <id>https://unknown404.github.io/unkown404.github.io/2023/01/16/shelljs/</id>
    <published>2023-01-16T02:10:25.000Z</published>
    <updated>2023-02-02T10:21:28.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="node-js-使用-shell-指令"><a href="#node-js-使用-shell-指令" class="headerlink" title="node.js 使用 shell 指令"></a>node.js 使用 shell 指令</h2><h3 id="child-process"><a href="#child-process" class="headerlink" title="child_process"></a>child_process</h3><p>node 提供的一个子进程 API</p><h4 id="常见指令"><a href="#常见指令" class="headerlink" title="常见指令"></a>常见指令</h4><h5 id="child-process-spawn-command-args-options"><a href="#child-process-spawn-command-args-options" class="headerlink" title="child_process.spawn(command[, args][, options])"></a>child_process.spawn(command[, args][, options])</h5><p>创建一个新进程来执行指令。指令执行的参数为该函数传入的第二个参数。child_process.spawn 返回 stdout 和 stderr 流对象。 程序可以通过 stdout 的 data、end 或者其他事件来获取子进程返回的数据。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> &#123; spawn &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>);<br><span class="hljs-keyword">const</span> ls = <span class="hljs-title function_">spawn</span>(<span class="hljs-string">&#x27;ls&#x27;</span>, [<span class="hljs-string">&#x27;-lh&#x27;</span>, <span class="hljs-string">&#x27;/usr&#x27;</span>]);<br><br>ls.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`stdout: <span class="hljs-subst">$&#123;data&#125;</span>`</span>);<br>&#125;);<br><br>ls.<span class="hljs-property">stderr</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`stderr: <span class="hljs-subst">$&#123;data&#125;</span>`</span>);<br>&#125;);<br><br>ls.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">code</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`child process exited with code <span class="hljs-subst">$&#123;code&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="child-process-exec-command-options-callback"><a href="#child-process-exec-command-options-callback" class="headerlink" title="child_process.exec(command[, options][, callback])"></a>child_process.exec(command[, options][, callback])</h5><p>创建一个 shell 执行指令。存在数据大小限制。 当子进程返回的数据超过默认大小时，程序就会产生”Error: maxBuffer exceeded”异常。</p><h5 id="child-process-execFile-file-args-options-callback"><a href="#child-process-execFile-file-args-options-callback" class="headerlink" title="child_process.execFile(file[, args][, options][, callback])"></a>child_process.execFile(file[, args][, options][, callback])</h5><p>同 exec 类似，但使用的是制定的文件创建进程执行。需要单独写.sh 文件，可编写复杂逻辑，但在 windows 上使用时会有兼容问题</p><h3 id="shelljs"><a href="#shelljs" class="headerlink" title="shelljs"></a>shelljs</h3><p>基于 nodeAPI 的一个扩展，要引入插件。相比原生的 child_process 的兼容性更好，使用更灵活。<br><strong>安装指令</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span>--save-dev <span class="hljs-keyword">shelljs</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">or</span><br><span class="hljs-keyword"></span>yarn <span class="hljs-keyword">add </span><span class="hljs-keyword">shelljs </span>-D<br></code></pre></td></tr></table></figure><p><strong>使用方法</strong></p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-comment">// 局部模式</span><br><span class="hljs-variable">var</span> <span class="hljs-variable">shell</span> = <span class="hljs-function"><span class="hljs-title">require</span>(<span class="hljs-string">&#x27;shelljs&#x27;</span>);</span><br><span class="hljs-function"><span class="hljs-variable">shell.exec</span>(<span class="hljs-string">&#x27;git add .&#x27;</span>);</span><br><span class="hljs-function"><span class="hljs-variable">shell.exec</span>(<span class="hljs-string">&quot;git commit -m &#x27;auto-commit&#x27;&quot;</span>)</span><br><span class="hljs-variable">shell.exec</span>(<span class="hljs-string">&#x27;git push&#x27;</span>)<br><br><span class="hljs-comment">// 全局模式下，就不需要用shell开头了。</span><br><span class="hljs-function"><span class="hljs-title">require</span>(<span class="hljs-string">&#x27;shelljs/global&#x27;</span>);</span><br><span class="hljs-function"><span class="hljs-title">exec</span>(<span class="hljs-string">&#x27;git add .&#x27;</span>);</span><br><span class="hljs-function"><span class="hljs-title">exec</span>(<span class="hljs-string">&quot;git commit -m &#x27;auto-commit&#x27;&quot;</span>)</span><br><span class="hljs-function"><span class="hljs-title">exec</span>(<span class="hljs-string">&#x27;git push&#x27;</span>)</span><br></code></pre></td></tr></table></figure><h2 id="shell-常用指令"><a href="#shell-常用指令" class="headerlink" title="shell 常用指令"></a>shell 常用指令</h2><h3 id="pwd-显示当前目录名称"><a href="#pwd-显示当前目录名称" class="headerlink" title="pwd - 显示当前目录名称"></a>pwd - 显示当前目录名称</h3><h3 id="ls-显示目录信息"><a href="#ls-显示目录信息" class="headerlink" title="ls - 显示目录信息"></a>ls - 显示目录信息</h3><p><strong>使用参数</strong></p><p>-a :显示包括隐藏文件和目录在内的所有目录和文件</p><p>-l :显示文件的详细信息</p><p>-h :配合-l 以人性化的方式显示文件大小</p><p>-t :按文件最后修改时间排序文件</p><h3 id="cd-目录切换"><a href="#cd-目录切换" class="headerlink" title="cd - 目录切换"></a>cd - 目录切换</h3><p><strong>使用示例</strong></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span> 返回根目录<br><span class="hljs-keyword">cd</span><br><span class="hljs-string">//</span> 返回上一级目录<br><span class="hljs-keyword">cd</span> <span class="hljs-string">..</span><br><span class="hljs-string">//</span> 前往当前文件夹下的某目录<br><span class="hljs-keyword">cd</span> &lt;directory&gt;<br></code></pre></td></tr></table></figure><h3 id="rm-删除文件"><a href="#rm-删除文件" class="headerlink" title="rm - 删除文件"></a>rm - 删除文件</h3><p><strong>使用参数</strong></p><p>-f :强制删除文件</p><p>-r :递归删除目录及内容</p><h3 id="cp-复制文件"><a href="#cp-复制文件" class="headerlink" title="cp - 复制文件"></a>cp - 复制文件</h3><p><strong>指令格式</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cp</span> [<span class="hljs-keyword">options</span>] <span class="hljs-symbol">&lt;source&gt;</span> <span class="hljs-symbol">&lt;dest&gt;</span><br></code></pre></td></tr></table></figure><p><strong>使用参数</strong><br>-a :复制时保留链接、文件属性</p><p>-f :覆盖已经存在的目标文件而不给出提示</p><p>-r :若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件</p><h3 id="echo-显示指定文本"><a href="#echo-显示指定文本" class="headerlink" title="echo - 显示指定文本"></a>echo - 显示指定文本</h3><p><strong>使用示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 显示普通字符串</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello world&quot;</span><br><br><span class="hljs-comment"># 显示转义字符</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\&quot;hello world\&quot;&quot;</span> <span class="hljs-comment"># 此时结果显示为&quot;hello world&quot;</span><br><br><span class="hljs-comment"># 显示变量</span><br>content=<span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;He said <span class="hljs-variable">$&#123;content&#125;</span>&quot;</span><br><br><span class="hljs-comment"># 显示换行</span><br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;hello \n&quot;</span> <span class="hljs-comment"># -e开启转义，即\n可以换行</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;world&quot;</span><br><br><span class="hljs-comment"># 显示结果定向至文件</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello world &gt; test&quot;</span><br></code></pre></td></tr></table></figure><h3 id="chmod-控制用户对文件的权限"><a href="#chmod-控制用户对文件的权限" class="headerlink" title="chmod - 控制用户对文件的权限"></a>chmod - 控制用户对文件的权限</h3><p><strong>指令格式</strong></p><ol><li>参数法</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">chmod <span class="hljs-selector-attr">[user]</span><span class="hljs-selector-attr">[operator]</span><span class="hljs-selector-attr">[permission]</span> &lt;filename&gt;<br></code></pre></td></tr></table></figure><p><strong>使用参数</strong><br><strong>user</strong>：限定权限调整的用户范围</p><ul><li>u：user 表示该文件的所有者</li><li>g：group 表示与该文件的所有者属于同一组( group )者，即用户组</li><li>o：other 表示其它用户组</li><li>a：all 表示这三者皆是</li></ul><p><strong>operator</strong>：权限调整内容</p><ul><li>+：增加权限</li><li>-：撤销权限</li><li>&#x3D;：设定权限</li></ul><p><strong>permission</strong>：权限内容</p><ul><li>r：read，表示可读取，对于一个目录，如果没有 r 权限，那么就意味着不能通过 ls 查看这个目录的内容。</li><li>w：write，表示可写入，对于一个目录，如果没有 w 权限，那么就意味着不能在目录下创建新的文件。</li><li>x：excute，表示可执行，对于一个目录，如果没有 x 权限，那么就意味着不能通过 cd 进入这个目录。</li></ul><ol start="2"><li>数字法</li></ol><p>chmod 命令可以使用八进制数来指定权限。文件或目录的权限位是由 9 个权限位来控制，每三位为一组，它们分别是文件所有者（User）的读、写、执行，用户组（Group）的读、写、执行以及其它用户（Other）的读、写、执行。一组权限位中已设置时置为 1，不设置时置为 0。<br>以权限 rwx 为例，其对应的二进制表示为 111，即 4+2+1，也就是 7.<br><strong>使用示例</strong></p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi"># 表示所有的用户都有读写执行文件<span class="hljs-keyword">file</span>的权利，等同于chmod a=wrx <span class="hljs-keyword">file</span><br>chmod <span class="hljs-number">777</span> <span class="hljs-keyword">file</span><br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://nodejs.org/dist/latest-v12.x/docs/api/child_process.html">Nodejs 文档</a><br>（2）<a href="https://juejin.cn/post/6921734567342637070">如何在 nodejs 执行 shell 指令</a><br>（3）<a href="https://juejin.cn/post/7161392772665540644">package.json 配置完全解读</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;node-js-使用-shell-指令&quot;&gt;&lt;a href=&quot;#node-js-使用-shell-指令&quot; class=&quot;headerlink&quot; title=&quot;node.js 使用 shell 指令&quot;&gt;&lt;/a&gt;node.js 使用 shell 指令&lt;/h2&gt;&lt;h3 i</summary>
      
    
    
    
    <category term="工作技巧" scheme="https://unknown404.github.io/unkown404.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="node.js" scheme="https://unknown404.github.io/unkown404.github.io/tags/node-js/"/>
    
    <category term="Shell" scheme="https://unknown404.github.io/unkown404.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>hash路由使用锚点解决方案</title>
    <link href="https://unknown404.github.io/unkown404.github.io/2022/12/16/hashAnchor/"/>
    <id>https://unknown404.github.io/unkown404.github.io/2022/12/16/hashAnchor/</id>
    <published>2022-12-16T02:57:34.000Z</published>
    <updated>2023-02-19T03:30:41.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>页面的锚点功能需要 url 的 hash 值与页面的 DOM id 相一致才能进行跳转；而路由在 hash 模式下已经将#占用, 页面的锚点功能失效</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="场景-1-原生锚点"><a href="#场景-1-原生锚点" class="headerlink" title="场景 1:原生锚点"></a>场景 1:原生锚点</h3><p>需要手动获取锚点元素，再使用scrollIntoView方法</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs JSX"><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">CustomLink</span>=(<span class="hljs-params">props:&#123;id:string, children:any&#125;</span>)=&gt; &#123;<br>  <span class="hljs-keyword">const</span> &#123;id,children&#125;=props<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClick</span> = (<span class="hljs-params">e:any</span>) =&gt; &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>();<br>    <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(id);<br>    <span class="hljs-comment">// scrollIntoView()将目标元素移动到浏览器顶部</span><br>    <span class="hljs-comment">// scrollIntoView(false)将目标元素移动到浏览器底部</span><br>    element?.<span class="hljs-title function_">scrollIntoView</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span>&#123;children&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> &gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;anchor&#x27;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">CustomLink</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;test1&#x27;</span>&gt;</span>test1<span class="hljs-tag">&lt;/<span class="hljs-name">CustomLink</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">CustomLink</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;test2&#x27;</span>&gt;</span>test2<span class="hljs-tag">&lt;/<span class="hljs-name">CustomLink</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">height:</span> &#x27;<span class="hljs-attr">600vh</span>&#x27;, <span class="hljs-attr">padding:</span> <span class="hljs-attr">8</span> &#125;&#125;&gt;</span>Scroll to bottom<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;test1&#x27;</span>&gt;</span>test1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Scroll to bottom<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">height:</span> &#x27;<span class="hljs-attr">600vh</span>&#x27;, <span class="hljs-attr">padding:</span> <span class="hljs-attr">8</span> &#125;&#125;&gt;</span>Scroll to bottom<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Scroll to bottom<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">height:</span> &#x27;<span class="hljs-attr">600vh</span>&#x27;, <span class="hljs-attr">padding:</span> <span class="hljs-attr">8</span> &#125;&#125; <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;test2&#x27;</span>&gt;</span>test2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Scroll to bottom<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="场景-2-antd-的-anchor-组件"><a href="#场景-2-antd-的-anchor-组件" class="headerlink" title="场景 2:antd 的 anchor 组件"></a>场景 2:antd 的 anchor 组件</h3><p>anchor 组件在点击锚点后会修改 URL，而单页应用中如果使用哈希模式的路由，当 URL 被修改后，刷新页面会导致当前路由没有定义而出现 404 的情况。<br>对于这一情况的解决方案就是利用组件的 onClick 事件阻止默认的 url 修改</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JSX"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Anchor</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;antd&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; useHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;umi&#x27;</span>;<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Link</span> &#125; = <span class="hljs-title class_">Anchor</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> history = <span class="hljs-title function_">useHistory</span>();<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Anchor</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;(event:</span> <span class="hljs-attr">Event</span>, <span class="hljs-attr">link:</span> &#123; <span class="hljs-attr">href:</span> <span class="hljs-attr">string</span>; <span class="hljs-attr">title</span>?<span class="hljs-attr">:</span> <span class="hljs-attr">string</span> &#125;) =&gt;</span> &#123;</span><br><span class="language-xml">        event.preventDefault();</span><br><span class="language-xml">        history.push(`$&#123;history.location.pathname&#125;$&#123;link.href&#125;`);</span><br><span class="language-xml">      &#125;&#125;</span><br><span class="language-xml">    &gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#何时使用&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;何时使用&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#代码演示&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;代码演示&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#api&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;API&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#anchor-props&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Anchor Props&quot;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#link-props&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Link Props&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#faq&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;FAQ&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Anchor</span>&gt;</span></span><br>  );<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>经过实际测试发现，调用 event.preventDefault()之后，只会阻止 URL 被修改，并不会阻止点击锚点后的滚动事件。所以不需要像原生场景一样使用 scrollView 函数。但为了url和锚点相对应，增加了history.push函数来实现。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://blog.csdn.net/weixin_43487782/article/details/108873639">antd的anchor组件点击锚点导致路由发生变化</a><br>（2）<a href="https://blog.csdn.net/Whoopsina/article/details/123804087">项目中使用了Hash路由时如何同时使用锚点？</a></p>]]></content>
    
    
    <summary type="html">路由在 hash 模式下已经将#占用, 页面的锚点功能失效</summary>
    
    
    
    <category term="踩坑经历" scheme="https://unknown404.github.io/unkown404.github.io/categories/%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="前端路由" scheme="https://unknown404.github.io/unkown404.github.io/tags/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>代码样式调整</title>
    <link href="https://unknown404.github.io/unkown404.github.io/2022/12/15/codeFormat/"/>
    <id>https://unknown404.github.io/unkown404.github.io/2022/12/15/codeFormat/</id>
    <published>2022-12-15T14:25:36.000Z</published>
    <updated>2023-02-19T03:19:04.422Z</updated>
    
    <content type="html"><![CDATA[<p>为了使代码风格统一，更有利于阅读，可以借助一些工具进行优化。</p><span id="more"></span><h2 id="prettier"><a href="#prettier" class="headerlink" title="prettier"></a>prettier</h2><p>代码格式化工具。</p><h3 id="安装指令"><a href="#安装指令" class="headerlink" title="安装指令"></a>安装指令</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span>--save-dev prettier<br><span class="hljs-keyword">or</span><br><span class="hljs-keyword"></span>yarn <span class="hljs-keyword">add </span>prettier -D<br></code></pre></td></tr></table></figure><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><p>在根目录新建 .prettierrc.json，配置自己所需要的参数：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123;<br>  <span class="hljs-string">&quot;singleQuote&quot;</span>: true,  <span class="hljs-regexp">//</span> 使用单引号<br>  <span class="hljs-string">&quot;semi&quot;</span>: false,  <span class="hljs-regexp">//</span> 不使用分号<br>  <span class="hljs-string">&quot;bracketSpacing&quot;</span>: true,  <span class="hljs-regexp">//</span> 在对象,数组括号与文字之间加空格<br>  <span class="hljs-string">&quot;htmlWhitespaceSensitivity&quot;</span>: <span class="hljs-string">&quot;ignore&quot;</span>,  <span class="hljs-regexp">//</span> 对html的空格不敏感<br>  <span class="hljs-string">&quot;endOfLine&quot;</span>: <span class="hljs-string">&quot;auto&quot;</span>,  <span class="hljs-regexp">//</span> 行结尾统一样式，保持现有的行尾<br>  <span class="hljs-string">&quot;trailingComma&quot;</span>: <span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-regexp">//</span> 对象，数组等末尾不加逗号<br>  <span class="hljs-string">&quot;tabWidth&quot;</span>: <span class="hljs-number">2</span> <span class="hljs-regexp">//</span>  水平缩进的空格数为<span class="hljs-number">2</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="lint-staged"><a href="#lint-staged" class="headerlink" title="lint-staged"></a>lint-staged</h2><p>本地暂存代码检查工具。只检测 git add . 中暂存区的文件，对过滤出的文件执行脚本。</p><h3 id="安装指令-1"><a href="#安装指令-1" class="headerlink" title="安装指令"></a>安装指令</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span>lint-staged --save-dev<br><span class="hljs-keyword">or</span><br><span class="hljs-keyword"></span>yarn <span class="hljs-keyword">add </span>lint-staged -D<br></code></pre></td></tr></table></figure><h3 id="配置方式-1"><a href="#配置方式-1" class="headerlink" title="配置方式"></a>配置方式</h3><p>lint-staged 从 v3.1 开始可以使用不同的方式进行配置：</p><ul><li>package.json<br>示例：</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;lint-staged&quot;</span>: &#123;<br>    <span class="hljs-regexp">//</span> 匹配暂存区所有的js，vue文件，并执行命令<br>  <span class="hljs-string">&quot;*.&#123;js,vue,jsx,tsx&#125;&quot;</span>: [<br>    <span class="hljs-string">&quot;prettier --write&quot;</span>,<br>    <span class="hljs-string">&quot;eslint --cache --fix&quot;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>配置对象的 key 值为匹配的文件，右侧 value 对应执行指令。lint-staged 指令自动在最后包含了 git add 的操作，所以可以不用专门去写</p><ul><li>.lintstagedrc JSON 或 YML 格式的文件</li><li>lint-staged.config.js 格式的文件</li></ul><h2 id="husky"><a href="#husky" class="headerlink" title="husky"></a>husky</h2><p>Git hooks 工具，对 git 执行的一些命令，通过对应的 hooks 钩子触发，执行自定义的脚本程序。<br>常用的 gitHooks 包括：</p><ul><li>pre-commit：每次 commit 之前会执行的操作，常用于触发时进行代码格式验证</li><li>commit-msg：启动提交信息编辑器，常用于对 commit 消息和用户进行校验</li><li>pre-push：远程推代码前执行，常用于推代码前做单元测试和 e2e</li></ul><h3 id="安装指令-2"><a href="#安装指令-2" class="headerlink" title="安装指令"></a>安装指令</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">npm</span> install husky@<span class="hljs-number">4</span>.<span class="hljs-number">3</span> --save-dev<br><span class="hljs-attribute">or</span><br><span class="hljs-attribute">yarn</span> add husky@<span class="hljs-number">4</span>.<span class="hljs-number">3</span> -D<br></code></pre></td></tr></table></figure><h3 id="配置方式-2"><a href="#配置方式-2" class="headerlink" title="配置方式"></a>配置方式</h3><p>husky 版本在 6 以下时可以直接在 package.json 配置，例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;husky&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;hooks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;pre-commit&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;lint-staged&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>6 版本以上的 husky 把的配置提取到了根目录，package.json 中的配置在 husky 升级后无效了。需要执行指令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">npx husky <span class="hljs-keyword">add</span><span class="language-bash"> .husky/pre-commit <span class="hljs-string">&quot;npx lint-staged&quot;</span></span><br></code></pre></td></tr></table></figure><p>指令执行后会在根目录创建 .husky 文件夹，文件夹内部有一个 pre-commit 文件，包含指令 npx lint-staged</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://www.npmjs.com/package/lint-staged#Configuration">lint-staged 官方文档</a><br>（2）<a href="https://www.prettier.cn/docs/index.html">prettier 官方文档</a><br>（3）<a href="https://juejin.cn/post/6947200436101185566">GitHook 工具 —— husky（格式化代码）</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;为了使代码风格统一，更有利于阅读，可以借助一些工具进行优化。&lt;/p&gt;</summary>
    
    
    
    <category term="工作技巧" scheme="https://unknown404.github.io/unkown404.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="代码规范" scheme="https://unknown404.github.io/unkown404.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>package.json分析</title>
    <link href="https://unknown404.github.io/unkown404.github.io/2022/12/15/packageJson/"/>
    <id>https://unknown404.github.io/unkown404.github.io/2022/12/15/packageJson/</id>
    <published>2022-12-15T02:41:29.000Z</published>
    <updated>2023-02-19T03:19:04.429Z</updated>
    
    <content type="html"><![CDATA[<p>虽然管理维护前端项目时经常需要跟该文件打交道，但在安装代码规范相关工具时，发现自己对其中的配置并不十分了解，所以想记录一下。</p><span id="more"></span><h2 id="文件配置"><a href="#文件配置" class="headerlink" title="文件配置"></a>文件配置</h2><p>描述配置在这里略过不计，除非自己要写包，不然感觉记忆没什么用</p><h3 id="workspaces"><a href="#workspaces" class="headerlink" title="workspaces"></a>workspaces</h3><p>workspaces 主要用于 monorepo 仓库管理模式、解决如何在一个顶层 root package 下管理多个子 packages 的问题，在 workspaces 声明目录下的 package 会软链到最上层 root package 的 node_modules 中，不用手动执行 npm link 操作。</p><p>通常子项目都会平铺管理在 packages 目录下，所以根目录下 workspaces 通常配置为：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-string">&quot;workspaces&quot;</span>: [<br>  <span class="hljs-string">&quot;packages/*&quot;</span><br>]<br></code></pre></td></tr></table></figure><h2 id="脚本配置"><a href="#脚本配置" class="headerlink" title="脚本配置"></a>脚本配置</h2><h3 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h3><p>指定项目的一些内置脚本命令，这些命令可以通过 npm run 来执行。npm run 的时候，就会自动创建一个 shell 脚本，将本地目录的 node_modules&#x2F;.bin 子目录加入 PATH 变量。这意味着，当前目录的 node_modules&#x2F;.bin 子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>  <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack&quot;</span>,<br>  <span class="hljs-string">&quot;prebuild&quot;</span>: <span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-regexp">//</span> build 执行之前的钩子<br>  <span class="hljs-string">&quot;postbuild&quot;</span>: <span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-regexp">//</span> build 执行之后的钩子<br>&#125;<br></code></pre></td></tr></table></figure><p>如果存在前缀指令<code>pre-*</code>、<code>post-*</code>的话，执行指令 npm run build 时会按照<code>prebuild - build - postbuild</code>执行顺序执行，这种语法现在并不推崇，需谨慎使用。</p><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>用于设置 scripts 里的脚本在运行时的参数。</p><h2 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h2><h3 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h3><p>运行依赖，也就是项目生产环境下需要用到的依赖。比如 react，vue，状态管理库以及组件库等。</p><p>使用 npm install xxx 或则 npm install xxx –save 时，会被自动插入到该字段中。</p><h3 id="devDependencies"><a href="#devDependencies" class="headerlink" title="devDependencies"></a>devDependencies</h3><p>开发依赖，项目开发环境需要用到而运行时不需要的依赖，用于辅助开发，通常包括项目工程化工具比如 webpack，vite，eslint 等。<br>使用 npm install xxx -D 或者 npm install xxx –save-dev 时，会被自动插入到该字段中。</p><h2 id="三方配置"><a href="#三方配置" class="headerlink" title="三方配置"></a>三方配置</h2><p>package.json 中也存在很多三方属性，比如 tsc 中使用的 types、构建工具中使用的 sideEffects,git 中使用的 husky，eslint 使用的 eslintIgnore。这里只列举部分属性。</p><h3 id="lint-staged"><a href="#lint-staged" class="headerlink" title="lint-staged"></a>lint-staged</h3><p>lint-staged 是一个在 Git 暂存文件上运行 linters 的工具，配置后每次修改一个文件即可给所有文件执行一次 lint 检查，通常配合 gitHooks 一起使用。</p><h3 id="browserslist"><a href="#browserslist" class="headerlink" title="browserslist"></a>browserslist</h3><p>browserslist 字段用来告知支持哪些浏览器及版本。也可以使用 .browserslistrc 单文件配置。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-string">&quot;browserslist&quot;</span>: [<br>  <span class="hljs-string">&quot;&gt; 1%&quot;</span>,<br>  <span class="hljs-string">&quot;last 2 versions&quot;</span><br>]<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/7099041402771734559">深入浅出 package.json</a><br>（2）<a href="https://juejin.cn/post/7023539063424548872">关于前端大管家 package.json，你知道多少？</a><br>（3）<a href="https://juejin.cn/post/7161392772665540644">package.json 配置完全解读</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;虽然管理维护前端项目时经常需要跟该文件打交道，但在安装代码规范相关工具时，发现自己对其中的配置并不十分了解，所以想记录一下。&lt;/p&gt;</summary>
    
    
    
    <category term="技术学习" scheme="https://unknown404.github.io/unkown404.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="前端依赖包管理" scheme="https://unknown404.github.io/unkown404.github.io/tags/%E5%89%8D%E7%AB%AF%E4%BE%9D%E8%B5%96%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>react中获取ref相关的函数总结</title>
    <link href="https://unknown404.github.io/unkown404.github.io/2022/12/09/reactRef/"/>
    <id>https://unknown404.github.io/unkown404.github.io/2022/12/09/reactRef/</id>
    <published>2022-12-09T06:15:58.000Z</published>
    <updated>2023-02-19T03:19:04.431Z</updated>
    
    <content type="html"><![CDATA[<p>虽然 react 中很少使用操作 DOM 的逻辑，但为了能够理解开源代码，还是整理记录了常用的几个相关函数。</p><span id="more"></span><h2 id="获取-react-元素"><a href="#获取-react-元素" class="headerlink" title="获取 react 元素"></a>获取 react 元素</h2><h3 id="createRef"><a href="#createRef" class="headerlink" title="createRef"></a>createRef</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>常用于 class 组件（函数组件也可以用）</li><li>可获取原生 DOM 和自定义 class 组件的引用</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">//父组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoFocusTextInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  constructor(props) &#123;<br>    <span class="hljs-keyword">super</span>(props);<br>    <span class="hljs-keyword">this</span>.textInput = <span class="hljs-type">React</span>.createRef();<br>  &#125;<br><br>  componentDidMount() &#123;<br>    <span class="hljs-keyword">this</span>.textInput.current.focusTextInput();<br>  &#125;<br><br>  render() &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;<span class="hljs-type">CustomTextInput</span> ref=&#123;<span class="hljs-keyword">this</span>.textInput&#125; /&gt;<br>    );<br>  &#125;<br>&#125;<br><span class="hljs-comment">//子组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomTextInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  constructor(props) &#123;<br>    <span class="hljs-keyword">super</span>(props);<br>    <span class="hljs-comment">// 创建一个 ref 来存储 textInput 的 DOM 元素</span><br>    <span class="hljs-keyword">this</span>.textInput = <span class="hljs-type">React</span>.createRef();<br>    <span class="hljs-keyword">this</span>.focusTextInput = <span class="hljs-keyword">this</span>.focusTextInput.bind(<span class="hljs-keyword">this</span>);<br>  &#125;<br><br>  focusTextInput() &#123;<br>    <span class="hljs-comment">// 直接使用原生 API 使 text 输入框获得焦点</span><br>    <span class="hljs-comment">// 注意：我们通过 &quot;current&quot; 来访问 DOM 节点</span><br>    <span class="hljs-keyword">this</span>.textInput.current.focus();<br>  &#125;<br><br>  render() &#123;<br>    <span class="hljs-comment">// 告诉 React 我们想把 &lt;input&gt; ref 关联到</span><br>    <span class="hljs-comment">// 构造器里创建的 `textInput` 上</span><br>    <span class="hljs-keyword">return</span> (<br>      &lt;div&gt;<br>        &lt;input<br>          <span class="hljs-class"><span class="hljs-keyword">type</span></span>=<span class="hljs-string">&quot;text&quot;</span><br>          ref=&#123;<span class="hljs-keyword">this</span>.textInput&#125; /&gt;<br>        &lt;input<br>          <span class="hljs-class"><span class="hljs-keyword">type</span></span>=<span class="hljs-string">&quot;button&quot;</span><br>          value=<span class="hljs-string">&quot;Focus the text input&quot;</span><br>          onClick=&#123;<span class="hljs-keyword">this</span>.focusTextInput&#125;<br>        /&gt;<br>      &lt;/div&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>createRef 每次渲染都会返回一个新的引用</li></ol><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const createRef = <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> &#123; current: <span class="hljs-literal">null</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol><li>只能用于函数组件</li><li>useRef 的引用存在于组件的整个生命周期</li></ol><h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">let obj = &#123; current: <span class="hljs-literal">null</span> &#125;<br><br>const useRef = <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> obj<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>createRef 与 useRef 区别</strong><br>虽然都是用于创建 ref 属性、访问 DOM 实例对象，但两者适用的组件语法略有差异：createRef 更适用于 class 组件，由于其并没有 Hooks 的效果，其内部的值会随着函数组件重复执行而不断被初始化，而在 class 组件中由于分离了生命周期，使初始化时机仅执行一次。</p></blockquote><p>以下面的代码为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; createRoot &#125; = <span class="hljs-title class_">ReactDOM</span>;<br><span class="hljs-keyword">const</span> &#123; useRef, useState, createRef &#125; = <span class="hljs-title class_">React</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>   <span class="hljs-keyword">const</span> [renderIndex,setRenderIndex] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> refFromUseRef = <span class="hljs-title function_">useRef</span>();<br>   <span class="hljs-keyword">const</span> refFromCreateRef = <span class="hljs-title function_">createRef</span>();<br><br><br>    <span class="hljs-keyword">if</span> (!refFromUseRef.<span class="hljs-property">current</span>)&#123;<br>       refFromUseRef.<span class="hljs-property">current</span>=renderIndex<br>   &#125;<br>    <span class="hljs-keyword">if</span> (!refFromCreateRef.<span class="hljs-property">current</span>) &#123;<br>        refFromCreateRef.<span class="hljs-property">current</span> = renderIndex<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>index &#123;renderIndex&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>refFromUseRef &#123;refFromUseRef.current&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>refFromCreateRef &#123;refFromCreateRef.current&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123; setRenderIndex(p=&gt;p+1)&#125;&#125;&gt;a<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ComponentDemo</span> = <span class="hljs-title class_">App</span>;<br><span class="hljs-title function_">createRoot</span>(mountNode).<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ComponentDemo</span> /&gt;</span></span>);<br><br></code></pre></td></tr></table></figure><p>在执行的过程中会发现即使组件重新渲染, 由于 refFromUseRef 的值一直存在(类似于 this ) , 无法重新赋值；而 refFromCreateRef 会随组件渲染不断改变引用值。</p><h2 id="父组件获取子组件内部的一个元素"><a href="#父组件获取子组件内部的一个元素" class="headerlink" title="父组件获取子组件内部的一个元素"></a>父组件获取子组件内部的一个元素</h2><h3 id="forwardRef"><a href="#forwardRef" class="headerlink" title="forwardRef"></a>forwardRef</h3><p>获取函数子组件内部元素的 ref 得用 forwardRef，因为 ref 不像 props 作为参数可以传递。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 父元素。可以直接获取 DOM button 的 ref：</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span>=(<span class="hljs-params"></span>)=&gt;&#123;<br>    <span class="hljs-keyword">const</span> ref = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>();<br>    <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">FancyButton</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span>&gt;</span>Click me!<span class="hljs-tag">&lt;/<span class="hljs-name">FancyButton</span>&gt;</span></span>)<br>&#125;<br><br><span class="hljs-comment">//子元素</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">FancyButton</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;FancyButton&quot;</span>&gt;</span></span><br><span class="language-xml">    &#123;props.children&#125;</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>));<br></code></pre></td></tr></table></figure><h2 id="父组件获取子组件内部多个元素-x2F-方法"><a href="#父组件获取子组件内部多个元素-x2F-方法" class="headerlink" title="父组件获取子组件内部多个元素&#x2F;方法"></a>父组件获取子组件内部多个元素&#x2F;方法</h2><h3 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h3><p>useImperativeHandle 需要和 forwardRef 结合使用。可以让你在使用 ref 时自定义暴露给父组件的实例值。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const FancyInput= React.forwardRef(props, ref) =&gt; &#123;<br>  const inputRef = useRef();<br>  useImperativeHandle(ref, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (&#123;<br>    focus: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      inputRef.current.focus();<br>    &#125;<br>  &#125;));<br>  <span class="hljs-keyword">return</span> &lt;input ref=&#123;inputRef&#125; ... /&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>本例中渲染<code> &lt;FancyInput ref=&#123;inputRef&#125; /&gt;</code> 的父组件可以调用 inputRef.current.focus()。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://blog.csdn.net/frontend_frank/article/details/104243286">什么是 useRef , useRef 与 createRef 区别, 以及在什么情况下使用 useRef</a><br>（2）<a href="https://juejin.cn/post/6844904079164964878">精读《useRef 与 createRef 的区别》</a><br>（3）<a href="https://juejin.cn/post/7146095092674068487">一文学会 useImperativeHandle</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;虽然 react 中很少使用操作 DOM 的逻辑，但为了能够理解开源代码，还是整理记录了常用的几个相关函数。&lt;/p&gt;</summary>
    
    
    
    <category term="前端技术体系" scheme="https://unknown404.github.io/unkown404.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="React" scheme="https://unknown404.github.io/unkown404.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>页面置灰的实现方式</title>
    <link href="https://unknown404.github.io/unkown404.github.io/2022/12/02/cssUsage/"/>
    <id>https://unknown404.github.io/unkown404.github.io/2022/12/02/cssUsage/</id>
    <published>2022-12-02T01:46:33.000Z</published>
    <updated>2022-12-13T08:57:22.748Z</updated>
    
    <content type="html"><![CDATA[<p>记一次 css 踩坑经历</p><span id="more"></span><h2 id="业务需求描述"><a href="#业务需求描述" class="headerlink" title="业务需求描述"></a>业务需求描述</h2><p>涉及一些重要的悼念活动时，需要将网站主页面置为灰色，同时希望不要影响其他功能页面的颜色</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>可将页面的 CSS 样式设置为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css">.<span class="hljs-selector-attr">[classname]</span>  &#123;<br>    -webkit-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    -moz-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    -ms-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    -o-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    <span class="hljs-attribute">filter</span>: gray;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的点是如果页面组件有 fixed 定位，上述 css 写法可能会导致组件位置出现问题，根据 MDN 的文档，对 position 定位有下面一段描述：</p><blockquote><p><strong>fixed</strong><br>元素会被移出正常文档流，并不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform, perspective 或 filter 属性非 none 时，容器由视口改为该祖先。</p></blockquote><p><strong>解决方法：</strong><br>将 filter 的样式写在 html 上。<br><strong>注意点：</strong></p><ol><li>非 SPA 项目处理时书写方式最好是：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>  &#123;<br>    -webkit-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    -moz-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    -ms-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    -o-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    <span class="hljs-attribute">filter</span>: gray;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是因为尽管 html5.0 规范允许在<code>&lt;html&gt;</code>标签上添加 class 属性，但没有保证该 class 属性一定能生效。</p><ol start="2"><li>处理 SPA 页面时如果书写上述样式，会导致所有页面样式都会变灰。比较好的实现方式是利用页面的生命周期，为 html 节点手动添加样式。并在页面跳转时去除变灰样式。这里以 react 为例：</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">componentDidMount</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">if</span>(global.document)&#123;<br>      const html=document<span class="hljs-selector-class">.getElementsByTagName</span>(<span class="hljs-string">&#x27;html&#x27;</span>)<br>      <span class="hljs-built_in">if</span>(<span class="hljs-selector-tag">html</span><span class="hljs-selector-attr">[0]</span>)&#123;<br>        <span class="hljs-selector-tag">html</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.style</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;filter&#x27;</span> as any]</span>=<span class="hljs-string">&#x27;grayscale(100%)&#x27;</span><br>      &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">componentWillUnmount</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">if</span>(global.document)&#123;<br>        const html=document<span class="hljs-selector-class">.getElementsByTagName</span>(<span class="hljs-string">&#x27;html&#x27;</span>)<br>        <span class="hljs-built_in">if</span>(<span class="hljs-selector-tag">html</span><span class="hljs-selector-attr">[0]</span>)&#123;<br>            <span class="hljs-selector-tag">html</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.style</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;filter&#x27;</span>  as any]</span>=<span class="hljs-string">&#x27;none&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>使用 js 添加样式时，如果代码使用了 ts 语法，可能会报错：<code>Element implicitly has an &#39;any&#39; type because index expression is not of type &#39;number&#39;</code>，这是因为 CSSStyleDeclaration 它的 index 值设置为了 number 而不是 string，这个报错的根本原因，兼容浏览器的 css 属性<code>-webkit-*</code>、<code>-o-*</code>等已经不在 CSSStyleDeclaration 内部了。考虑到现在大部分浏览器都支持 css3 了，兼容性写法可以适时去掉</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position">MDN position</a><br>（2）<a href="https://stackoverflow.com/questions/53526178/element-implicitly-has-an-any-type-because-index-expression-is-not-of-type-nu">Element implicitly has an ‘any’ type because index expression is not of type ‘number’ [7015]</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记一次 css 踩坑经历&lt;/p&gt;</summary>
    
    
    
    <category term="踩坑经历" scheme="https://unknown404.github.io/unkown404.github.io/categories/%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="CSS" scheme="https://unknown404.github.io/unkown404.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>js实现从utf-8到base64编码</title>
    <link href="https://unknown404.github.io/unkown404.github.io/2022/11/29/encodeBase64/"/>
    <id>https://unknown404.github.io/unkown404.github.io/2022/11/29/encodeBase64/</id>
    <published>2022-11-29T13:42:55.000Z</published>
    <updated>2022-12-13T08:57:22.748Z</updated>
    
    <content type="html"><![CDATA[<p>编码知识小记</p><span id="more"></span><h2 id="编码相关概念的辨析"><a href="#编码相关概念的辨析" class="headerlink" title="编码相关概念的辨析"></a>编码相关概念的辨析</h2><h3 id="编码历史"><a href="#编码历史" class="headerlink" title="编码历史"></a>编码历史</h3><p>计算机起源之初，科学家对英语字符与二进制位之间的关系做了统一规定，定义了 128 个字符的编码规则，用七位二进制表示。这套编码规则被称为 ASCII 编码。随着计算机的普及，在不同的地区和国家，当地程序员为了适应本地的语言使用创建了新的字符编码。但不同国家间读取内容时由于编码方式的差异会导致内容乱码，对国际沟通交流造成了障碍。</p><p>这时候 Unicode 就出现了。 Unicode 是国际标准字符集，它将世界各种语言的每个字符定义一个唯一的编码，以满足跨语言、跨平台的文本信息转换。Unicode 字符集的编码范围是 0x0000 - 0x10FFFF , 可以容纳一百多万个字符， 每个字符都有一个独一无二的编码，也即每个字符都有一个二进制数值和它对应。</p><h3 id="Unicode、utf-8、utf-16-辨析"><a href="#Unicode、utf-8、utf-16-辨析" class="headerlink" title="Unicode、utf-8、utf-16 辨析"></a>Unicode、utf-8、utf-16 辨析</h3><p>Unicode 只是字符集，即很多个字符的集合；而 UTF-8、UTF-16、UTF-32 才是真正的字符编码规则：utf-8 是用一个字节来编码所有的字符，utf-16 是用两个字节来编码所有的字符，utf-32 则选择用 4 个字节来编码。<br>其中最常见的编码规则是 utf-8，因为互联网的大部分资源都是英文的，使用 utf-8 保存更节省空间。Unicode 转 utf-8 主要是变长编码，有具体表格展示不同 unicode 的编码规则，这里不再赘述。</p><h3 id="Base64-编码"><a href="#Base64-编码" class="headerlink" title="Base64 编码"></a>Base64 编码</h3><p>Base64 的编码方法要求把每三个 8bit 的字节转换成四个 6bit 的字节，然后把 6Bit 再添两位高位 0，组成四个 8Bit 的字节。经过 base64 编码后的字符串会比原来长 1&#x2F;3。</p><h2 id="前端页面表单数据转-base64"><a href="#前端页面表单数据转-base64" class="headerlink" title="前端页面表单数据转 base64"></a>前端页面表单数据转 base64</h2><p>需要注意的点是虽然 html 和 js 的编码是 utf-8，但 js 从页面得到的中文是 utf-16 编码，直接转 base64 是会出错的。<br>MDN 上给出了最简单的解决方法：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> utf8<span class="hljs-constructor">_to_b64(<span class="hljs-params">str</span>)</span> &#123;<br>  return window.btoa(unescape(encode<span class="hljs-constructor">URIComponent(<span class="hljs-params">str</span>)</span>));<br>&#125;<br><br><span class="hljs-keyword">function</span> b64<span class="hljs-constructor">_to_utf8(<span class="hljs-params">str</span>)</span> &#123;<br>  return decode<span class="hljs-constructor">URIComponent(<span class="hljs-params">escape</span>(<span class="hljs-params">window</span>.<span class="hljs-params">atob</span>(<span class="hljs-params">str</span>)</span>));<br>&#125;<br><br><span class="hljs-comment">// Usage:</span><br>utf8<span class="hljs-constructor">_to_b64(<span class="hljs-string">&quot;✓ à la mode&quot;</span>)</span>; <span class="hljs-comment">// &quot;4pyTIMOgIGxhIG1vZGU=&quot;</span><br>b64<span class="hljs-constructor">_to_utf8(<span class="hljs-string">&quot;4pyTIMOgIGxhIG1vZGU=&quot;</span>)</span>; <span class="hljs-comment">// &quot;✓ à la mode&quot;</span><br></code></pre></td></tr></table></figure><p>里面涉及的流程是：</p><ol><li>先用 encodeURIComponent 把 js 的字符串转成 UTF-8 的百分号编码形式。该方法不会对 ASCII 字母和数字及部分 ASCII 标点符号进行编码，非英文字符会先转为 UTF8 的字节码，然后前面加个%进行拼接；</li><li>再用 unescape 把百分号编码按字节转化成对应的含有 Latin-1 字符集字符的 js 字符串 （即使它是乱码）；</li><li>最后用 btoa 把只含有 Latin-1 的 js 字符串转换成 Base64 编码；根据 MDN 文档，btoa 可以将二进制字符串转为 base64 编码的 ASCII 字符串，在实际操作中发现如果直接对中文编码会抛出错误：‘The string to be encoded contains characters outside of the Latin1 range.’，可以推断 btoa 是可以处理 Latin-1 字符集字符的。</li></ol><p>关于这种编码方式，网上也看到有去掉 escape&#x2F;unescape 的版本，似乎同样能得到预期结果。但是这得到的编码并非 utf-8 转 base64 的结果，在只有 ASCII 码时 unescape 使用与否都能得到一样的答案，然而出现带百分号编码的字符串时省去 unescape 会使编码结果的长度增加了，因为 btoa 编码了百分号；且如果是将编码结果传给其他 API 时会很难理解其内容</p><h2 id="前端-node-js-转-base64"><a href="#前端-node-js-转-base64" class="headerlink" title="前端 node.js 转 base64"></a>前端 node.js 转 base64</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">//utf-8 转 base64</span><br>const txt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Buffer</span>(<span class="hljs-string">&#x27;文字&#x27;</span>).toString(<span class="hljs-string">&#x27;base64&#x27;</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(txt)<br><br><span class="hljs-comment">//base64 转 utf-8</span><br>const ztxt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Buffer</span>(txt, <span class="hljs-string">&#x27;base64&#x27;</span>).toString(<span class="hljs-string">&#x27;utf8&#x27;</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(ztxt)<br></code></pre></td></tr></table></figure><p>处理起来相对简单，可以直接用 buffer 模块的 api</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://zhuanlan.zhihu.com/p/427488961">Unicode、UTF-8、UTF-16 终于懂了</a><br>（2）<a href="https://developer.mozilla.org/en-US/docs/Glossary/Base64#Solution_2_%E2%80%93_escaping_the_string_before_encoding_it">Base64</a><br>（3）<a href="https://best33.com/311.moe">为什么 escape 可以使 btoa 正确处理 UTF-8 编码的字符串？</a><br>（4）<a href="https://stackoverflow.com/questions/30631927/converting-to-base64-in-javascript-without-deprecated-escape-call">Converting to Base64 in JavaScript without Deprecated ‘Escape’ call</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;编码知识小记&lt;/p&gt;</summary>
    
    
    
    <category term="工作技巧" scheme="https://unknown404.github.io/unkown404.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="WEB API" scheme="https://unknown404.github.io/unkown404.github.io/tags/WEB-API/"/>
    
  </entry>
  
  <entry>
    <title>依赖失踪之谜 —— 记一次失败的问题查找</title>
    <link href="https://unknown404.github.io/unkown404.github.io/2022/11/29/nvmProblemSearch/"/>
    <id>https://unknown404.github.io/unkown404.github.io/2022/11/29/nvmProblemSearch/</id>
    <published>2022-11-29T10:08:22.000Z</published>
    <updated>2023-02-19T03:19:04.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>全局安装的依赖包突然找不到了，调用指令返回 <code>zsh: command not found:xxx</code> 的报错。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>对于上述报错问题，网上的回复基本统一是缺少环境变量配置。MAC 电脑的环境变量文件加载顺序为：</p><ul><li>&#x2F;etc&#x2F;profile，系统级文件，系统启动即加载</li><li>&#x2F;etc&#x2F;path，系统级文件，系统启动即加载</li><li>&#x2F;.bash_profile，用户级的环境变量配置文件，当该文件存在时忽略<del>&#x2F;.bash_login 、</del>&#x2F;.profile 、~&#x2F;.bashrc 文件的配置</li></ul><p>解决环境变量问题步骤：</p><ol><li>打开 zsh 控制台，输入指令：<code>open .zshrc</code></li><li>查看环境变量 PATH。PATH 的通常写法为</li></ol><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">export <span class="hljs-built_in">PATH</span> = &lt;<span class="hljs-built_in">path</span> <span class="hljs-number">1</span>&gt; : &lt;<span class="hljs-built_in">path</span> <span class="hljs-number">2</span>&gt; ... : &lt;<span class="hljs-built_in">path</span> n&gt; : $<span class="hljs-built_in">PATH</span><br></code></pre></td></tr></table></figure><p>涉及多个环境变量时用分号隔开。</p><p>当前电脑配置的 zshrc 内容为：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">NVM_DIR</span>=<span class="hljs-string">&quot;/Users/danhuipeng/.nvm&quot;</span><br>[ -s <span class="hljs-string">&quot;<span class="hljs-variable">$NVM_DIR</span>/nvm.sh&quot;</span> ] &amp;&amp; \. <span class="hljs-string">&quot;<span class="hljs-variable">$NVM_DIR</span>/nvm.sh&quot;</span>  # This loads nvm<br><br><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.yarn/bin:<span class="hljs-variable">$HOME</span>/.config/yarn/global/node_modules/.bin:<span class="hljs-variable">$PATH</span>&quot;</span><br><br>source ~/.bash_profile<br></code></pre></td></tr></table></figure><p>虽然有 yarn 的路径在环境变量中，但因为全局依赖包没有使用 yarn，所以现在的设置并不能解决问题。推测可能是因为当前的 path 内容并没有指向全局 npm 的依赖包目录下 。</p><ol start="3"><li>添加环境变量。使用指令<code>npm config get prefix</code>获取全局安装包时使用的 node，使用指令<code>npm root -g</code>来寻找全局仓库路径。得到的结果分别为：</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">～<span class="hljs-regexp">/.nvm/</span>versions<span class="hljs-regexp">/node/</span>v15.<span class="hljs-number">14.0</span><br>～<span class="hljs-regexp">/.nvm/</span>versions<span class="hljs-regexp">/node/</span>v15.<span class="hljs-number">14.0</span><span class="hljs-regexp">/lib/</span>node_modules<br></code></pre></td></tr></table></figure><p>根目录已省略。尝试将这两个变量添加到 path 后，执行指令发<code>source .zshrc</code>现并没有解决问题。为了明确为什么找不到依赖包执行了指令<code>cd ~/.nvm/versions/node/v15.14.0/lib/node_modules</code>到全局依赖目录下，尝试查看内容列表，然而执行指令<code>ls</code>后什么也没发生，即该目录下的内容已空！！为什么会空了呢？完全不知道原因，和其他版本的依赖目录比较发现连 npm 都没有了？？<br><img src="/unkown404.github.io/img/log.png"></p><p>问题排查到这里已经进行不下去了，只能进行依赖重装。</p><p>考虑到本人使用 node 15 的时候比较少，大多数项目使用的都是 14，所以采用指令<code>nvm alias default v14</code>调整 node 的默认版本。因为 node 15 现在连 npm 都没有了，所以使用<code>nvm uninstall v15</code>指令卸载 node15。使用指令<code>nvm ls</code>检查发现现在已经开始使用 node v14 了</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xl">       v10.<span class="hljs-number">24.1</span><br>       v12.<span class="hljs-number">16.3</span><br>       v12.<span class="hljs-number">22.1</span><br>-&gt;     v14.<span class="hljs-number">19.3</span><br><span class="hljs-function"><span class="hljs-title">default</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">v14</span> (-&gt;</span> v14.<span class="hljs-number">19.3</span>)<br><span class="hljs-function"><span class="hljs-title">iojs</span> -&gt;</span> N/A (default)<br><span class="hljs-function"><span class="hljs-title">unstable</span> -&gt;</span> N/A (default)<br><span class="hljs-function"><span class="hljs-title">node</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">stable</span> (-&gt;</span> v14.<span class="hljs-number">19.3</span>) (default)<br><span class="hljs-function"><span class="hljs-title">stable</span> -&gt;</span> <span class="hljs-number">14.19</span> (-&gt; v14.<span class="hljs-number">19.3</span>) (default)<br><span class="hljs-function"><span class="hljs-title">lts</span>/* -&gt;</span> <span class="hljs-function"><span class="hljs-title">lts</span>/hydrogen (-&gt;</span> N/A)<br><span class="hljs-function"><span class="hljs-title">lts</span>/argon -&gt;</span> <span class="hljs-function"><span class="hljs-title">v4</span>.9.1 (-&gt;</span> N/A)<br><span class="hljs-function"><span class="hljs-title">lts</span>/boron -&gt;</span> <span class="hljs-function"><span class="hljs-title">v6</span>.17.1 (-&gt;</span> N/A)<br><span class="hljs-function"><span class="hljs-title">lts</span>/carbon -&gt;</span> <span class="hljs-function"><span class="hljs-title">v8</span>.17.0 (-&gt;</span> N/A)<br><span class="hljs-function"><span class="hljs-title">lts</span>/dubnium -&gt;</span> v10.<span class="hljs-number">24.1</span><br><span class="hljs-function"><span class="hljs-title">lts</span>/erbium -&gt;</span> <span class="hljs-function"><span class="hljs-title">v12</span>.22.12 (-&gt;</span> N/A)<br><span class="hljs-function"><span class="hljs-title">lts</span>/fermium -&gt;</span> <span class="hljs-function"><span class="hljs-title">v14</span>.21.1 (-&gt;</span> N/A)<br><span class="hljs-function"><span class="hljs-title">lts</span>/gallium -&gt;</span> <span class="hljs-function"><span class="hljs-title">v16</span>.18.1 (-&gt;</span> N/A)<br><span class="hljs-function"><span class="hljs-title">lts</span>/hydrogen -&gt;</span> <span class="hljs-function"><span class="hljs-title">v18</span>.12.1 (-&gt;</span> N/A)<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>(1)<a href="https://wenku.baidu.com/view/2cb4a1ffae51f01dc281e53a580216fc700a53a9.html?_wkts_=1669702352151&bdQuery=zsh%E6%80%8E%E4%B9%88%E9%85%8D%E5%A4%9A%E4%B8%AA%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">Mac 在 bash 和 zsh 配置环境变量 path 的几种方法</a><br>(2)<a href="https://blog.csdn.net/Wildpiglolo/article/details/123828019">npm 全局安装后，对应的环境变量目录下找不到文件</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大无语事件。。。&lt;/p&gt;</summary>
    
    
    
    <category term="踩坑经历" scheme="https://unknown404.github.io/unkown404.github.io/categories/%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="依赖安装" scheme="https://unknown404.github.io/unkown404.github.io/tags/%E4%BE%9D%E8%B5%96%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>小程序踩坑经历--canvas层级过高</title>
    <link href="https://unknown404.github.io/unkown404.github.io/2022/09/30/appletCanvas/"/>
    <id>https://unknown404.github.io/unkown404.github.io/2022/09/30/appletCanvas/</id>
    <published>2022-09-30T08:54:38.000Z</published>
    <updated>2022-11-29T13:41:02.783Z</updated>
    
    <content type="html"><![CDATA[<p>小程序开发弹窗功能时遇到的问题。</p><span id="more"></span><h2 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h2><p>需要在某一计算结果页设置收集信息弹窗，点击按钮时弹窗悬浮于页面正中；计算结果页包含绘制的饼图</p><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><p>canvas 属于原生组件，拥有最高层级，页面中其他组件无论设置 z-index 多少都无法覆盖在 canvas 上；且 canvas 标签不能使用<code>visibility:hidden</code>或 <code>opacity: 0;</code>去隐藏，放在父元素设置同样不可行</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>对于只需要展示文字或图片的简单弹窗，可以使用 cover-view 组件，该组件有小程序最高层级。<br>对于功能相对复杂的弹窗，则需要将 canvas 转为图片。<br>具体操作内容：</p><ol><li>模版部分：<br>新增替代 canvas 的图片模块，与 canvas 同级。这里为方便新增的模块和 canvas 同类名以便获取同样的样式大小设置。<br>新增变量 imgHide 和 chartImg，分别用于控制 canvas 到图片切换的过程和获取导出图片的临时路径。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Vue">&lt;template&gt;<br>    ...<br>    &lt;canvas<br>        :hidden=&quot;!imgHide&quot;<br>        class=&quot;chart-canvas&quot;<br>        canvas-id=&quot;ringCanvas&quot;<br>    &gt;&lt;/canvas&gt;<br>    &lt;view class=&quot;chart-canvas&quot; :hidden=&quot;imgHide&quot;&gt;<br>        &lt;img :src=&quot;chartImg&quot;/&gt;<br>    &lt;/view&gt;<br>    ...<br>    &lt;view @click=&quot;modalShow&quot;&gt;tap&lt;/view&gt;<br>    &lt;view class=&quot;modal&quot;&gt;<br>        ...<br>    &lt;/view&gt;<br>&lt;/template&gt;<br><br></code></pre></td></tr></table></figure><ol start="2"><li>JS 逻辑部分：<br>1）初始化 imgHide 和 chartImg，分别设为 false 和’’<br>2）增加新方法 canvasToImg，处理 canvas 导出图片的任务。这里 destWidth、destHeight 都设置为原宽高的 2 倍是因为 canvas 是位图，将它渲染到高清屏时,会被放大,每个像素点会用 devicePixelRatio 的平方个物理像素点来渲染,因此图片会变得模糊。使用 2 倍图可以解决问题。绘制成功时将文件路径赋值给 chartImg</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">canvasToImg</span>(<span class="hljs-params">width, height</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        wx.<span class="hljs-title function_">canvasToTempFilePath</span>(&#123;<br>            <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,<br>            <span class="hljs-attr">y</span>: <span class="hljs-number">0</span>,<br>            width,<br>            height,<br>            <span class="hljs-attr">destWidth</span>: width * <span class="hljs-number">2</span>,<br>            <span class="hljs-attr">destHeight</span>: height * <span class="hljs-number">2</span>,<br>            <span class="hljs-attr">canvasId</span>: <span class="hljs-string">&#x27;ringCanvas&#x27;</span>,<br>            <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>                <span class="hljs-keyword">const</span> filePath = res.<span class="hljs-property">tempFilePath</span><br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;tempFilePath&#x27;</span>, filePath)<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">chartImg</span> = filePath<br>            &#125;,<br>            <span class="hljs-attr">fail</span>: <span class="hljs-function"><span class="hljs-params">rej</span> =&gt;</span> &#123;<br>                <span class="hljs-keyword">throw</span> rej<br>            &#125;<br>        &#125;)<br>    &#125;, <span class="hljs-number">1000</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>选择 canvas 切 img 的时机。<br>如果在拿到导出图片路径时立即切图片，会导致页面的 chart 有一段不自然的闪烁看起来很奇怪；如果不考虑切换操作，直接在图片位置加 loading 图直到拿到导出图片路径，则体感加载时间会很长，因为 loading 时间包括了 canvas 绘制和图片导出，都是比较耗时的操作。<br>既然 canvas 换图片的操作是为了解决弹窗被遮挡的问题，那么可以将改变 imgHide 时机放置在点击按钮、弹出弹窗的方法中。<br>同时考虑到 canvas 导出图片的时间很长，如果在未完成该操作时弹窗就关闭的话用户就会看到空白的图片，所以需要在弹窗关闭的方法中增加是否需要切回 canvas 的判断。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">modalShow</span>(<span class="hljs-params"></span>) &#123;<br>    ...<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">imgHide</span> = <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-title function_">modalClose</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">chartImg</span> != <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">imgHide</span> = <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的点是如果 canvas 的面积大于弹窗的面积，那么当点击弹窗、canvas 尚未导出图片路径时，仍可以透过弹窗的 mask 看到没图的 img 元素的边框。<del>（这时最好不要做这个功能了）</del></p><ol start="4"><li>如果是需要反复绘制的场景，需要注意绘制前 canvas 是否仍然存在，否则 canvas 无法重新绘制，转成图片自然也不执行。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">onShow</span>(<span class="hljs-params"></span>) &#123;<br>    ...<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">imgHide</span> = <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://wenku.baidu.com/view/9d46b515ba0d6c85ec3a87c24028915f804d842d.html">微信小程序 canvas 层级过高，遮住弹窗解决方法</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;小程序开发弹窗功能时遇到的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="踩坑经历" scheme="https://unknown404.github.io/unkown404.github.io/categories/%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="小程序" scheme="https://unknown404.github.io/unkown404.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>webpack配置踩坑经历</title>
    <link href="https://unknown404.github.io/unkown404.github.io/2022/09/20/webpackConfig/"/>
    <id>https://unknown404.github.io/unkown404.github.io/2022/09/20/webpackConfig/</id>
    <published>2022-09-20T14:15:46.000Z</published>
    <updated>2022-09-20T14:43:01.591Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题：webpack项目使用域名访问出现Invalid-Host-header，使用ip可访问"><a href="#问题：webpack项目使用域名访问出现Invalid-Host-header，使用ip可访问" class="headerlink" title="问题：webpack项目使用域名访问出现Invalid Host header，使用ip可访问"></a>问题：webpack项目使用域名访问出现Invalid Host header，使用ip可访问</h2><p><strong>原因</strong>：新版的webpack-dev-server出于安全考虑,默认检查hostname,如果hostname 不是配置内的,将中断访问。<br><strong>解决方法</strong>：找到server的配置文件，添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">devServer:</span> &#123;<br>  <span class="hljs-attr">disableHostCheck:</span> <span class="hljs-literal">true</span>,<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题：webpack项目使用域名访问出现Invalid-Host-header，使用ip可访问&quot;&gt;&lt;a href=&quot;#问题：webpack项目使用域名访问出现Invalid-Host-header，使用ip可访问&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="踩坑经历" scheme="https://unknown404.github.io/unkown404.github.io/categories/%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="webpack" scheme="https://unknown404.github.io/unkown404.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Vue</title>
    <link href="https://unknown404.github.io/unkown404.github.io/2022/09/18/Vue/"/>
    <id>https://unknown404.github.io/unkown404.github.io/2022/09/18/Vue/</id>
    <published>2022-09-18T09:02:00.000Z</published>
    <updated>2023-02-19T07:41:55.271Z</updated>
    
    <content type="html"><![CDATA[<p>前端 vue 框架方面知识整理。</p><span id="more"></span><h2 id="Vue-相关基本概念"><a href="#Vue-相关基本概念" class="headerlink" title="Vue 相关基本概念"></a>Vue 相关基本概念</h2><h3 id="MVVM-和-MVC-的区别"><a href="#MVVM-和-MVC-的区别" class="headerlink" title="MVVM 和 MVC 的区别"></a>MVVM 和 MVC 的区别</h3><h4 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h4><ul><li>Model 代表数据模型，数据和业务逻辑都在 Model 层中定义；</li><li>View 代表 UI 视图，负责数据的展示；</li><li>ViewModel 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作；</li></ul><p>ViewModel 通过双向数据绑定连接 view 和 model，view 和 model 间的同步工作是自动的，无需手动操作 DOM</p><h4 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h4><ul><li>Model 代表数据模型，数据和业务逻辑都在 Model 层中定义，Model 发生的变化会通知到 View 层；</li><li>View 代表 UI 视图，负责数据的展示；</li><li>Controller 主要负责用户与应用的响应操作，用户与页面产生交互的时候，Controller 中的事件触发器会调用合适的 model 处理问题；</li></ul><h3 id="双向绑定-x2F-响应式原理"><a href="#双向绑定-x2F-响应式原理" class="headerlink" title="双向绑定&#x2F;响应式原理"></a>双向绑定&#x2F;响应式原理</h3><p>Object.defineProperty 劫持数据，添加 setter&#x2F;getter 属性监听数据变化情况，发消息给订阅者触发监听回调</p><ol><li>实现一个监听器 observer：遍历对象属性，添加 setter&#x2F;getter，数据改变时可通过 setter 听到变化</li><li>实现一个编译器 compiler：编译模版，将模版的变量替换为数据，指令节点绑定更新函数</li><li>实现一个订阅者 watcher：连接 observer 和 compiler 桥梁，订阅 observer 属性变化消息，接收变化时触发 compiler 更新函数</li><li>实现一个订阅器 dep：订阅发布管理模式，统一管理 watcher 和 observer</li></ol><h3 id="Vue-diff-算法"><a href="#Vue-diff-算法" class="headerlink" title="Vue diff 算法"></a>Vue diff 算法</h3><h4 id="vue-2-x-双端-diff"><a href="#vue-2-x-双端-diff" class="headerlink" title="vue 2.x - 双端 diff"></a>vue 2.x - 双端 diff</h4><p>双端 diff 算法是头尾指针向中间移动，分别判断头尾节点是否可以复用，如果没有找到可复用的节点再去遍历查找对应节点的下标，然后移动。全部处理完之后也要对剩下的节点进行批量的新增和删除。</p><h4 id="vue-3-最长递增子序列"><a href="#vue-3-最长递增子序列" class="headerlink" title="vue 3 - 最长递增子序列"></a>vue 3 - 最长递增子序列</h4><h3 id="Vue-属性"><a href="#Vue-属性" class="headerlink" title="Vue 属性"></a>Vue 属性</h3><h4 id="data-为什么是一个函数而不是对象"><a href="#data-为什么是一个函数而不是对象" class="headerlink" title="data 为什么是一个函数而不是对象"></a>data 为什么是一个函数而不是对象</h4><p>如果 data 是对象，当组件复用时，由于多个实例引用同一个对象，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。</p><h4 id="computed-和-watch-区别"><a href="#computed-和-watch-区别" class="headerlink" title="computed 和 watch 区别"></a>computed 和 watch 区别</h4><p><strong>computed</strong></p><ol><li>支持缓存</li><li>不支持异步</li><li>如果 computed 属性的属性值是函数，那么默认使用 get 方法，函数的返回值就是属性的属性值；在 computed 中，属性有一个 get 方法和一个 set 方法，当数据被赋值时，会调用 set 方法。</li><li>第一次加载时会监听</li><li>computed 属性函数需要 return</li></ol><p><strong>watch</strong></p><ol><li>不支持缓存</li><li>支持异步</li><li>监听数据必须是 data 中声明的或者父组件传递过来的 props 中的数据</li><li>第一次加载时默认不监听，除非 immediate 为 true</li><li>watch 属性函数不需要 return</li></ol><h3 id="Vue-模版指令"><a href="#Vue-模版指令" class="headerlink" title="Vue 模版指令"></a>Vue 模版指令</h3><h4 id="v-show-和-v-if-区别"><a href="#v-show-和-v-if-区别" class="headerlink" title="v-show 和 v-if 区别"></a>v-show 和 v-if 区别</h4><p>v-show 只是在 display: none 和 display: block 之间切换。DOM 一直存在<br>v-if 的话就得说到 Vue 底层的编译了。当属性初始为 false 时，组件就不会被渲染，直到条件为 true，并且切换条件时会触发销毁&#x2F;挂载组件</p><h4 id="v-if-和-v-for-共用时控制台报错"><a href="#v-if-和-v-for-共用时控制台报错" class="headerlink" title="v-if 和 v-for 共用时控制台报错"></a>v-if 和 v-for 共用时控制台报错</h4><p>当它们同时存在于一个节点上时，v-if 比 v-for 的优先级更高。这意味着 v-if 的条件将无法访问到 v-for 作用域内定义的变量别名<br>正确写法：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;todo in todos&quot;</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;!todo.isComplete&quot;</span>&gt;</span></span><br><span class="language-xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">todo.name</span> &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="Vue3-0-新特性"><a href="#Vue3-0-新特性" class="headerlink" title="Vue3.0 新特性"></a>Vue3.0 新特性</h3><h4 id="Proxy-替代-Object-defineProperty"><a href="#Proxy-替代-Object-defineProperty" class="headerlink" title="Proxy 替代 Object.defineProperty"></a>Proxy 替代 Object.defineProperty</h4><h5 id="Proxy-特点"><a href="#Proxy-特点" class="headerlink" title="Proxy 特点"></a>Proxy 特点</h5><ol><li>可以直接监听整个对象而非属性；</li><li>Proxy 可以直接监听数组的变化；</li><li>Proxy 与 Object.defineProperty 相比有更多拦截方法；</li><li>Proxy 返回的是一个新对象，可以只操作新的对象达到目的，而 Object.defineProperty 只能遍历对象属性直接修改;</li></ol><h5 id="Object-defineProperty-特点"><a href="#Object-defineProperty-特点" class="headerlink" title="Object.defineProperty 特点"></a>Object.defineProperty 特点</h5><ol><li>Object.defineProperty 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历</li><li>Object.defineProperty 也不能对 es6 新产生的 Map,Set 这些数据结构做出监听，不能监听数组和对象</li><li>Object.defineProperty 不能监听新增和删除操作</li></ol><h4 id="组合式-API"><a href="#组合式-API" class="headerlink" title="组合式 API"></a>组合式 API</h4><p>Vue 之前的风格可以说属于选项式 API，用包含多个选项的对象来描述组件的逻辑，例如 data、methods 和 mounted。组合式 API 是写在标签<code>&lt;script setup&gt;</code>的内部的，风格接近 react 钩子函数</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>1）生命周期钩子只有 onBeforeMount、onMounted、onBeforeUpdate、onUpdated、onBeforeUnmount 和 onUnmounted，不存在跟 beforeCreate 和 created 生命周期相关的钩子<br>2）父子组件之间的数据交互依赖于函数 defineProps 和 defineEmits、defineExpose<br>3）不会使用 this（因为不存在组件实例了）<br>4）需要使用 ref 或者 reactive 创建响应式数据</p><h5 id="ref-和-reactive-区别"><a href="#ref-和-reactive-区别" class="headerlink" title="ref 和 reactive 区别"></a>ref 和 reactive 区别</h5><p><strong>ref</strong>：通常用来定义常用的基础类型(String,Number,Boolean 等等)，ref 函数包裹的数据需要用.value 来查询<br><strong>reactive</strong>：通常用来定义对象</p><h4 id="支持-TypeScript"><a href="#支持-TypeScript" class="headerlink" title="支持 TypeScript"></a>支持 TypeScript</h4><p>Vue 3.0 是用 TypeScript 编写的，因此支持 TypeScript。<br>在单文件组件中使用 TypeScript，需要在 <code>&lt;script&gt;</code> 标签上加上 lang&#x3D;”ts” 的 attribute。<br><strong>类型推断对比</strong></p><table style="text-align:center;">    <tr>       <th></th>        <th>组合式API</th>      <th>选项式API</th>   </tr>   <tr>       <td>props类型推导</td>           <td>defineProps</td>           <td>defineComponent</td>   </tr>   <tr>       <td>emits类型推导</td>           <td>defineEmits</td>           <td>defineComponent</td>   </tr>   <tr>       <td>计算属性类型推导</td>           <td>泛型参数显式指定computed()类型</td>           <td>显式地标记出计算属性的类型</td>   </tr>   <tr>       <td>事件处理函数类型推导</td>           <td colspan="2">显式地强制转换 event 上的属性(例：event.target as HTMLInputElement）</td>   </tr>   <tr>       <td>ref类型推导</td>           <td>Ref传入泛型参数;ref初始化时也会推导类型</td>           <td rowspan="2">无</td>   </tr>    <tr>       <td>reactive类型推导</td>           <td>interface定义</td>   </tr></table><h3 id="新内置组件-Suspense、Teleport"><a href="#新内置组件-Suspense、Teleport" class="headerlink" title="新内置组件 Suspense、Teleport"></a>新内置组件 Suspense、Teleport</h3><ul><li><strong>Suspense</strong>：组件有两个插槽：#default 和 #fallback。两个插槽都只允许一个直接子节点。初始渲染时渲染默认的插槽内容。如果遇到异步依赖，则会进入挂起状态。在挂起状态期间，展示的是后备内容。当所有遇到的异步依赖都完成后，将展示出默认插槽的内容。</li><li><strong>Teleport</strong>：接收一个 to 的属性来指定传送的目标。to 的值可以是 CSS 选择器字符串，也可以是一个 DOM 元素对象。被 Teleport 标签包裹的模块将置于 to 指定的 DOM 之下。适用于子组件调用公共组件如全局提示框的场景</li></ul><h2 id="Vue-生命周期（Vue3-0-版本）"><a href="#Vue-生命周期（Vue3-0-版本）" class="headerlink" title="Vue 生命周期（Vue3.0 版本）"></a>Vue 生命周期（Vue3.0 版本）</h2><p><img src="/unkown404.github.io/img/life-cycle.png"></p><h3 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h3><p>实例初始化完成、props 解析之后、data() 和 computed 等选项处理之前立即调用。</p><h3 id="created"><a href="#created" class="headerlink" title="created"></a>created</h3><p>data、computed、method、watch 已经设置完成。跟 DOM 操作相关的属性方法仍不可使用。</p><h3 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h3><p>即将首次执行 DOM 渲染过程。</p><p>服务器渲染流程不包括该生命周期。</p><h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h3><p>组件挂载完之后调用。挂载完成的定义为：所有同步子组件都已经被挂载且其自身的 DOM 树已经创建完成并插入了父容器中。<br>该生命周期通常用于执行需要访问组件所渲染的 DOM 树相关的副作用。</p><p>服务器渲染流程不包括该生命周期。</p><h3 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h3><p>响应式数据更新时调用，可以用来在 Vue 更新 DOM 之前访问 DOM 状态。</p><p>服务器渲染流程不包括该生命周期。</p><h3 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h3><p>调用时，组件 DOM 已经更新，所以可以执行依赖于 DOM 的操作。</p><p>服务器渲染流程不包括该生命周期。</p><h3 id="beforeUnmount"><a href="#beforeUnmount" class="headerlink" title="beforeUnmount"></a>beforeUnmount</h3><p>一个组件实例被卸载之前调用。当这个钩子被调用时，组件实例依然还保有全部的功能。</p><p>服务器渲染流程不包括该生命周期。</p><h3 id="unmounted"><a href="#unmounted" class="headerlink" title="unmounted"></a>unmounted</h3><p>一个组件实例被卸载之后调用。可以在这个钩子中手动清理一些副作用，例如计时器、DOM 事件监听器或者与服务器的连接。</p><p>服务器渲染流程不包括该生命周期。<br><strong>备注</strong>：<br>Vue2 的生命周期钩子除了最后两个的名称是 beforeDestroy 和 destroyed，其他都一样</p><h3 id="KeepAlive-组件生命周期"><a href="#KeepAlive-组件生命周期" class="headerlink" title="KeepAlive 组件生命周期"></a>KeepAlive 组件生命周期</h3><h4 id="KeepAlive-组件简介"><a href="#KeepAlive-组件简介" class="headerlink" title="KeepAlive 组件简介"></a>KeepAlive 组件简介</h4><p>vue 的内置组件，它的功能是在多个组件间动态切换时缓存被移除的组件实例。</p><h4 id="activated"><a href="#activated" class="headerlink" title="activated"></a>activated</h4><p>在首次挂载、以及每次从缓存中被重新插入的时候调用</p><h4 id="deactivated"><a href="#deactivated" class="headerlink" title="deactivated"></a>deactivated</h4><p>在从 DOM 上移除、进入缓存以及组件卸载时调用</p><h3 id="适合做异步请求的生命周期"><a href="#适合做异步请求的生命周期" class="headerlink" title="适合做异步请求的生命周期"></a>适合做异步请求的生命周期</h3><p>created、beforeMount、mounted 都可以做异步请求，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。<br>考虑到服务端渲染不包括周期 beforeMount、mounted，异步请求放在 created 一致性更好；另一方面 created 调用异步数据相比其他周期调用页面加载时间会缩短。</p><h3 id="父子组件嵌套时，父组件和子组件生命周期钩子执行顺序"><a href="#父子组件嵌套时，父组件和子组件生命周期钩子执行顺序" class="headerlink" title="父子组件嵌套时，父组件和子组件生命周期钩子执行顺序"></a>父子组件嵌套时，父组件和子组件生命周期钩子执行顺序</h3><ul><li><strong>加载渲染过程</strong> 父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</li><li><strong>子组件更新过程</strong> 父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</li><li><strong>父组件更新过程</strong> 父 beforeUpdate -&gt; 父 updated</li><li><strong>销毁过程</strong> 父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</li></ul><h2 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h2><h3 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h3><p><strong>1）props</strong><br>通过 props 传递数据给子组件<br><strong>2）emit</strong><br>父组件可以通过 v-on 或 @ 来选择性地监听子组件上抛的事件，如示例中自定义的事件 increaseBy；该属性的处理函数可以写在父组件的 method 里<br>子组件调用内置的 $emit 方法，通过传入事件名称来抛出一个事件；也可以通过设置 emits 属性实现</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 父组件</span><br>&lt;MyButton <span class="hljs-meta">@increase</span>-<span class="hljs-keyword">by</span>=<span class="hljs-string">&quot;(n) =&gt; count += n&quot;</span> /&gt;<br><br><span class="hljs-comment">// 子组件</span><br>&lt;button <span class="hljs-meta">@click</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$emit</span>(&#x27;increaseBy&#x27;, 1)&quot;</span>&gt;<br>  Increase <span class="hljs-keyword">by</span> <span class="hljs-number">1</span><br>&lt;/button&gt;<br></code></pre></td></tr></table></figure><p><strong>3）v-model</strong><br>当 v-model 指令用于自定义的组件时，等效于如下写法：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir">&lt;CustomInput<br>  <span class="hljs-symbol">:modelValue=<span class="hljs-string">&quot;searchText&quot;</span></span><br>  <span class="hljs-variable">@update</span><span class="hljs-symbol">:modelValue=<span class="hljs-string">&quot;newValue =&gt; searchText = newValue&quot;</span></span><br>/&gt;<br></code></pre></td></tr></table></figure><p>如果要实现和原生元素 input 一样的绑定效果，自定义组件 CustomInput 内部需要做如下操作：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- CustomInput.vue --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;modelValue&#x27;</span>],</span><br><span class="language-javascript">  <span class="hljs-attr">emits</span>: [<span class="hljs-string">&#x27;update:modelValue&#x27;</span>]</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;modelValue&quot;</span></span><br><span class="hljs-tag">    @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;</span></span><br><span class="hljs-tag">  /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>子组件中通过将属性 modelValue 和原生元素 input 的 value 绑定，当 input 的值变化时通过 emit 向上传递变化的值</p><p><strong>4）ref</strong><br>使用选项式 API 时，可以通过 this.$refs.name 的方式获取指定元素或者组件</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs perl">// 父组件<br><br>&lt;template&gt;<br>&lt;child <span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;childNode&quot;</span>&gt;&lt;<span class="hljs-regexp">/child&gt;</span><br><span class="hljs-regexp">&lt;/</span>template&gt;<br>&lt;script&gt;<br>export default&#123;<br>  data()&#123;&#125;,<br>  methods:&#123;<br>    test()&#123;<br>      this.$refs.childNode.childMethod()<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;<span class="hljs-regexp">/script&gt;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><br><br>// 子组件(child)<br><br>&lt;script&gt;<br>export default&#123;<br>  data()&#123;&#125;,<br>  methods:&#123;<br>    childMethod()&#123;<br>      console.log(<span class="hljs-string">&#x27;test&#x27;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>5) $attrs</strong><br>子组件的$attrs 对象包含了除组件所声明的 props 和 emits 之外的所有其他 attribute，例如 class，style，v-on 监听器等等。子组件可以利用<code>v-bind=&quot;$attrs&quot;</code>将属性传到目标元素上。<br>vue2 中$listeners包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。而在vue3，$listeners 被移除了</p><h3 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h3><h4 id="parent"><a href="#parent" class="headerlink" title="$parent"></a>$parent</h4><p>$parent 可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法）<br>可以通过共同的父组件来管理状态和事件函数。比如说其中一个兄弟组件调用父组件传递过来的事件函数修改父组件中的状态，然后父组件将状态传递给另一个兄弟组件。</p><h4 id="eventBus"><a href="#eventBus" class="headerlink" title="eventBus"></a>eventBus</h4><p>Vue3 中移除了事件总线，但是可以借助于第三方工具来完成，Vue 官方推荐 mitt 或 tiny-emitter；<br>但基本的使用方法保持不变，组件 1 使用 emit 函数发送事件名和参数，组件 2 使用 on 函数监听对应的事件名，执行处理函数</p><h3 id="跨多层次组件通信"><a href="#跨多层次组件通信" class="headerlink" title="跨多层次组件通信"></a>跨多层次组件通信</h3><h4 id="provide、inject"><a href="#provide、inject" class="headerlink" title="provide、inject"></a>provide、inject</h4><p>祖先组件：使用 provide 属性或方法，指定想要提供给后代组件的数据或方法<br>后代组件：使用 inject 获取祖先组件的值</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">// 祖先组件</span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; ref, provide &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; fooSymbol &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./injectionSymbols&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 提供静态值</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 提供响应式的值</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;count&#x27;</span>, count)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 提供时将 Symbol 作为 key</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">provide</span>(fooSymbol, count)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml">/////////////////////////////////////////////////</span><br><span class="language-xml">// 后代组件</span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; inject &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; fooSymbol &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./injectionSymbols&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 注入值的默认方式</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> foo = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 注入响应式的值</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;count&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 通过 Symbol 类型的 key 注入</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> foo2 = <span class="hljs-title function_">inject</span>(fooSymbol)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 注入一个值，若为空则使用提供的默认值</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> bar = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;default value&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 注入时为了表明提供的默认值是个函数，需要传入第三个参数</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> fn = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;function&#x27;</span>, <span class="hljs-function">() =&gt;</span> </span></span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml"><span class="language-javascript">, <span class="hljs-literal">false</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"></span><br></code></pre></td></tr></table></figure><h2 id="Vue-生态"><a href="#Vue-生态" class="headerlink" title="Vue 生态"></a>Vue 生态</h2><h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><h4 id="前端路由和后端路由区别"><a href="#前端路由和后端路由区别" class="headerlink" title="前端路由和后端路由区别"></a>前端路由和后端路由区别</h4><p>前端路由：页面跳转的 URL 规则匹配由前端来控制，把渲染的任务交给了浏览器，通过客户端的算力来解决页面的构建<br>后端路由：浏览器地址输入栏输入 URL 回车时后端根据路径将对应的 html 模版渲染好返回给前端</p><h4 id="直接使用-a-链接与使用-router-link-的区别"><a href="#直接使用-a-链接与使用-router-link-的区别" class="headerlink" title="直接使用 a 链接与使用 router-link 的区别"></a>直接使用 a 链接与使用 router-link 的区别</h4><p>抹平了两种模式下 href 的书写方式，会得到正确的 href 值；history 模式下调用 pushState 并阻止默认行为。</p><h4 id="hash-模式和-history-模式区别"><a href="#hash-模式和-history-模式区别" class="headerlink" title="hash 模式和 history 模式区别"></a>hash 模式和 history 模式区别</h4><h5 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a>hash 模式</h5><p>开发中默认的模式，它的 URL 带着一个#。<br>特点：hash 值会出现在 URL 里面，但是不会出现在 HTTP 请求中，对后端完全没有影响。所以改变 hash 值，不会重新加载页面。<br>原理： hash 模式的主要原理就是监听 onhashchange()事件</p><h5 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a>history 模式</h5><p>传统的路由分发模式，即用户在输入一个 URL 时，服务器会接收这个请求，并解析这个 URL，然后做出相应的逻辑处理。URL 不会带#。<br>特点：history 模式下的某些路径如果后台没有配置，URL 输入访问时会返回 404。解决方法为需要在服务器上添加一个简单的回退路由。<br>原理：通过按钮进行的路由跳转用 pushState、replaceState 来改变路由但不触发后端请求，再用回调函数调用新页面组件；点击浏览器前进后退按钮时监听 popstate 事件进行页面切换</p><h4 id="route-和-router-的区别"><a href="#route-和-router-的区别" class="headerlink" title="$route 和$router 的区别"></a>$route 和$router 的区别</h4><p>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数<br>$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</p><h4 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h4><h5 id="全局路由钩子"><a href="#全局路由钩子" class="headerlink" title="全局路由钩子"></a>全局路由钩子</h5><p><strong>beforeEach</strong><br>触发时机：进入路由之前<br>应用：登录态判断跳转<br><strong>beforeResolve</strong><br>触发时机：进入路由之前、可以访问 route 配置中自定义的 meta 变量。在 beforeRouteEnter 之后<br>应用：页面访问权限判断跳转<br><strong>afterEach</strong><br>触发时机：进入路由之后<br>应用：跳转之后滚动条回到顶部</p><h5 id="单个路由钩子"><a href="#单个路由钩子" class="headerlink" title="单个路由钩子"></a>单个路由钩子</h5><p><strong>beforeEnter</strong><br>在路由配置文件中使用，beforeEnter 属性可传入函数数组<br>触发时机：只在进入路由时触发，不会在 params、query 或 hash 改变时触发。<br>应用：为不同的路由配置重定向逻辑</p><h5 id="路由组件内钩子"><a href="#路由组件内钩子" class="headerlink" title="路由组件内钩子"></a>路由组件内钩子</h5><p><strong>beforeRouteEnter</strong><br>触发时机 ∶ 进入组件前触发，此时组件未创建，不能用 this<br><strong>beforeRouteUpdate</strong><br>触发时机 ∶ 当前地址改变并且改组件被复用时触发，举例来说，带有动态参数的路径 foo&#x2F;∶id，在 &#x2F;foo&#x2F;1 和 &#x2F;foo&#x2F;2 之间跳转的时候，由于会渲染同样的 foo 组件，这个钩子在这种情况下就会被调用。发生在 beforeEnter 前<br><strong>beforeRouteLeave</strong><br>触发时机 ∶ 离开组件被调用<br>应用：离开页面前弹出提示语</p><h5 id="路由钩子执行生命周期的顺序"><a href="#路由钩子执行生命周期的顺序" class="headerlink" title="路由钩子执行生命周期的顺序"></a>路由钩子执行生命周期的顺序</h5><ol><li>导航被触发。</li><li>在失活的组件里调用 beforeRouteLeave 守卫。</li><li>调用全局的 beforeEach 守卫。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。</li><li>在路由配置里调用 beforeEnter。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫(2.5+)。</li><li>导航被确认。</li><li>调用全局的 afterEach 钩子。</li><li>触发 DOM 更新。</li><li>调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ol><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><p>为 Vue.js 应用程序开发的状态管理模式。</p><h4 id="vuex-属性"><a href="#vuex-属性" class="headerlink" title="vuex 属性"></a>vuex 属性</h4><ul><li>state：数据源存放地</li><li>getters：从基本数据 state 派生出来的数据，store 的计算属性</li><li>mutations：同步提交更改数据的方法(目的：方便调试)</li><li>actions：异步调用 mutation 方法</li><li>module：模块化 vuex</li></ul><h4 id="vuex-vs-localStorage"><a href="#vuex-vs-localStorage" class="headerlink" title="vuex vs localStorage"></a>vuex vs localStorage</h4><ol><li>存储位置：vuex 存储在内存，localStorage 则以文件的方式存储在本地</li><li>存储内容：localStorage 只能存储字符串类型的数据</li><li>持久性：刷新页面时 vuex 存储的值会丢失，localstorage 不会</li></ol><h3 id="pinia"><a href="#pinia" class="headerlink" title="pinia"></a>pinia</h3><p>全新的 Vue 状态管理库，vuex 的代替者。</p><h4 id="pinia-特点"><a href="#pinia-特点" class="headerlink" title="pinia 特点"></a>pinia 特点</h4><ol><li>Vue2 和 Vue3 都能支持</li><li>抛弃传统的 mutation ，只有 state, getter 和 action ，简化状态管理库</li><li>不需要嵌套模块，符合 Vue3 的 Composition api，让代码扁平化</li><li>TypeScript 支持</li></ol><h4 id="pinia-数据修改"><a href="#pinia-数据修改" class="headerlink" title="pinia 数据修改"></a>pinia 数据修改</h4><p><strong>简单数据修改</strong>：直接操作 <code>store.属性名</code>进行修改<br><strong>多条数据修改</strong>：</p><ol><li>使用$patch 方法。patch 接受对象和函数作为入参。在涉及集合的修改(例如，从数组中推送、移除、拼接一个元素)的操作，使用对象的语法更加耗时，官方文档推荐使用函数。代码示例：</li></ol><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">store</span>.$patch(&#123;<br>  var<span class="hljs-number">1</span>:<span class="hljs-keyword">store</span>.var<span class="hljs-number">1</span>++<span class="hljs-punctuation">,</span><br>  var<span class="hljs-number">2</span>:<span class="hljs-keyword">store</span>.var<span class="hljs-number">2</span>++<br>&#125;)<br><span class="hljs-keyword">store</span>.$patch((<span class="hljs-keyword">store</span>)<span class="hljs-operator">=</span>&gt;&#123;<br>  var<span class="hljs-number">1</span>:<span class="hljs-keyword">store</span>.var<span class="hljs-number">1</span>++<span class="hljs-punctuation">,</span><br>  var<span class="hljs-number">2</span>:<span class="hljs-keyword">store</span>.var<span class="hljs-number">2</span>++<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="2"><li>使用 store 的 action 方法</li></ol><h2 id="Vue-项目开发注意事项"><a href="#Vue-项目开发注意事项" class="headerlink" title="Vue 项目开发注意事项"></a>Vue 项目开发注意事项</h2><h3 id="assets-和-static-的区别"><a href="#assets-和-static-的区别" class="headerlink" title="assets 和 static 的区别"></a>assets 和 static 的区别</h3><p>相同点：都是存放静态资源文件。<br>不同点：assets 中存放的静态资源文件在项目打包时会进行压缩体积，代码格式化操作。static 文件夹下的文件则不会。</p><h3 id="Class-与-Style-如何动态绑定"><a href="#Class-与-Style-如何动态绑定" class="headerlink" title="Class 与 Style 如何动态绑定"></a>Class 与 Style 如何动态绑定</h3><p>使用对象语法或数组语法进行绑定。这里以 class 为例，style 类似</p><ul><li>对象语法</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> v-bind:<span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br><br>data: &#123;<br>  isActive: <span class="hljs-literal">true</span>,<br>  hasError: <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>数组语法</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;div v-bind:<span class="hljs-keyword">class</span>=&quot;[<span class="hljs-symbol">isActive</span> ? <span class="hljs-symbol">activeClass</span> : &#x27;&#x27;, <span class="hljs-symbol">errorClass</span>]&quot;&gt;&lt;/<span class="hljs-symbol">div</span>&gt;<br><br><span class="hljs-symbol">data: </span>&#123;<br>  activeClass: <span class="hljs-string">&#x27;active&#x27;</span>,<br>  errorClass: <span class="hljs-string">&#x27;text-danger&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/6964779204462247950/">「2021」高频前端面试题汇总之 Vue 篇（下）</a><br>（2）<a href="https://juejin.cn/post/7064368176846340132"> Vue 这一块拿捏了</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前端 vue 框架方面知识整理。&lt;/p&gt;</summary>
    
    
    
    <category term="前端基础" scheme="https://unknown404.github.io/unkown404.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="vue" scheme="https://unknown404.github.io/unkown404.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>ES7装饰器语法</title>
    <link href="https://unknown404.github.io/unkown404.github.io/2022/09/02/decorator/"/>
    <id>https://unknown404.github.io/unkown404.github.io/2022/09/02/decorator/</id>
    <published>2022-09-02T07:50:56.000Z</published>
    <updated>2023-02-19T03:19:04.423Z</updated>
    
    <content type="html"><![CDATA[<p>装饰器是是一种与类（class）相关的语法，用来注释或修改类和类方法。装饰器在 Python 和 Java 等语言中也被大量使用。目前在前端框架 Nestjs 也已经有应用。因此本文主要记录装饰器相关的知识点，帮助理解 Nestjs 程序。</p><span id="more"></span><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>装饰器模式是一种结构型设计模式，它允许向一个现有的对象添加新的功能，同时又不改变其结构，是作为对现有类的一个包装。<br>装饰器是针对这种设计模式的一个语法糖。其用法是：使用 @ 作为标识符，紧跟返回装饰器函数的表达式，被放置在被装饰代码前面。<br>由于该语法目前还处于第 2 阶段提案中，使用它之前需要使用 Babel 模块编译成 ES5 或 ES6。</p><h2 id="装饰器用法"><a href="#装饰器用法" class="headerlink" title="装饰器用法"></a>装饰器用法</h2><p>装饰器主要用于:</p><ol><li>装饰类</li><li>装饰方法或属性</li></ol><h3 id="装饰类"><a href="#装饰类" class="headerlink" title="装饰类"></a>装饰类</h3><p>装饰类的时候，装饰器方法一般会接收一个目标类作为参数。</p><h4 id="babel-编译情况"><a href="#babel-编译情况" class="headerlink" title="babel 编译情况"></a>babel 编译情况</h4><p>编译前：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@annotation</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123; &#125;<br><br><span class="hljs-function">function <span class="hljs-title">annotation</span><span class="hljs-params">(<span class="hljs-keyword">target</span>)</span> </span>&#123;<br>   <span class="hljs-keyword">target</span>.annotated = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译后：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">var <span class="hljs-number">_</span><span class="hljs-keyword">class</span>;<br><br><span class="hljs-keyword">let</span> MyClass = <span class="hljs-keyword">annotation</span>(<span class="hljs-number">_</span><span class="hljs-keyword">class</span> = <span class="hljs-keyword">class</span> MyClass &#123;&#125;) || <span class="hljs-number">_</span><span class="hljs-keyword">class</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">annotation</span>(target) &#123;<br>  target.annotated = true;<br>&#125;<br></code></pre></td></tr></table></figure><p>从编译的结果可以看出类装饰器的第一个参数就是要装饰的类，它的功能就是对类进行处理。</p><h4 id="类装饰器的作用"><a href="#类装饰器的作用" class="headerlink" title="类装饰器的作用"></a>类装饰器的作用</h4><ol><li>给目标类增加静态属性</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> add<span class="hljs-constructor">Attribute(<span class="hljs-params">targetClass</span>)</span> &#123;<br>  targetClass.isUseDecorator = <span class="hljs-literal">true</span>;<br>&#125;<br><br>@addAttribute<br><span class="hljs-keyword">class</span> TargetClass &#123; &#125;<br><br>console.log(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TargetClass</span>.</span></span>isUseDecorator); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>在上面这个例子中，我们定义了 addAttribute 的装饰器，用于为 TargetClass 添加静态属性 isUseDecorator 并设置为 true。<br>另一方面，类装饰器可以使用表达式传入参数为静态属性赋值，利用装饰器工厂模式。如下面的代码：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">function</span> <span class="hljs-title function_">addAttribute</span>(<span class="hljs-params">content</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable">function</span> <span class="hljs-title function_">decFn</span>(<span class="hljs-params">targetClass</span>) &#123;<br>    <span class="hljs-variable">targetClass</span>.<span class="hljs-property">content</span> <span class="hljs-operator">=</span> <span class="hljs-variable">content</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable">targetClass</span>;<br>  &#125;;<br>&#125;<br><br>@<span class="hljs-title function_">addAttribute</span>(&#x27;这是内容～～～&#x27;)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TargetClass</span> &#123; &#125;<br><br><span class="hljs-variable">console</span>.<span class="hljs-property">log</span>(<span class="hljs-title class_">TargetClass</span>.<span class="hljs-property">content</span>); <span class="hljs-comment">// 这是内容～～～</span><br></code></pre></td></tr></table></figure><p>该示例就是为 TargetClass 添加静态属性 content 并用传入的参数‘这是内容～～～’为 content 赋值。这种使用方法更加灵活。</p><ol start="2"><li>添加原型方法<br>既然类装饰器接收的参数就是类定义本身，那么该装饰器也可以通过访问类的 prototype 属性来添加或修改原型方法</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">targetClass</span>) &#123;<br>  targetClass.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">decFun</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;这里是装饰器 decorator 添加的原型方法 decFun~&#x27;</span>);<br>  &#125;;<br>&#125;<br><br>@decorator<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TargetClass</span> &#123; &#125;<br><br><span class="hljs-keyword">const</span> targetClass = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TargetClass</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(targetClass);<br>targetClass.<span class="hljs-title function_">decFun</span>();<br></code></pre></td></tr></table></figure><h3 id="装饰方法和属性"><a href="#装饰方法和属性" class="headerlink" title="装饰方法和属性"></a>装饰方法和属性</h3><h4 id="预备知识：属性描述符"><a href="#预备知识：属性描述符" class="headerlink" title="预备知识：属性描述符"></a>预备知识：属性描述符</h4><p>属性描述符表达了一个属性的相关信息(元数据）,本质上是一个对象。属性主要分为两种：访问器属性和数据属性。</p><h5 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h5><p>特点：当给属性赋值或者取值的时候，会自动的运行一个函数。<br>具有描述符属性：configurable、enumerable、get、set</p><h5 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h5><p>特点：在我们使用对象的过程中，对一个对象进行取值和赋值的时候，该属性称之为 数据属性<br>具有描述符属性：configurable、enumerable、writable、value<br>如示例所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> o = &#123;&#125;;<br>o.a = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 等同于 :</span><br><span class="hljs-built_in">Object</span>.defineProperty(o, <span class="hljs-string">&quot;a&quot;</span>, &#123;<br>  value : <span class="hljs-number">1</span>,<br>  writable : <span class="hljs-keyword">true</span>,<br>  configurable : <span class="hljs-keyword">true</span>,<br>  enumerable : <span class="hljs-keyword">true</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>两种属性共有的属性为 configurable 和 enumerable。<br>configurable：是否可配置，默认为 false。为 true 时，表示当前属性的‘属性表述符’对象可以被更改，该属性可以使用 delete 删除<br>enumerable：是否可枚举，默认为 false。为 true 时，表示当前属性可以被枚举，也就是当前属性是否可以在 for…in 循环和 Object.keys() 中被遍历出来</p><p>(value 和 writable)与(get 和 set)是不共存的，只要定义了其中一个，就定下来了该描述符的性质是数据属性还是访问器属性。</p><h4 id="babel-编译情况-1"><a href="#babel-编译情况-1" class="headerlink" title="babel 编译情况"></a>babel 编译情况</h4><p>根据<a href="https://github.com/mqyqingfeng/Blog/issues/109">ES6 系列之我们来聊聊装饰器</a>,babel 编译后的方法装饰器可以分为 3 个处理步骤：</p><ol><li>拷贝需要装饰的属性其对应的属性描述符<br>使用 Object.getOwnPropertyDescriptor 可以获得指定属性的属性描述符。该函数接收两个参数：属性所在对象和要取得描述的属性。<br>其中 Babel 的 Class 为了与 decorator 配合而产生了一个属性 initializer</li><li>应用多个 decorators 方法：当同一个方法使用多个装饰器模型时，遵从洋葱模型，从外到内进入，然后由内向外执行</li></ol><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">decorator1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;decorator1&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">decFn1</span>(<span class="hljs-params">targetClass</span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;decFn1&#x27;</span>);<br>    <span class="hljs-keyword">return</span> targetClass;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">decorator2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;decorator2&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">decFn2</span>(<span class="hljs-params">targetClass</span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;decFn2&#x27;</span>);<br>    <span class="hljs-keyword">return</span> targetClass;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>假如存在装饰器 decorator1、decorator2，修饰同一个方法 targetFunc，其输出结果为：<code>decorator1-&gt;decorator2-&gt;decFn2-&gt;decFn1</code></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@decorator1</span>()<br><span class="hljs-variable">@decorator2</span>()<br>targetFunc()<br></code></pre></td></tr></table></figure><ol start="3"><li>处理需要装饰的属性或方法，属性描述符的调整最终还是由 Object.defineProperty 来实现</li></ol><h4 id="方法装饰器使用方法"><a href="#方法装饰器使用方法" class="headerlink" title="方法装饰器使用方法"></a>方法装饰器使用方法</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function">function <span class="hljs-title">readonly</span><span class="hljs-params">(<span class="hljs-keyword">target</span>, name, descriptor)</span> </span>&#123;<br>  descriptor.writable = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-keyword">return</span> descriptor;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-meta">@readonly</span><br>  name = <span class="hljs-string">&#x27;zhangsan&#x27;</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person();<br></code></pre></td></tr></table></figure><p>如示例所示，方法装饰器接收的入参同 Object.defineProperty 一致，包括：</p><ul><li>要定义属性的对象（obj）</li><li>要定义或修改的属性名或 Symbol（props）</li><li>要定义或修改的属性描述符（descriptor）</li></ul><h2 id="装饰器应用"><a href="#装饰器应用" class="headerlink" title="装饰器应用"></a>装饰器应用</h2><h3 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h3><p>使用高阶函数 connect 时，需要将代码写成以下格式：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyReactComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(<span class="hljs-type">MyReactComponent</span>);<br></code></pre></td></tr></table></figure><p>而使用装饰器后代码可简化为：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@connect</span>(mapStateToProps, mapDispatchToProps)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyReactComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;&#125;;<br></code></pre></td></tr></table></figure><p>语义也更加简洁明了</p><h3 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h3><p>在频繁触发事件的场景下，为了提升性能常会用防抖和节流函数，其特点是会返回一个匿名函数。为了能在组件销毁时能有效解绑事件，需要用变量将匿名函数存储起来。但使用装饰器语法后就不需要再设置多余的变量了。防抖装饰器的实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//防抖函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_debounce</span>(<span class="hljs-params">func, wait, immediate</span>) &#123;<br><br>    <span class="hljs-keyword">var</span> timeout;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> context = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-keyword">var</span> args = <span class="hljs-variable language_">arguments</span>;<br><br>        <span class="hljs-keyword">if</span> (timeout) <span class="hljs-built_in">clearTimeout</span>(timeout);<br>        <span class="hljs-keyword">if</span> (immediate) &#123;<br>            <span class="hljs-keyword">var</span> callNow = !timeout;<br>            timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>                timeout = <span class="hljs-literal">null</span>;<br>            &#125;, wait)<br>            <span class="hljs-keyword">if</span> (callNow) func.<span class="hljs-title function_">apply</span>(context, args)<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>                func.<span class="hljs-title function_">apply</span>(context, args)<br>            &#125;, wait);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//防抖装饰器</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">wait, immediate</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleDescriptor</span>(<span class="hljs-params">target, key, descriptor</span>) &#123;<br>    <span class="hljs-keyword">const</span> callback = descriptor.<span class="hljs-property">value</span>;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyntaxError</span>(<span class="hljs-string">&#x27;Only functions can be debounced&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> fn = <span class="hljs-title function_">_debounce</span>(callback, wait, immediate)<br><br>    <span class="hljs-keyword">return</span> &#123;<br>      ...descriptor,<br>      <span class="hljs-title function_">value</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">fn</span>()<br>      &#125;<br>    &#125;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在使用时只需要在目标函数上方添加@debounce，传入等待时间和是否立即响应的变量即可。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Toggle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br><br>  <span class="hljs-meta">@debounce</span>(<span class="hljs-number">500</span>, <span class="hljs-literal">true</span>)<br>  handleClick() &#123;<br>    console.log(&#x27;toggle&#x27;)<br>  &#125;<br><br>  render() &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;button onClick=&#123;<span class="hljs-keyword">this</span>.handleClick&#125;&gt;<br>        button<br>      &lt;/button&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>节流的实现也基本相似，这里不再列举。</p><h2 id="TypeScript-装饰器"><a href="#TypeScript-装饰器" class="headerlink" title="TypeScript 装饰器"></a>TypeScript 装饰器</h2><p>在 TypeScript 中，可以实现以下五种装饰器：类装饰器、方法装饰器、属性装饰器、访问器装饰器、参数装饰器</p><h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>格式：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs r"><span class="hljs-keyword">function</span> classDecorator<span class="hljs-operator">&lt;</span><span class="hljs-built_in">T</span> extends Constructor<span class="hljs-operator">&gt;</span><span class="hljs-punctuation">(</span>targetClass<span class="hljs-operator">:</span><span class="hljs-built_in">T</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">&#123;</span><br><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>入参：<br>targetClass - 类构造器</p><h3 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h3><p>格式：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-keyword">method</span><span class="hljs-constructor">Decorator(<span class="hljs-params">target</span>: Object, <span class="hljs-params">propertyName</span>: <span class="hljs-params">string</span>, <span class="hljs-params">propertyDescriptor</span>: PropertyDescriptor)</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>入参：<br>target - 如果是静态方法就是类的构造器（TargetClass），如果是实例方法就是类的原型（TargetClass.prototype）<br>propertyName - 函数名<br>propertyDescriptor - 函数的属性描述符</p><h3 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h3><p>格式：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> property<span class="hljs-constructor">Decorator(<span class="hljs-params">target</span>: Object, <span class="hljs-params">propertyName</span>: <span class="hljs-params">string</span>)</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>入参：<br>target - 如果是静态方法就是类的构造器（TargetClass），如果是实例方法就是类的原型（TargetClass.prototype）<br>propertyName - 属性名</p><h3 id="参数装饰器"><a href="#参数装饰器" class="headerlink" title="参数装饰器"></a>参数装饰器</h3><p>格式：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> parameter<span class="hljs-constructor">Decorator(<span class="hljs-params">target</span>: Object, <span class="hljs-params">propertyName</span>: <span class="hljs-params">string</span>, <span class="hljs-params">index</span>: <span class="hljs-params">number</span>)</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>入参：<br>target - 如果是静态方法就是类的构造器（TargetClass），如果是实例方法就是类的原型（TargetClass.prototype）<br>propertyName - 参数名<br>index - 参数在函数参数列表的位置</p><h3 id="访问器装饰器"><a href="#访问器装饰器" class="headerlink" title="访问器装饰器"></a>访问器装饰器</h3><p>格式：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> accessor<span class="hljs-constructor">Decorator(<span class="hljs-params">target</span>: Object, <span class="hljs-params">propertyName</span>: <span class="hljs-params">string</span>, <span class="hljs-params">propertyDescriptor</span>: PropertyDescriptor)</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>入参：<br>target - 如果是静态方法就是类的构造器（TargetClass），如果是实例方法就是类的原型（TargetClass.prototype）<br>propertyName - 属性名<br>propertyDescriptor - 函数的属性描述符</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://github.com/mqyqingfeng/Blog/issues/109">系列之我们来聊聊装饰器</a><br>（2）<a href="https://juejin.cn/post/7072883925764276254">Decorator 装饰器</a><br>（3）<a href="https://juejin.cn/post/6844904100144889864">都 2020 年了，你还不会 JavaScript 装饰器</a><br>（4）<a href="https://juejin.cn/post/6996590290555371534">TypeScript 装饰器的基本语法</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;装饰器是是一种与类（class）相关的语法，用来注释或修改类和类方法。装饰器在 Python 和 Java 等语言中也被大量使用。目前在前端框架 Nestjs 也已经有应用。因此本文主要记录装饰器相关的知识点，帮助理解 Nestjs 程序。&lt;/p&gt;</summary>
    
    
    
    <category term="前端技术体系" scheme="https://unknown404.github.io/unkown404.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="ES6" scheme="https://unknown404.github.io/unkown404.github.io/tags/ES6/"/>
    
    <category term="JavaScript" scheme="https://unknown404.github.io/unkown404.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ES6语法</title>
    <link href="https://unknown404.github.io/unkown404.github.io/2022/08/29/es6/"/>
    <id>https://unknown404.github.io/unkown404.github.io/2022/08/29/es6/</id>
    <published>2022-08-29T09:01:20.000Z</published>
    <updated>2023-02-19T03:19:04.423Z</updated>
    
    <content type="html"><![CDATA[<p>面试时常问的 ES6 特性</p><span id="more"></span><h2 id="let-const"><a href="#let-const" class="headerlink" title="let,const"></a>let,const</h2><p>创建块级作用域，若调用发生在声明前会暂时性死区<br>const 指向地址不能改变，但可以增加内部属性</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>特点：没有 this 和 arguments；不能作为构造函数；没有函数提升</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br> <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tyler&#x27;</span>,<br> <span class="hljs-attr">a</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;Anderson&#x27;</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-title function_">test</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>  &#125;<br>  <span class="hljs-title function_">test</span>()<br> &#125;,<br>&#125;<br>obj.<span class="hljs-title function_">a</span>()<br><br><span class="hljs-comment">// Tyler</span><br><span class="hljs-comment">// 找到最近的非箭头函数a，所以箭头函数的this 就是a 的this。</span><br><span class="hljs-comment">// a目前是由obj调用的，因此此时箭头函数的this 为obj</span><br></code></pre></td></tr></table></figure><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>使用方法：const proxy &#x3D; new Proxy(target, handler)<br>输入参数：</p><ul><li>target：拦截的目标对象</li><li>handler：定制拦截行为</li></ul><h3 id="Proxy-与-Object-defineProperty-对比"><a href="#Proxy-与-Object-defineProperty-对比" class="headerlink" title="Proxy 与 Object.defineProperty 对比"></a>Proxy 与 Object.defineProperty 对比</h3><p>Proxy 的优点：</p><ul><li>Proxy 可以直接监听整个对象而非属性。</li><li>Proxy 可以直接监听数组的变化。</li><li>Proxy 有 13 中拦截方法，如 ownKeys、deleteProperty、has 等是 Object.defineProperty 不具备的。</li><li>Proxy 返回的是一个新对象，我们可以只操作新的对象达到目的，而 Object.defineProperty 只能遍历对象属性直接修改;</li><li>Proxy 做为新标准将受到浏览器产商重点持续的性能优化,也就是传说中的新标准的性能红利。</li></ul><p>Object.defineProperty 的优点：</p><ul><li>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平。</li></ul><p>Object.defineProperty 的缺点：</p><ul><li>Object.defineProperty 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。</li><li>Object.defineProperty 不能监听数组。是通过重写数据的那 7 个可以改变数据的方法来对数组进行监听的。</li><li>Object.defineProperty 也不能对 es6 新产生的 Map,Set 这些数据结构做出监听。</li><li>Object.defineProperty 也不能监听新增和删除操作，通过 Vue.set()和 Vue.delete 来实现响应式的。</li></ul><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>导入导出方式：import、export</p><h3 id="commonJs-vs-ES6"><a href="#commonJs-vs-ES6" class="headerlink" title="commonJs vs ES6"></a>commonJs vs ES6</h3><ol><li>commonJs 输出是值的拷贝，es6 输出值的引用</li><li>commonJs 模块运行时加载（先加载全部模块再导入方法），es6 模块是编译时加载（指定加载某输出值）</li><li>commonJs 同步导入，es6 模块异步导入</li></ol><h3 id="其他模块化方法特点"><a href="#其他模块化方法特点" class="headerlink" title="其他模块化方法特点"></a>其他模块化方法特点</h3><p>amd 和 requireJs：依赖前置，提前执行<br>cmd 和 seaJs：依赖后置，延迟执行<br>umd：通用模块定义规范</p><h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>3 种状态：1）pending；2）resolved；3）rejected<br>特点：1）立即执行；2）then 异步回调；3）状态不可逆；4）链式调用</p><h4 id="promise-简易实现"><a href="#promise-简易实现" class="headerlink" title="promise 简易实现"></a>promise 简易实现</h4><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs pf">function myPromise(fn) &#123;<br>    <span class="hljs-keyword">const</span> that = this<br>    that.<span class="hljs-keyword">state</span> = &#x27;pending&#x27;<br>    that.value = null<br>    that.resolvedCallbacks = []<br>    that.rejectedCallbacks = []<br><br>    function resolve(value) &#123;<br>        if (that.<span class="hljs-keyword">state</span> === &#x27;pending&#x27;) &#123;<br>            that.<span class="hljs-keyword">state</span> = &#x27;resolved&#x27;<br>            that.value = value<br>            that.resolvedCallbacks.map(cb =&gt; cb(value))<br>        &#125;<br>    &#125;<br><br>    function reject(value) &#123;<br>        if (that.<span class="hljs-keyword">state</span> === &#x27;pending&#x27;) &#123;<br>            that.<span class="hljs-keyword">state</span> = &#x27;rejected&#x27;<br>            that.value = value<br>            that.rejectedCallbacks.map(cb =&gt; cb(value))<br>        &#125;<br>    &#125;<br>    try &#123;<br>        fn(resolve, reject)<br>    &#125; catch (e) &#123;<br>        reject(e)<br>    &#125;<br>&#125;<br>myPromise.prototype.then = function (<span class="hljs-keyword">on</span>Fulfilled, <span class="hljs-keyword">on</span>Rejected) &#123;<br>    <span class="hljs-keyword">const</span> that = this<br>    <span class="hljs-keyword">on</span>Fulfilled = typeof <span class="hljs-keyword">on</span>Fulfilled === &#x27;function&#x27; ? <span class="hljs-keyword">on</span>Fulfilled : v =&gt; v<br>    <span class="hljs-keyword">on</span>Rejected = typeof <span class="hljs-keyword">on</span>Rejected === &#x27;function&#x27; ? <span class="hljs-keyword">on</span>Rejected : e =&gt;<br>        throw e<br>    if (that.<span class="hljs-keyword">state</span> === &#x27;resolved&#x27;) <span class="hljs-keyword">on</span>Fulfilled(that.value)<br>    if (that.<span class="hljs-keyword">state</span> === &#x27;rejected&#x27;) <span class="hljs-keyword">on</span>Rejected(that.value)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h3><p>generator 的语法糖。<br>async 声明 function 是一个异步函数，返回一个 promise 对象，可以使用 then 方法添加回调函数。<br>await 操作符只能在异步函数 async function 内部使用。await 会阻塞后面的代码，等待接在 await 后面的表达式返回 Promise 对象结果。</p><h2 id="数据类型-Set、Map"><a href="#数据类型-Set、Map" class="headerlink" title="数据类型 Set、Map"></a>数据类型 Set、Map</h2><h3 id="Set-和-weakSet、Map-和-WeakMap-区别"><a href="#Set-和-weakSet、Map-和-WeakMap-区别" class="headerlink" title="Set 和 weakSet、Map 和 WeakMap 区别"></a>Set 和 weakSet、Map 和 WeakMap 区别</h3><p>weakSet 结构与 Set 类似，是不重复值集合，但 weakSet 只能是对象且为弱引用，且不可遍历<br>weakMap 结构与 Map 类似，但 weakMap 只接受对象为键名，键名是对象弱引用，且不可遍历</p><h3 id="Map-和-Object-的区别"><a href="#Map-和-Object-的区别" class="headerlink" title="Map 和 Object 的区别"></a>Map 和 Object 的区别</h3><p>1）Key filed：在 Object 中， key 必须是简单数据类型（整数，字符串或者是 symbol），而在 Map 中则可以是 JavaScript 支持的所有数据类型，也就是说可以用一个 Object 来当做一个 Map 元素的 key。<br>2）元素顺序：Map 元素的顺序遵循插入的顺序，而 Object 的则没有这一特性。<br>3）初始化、增查删改方式</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;面试时常问的 ES6 特性&lt;/p&gt;</summary>
    
    
    
    <category term="前端基础" scheme="https://unknown404.github.io/unkown404.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="ES6" scheme="https://unknown404.github.io/unkown404.github.io/tags/ES6/"/>
    
    <category term="JavaScript" scheme="https://unknown404.github.io/unkown404.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>依赖包管理工具比较</title>
    <link href="https://unknown404.github.io/unkown404.github.io/2022/08/23/packageInfo/"/>
    <id>https://unknown404.github.io/unkown404.github.io/2022/08/23/packageInfo/</id>
    <published>2022-08-23T14:06:42.000Z</published>
    <updated>2023-02-19T03:19:04.428Z</updated>
    
    <content type="html"><![CDATA[<p>前端常用的包依赖管理工具有 npm、yarn 以及近期非常受欢迎的 pnpm，本文主要也是对比这几个工具之间的区别。</p><span id="more"></span><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>最早出现的安装包工具， Node.js 标准的软件包管理器。</p><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p>npm 是围绕着<a href="https://semver.org/">语义版本控制（semver）</a>的思想而设计的。大致的准则为：</p><ul><li>版本号由三部分组成：major.minor.patch，即主版本号.次版本号.修补版本号。<ul><li>主版本号：更改时代表了一个破坏兼容性的大变化。</li><li>次版本号：更改时不会破坏任何内容，增加了新功能。</li><li>修补版本号：更改时表示做了向后兼容的缺陷修复。</li></ul></li><li>版本是严格递增的，如该例所示：16.2.0 -&gt; 16.3.0 -&gt; 16.3.1</li><li>修补版本号有时后面可能还会有先行版本号，例如 1.0.0-alpha.1。常用的先行版本一般为 alpha（内部先行版），beta（公开测试版），rc（候选版），stable（稳定版）</li></ul><h4 id="版本控制符"><a href="#版本控制符" class="headerlink" title="版本控制符"></a>版本控制符</h4><p>使用 npm install 时，会发现 package.json 文件的版本号前面默认出现符号<code>^</code>，该符号即为版本控制符。常见的版本控制符包括：</p><ul><li><code>~</code> 会匹配最近的小版本依赖包，比如 ~1.2.3 会匹配所有 1.2.x 版本，但是不包括 1.3.0</li><li><code>^ </code>会匹配最新的大版本依赖包（npm i 默认的版本控制符），比如 ^1.2.3 会匹配所有 1.x.x 的包，包括 1.3.0，但是不包括 2.0.0</li><li><code>* </code>安装最新版本的依赖包，比如 *1.2.3 会匹配 x.x.x<br>除此之外还有其他版本控制方法：</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123; <span class="hljs-string">&quot;dependencies&quot;</span> :<br>  &#123; <span class="hljs-string">&quot;foo&quot;</span> : <span class="hljs-string">&quot;1.0.0 - 2.9999.9999&quot;</span>,<span class="hljs-regexp">//</span> 大于等于<span class="hljs-number">1.0</span>.<span class="hljs-number">0</span> 小于 <span class="hljs-number">2.9999</span>.<span class="hljs-number">9999</span><br>  <span class="hljs-string">&quot;bar&quot;</span> : <span class="hljs-string">&quot;&gt;=1.0.2 &lt;2.1.2&quot;</span>, <span class="hljs-regexp">//</span> 比较清晰  左闭右开<br>  <span class="hljs-string">&quot;baz&quot;</span> : <span class="hljs-string">&quot;&gt;1.0.2 &lt;=2.3.4&quot;</span>, <span class="hljs-regexp">//</span> 左开右闭<br>  <span class="hljs-string">&quot;boo&quot;</span> : <span class="hljs-string">&quot;2.0.1&quot;</span>, <span class="hljs-regexp">//</span> 规定版本<br>  <span class="hljs-string">&quot;qux&quot;</span> : <span class="hljs-string">&quot;&lt;1.0.0 || &gt;=2.3.1 &lt;2.4.5 || &gt;=2.5.2 &lt;3.0.0&quot;</span>, <span class="hljs-regexp">//</span> 表达式也算清晰<br>  <span class="hljs-string">&quot;asd&quot;</span> : <span class="hljs-string">&quot;http://asdf.com/asdf.tar.gz&quot;</span>, <span class="hljs-regexp">//</span> 指定下载地址代替版本<br>  <span class="hljs-string">&quot;til&quot;</span> : <span class="hljs-string">&quot;^1.2.3&quot;</span>, <span class="hljs-regexp">//</span> 同一主版本号，不小于<span class="hljs-number">1.2</span>.<span class="hljs-number">3</span> 即 <span class="hljs-number">1</span>.x.y  x&gt;=<span class="hljs-number">2</span> y&gt;=<span class="hljs-number">3</span><br>  <span class="hljs-string">&quot;elf&quot;</span> : <span class="hljs-string">&quot;~1.2.3&quot;</span>,  <span class="hljs-regexp">//</span> 同一主版本和次版本号 即<span class="hljs-number">1.2</span>.x x&gt;= <span class="hljs-number">2</span><br>  <span class="hljs-string">&quot;two&quot;</span> : <span class="hljs-string">&quot;2.x&quot;</span> , <span class="hljs-regexp">//</span> 这个比较形象，x&gt;=<span class="hljs-number">0</span>  即<span class="hljs-number">2.0</span>.<span class="hljs-number">0</span> 以上均可<br>  <span class="hljs-string">&quot;thr&quot;</span> : <span class="hljs-string">&quot;3.3.x&quot;</span> , <span class="hljs-regexp">//</span> 同上 x&gt;= <span class="hljs-number">0</span>  即<span class="hljs-number">3.3</span>.<span class="hljs-number">0</span> 以上<br>  <span class="hljs-string">&quot;lat&quot;</span> : <span class="hljs-string">&quot;latest&quot;</span>,  <span class="hljs-regexp">//</span> 最新版本<br>  <span class="hljs-string">&quot;dyl&quot;</span> : <span class="hljs-string">&quot;file:../dyl&quot;</span>,  <span class="hljs-regexp">//</span> 从本地下载<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="package-lock-json"><a href="#package-lock-json" class="headerlink" title="package-lock.json"></a>package-lock.json</h4><p>早期的 npm 没有锁定包版本的功能，如果某个依赖包发布了不兼容或者有 bug 版本，部署上线时项目就可能会发生问题。针对这一问题 yarn 提出了固化版本的方案，而 npm 在^5.x.x.x 以后才有的 package-lock.json。<br>不同版本 npm 对 package-lock.json 的实现是不同的。是在一直迭代和发展的：</p><ol><li>npm 5.0.x 版本，不管 package.json 怎么变，npm i 时都会根据 lock 文件下载。</li><li>5.1.0 版本后 npm install 会无视 lock 文件 去下载最新的 npm 包</li><li>5.4.2 版本如果改了 package.json，且 package.json 和 lock 文件不同，那么执行 npm i 时 npm 会根据 package 中的版本号以及语义含义去下载最新的包，并更新至 lock。<br>如果两者是同一状态，那么执行 npm i 都会根据 lock 下载，不会理会 package 实际包的版本是否有新。</li></ol><p>package-lock.json 的文件格式如下：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs perl">...<br><span class="hljs-string">&quot;@ant-design/colors&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;4.0.5&quot;</span>,<br>    <span class="hljs-string">&quot;resolved&quot;</span>: <span class="hljs-string">&quot;http://npm.internal.focus.cn:80/@ant-design%2fcolors/-/colors-4.0.5.tgz&quot;</span>,<br>    <span class="hljs-string">&quot;integrity&quot;</span>: <span class="hljs-string">&quot;sha1-19EA11Rcyo9iSVRgSmiS/Ei6Wq4=&quot;</span>,<br>    <span class="hljs-string">&quot;requires&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;tinycolor2&quot;</span>: <span class="hljs-string">&quot;^1.4.1&quot;</span><br>    &#125;<br>&#125;,<br><span class="hljs-string">&quot;@ant-design/icons&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;4.6.2&quot;</span>,<br>    <span class="hljs-string">&quot;resolved&quot;</span>: <span class="hljs-string">&quot;https://registry.npmjs.org/@ant-design/icons/-/icons-4.6.2.tgz&quot;</span>,<br>    <span class="hljs-string">&quot;integrity&quot;</span>: <span class="hljs-string">&quot;sha512-QsBG2BxBYU/rxr2eb8b2cZ4rPKAPBpzAR+0v6rrZLp/lnyvflLH3tw1vregK+M7aJauGWjIGNdFmUfpAOtw25A==&quot;</span>,<br>    <span class="hljs-string">&quot;requires&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;@ant-design/colors&quot;</span>: <span class="hljs-string">&quot;^6.0.0&quot;</span>,<br>    <span class="hljs-string">&quot;@ant-design/icons-svg&quot;</span>: <span class="hljs-string">&quot;^4.0.0&quot;</span>,<br>    <span class="hljs-string">&quot;@babel/runtime&quot;</span>: <span class="hljs-string">&quot;^7.11.2&quot;</span>,<br>    <span class="hljs-string">&quot;classnames&quot;</span>: <span class="hljs-string">&quot;^2.2.6&quot;</span>,<br>    <span class="hljs-string">&quot;rc-util&quot;</span>: <span class="hljs-string">&quot;^5.9.4&quot;</span><br>    &#125;,<br>    <span class="hljs-string">&quot;dependencies&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;@ant-design/colors&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;6.0.0&quot;</span>,<br>        <span class="hljs-string">&quot;resolved&quot;</span>: <span class="hljs-string">&quot;https://registry.npmjs.org/@ant-design/colors/-/colors-6.0.0.tgz&quot;</span>,<br>        <span class="hljs-string">&quot;integrity&quot;</span>: <span class="hljs-string">&quot;sha512-qAZRvPzfdWHtfameEGP2Qvuf838NhergR35o+EuVyB5XvSA98xod5r4utvi4TJ3ywmevm290g9nsCG5MryrdWQ==&quot;</span>,<br>        <span class="hljs-string">&quot;requires&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;@ctrl/tinycolor&quot;</span>: <span class="hljs-string">&quot;^3.4.0&quot;</span><br>        &#125;<br>    &#125;<br>    &#125;<br>&#125;,<br>...<br></code></pre></td></tr></table></figure><p>可以看到，安装包需要的依赖包，如果顶级依赖满足需求的，则不再安装，仅有 requires 属性；如果不满足，则会在对应文件夹下面根据依赖安装符合版本，如上面的文件里的@ant-design&#x2F;icons，内部仍有 dependencies 属性。</p><h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><h4 id="npm-2-x"><a href="#npm-2-x" class="headerlink" title="npm 2.x"></a>npm 2.x</h4><p>npm2.x 版本安装依赖包时会安装每一个包所依赖的所有依赖项，依赖项的依赖包也会安装在其 node_modules 目录下。如下图所示，即 node_modules 存在嵌套。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">.</span><br><span class="hljs-bullet"></span>└──node<span class="hljs-emphasis">_modules</span><br><span class="hljs-emphasis">        ├──test1</span><br><span class="hljs-emphasis">        └──test2</span><br><span class="hljs-emphasis">            └──node_</span>modules<br><span class="hljs-code">                    └──test3</span><br></code></pre></td></tr></table></figure><p>这样的处理方式造成了两个问题：</p><ol><li>多个包之间难免会有公共的依赖，这样嵌套的话，同样的依赖会复制很多次，会占据比较大的磁盘空间。</li><li>windows 的文件路径最长是 260 多个字符，这样嵌套是会超过 windows 路径的长度限制的。</li></ol><h4 id="npm-3"><a href="#npm-3" class="headerlink" title="npm 3+"></a>npm 3+</h4><p>同 yarn 一样采用了扁平化依赖的方式解决问题。与之前的目录相比，现在的文件夹结构更接近于</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">.</span><br><span class="hljs-bullet"></span>└──node_modules<br><span class="hljs-code">        ├──test1</span><br><span class="hljs-code">        ├──test2</span><br><span class="hljs-code">        └──test3</span><br></code></pre></td></tr></table></figure><p>所有的依赖都被拍平到 node_modules 目录下，不再有很深层次的嵌套关系。这样在安装新的包时，根据 node require 机制，会不停往上级的 node_modules 当中去找，如果找到相同版本的包就不会重新安装，解决了大量包重复安装的问题，而且依赖层级也不会太深。<br>但扁平化依赖方法存在的问题包括：</p><ul><li>依赖结构的不确定性。</li><li>扁平化算法本身的复杂性很高，耗时较长。</li><li>项目中仍然可以非法访问没有声明过依赖的包<br>依赖结构的不确定性是如果声明的依赖包 test1、test2 同时依赖另一个包 test3，但是是不同版本的时候，扁平化的结果可能有两种。</li></ul><p><em>npm2.x 下 test1、test2 依赖包结构</em></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c">.<br>└──node_modules<br>        ├──test1<br>        <span class="hljs-string">|   └──node_modules</span><br>        <span class="hljs-string">|           └──test3@1.0.1</span><br>        └──test2<br>            └──node_modules<br>                    └──test3@<span class="hljs-number">1.0</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><em>npm3+下 test1、test2 安装结果 1</em></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c">.<br>└──node_modules<br>        ├──test1<br>        └──test2<br>        <span class="hljs-string">|   └──node_modules</span><br>        <span class="hljs-string">|           └──test3@1.0.2</span><br>        └──test3@<span class="hljs-number">1.0</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><em>npm3+下 test1、test2 安装结果 2</em></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c">.<br>└──node_modules<br>        ├──test1<br>        <span class="hljs-string">|   └──node_modules</span><br>        <span class="hljs-string">|           └──test3@1.0.1</span><br>        ├──test2<br>        └──test3@<span class="hljs-number">1.0</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>两种结果都有可能存在，实际安装时取决于 test1 和 test2 在 package.json 中的位置，如果 test1 声明在前面，那么就是前面的结构，否则是后面的结构。<br>为了解决依赖结构的不确定性的问题，npm 5.x 推出 package-lock.json，保证第一次安装以后 node_modules 以后在添加依赖或者重装时也不会变。</p><h2 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h2><p>yarn 是在 npm2.x 版本没有很好的优化方案时提出的，主要用于解决嵌套超过 windows 路径的长度限制的 node_modules。虽然现在 npm 也日益趋同 yarn，但在安装速度上 yarn 还是优于 npm</p><h3 id="版本控制-1"><a href="#版本控制-1" class="headerlink" title="版本控制"></a>版本控制</h3><p>默认依赖都会生成 yarn.lock 文件，该文件会通过包名+版本来确定具体信息。<br>yarn.lock 文件格式如下，yarn 用的是自己设计的格式，语法上有点像 YAML，# 开头的行是注释。依赖的依赖不会被记录在 dependencies，依赖包的依赖版本如果不存在语义冲突则会合并信息</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-string">&quot;@angular-devkit/core@12.2.10&quot;</span>:<br>  version <span class="hljs-string">&quot;12.2.10&quot;</span><br>  resolved <span class="hljs-string">&quot;http://npm.internal.focus.cn:80/@angular-devkit%2fcore/-/core-12.2.10.tgz#3da62eceef3904f92cd3f860618b4ae513029ce2&quot;</span><br>  integrity sha1-PaYuzu85BPks<span class="hljs-number">0</span>/hgYYtK5RMCnOI=<br>  dependencies:<br>    ajv <span class="hljs-string">&quot;8.6.2&quot;</span><br>    ajv-formats <span class="hljs-string">&quot;2.1.0&quot;</span><br>    fast-json-stable-stringify <span class="hljs-string">&quot;2.1.0&quot;</span><br>    magic-string <span class="hljs-string">&quot;0.25.7&quot;</span><br>    rxjs <span class="hljs-string">&quot;6.6.7&quot;</span><br>    source-<span class="hljs-keyword">map</span> <span class="hljs-string">&quot;0.7.3&quot;</span><br></code></pre></td></tr></table></figure><p>Yarn 仅以 flatten 格式 描述各个包之间的依赖关系，并依赖于其当前实现来创建目录结构。这意味着如果其内部算法发生变化，结构也会发生变化。</p><h3 id="依赖关系-1"><a href="#依赖关系-1" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>同 npm 基本一样，其共有的问题是：如果你有 100 个项目使用了某个依赖（dependency），就会有 100 份该依赖的副本保存在硬盘上</p><h2 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h2><p>同 npm 和 Yarn，都属于 Javascript 包管理安装工具，它较 npm 和 Yarn 在性能上得到很大提升，被称为快速的，节省磁盘空间的包管理工具。</p><h3 id="依赖关系-2"><a href="#依赖关系-2" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>为了解决 npm、yarn 安装时依赖可能复制多次、占用磁盘空间的问题，pnpm 采用了全局仓库保存依赖、项目通过 link 的方式访问内容。<br><img src="/unkown404.github.io/img/pnpm.png"></p><p>当执行 pnpm install 时，项目的 node_modules 文件夹下除了安装的包名 bar、其依赖保持原有的树状、不进行提升，还会有.pnpm 目录，目录下是以展平结构管理每个版本包的源码内容，以硬链接方式指向 pnpm-store 中的文件地址。pnpm-store 是全局的 store，存储所有 npm 包，同一版本的包仅存储一份内容，甚至不同版本的包也仅存储 diff 内容。<br>如上图所示一个包的寻找需要经过三层结构：<code>node_modules/bar</code> &gt; 软链接 <code>node_modules/.pnpm/bar@1.0.0/node_modules/bar</code> &gt; 硬链接 <code>~/.pnpm-store/v3/files/00/xxxxxx</code>。</p><h4 id="备注：软链接和硬链接"><a href="#备注：软链接和硬链接" class="headerlink" title="备注：软链接和硬链接"></a>备注：软链接和硬链接</h4><p>在 Linux 系统中，内核为每一个新创建的文件分配一个 Inode(索引结点)，每个文件都有一个惟一的 inode 号。文件属性保存在索引结点里，在访问文件时，索引结点被复制到内存在，从而实现文件的快速访问。<br>Linux 中包括两种链接：硬链接(Hard Link)和软链接(Soft Link)，软链接又称为符号链接（Symbolic link）。<br>硬链接说白了是一个指针，指向文件索引节点，系统并不为它重新分配 inode，他将与源文件共用一个 inode。<br>软链接相当于 windows 的快捷方式，软链接文件会将 inode 指向源文件的 block，原文件＆链接文件拥有不同的 inode 号</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/6932046455733485575">关于现代包管理器的深度思考——为什么现在我更推荐 pnpm 而不是 npm&#x2F;yarn?</a><br>（2）<a href="https://juejin.cn/post/6844904022718038024">yarn or npm 版本固化如何选择</a><br>（3）<a href="https://juejin.cn/post/7127295203177676837">pnpm 是凭什么对 npm 和 yarn 降维打击的</a><br>（4）<a href="https://mp.weixin.qq.com/s/bZ7AVSjBcZrZ3I387_esmg">该用 pnpm 了，“快、准、狠”。</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前端常用的包依赖管理工具有 npm、yarn 以及近期非常受欢迎的 pnpm，本文主要也是对比这几个工具之间的区别。&lt;/p&gt;</summary>
    
    
    
    <category term="技术学习" scheme="https://unknown404.github.io/unkown404.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="前端依赖包管理" scheme="https://unknown404.github.io/unkown404.github.io/tags/%E5%89%8D%E7%AB%AF%E4%BE%9D%E8%B5%96%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    
    <category term="npm" scheme="https://unknown404.github.io/unkown404.github.io/tags/npm/"/>
    
    <category term="yarn" scheme="https://unknown404.github.io/unkown404.github.io/tags/yarn/"/>
    
    <category term="pnpm" scheme="https://unknown404.github.io/unkown404.github.io/tags/pnpm/"/>
    
  </entry>
  
</feed>
