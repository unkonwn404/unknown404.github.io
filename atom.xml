<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小白的文件整理箱</title>
  
  
  <link href="https://unknown-four-hundred-and-four.gitee.io/unknown_404/atom.xml" rel="self"/>
  
  <link href="https://unknown-four-hundred-and-four.gitee.io/unknown_404/"/>
  <updated>2022-03-27T11:05:49.000Z</updated>
  <id>https://unknown-four-hundred-and-four.gitee.io/unknown_404/</id>
  
  <author>
    <name>小白的文件整理箱</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TypeScript</title>
    <link href="https://unknown-four-hundred-and-four.gitee.io/unknown_404/2022/03/27/typescript/"/>
    <id>https://unknown-four-hundred-and-four.gitee.io/unknown_404/2022/03/27/typescript/</id>
    <published>2022-03-27T11:05:48.000Z</published>
    <updated>2022-03-27T11:05:49.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>类型系统按照「是否允许隐式类型转换」来分类，可以分为强类型和弱类型。<br>JavaScript就属于弱类型语言，灵活性强，但不利的一点是没有编译过程，语言的类型错误只有运行时才会发现（JavaScript因此被称为动态语言）。而TypeScript可以弥补这一点：TypeScript 在运行前需要先编译为 JavaScript，而在编译阶段就会进行类型检查并报错（TypeScript对应称为静态语言）。同时TypeScript 增强了编辑器（IDE）的功能，包括代码补全、接口提示、跳转到定义、代码重构等，这在很大程度上提高了开发效率。</p><p>本文主要记录一些常用的typescript语法及一些需要辨析的注意点。</p><h2 id="anyScript使用方法"><a href="#anyScript使用方法" class="headerlink" title="anyScript使用方法"></a>anyScript使用方法</h2><p>用于代码标红但确实不知道如何声明的场景</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// @ts-nocheck 禁用整个文件的ts校验，置于文件头顶</span><br><span class="line">// @ts-ignore 禁用单行ts校验，放在报错行的上方使用</span><br><span class="line">any和unknown</span><br></pre></td></tr></table></figure><p>在遇到确实难以定义类型的场景下可以使用以上方法逃课，以后再思考可能的改进方式。</p><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><p>在TypeScript 3.1的文档里，基础类型包括：boolean,string,number,Array&lt;&gt;,Tuple,any,void,undefined,null,never<br>简单记录下使用偏少的类型它的特点。</p><p>辨析点：</p><h3 id="1）unknown-vs-any"><a href="#1）unknown-vs-any" class="headerlink" title="1）unknown vs any"></a>1）unknown vs any</h3><p>unknown与any一样，所有类型都可以分配给unknown，unknown 类型的值只能赋给 unknown 本身和 any 类型。但unknown仍然有静态检测能力，个人理解是unknown没有放弃类型的推断，并不是所有类型的内部方法unknown类型数据都可以随便调用</p><h3 id="2）void，null和undefined"><a href="#2）void，null和undefined" class="headerlink" title="2）void，null和undefined"></a>2）void，null和undefined</h3><p>相同点是这3个本身在声明变量的过程中用处不大。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let unusable: void = undefined;</span><br><span class="line">let u: undefined = undefined;</span><br><span class="line">let n: null = null;</span><br></pre></td></tr></table></figure><p>默认情况下null和undefined是所有类型的子类型。<br>undefined 也是 void 的一个子集。当你对函数返回值并不在意（number、boolean、undefined都可以是返回值）时，使用 void 而不是 undefined。</p><h2 id="接口与类型别名"><a href="#接口与类型别名" class="headerlink" title="接口与类型别名"></a>接口与类型别名</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>可用于对象类型命名和定义类型参数。<br>基本语法：<code>interface SquareConfig &#123;&#125;</code><br>接口名开头需大写，因为定义的是一种类型。</p><h4 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h4><p>使用写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">  color?: string;</span><br><span class="line">  width?: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据使用经验，在调用该类型SquareConfig的变量其属性时编译等效于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">  color: string｜undefined;</span><br><span class="line">  width: number｜undefined;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以假如使用变量的color属性调用string的默认方法或者赋值给一个string变量时就会报错</p><h4 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h4><p>一些对象属性只能在对象刚刚创建的时候修改其值。可以在属性名前用 readonly来指定只读属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">    readonly x: number;</span><br><span class="line">    readonly y: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>辨析点：<br><strong>const vs readonly</strong>：const可以防止变量的值被修改，readonly可以防止变量的属性被修改。</p><h4 id="索引签名"><a href="#索引签名" class="headerlink" title="索引签名"></a>索引签名</h4><p>描述了对象索引的类型，还有相应的索引返回值类型。索引签名只支持以下两种：</p><ul><li>字符串索引签名</li><li>数字索引签名<br>一个接口中最多只能定义一个字符串索引签名，该签名会约束对象类型的所有属性类型。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface NumberDictionary &#123;</span><br><span class="line">  [index: string]: number;</span><br><span class="line">  length: number;    // 可以，length是number类型</span><br><span class="line">  name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3>类型别名声明可以为TypeScript中任意类型命名<br>基本语法：<code>type AliasType=string｜boolean｜number</code><h3 id="interface与type区别"><a href="#interface与type区别" class="headerlink" title="interface与type区别"></a>interface与type区别</h3></li></ul><ol><li>type可以用于非对象类型，而接口只能用于对象类型</li><li>接口可以继承其他对象类型，type不支持继承只能用交叉类型实现继承效果。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- type类型扩展方式 --&gt;</span><br><span class="line">type Name = &#123; name: string &#125;;</span><br><span class="line">type Person = Name &amp; &#123; age: number &#125;;</span><br><span class="line">&lt;!-- interface类型扩展方式 --&gt;</span><br><span class="line">interface IName &#123; name: string &#125;;</span><br><span class="line">interface IPerson extends IName &#123; age: number &#125;;</span><br></pre></td></tr></table></figure></li><li>接口具有声明合并的行为，type没有</li></ol><h2 id="运算符使用"><a href="#运算符使用" class="headerlink" title="运算符使用"></a>运算符使用</h2><h3 id="非空断言运算符"><a href="#非空断言运算符" class="headerlink" title="非空断言运算符 !"></a>非空断言运算符 !</h3><p>置于变量名后，用于强调元素不是null或undefined。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const test=(func:()=&gt;void)=&gt;&#123;</span><br><span class="line">    func!()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可选链运算符"><a href="#可选链运算符" class="headerlink" title="可选链运算符 ?."></a>可选链运算符 ?.</h3><p>ES11(ES2020)新增的特性。?.用来判断左侧的变量是否存在，不存在不会继续表达式运算。例如书写a?.b时实际上等效于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a === null || a === void 0 ? void 0 : a.b;</span><br></pre></td></tr></table></figure><h3 id="空值合并运算符"><a href="#空值合并运算符" class="headerlink" title="空值合并运算符 ??"></a>空值合并运算符 ??</h3><p>ES11(ES2020)新增的特性。当左侧的操作数为 null 或者 undefined 时，返回其右侧操作数，否则返回左侧操作数。<br>let b &#x3D; a ?? 10等效于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let b = a !== null &amp;&amp; a !== void 0 ? a : 10;</span><br></pre></td></tr></table></figure><h3 id="数字分割符"><a href="#数字分割符" class="headerlink" title="数字分割符_"></a>数字分割符_</h3><p>可以用于长数字分隔，方便阅读，不会编译进JavaScript。个人理解类似计算器的数字每隔3位加一个逗号方便阅读的作用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let num:number = 12_345.678_9</span><br></pre></td></tr></table></figure><h2 id="内置工具类型"><a href="#内置工具类型" class="headerlink" title="内置工具类型"></a>内置工具类型</h2><h3 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial<T></h3><p>作用是将泛型T所有属性变为可选属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Partial&lt;T&gt; = &#123;</span><br><span class="line">[P in keyof T]?: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required<T></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">作用是将泛型T所有属性变为必选属性。</span><br><span class="line">type Required&lt;T&gt; = &#123;</span><br><span class="line">  [P in keyof T]-?: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Record-lt-K-T-gt"><a href="#Record-lt-K-T-gt" class="headerlink" title="Record&lt;K, T&gt;"></a>Record&lt;K, T&gt;</h3><p>作用是将 K 中所有属性值转化为 T 类型。K提供对象属性名的联合类型，T提供对象属性类型。<br>因为K是用作对象属性名设置，所以参数K必须能够赋值给string｜number｜symbol类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Record&lt;K extends keyof any,T&gt; = &#123;</span><br><span class="line">  [key in K]: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type K=&#x27;x&#x27;|&#x27;y&#x27;</span><br><span class="line">type R=Record&lt;K,number&gt;</span><br><span class="line">const a:R=&#123;x:0,y:0&#125;</span><br></pre></td></tr></table></figure><h3 id="Pick-lt-T-K-gt"><a href="#Pick-lt-T-K-gt" class="headerlink" title="Pick&lt;T, K&gt;"></a>Pick&lt;T, K&gt;</h3><p>作用是将 T 类型中的 K 键列表提取，K必须为对象类型T存在的属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Pick&lt;T, K extends keyof T&gt; = &#123;</span><br><span class="line">  [P in K]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interface Point=&#123;x:number,y:number&#125;</span><br><span class="line">type T=Pick&lt;Point,&#x27;x&#x27;|&#x27;y&#x27;&gt;//&#123;x:number,y:number&#125;</span><br></pre></td></tr></table></figure><h3 id="Omit-lt-T-K-gt"><a href="#Omit-lt-T-K-gt" class="headerlink" title="Omit&lt;T, K&gt;"></a>Omit&lt;T, K&gt;</h3><p>与<code>Pick&lt;T, K&gt;</code>互补。用于去除类型 T 中包含 K 的键值对。如果K为T不存在的属性则新类型等同于T。</p><h3 id="Exclude-lt-T-U-gt"><a href="#Exclude-lt-T-U-gt" class="headerlink" title="Exclude&lt;T, U&gt;"></a>Exclude&lt;T, U&gt;</h3><p>在 T 类型中，去除 T 类型和 U 类型的交集。</p><h3 id="Extract-lt-T-U-gt"><a href="#Extract-lt-T-U-gt" class="headerlink" title="Extract&lt;T, U&gt;"></a>Extract&lt;T, U&gt;</h3><p>与<code>Exclude&lt;T, U&gt;</code>互补。获取T类型中所有能赋值给U的类型，没有返回never。</p><h3 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType<T></h3><p>获取 T 类型(函数)对应的返回值类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function foo(x: string | number): string | number &#123; /*..*/ &#125;</span><br><span class="line">type FooType = ReturnType&lt;foo&gt;;  // string | number</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>（1）<a href="https://juejin.cn/post/6926794697553739784">TypeScript 高级用法</a><br>（2）<a href="https://juejin.cn/post/6981728323051192357#heading-0">一篇够用的TypeScript总结</a><br>（3）<a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html">TypeScript文档</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;TypeScript一些特性记录和辨析，方便自己记忆，为日后使用准备。&lt;/p&gt;</summary>
    
    
    
    <category term="前端技术体系" scheme="https://unknown-four-hundred-and-four.gitee.io/unknown_404/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="TypeScript" scheme="https://unknown-four-hundred-and-four.gitee.io/unknown_404/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch查询语句使用</title>
    <link href="https://unknown-four-hundred-and-four.gitee.io/unknown_404/2022/03/14/esUseage/"/>
    <id>https://unknown-four-hundred-and-four.gitee.io/unknown_404/2022/03/14/esUseage/</id>
    <published>2022-03-14T12:43:59.000Z</published>
    <updated>2022-03-18T10:45:49.166Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><p>es 中的查询请求有两种方式，一种是简易版的查询，另外一种是使用 JSON 完整的请求体，叫做结构化查询（DSL）。DSL 的查询方式是 POST 过去一个 json，由于 post 的请求是 json 格式的，所以存在很多灵活性，也有很多形式。笔者出于使用 nodejs 技术调用 es 查询的需求，因此主要搜集的资料是关于 DSL 的。</p><p>本文并不是查询方法的全列举，而是针对自己实际使用的几种方法进行比较辨析。如果日后尝试使用其他方法，也会在这里添加补充说明。</p><div class="alert info"><p>使用 DSL 查询语法时，由于使用 json 字符串时存在特殊符号例如<code>*,/,\</code>等影响解析，因此需要使用两个反斜杠<code>\\</code>进行转义</p></div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">calcQueryString</span>=(<span class="params">keyword:<span class="built_in">string</span></span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> keyword.<span class="title function_">replace</span>(<span class="regexp">/([-\/\\^$*+?.()|[\]&#123;&#125;])/g</span>, <span class="string">&#x27;\\$1&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全文查询"><a href="#全文查询" class="headerlink" title="全文查询"></a>全文查询</h2><h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p>不需要完整的卢塞恩语法支持。在查询语句里任何一个词项与分词匹配都会返回该文档。如果要查询所有关键词的文档，可以使用 and 操作符连接。结果里关键词但次序无法保证。</p><p>查询结构示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">        &quot;content&quot; : &quot;小白的文件整理箱&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该查询语句可能根据分词规则分为“小白”、“白的”、“文”、“整理箱”等多种关键词，只要有匹配的字词就会被搜出来，例如“文无定法”、“文小白”等都有可能</p><h3 id="match-phrase"><a href="#match-phrase" class="headerlink" title="match_phrase"></a>match_phrase</h3><p>在执行短语匹配查询时，查询结果会满足两个条件：1）必须匹配短语中的所有分词 2）保证各个分词的相对位置不变。</p><p>以 match 的查询语句为例，查询结果不会出现“文小白”，但有可能出现“小白菜的 zip 文件垃圾整理行李箱”</p><h3 id="multi-match"><a href="#multi-match" class="headerlink" title="multi_match"></a>multi_match</h3><p>match 语法的升级，可用于多个字段。也可以用指数符指定多个字段的权重</p><p>查询结构示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">        &quot;query&quot; : &quot;小白的文件整理箱&quot;,</span><br><span class="line">        &quot;fields&quot;:[&quot;title^3&quot;,&quot;content&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="query-string"><a href="#query-string" class="headerlink" title="query_string"></a>query_string</h3><p>常见写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;query_string&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &quot;(new york city) OR (big apple)&quot;,</span><br><span class="line">      &quot;fields&quot;: [&quot;content&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>支持运算符 AND 和 OR，括号内的查询语句作为整个查询。<br>支持 wildcard 语法。</p><h2 id="词项查询"><a href="#词项查询" class="headerlink" title="词项查询"></a>词项查询</h2><h3 id="term"><a href="#term" class="headerlink" title="term"></a>term</h3><p>term 是代表完全匹配，返回的文件必须包含完整的关键词。</p><h3 id="terms"><a href="#terms" class="headerlink" title="terms"></a>terms</h3><p>term 的升级版，可以查询多个字词。例如查询 content 字段包含“小白”和“文件整理箱”的文档。</p><p>查询结构示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;content&quot; : [&quot;小白&quot;,&quot;文件整理箱&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="prefix"><a href="#prefix" class="headerlink" title="prefix"></a>prefix</h3><p>查询某个字段以固定前缀开始的文档。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;prefix&quot;: &#123;</span><br><span class="line">        &quot;content&quot; : &quot;小白&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该查询语句会返回“小白”、“小白菜”等所有以“小白”开头的content文档。</p><h3 id="wildcard"><a href="#wildcard" class="headerlink" title="wildcard"></a>wildcard</h3><p>支持通配符搜索，可以使用?替换单个字符，用*替换零个或多个字符。通配符的查询效率较低不是很推荐。</p><h3 id="regexp"><a href="#regexp" class="headerlink" title="regexp"></a>regexp</h3><p>可以支持更为复杂的匹配模式。<em>（个人体验感觉不佳，用于带转义字段的查询时往往查不到，不知道什么原因；不如js的正则好用）</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;regexp&quot;: &#123;</span><br><span class="line">            &quot;postcode&quot;: &quot;W[0-9].+&quot; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询语句text字段和keyword字段的区别"><a href="#查询语句text字段和keyword字段的区别" class="headerlink" title="查询语句text字段和keyword字段的区别"></a>查询语句text字段和keyword字段的区别</h2><p>ElasticSearch 5.0以后，String字段被拆分成两种新的数据类型: text用于全文搜索，会分词,而keyword用于关键词搜索，不进行分词。对于字符串类型的字段，ES默认会再生成一个keyword字段用于精确索引。</p><p>简单理解就是text字段会被分词，而keyword字段是要求不分词完整地查找全字段。</p><p>keyword的查询语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">        &quot;content.keyword&quot; : &quot;小白&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询字段时-term、match、match-phrase、query-string-的区别"><a href="#查询字段时-term、match、match-phrase、query-string-的区别" class="headerlink" title="查询字段时 term、match、match_phrase、query_string 的区别"></a>查询字段时 term、match、match_phrase、query_string 的区别</h2><h3 id="1-1-term"><a href="#1-1-term" class="headerlink" title="1.1 term"></a>1.1 term</h3><p>1）term 查询 keyword 字段。</p><p>term 不会分词。而 keyword 字段也不分词。需要完全匹配才可。</p><p>2）term 查询 text 字段</p><p>因为 text 字段会分词，而 term 不分词，所以 term 查询的条件必须是 text 字段分词后的某一个。</p><p>eg. brown big box 作为 text 字段会被分为[ brown, big, box ]的词组，当 term 的查询内容为 brown 时可返回该词条<br>当 term 的查询内容为 brown big 的时候则不会返回</p><h3 id="1-2-match"><a href="#1-2-match" class="headerlink" title="1.2 match"></a>1.2 match</h3><p>1）match 查询 keyword 字段</p><p>match 会被分词，而 keyword 不会被分词，match 的需要跟 keyword 的完全匹配可以。</p><p>其他的不完全匹配的都是失败的。</p><p>2）match 查询 text 字段</p><p>match 分词，text 也分词，只要 match 的分词结果和 text 的分词结果有相同的就匹配。</p><p>eg. brown big box 的词条，当 term 的查询内容为 fox 时也可返回该词条，因为存在“ox“这一相同内容</p><h3 id="1-3-match-phrase"><a href="#1-3-match-phrase" class="headerlink" title="1.3.match_phrase"></a>1.3.match_phrase</h3><p>1）match_phrase 匹配 keyword 字段。</p><p>这个同上必须跟 keyword 一致才可以。</p><p>2）match_phrase 匹配 text 字段。</p><p>match_phrase 是分词的，text 也是分词的。match_phrase 的分词结果必须在 text 字段分词中都包含，而且顺序必须相同，而且必须都是连续的。</p><p><em>（与 match 匹配 text 情况相比就多了顺序相同一个条件）</em></p><h3 id="1-4-query-string"><a href="#1-4-query-string" class="headerlink" title="1.4.query_string"></a>1.4.query_string</h3><p>1）query_string 查询 keyword 类型的字段。</p><p>网上有说法无法查询。但根据实际经验做长字符串的查询是可行的，可能是 Lucene 语法使用不当的问题。  </p><p>query_string 查询 keyword 字段如果只是使用了局部字段查询的话需要在前后加“*”。</p><p>2）query_string 查询 text 类型的字段。</p><p>和 match_phrase 区别的是，不需要连续，顺序还可以调换。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>（1）<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html">Elasticsearch Guide</a><br>（2）《从Lucene到ElasticSearch：全文检索实战》<br>（3）<a href="https://www.cnblogs.com/duanxz/p/3508338.html">ES之五：关于Elasticsearch查找相关的问题汇总（match、match_phrase、query_string和term）</a><br>（4）<a href="https://www.cnblogs.com/yjf512/p/4897294.html">elasticsearch 查询（match和term）</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;摸索Elasticsearch查询语句时搜索和实践体验到的知识点&lt;/p&gt;</summary>
    
    
    
    <category term="技术学习" scheme="https://unknown-four-hundred-and-four.gitee.io/unknown_404/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Elasticsearch" scheme="https://unknown-four-hundred-and-four.gitee.io/unknown_404/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建博客</title>
    <link href="https://unknown-four-hundred-and-four.gitee.io/unknown_404/2022/03/14/hexoBlog/"/>
    <id>https://unknown-four-hundred-and-four.gitee.io/unknown_404/2022/03/14/hexoBlog/</id>
    <published>2022-03-14T06:05:43.000Z</published>
    <updated>2022-03-27T11:07:18.808Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2><p>1）<a href="https://nodejs.org/zh-cn/">node.js</a><br>2) <a href="https://git-scm.com/">git</a></p><h2 id="本地建站流程"><a href="#本地建站流程" class="headerlink" title="本地建站流程"></a>本地建站流程</h2><p>1.在<a href="https://gitee.com/">Gitee</a>注册登录账号，点击右上角“+”按钮创建新的仓库。仓库名可随意设置。但注意初始化时不要加文件。</p><div class="figure center" style="width:;"><img class="fig-img" src="gitee-init.png" alt=""></div><div style="clear:both;"></div><div class="alert info"><p>根据网上大多数博客的说法仓库名应该设置为用户名，否则 hexo 打包的 css 路径会找不到。但是实际操作中并没有遇到这样的问题推测有两个可能性。<br>1）这个问题只出现在 GitHub Page 开设的流程。<br>2）配置更新了，现在新版 hexo 的打包确保了相对路径的可查找性。</p></div> 2.将空仓库拉到本地，安装 hexo，安装指令如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.使用指令<code>hexo init</code>初始化 hexo，注意如果仓库的文件夹不为空的话，初始化就会失败，可以考虑新建一个文件夹，在新文件夹的位置启动初始化指令。<br><em>（推荐将初始化生成的文件夹都放在仓库的另一个分支，master 分支保留给 hexo 打包博客文件）</em><br>初始化后当前文件夹内部结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml //网站的配置文件，可配置大部分参数</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds  //模版文件夹</span><br><span class="line">├── source  //资源文件夹，用户添加资源的位置</span><br><span class="line">|   ├── _drafts  //草稿</span><br><span class="line">|   └── _posts   //博文</span><br><span class="line">└── themes  //主题文件夹。Hexo 会根据主题来生成静态页面。</span><br></pre></td></tr></table></figure><p>4.初始化完成以后 package.json 新增了几个指令，包括</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build&quot;: &quot;hexo generate&quot;,</span><br><span class="line">    &quot;clean&quot;: &quot;hexo clean&quot;,</span><br><span class="line">    &quot;deploy&quot;: &quot;hexo deploy&quot;,</span><br><span class="line">    &quot;server&quot;: &quot;hexo server&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>新增的 hexo 指令的意义是：</p><blockquote><p>hexo clean —— 清空已有 hexo 网站文件<br>hexo generate(or g) —— 依据网页文本与新的 CSS 样式生成新网站文件<br>hexo server(or s) —— 启动本地服务器，可以在 localhost:4000 查看网站修改效果<br>按上述顺序执行就可以在 localhost:4000 看到默认版式下的页面了。一般默认的是一个 landscape 主题。</p></blockquote><p>到此为止一个简单的博客就在本地建好了。我们可以通过调整 themes 文件夹的主题、修改_config.yml 文件来使自己的博客更加个性化。</p><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>hexo 有自己的<a href="https://hexo.io/themes/">主题网站</a>，可以选择自己感兴趣的主题点击进入其 github 主页进行下载，解压后添加到 themes 文件夹下。</p><p>虽然 hexo 的主题丰富，很容易找到合意的个性主题。但是第一次使用时最好找一个比较常用的模版，这样说明文档比较丰富、遇到问题网上搜索时也很容易找到答案 😭</p><p>个人比较推荐并以后打算尝试的模版包括<a href="https://github.com/theme-next/hexo-theme-next">Next</a>*(大家都喜欢应该是有理由的吧)<em>、<a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a></em>(文档看着真齐全)*。</p><p>当前使用的主题是<a href="https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak">tranquilpeak</a>，看着比较美观。后续以该主题为例讲解配置修改。</p><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p>1）GitHub 网站上以 zip 方式下载<br>2）将解压后的文件夹命名为 tranquilpeak 添加到博客的 themes 文件夹下<br>3）打开博客仓库的终端进入到 tranquilpeak 文件夹位置执行<code>npm install &amp;&amp; npm run prod</code><br>4）调整博客仓库主文件夹下的<code>theme: tranquilpeak</code><br>5）使用指令 hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 即可看到新样式</p><h3 id="tranquilpeak-相关配置"><a href="#tranquilpeak-相关配置" class="headerlink" title="tranquilpeak 相关配置"></a>tranquilpeak 相关配置</h3><p>tranquilpeak 主题文件夹下也有_config.yml 配置文件，在我下载的当前版本 4.1.3 里，作者把配置分为了“Sidebar Configuration”、“Header configuration”、“Author“、“Customization”、“Comment systems”、“Integrated services”和“Sharing options”。<br><strong>Sidebar Configuration</strong>：提供了侧边栏的菜单配置，可以根据自己的需求增减项目、调整链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sidebar:                   </span><br><span class="line">         menu:                 </span><br><span class="line">             home:             </span><br><span class="line">                title: Home    # 链接标题</span><br><span class="line">                url: /         # 链接URL</span><br><span class="line">                icon: home     # Font Awesome 图标名,https://fontawesome.com/icons?d=gallery&amp;m=free 上可以找到合适的图标</span><br></pre></td></tr></table></figure><p><strong>Header configuration</strong>：用于编辑头部右上角链接<br><strong>Author</strong>：编辑作者信息，包括以下几个部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">author:</span><br><span class="line">    email: </span><br><span class="line">    location: </span><br><span class="line">    picture: </span><br><span class="line">    twitter:</span><br><span class="line">    google_plus:</span><br><span class="line">    google_plus_business:</span><br></pre></td></tr></table></figure><p>其中location和picture的填写内容会显示在关于（作者）的页面上。而作者的其他信息例如座右铭、工作等则是在博客总文件夹下的语言选项选定以后，在<code>tranquilpeak\languages\</code>下寻找对应语言的模版，修改作者相关的信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">author:</span><br><span class="line">    # 你的个人简介 (支持 Markdown 和 HTML 语法)</span><br><span class="line">    bio: &quot;&quot;</span><br><span class="line">    # 你的工作简介</span><br><span class="line">    job: &quot;&quot;</span><br></pre></td></tr></table></figure><p><strong>Customization</strong>：有关于侧边栏的展示方法（sidebar_behavior）、文章列表缩略图位置（thumbnail_image_position）、封面图（cover_image）等配置。</p><p>“Comment systems”、“Integrated services”和“Sharing options”等配置暂时没有用到，以后再研究。</p><h2 id="书写博文"><a href="#书写博文" class="headerlink" title="书写博文"></a>书写博文</h2><p>1）可在终端执行如下指令完成页面新建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>layout变量可以有三种选择：post、page 和 draft。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 post 相同，都将储存到 source&#x2F;_posts 文件夹。</p><table><thead><tr><th align="center">layout选项</th><th align="center">生成文件路径</th></tr></thead><tbody><tr><td align="center">post</td><td align="center">source&#x2F;_posts</td></tr><tr><td align="center">page</td><td align="center">source</td></tr><tr><td align="center">draft</td><td align="center">source&#x2F;_drafts</td></tr></tbody></table><p>title是文章的名称，执行完指令后会在layout对应的路径下生成<code>&lt;title&gt;.md</code>文件。如果工程文件夹下的_config.yml 文件里<code>post_asset_folder</code>这一选项置为true的话则还会生成一个title的文件夹，可以存放引用资源。</p><p>2）调整文章内容<br>生成的文件头部通常会包含以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: </span><br><span class="line">date: </span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>如果是草稿则没有自动生成的date变量，执行语句<code>hexo publish draft  &lt;title&gt;</code>、移动到source&#x2F;_posts 文件夹时应该会出现。<br>根据自己的需要，可以在文件头部增加内容。以tranquilpeak为例，该样式支持categories、thumbnailImage、excerpt等配置。配置categories可以在分类页面看到自己这篇文章的归类情况；配置thumbnailImage时会在文章列表增加缩略图，但本地是看不到效果的，只有打包上传到gitee后才可以；配置excerpt时首页文章列表不会展示全文而只会展示摘要。<br>tranquilpeak模版还支持两个标签语法：<code>&lt;!-- more --&gt;</code>和<code>&lt;!-- toc --&gt;</code>。前者是将标志之前的内容将会自动生成首页的概览，后者则是自动生成文章目录。<br>具体的内容书写可以参考markdown语法。</p><h2 id="推送到gitee"><a href="#推送到gitee" class="headerlink" title="推送到gitee"></a>推送到gitee</h2><p>1）首先需要安装推送工具hexo-deployer-git。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>2）在博客工程文件夹下的_config.yml找到URL和deploy的配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><br><span class="line">url: https://unknown-four-hundred-and-four.gitee.io/unknown_404</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://gitee.com/unknown-four-hundred-and-four/unknown_404.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>这里URL需要改成静态资源最后部署的域名，按照配置文件的说明，应该是<code>https://&#123;username&#125;.github.io/&#123;project&#125;</code>的格式，username是GitHub用户名，在GitHub上仓库名和用户名是相同，但在gitee上可以不一样，所以要注意实际上需要填入的是仓库名。project对应当前博客的工程名。<br>deploy选项里repository对应博客仓库的git地址，branch可根据需要修改，部署到page时注意一致性即可。<br>3）文件生成成功后执行<code>hexo deploy</code>指令，将文件推到远程仓库的master分支上。</p><div class="figure center" style="width:;"><img class="fig-img" src="gitee-master.png" alt=""></div><div style="clear:both;"></div><h2 id="gitee-page服务启动"><a href="#gitee-page服务启动" class="headerlink" title="gitee page服务启动"></a>gitee page服务启动</h2><p>1）在gitee仓库首页选择“服务-Gitee Page”</p><div class="figure center" style="width:;"><img class="fig-img" src="gitee-page.png" alt=""></div><div style="clear:both;"></div><p>2）如果没有实名认证的话开启Page服务需要验证，还需要绑定手机号。<br>3）进入到Gitee Pages 服务页面，选择部署分支，注意和工程文件夹下的_config.yml的deploy配置一致，如果选择了强制使用https，则工程文件夹下_config.yml的url配置也必须是https。</p><div class="figure center" style="width:;"><img class="fig-img" src="gitee-start.png" alt=""></div><div style="clear:both;"></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>（1）<a href="https://cungudafa.blog.csdn.net/article/details/104260494?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~LandingCtr~Rate-1.queryctrv4&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~LandingCtr~Rate-1.queryctrv4&utm_relevant_index=1">基于Gitee+Hexo搭建个人博客</a><br>（2）<a href="https://hexo.io/zh-cn/docs/writing">Hexo中文文档</a><br>（3）<a href="https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak/blob/master/DOCUMENTATION.md">tranquilpeak配置</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录自己使用hexo搭建个人博客并部署到gitee的流程。&lt;/p&gt;</summary>
    
    
    
    <category term="技术学习" scheme="https://unknown-four-hundred-and-four.gitee.io/unknown_404/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Hexo" scheme="https://unknown-four-hundred-and-four.gitee.io/unknown_404/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>markdown笔记</title>
    <link href="https://unknown-four-hundred-and-four.gitee.io/unknown_404/2022/03/13/markdown%E7%AC%94%E8%AE%B0/"/>
    <id>https://unknown-four-hundred-and-four.gitee.io/unknown_404/2022/03/13/markdown%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-13T08:28:58.000Z</published>
    <updated>2022-03-18T06:15:17.365Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。<br>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。<br>Markdown 编写的文档后缀为 .md, .markdown。</p></blockquote><h2 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h2><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h3><p>使用 # 号可表示 1-6 级标题，一级标题对应一个 <code>#</code>号，二级标题对应两个 <code>#</code> 号，以此类推。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure><p>效果：</p><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><h3 id="2-文字"><a href="#2-文字" class="headerlink" title="2.文字"></a>2.文字</h3><p>Markdown支持文字加粗、斜体、下划线、删除线等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*斜体文本*</span><br><span class="line">_斜体文本_</span><br><span class="line">**粗体文本**</span><br><span class="line">__粗体文本__</span><br><span class="line">***粗斜体文本***</span><br><span class="line">___粗斜体文本___</span><br><span class="line">&lt;u&gt;带下划线文本&lt;/u&gt;  </span><br><span class="line">~~删除线文本~~</span><br><span class="line">创建脚注格式类似这样 [^RUNOOB]。</span><br><span class="line"></span><br><span class="line">[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！</span><br></pre></td></tr></table></figure><p>效果：<br><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><em><strong>粗斜体文本</strong></em><br><em><strong>粗斜体文本</strong></em><br><u>带下划线文本</u><br><del>删除线文本</del><br>创建脚注格式类似这样 [^RUNOOB]。</p><p>[^RUNOOB]: 菜鸟教程 – 学的不仅是技术，更是梦想！！！</p><h3 id="3-段落"><a href="#3-段落" class="headerlink" title="3.段落"></a>3.段落</h3><p><strong>分割线</strong>：三个或者三个以上的 - 或者 * 都可以。显示效果是一样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><h2 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h2><hr><hr><hr><p><strong>换行</strong>：使用两个以上空格加上回车，或者在段落后面使用一个空行来表示重新开始一个段落。</p><h3 id="4-链接与图片"><a href="#4-链接与图片" class="headerlink" title="4.链接与图片"></a>4.链接与图片</h3><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）[超链接名](超链接地址 &quot;超链接title（optional）&quot;)</span><br><span class="line">2）&lt;https://www.runoob.com&gt;直接使用链接地址</span><br><span class="line">3）&lt;a href=&quot;https://www.runoob.com&quot; target=&quot;_blank&quot;&gt;菜鸟教程&lt;/a&gt;支持在新页面打开</span><br></pre></td></tr></table></figure><p>效果：<br><a href="https://www.runoob.com/">菜鸟教程</a><br><a href="https://www.runoob.com/">https://www.runoob.com</a><br><a href="https://www.runoob.com" target="_blank">菜鸟教程</a>  </p><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式：![alt 属性文本](图片地址 &quot;可选标题&quot;)</span><br><span class="line"></span><br><span class="line">![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png &quot;RUNOOB&quot;)</span><br></pre></td></tr></table></figure><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标" title="RUNOOB"></p><h3 id="5-区块与代码"><a href="#5-区块与代码" class="headerlink" title="5.区块与代码"></a>5.区块与代码</h3><h4 id="区块："><a href="#区块：" class="headerlink" title="区块："></a>区块：</h4><p>区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号<br><em>区块嵌套</em> ：一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><p>单行代码：代码之间分别用一个反引号包起来<br>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p><h3 id="6-列表"><a href="#6-列表" class="headerlink" title="6.列表"></a>6.列表</h3><h4 id="无序列表："><a href="#无序列表：" class="headerlink" title="无序列表："></a>无序列表：</h4><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure><p>效果：  </p><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ul><li>列表内容  <h4 id="有序列表："><a href="#有序列表：" class="headerlink" title="有序列表："></a>有序列表：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure>效果：</li></ul><ol><li>列表内容  </li><li>列表内容  </li><li>列表内容</li></ol><p><em>列表嵌套</em>：上一级和下一级之间敲三个空格即可</p><h3 id="7-表格"><a href="#7-表格" class="headerlink" title="7.表格"></a>7.表格</h3><p><code>|</code>来分隔不同的单元格，使用 <code>-</code>来分隔表头和其他行。</p><h4 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h4><p>我们可以设置表格的对齐方式：</p><ul><li>-: 设置内容和标题栏居右对齐。</li><li>:- 设置内容和标题栏居左对齐。</li><li>:-: 设置内容和标题栏居中对齐。<br>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table></li></ul><h2 id="Markdown效果预览"><a href="#Markdown效果预览" class="headerlink" title="Markdown效果预览"></a>Markdown效果预览</h2><p>VsCode：快捷键command+shift+v</p><h2 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h2><ol><li><a href="https://www.runoob.com/markdown/md-table.html">菜鸟教程</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录下markdown格式常用的几种语法，方便以后自己书写时使用。&lt;i&gt;备注：部分markdown语法似乎没有在该模版很好的展示&lt;/i&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="技术学习" scheme="https://unknown-four-hundred-and-four.gitee.io/unknown_404/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Markdown" scheme="https://unknown-four-hundred-and-four.gitee.io/unknown_404/tags/Markdown/"/>
    
  </entry>
  
</feed>
