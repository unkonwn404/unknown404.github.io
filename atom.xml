<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小白的文件整理箱</title>
  
  
  <link href="https://unkonwn404.github.io/unknown404.github.io/atom.xml" rel="self"/>
  
  <link href="https://unkonwn404.github.io/unknown404.github.io/"/>
  <updated>2024-03-04T06:45:50.810Z</updated>
  <id>https://unkonwn404.github.io/unknown404.github.io/</id>
  
  <author>
    <name>小白的文件整理箱</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>腾讯云服务基础操作记录</title>
    <link href="https://unkonwn404.github.io/unknown404.github.io/2024/02/22/k8s/"/>
    <id>https://unkonwn404.github.io/unknown404.github.io/2024/02/22/k8s/</id>
    <published>2024-02-22T14:47:26.000Z</published>
    <updated>2024-03-04T06:45:50.810Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为项目迁移老要操作腾讯云服务，所以写个总结的文章，梳理一下涉及的知识和操作。说真的前端部署真的应该考虑这些吗？</p><span id="more"></span><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h3><p>Kubernetes（简称 K8s）是一个开源的容器编排平台，用于自动化部署、扩展和管理容器化应用程序。<br>Kubernetes 集群的两种管理角色：Master 和 Node。</p><h4 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h4><p><img src="/unknown404.github.io/img/k8s/structure.jpg"></p><h5 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h5><p>集群的控制节点，每个 Kubernetes 集群需要有一个 master 节点来负责整个集群的管理和控制。包括以下结构</p><ul><li>Kubernetes API Server(kube-apiserver):提供了 HTTP Rest 接口的关键服务进程，是 Kubernetes 里所有资源的增，删，改，查等操作的唯一入口，也是集群控制的入口进程。</li><li>Kubernetes Controller Manager （kube-controller-manager）:Kubernetes 里所有资源对象的自动化控制中心，可以理解为资源对象的“大总管”</li><li>Kubernetes Schedule（kube-scheduler）:负责资源调度（Pod 调度）的进程，相当于公交公司的“调度室”。</li><li>etcd 服务：保存 Kubernetes 里所有资源对象的数据。</li></ul><h5 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h5><p>Kubernetes 集群中真正业务工作负载节点。当某个 Node 宕机后，其上的工作负载会被 Master 自动转移到其他节点上去。</p><ul><li>kubelet:负责 pod 对应的容器的创建，启停等任务。同时与 Master 节点密切协助，实现集群管理的基本功能。</li><li>kube-proxy:实现 Kubernetes service 的通信与负载均衡机制的重要组件。</li><li>Docker Engine（docker）：Docker 引擎，负责本机的容器创建和管理工作。</li></ul><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><ul><li>DNS：Kubernetes 提供了内建的 DNS 服务，用于解析服务名称到 Pod IP 地址，实现服务之间的通信。</li><li>Ingress Controller：可选组件，用于管理集群的入口流量，实现 HTTP 和 HTTPS 等应用层协议的路由和负载均衡。</li><li>Dashboard：可选的 Web UI，用于管理和监控 Kubernetes 集群。</li></ul><h4 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h4><h5 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h5><p>一组紧密关联的容器集合，它们共享 IPC 和 Network namespace，是 Kubernetes 调度的基本单位。在 VMware 的世界中，调度的原子单位是虚拟机（VM）；在 Docker 的 世界中，调度的原⼦单位是容器；⽽在 Kubernetes 的世界中，调度的原子单位是 Pod。每一个 pod 都有一个特殊的被称为“根容器”的 Pause 容器对应的镜像属于 Kubernetes 平台的一部分，除了 Pause 容器，每个 Pod 还包括一个或多个紧密相关的用户业务容器。</p><p>通过与 Master 节点的交互，Pod 可以被创建、调度到适合的节点上运行；而在 Node 节点上，kubelet 负责管理 Pod 的生命周期，而 kube-proxy 则负责处理 Pod 的网络通信。</p><h5 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h5><p>Pod 控制器是 Pod 启动的一种模版，用来保证在 K8S 里启动的 Pod 应始终按照用户的预期运行（副本数、生命周期、健康状态检查等）。之前主要是 Replication Controller 与 Replica Set 来实现，1.2 版本后官方更推荐用 Deployment。</p><p>Deployment 属于无状态应用部署（不会在本地存储持久化数据 ，多个 pod 间是没有关系的）。Deployment 的作用是管理和控制 Pod 和 ReplicaSet，管控它们运行在用户期望的状态中。除 Pod 管理之外，还提供了如扩缩容管理、一键回滚、不停机更新以及版本控制及其他特性。</p><h5 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h5><p>Pod 是非常重要的，但是可能随时会出现故障并销毁。如果通过 Deployment 或者 DaemonSet 对 Pod 进行管理，出现故障的 Pod 会自动被替换。但替换后的新 Pod 会拥有完全不同的 IP 地址。</p><p>Service 就是用来解决这个问题的核心概念，它并不是我们常说的“服务”的含义，而更像是网关层，可以看作一组提供相同服务的 Pod 的对外访问接口、流量均衡器。</p><h5 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h5><p>一个 Label 是一个 key&#x3D;value 的键值对。其中 key 与 value 由用户自己定义。Label 可以附加到各个资源对象上，例如 Node，Pod，Service，RC 等，一个资源对象可以定义任意数量的 Label，同一个 Label 也可以被添加到任意数量的资源对象上去，Label 通常在资源对象定义时确定，也可以在对象创建后动态添加或者删除。</p><p>当给某个资源对象定义一个 Label，就相当于给它打了一个标签，然后可以通过“Label Selector”（标签选择器）查询和筛选拥有某些 Label 的资源对象</p><p>Label Selector 可以用于以下场景：</p><ul><li>kube-controller 进程通过资源对象 RC 上定义的 Label Selector 来筛选要监控的 Pod 副本的数量，从而实现 Pod 副本的数量始终符合预期设定的全自动控制流程。</li><li>kube-proxy 进程通过 Service 的 Label Selector 来选择对应的 Pod，自动建立起每个 Service 到对应 Pod 的请求转发路由表，从而实现 Service 的智能负载均衡机制。</li><li>通过对某些 Node 定义特定的 Label，并且在 Pod 定义文件中使用 NodeSelector 这种标签调度策略，kube-scheduler 进程可以实现‘定向调度’的特性。</li></ul><h3 id="腾讯云-TKE-容器服务"><a href="#腾讯云-TKE-容器服务" class="headerlink" title="腾讯云 TKE 容器服务"></a>腾讯云 TKE 容器服务</h3><p>腾讯云容器服务（Tencent Kubernetes Engine, TKE）基于原生 kubernetes 提供以容器为核心的、高度可扩展的高性能容器管理服务。可以帮助用户轻松地在云上部署、管理和扩展容器化应用程序（大概吧）。</p><p>目前腾讯云列出的可配置的 k8s 属性如下表格所示<br><img src="/unknown404.github.io/img/k8s/k8sObj.jpg"></p><h3 id="腾讯云容器镜像服务"><a href="#腾讯云容器镜像服务" class="headerlink" title="腾讯云容器镜像服务"></a>腾讯云容器镜像服务</h3><p>一种容器镜像云端托管服务。该服务支持 Docker 镜像和 Helm Chart 的存储与分发，以及镜像的安全扫描。它为企业级客户提供了细颗粒度的访问权限管理和网络访问控制，支持镜像的全球同步及触发器，以满足客户拓展全球业务及使用容器 CI&#x2F;CD 工作流的需求。此外，TCR 还支持具有上千节点的大规模容器集群并发拉取 GB 级大镜像，保障业务的极速部署。</p><p>通过使用容器镜像服务，客户无需自建并维护镜像托管服务，即可在云端享受安全高效的镜像托管和分发服务。同时，该服务可以与腾讯云的容器服务 TKE 结合使用，为客户提供顺畅的容器上云体验。</p><h2 id="项目部署迁移操作"><a href="#项目部署迁移操作" class="headerlink" title="项目部署迁移操作"></a>项目部署迁移操作</h2><h3 id="镜像仓库迁移"><a href="#镜像仓库迁移" class="headerlink" title="镜像仓库迁移"></a>镜像仓库迁移</h3><p>公司里每个组都是有自己的命名空间的，所以项目迁移时需要在自己小组的命名空间下新建镜像仓库<br><img src="https://qcloudimg.tencent-cloud.cn/image/document/b95228adfa9046858ad971882c800fe6.png"><br>在部署工具里更新镜像仓库地址，打包镜像</p><h3 id="容器迁移"><a href="#容器迁移" class="headerlink" title="容器迁移"></a>容器迁移</h3><p>进入容器服务页面、选择 Deployment 菜单。在自己小组所属的命名空间下创建新的 deployment。由于部署脚手架利用了 Label 特性，所以表单的 label 一栏要增加项目的 appcode<br><img src="/unknown404.github.io/img/k8s/deployment.jpg"><br>容器一栏容器名可以和 deployment 保持一致；镜像选择自己小组的命名空间下新建的镜像仓库，刚新建好的镜像仓库没有版本，需要提前打包镜像推送到仓库；cpu&#x2F;内存限制可以分环境考虑：</p><ul><li>测试环境 cpu 限制 0.25 核，内存 256</li><li>正式环境 cpu 设置 0.25-0.5，内存 256-512</li></ul><p>核心思想就是测试环境能跑就行，正式环境需要有一定的扩展性。后面实例设置也是如此。<br><img src="/unknown404.github.io/img/k8s/container.jpg"><br>实例数量：等同于 replicas，直接指定 pod 实例数量。测试环境可以手动限制为 1 个，正式环境选择自动调节，实例范围 2-5，触发自动调节策略根据实际情况可以设置多个，例如满足 cpu 使用率高于 50%、内存利用率高于 50%中的一个触发<br><img src="/unknown404.github.io/img/k8s/pod.jpg"><br>镜像访问凭证：针对镜像仓库设置的，在 pod 中指定仓库密钥，默认都配置了 qcloudregistrykey 和 tencenthubkey，如果这个 key 设置错误将导致从镜像仓库拉取私有镜像失败（一般来说之前的人已经设过了，可以看看下拉列表；不确定的时候可以删除这一栏、估计也能跑的原因是腾讯云主账号权限高吧）</p><h3 id="服务迁移"><a href="#服务迁移" class="headerlink" title="服务迁移"></a>服务迁移</h3><p><img src="/unknown404.github.io/img/k8s/service.jpg"><br>服务器访问方式中，仅在集群内访问即设置 ClusterIP 的选项，服务只会在集群内部被访问，一般正式环境使用该配置（因为正式环境代码会部署到两个集群，应该是为了防止单一集群挂掉整个网站不可访问的情况吧）；内网 LB 访问即使用 ip+port 的形式可以访问到</p><p>容器端口：项目启动时的端口，一般如果是 ssr 项目就是指令启动时的端口，如果是 nginx 项目在没大改配置的条件下是 80<br>服务端口：自己随便设的端口，最后服务在集群外可通过负载均衡域名或 IP+服务端口访问服务</p><h3 id="测试服务运行效果"><a href="#测试服务运行效果" class="headerlink" title="测试服务运行效果"></a>测试服务运行效果</h3><p>点击新建的负载，查看 pod 的运行情况，如果没有正常运行，点击 tab “修正历史”查看原因。<br>服务设置为“仅在集群内访问”时，可以通过远程登录 pod 进行测试：点击 tab“Pod 管理“，选择一个 pod 点击远程登录，进入 cmd 界面后执行<code>curl &lt;Kubernetes Service 的域名&gt;:&lt;服务端口&gt;</code>，看返回是否是打包项目的内容<br><img src="https://qcloudimg.tencent-cloud.cn/image/document/4b2622c6b32d982dd29c6b25eb847e10.png"></p><p>服务设置为“内网 LB 访问”时，可以直接在浏览器地址栏输入<code>&lt;负载均衡IP&gt;:&lt;服务端口&gt;</code>看打开的页面是否是打包项目的内容。负载均衡 IP 在点击新建的 Service 名称的“详情”tab 里可以看到</p><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p><strong>Kubernetes Service 的域名</strong>：在 Kubernetes 中，每个 Service 都有一个唯一的域名，该域名遵循以下格式：<code>&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local</code>。其中：</p><ul><li><service-name> 是 Service 的名称。</li><li><namespace> 是 Service 所属的命名空间（Namespace）。</li><li>svc.cluster.local 是 Kubernetes 集群中所有 Service 的域名后缀。</li></ul><p>Kubernetes Service 的域名会映射到该 Service 的 ClusterIP 地址上。当你创建一个 Service 时，Kubernetes 会为该 Service 分配一个 ClusterIP 地址，并为该 Service 自动生成一个域名，其格式为 <code>&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local</code>。这个域名会自动解析到该 Service 的 ClusterIP 地址。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://zhuanlan.zhihu.com/p/618249568">kubernetes 入门看这篇就够了</a><br>（2）<a href="https://blog.csdn.net/wang_dian1/article/details/132045116">【云原生】K8S 超详细概述</a><br>（3）<a href="https://cloud.tencent.com/developer/article/1412208">在 TKE 集群中新建工作负载</a><br>（4）<a href="https://cloud.tencent.com/document/product/457/45598">tke 容器服务</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近因为项目迁移老要操作腾讯云服务，所以写个总结的文章，梳理一下涉及的知识和操作。说真的前端部署真的应该考虑这些吗？&lt;/p&gt;</summary>
    
    
    
    <category term="备忘录" scheme="https://unkonwn404.github.io/unknown404.github.io/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
    <category term="k8s" scheme="https://unkonwn404.github.io/unknown404.github.io/tags/k8s/"/>
    
    <category term="前端部署" scheme="https://unkonwn404.github.io/unknown404.github.io/tags/%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>h5使用canvas绘制海报</title>
    <link href="https://unkonwn404.github.io/unknown404.github.io/2024/02/05/h5poster/"/>
    <id>https://unkonwn404.github.io/unknown404.github.io/2024/02/05/h5poster/</id>
    <published>2024-02-05T09:00:26.000Z</published>
    <updated>2024-02-06T02:52:52.349Z</updated>
    
    <content type="html"><![CDATA[<p>最近开发 canvas 绘制时发现自己有点忘了绘制规则了，所以贴一下代码做个备份。</p><span id="more"></span><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> bg = <span class="hljs-string">&quot;xxx.png&quot;</span>;<br><span class="hljs-keyword">var</span> qrcode = <span class="hljs-string">&quot;xxxx.png&quot;</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: 海报生成函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; sourceItem 「imgUrl：头图；text（array）；title；」</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; rect 海报宽高值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">*</span>&#125; base64图片</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">drawPoster</span>(<span class="hljs-params"></span><br><span class="hljs-params">  sourceItem,</span><br><span class="hljs-params">  rect = &#123; width: <span class="hljs-number">375</span>, height: <span class="hljs-number">667</span> &#125;</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; imgUrl, text, title, type &#125; = sourceItem;<br>  <span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;canvas&quot;</span>);<br>  <span class="hljs-keyword">var</span> dpr = <span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span> || <span class="hljs-number">1</span>;<br>  canvas.<span class="hljs-property">width</span> = rect.<span class="hljs-property">width</span> * dpr;<br>  canvas.<span class="hljs-property">height</span> = rect.<span class="hljs-property">height</span> * dpr;<br>  <span class="hljs-keyword">const</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&quot;2d&quot;</span>);<br>  ctx.<span class="hljs-title function_">clearRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, canvas.<span class="hljs-property">width</span>, canvas.<span class="hljs-property">height</span>);<br>  <span class="hljs-comment">// 绘制背景图</span><br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">drawPic</span>(ctx, dpr, bg);<br>  <span class="hljs-comment">// 绘制ai图</span><br>  ctx.<span class="hljs-title function_">save</span>();<br>  <span class="hljs-title function_">drawArcFrame</span>(ctx, <span class="hljs-number">64</span> * dpr, <span class="hljs-number">64</span> * dpr, <span class="hljs-number">246</span> * dpr, <span class="hljs-number">376</span> * dpr, <span class="hljs-number">16</span> * dpr);<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">drawPic</span>(<br>    ctx,<br>    dpr,<br>    imgUrl,<br>    &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">64</span> * dpr, <span class="hljs-attr">y</span>: <span class="hljs-number">64</span> * dpr &#125;,<br>    &#123; <span class="hljs-attr">width</span>: <span class="hljs-number">246</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">376</span> &#125;<br>  );<br>  ctx.<span class="hljs-title function_">restore</span>();<br>  <span class="hljs-comment">// 绘制qrcode</span><br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">drawPic</span>(<br>    ctx,<br>    dpr,<br>    qrcode,<br>    &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">239</span> * dpr, <span class="hljs-attr">y</span>: <span class="hljs-number">369</span> * dpr &#125;,<br>    &#123; <span class="hljs-attr">width</span>: <span class="hljs-number">68</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">68</span> &#125;<br>  );<br>  <span class="hljs-comment">// 绘制文字</span><br>  <span class="hljs-keyword">const</span> lineHeight = <span class="hljs-number">25</span> * dpr;<br>  <span class="hljs-keyword">var</span> startY = <span class="hljs-number">467</span> * dpr + lineHeight,<br>    startX = <span class="hljs-number">0</span>;<br>  ctx.<span class="hljs-property">textAlign</span> = <span class="hljs-string">&quot;center&quot;</span>;<br>  <span class="hljs-comment">// 预处理，对每行文字进行折行逻辑处理</span><br>  <span class="hljs-keyword">let</span> lineCount = <span class="hljs-number">4</span>;<br>  <span class="hljs-keyword">let</span> row = [];<br>  ctx.<span class="hljs-property">font</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-number">17</span> * dpr&#125;</span>px PingFangSC, PingFang SC`</span>; <span class="hljs-comment">// 设置字体样式和大小</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; text.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> line = text[i];<br>    <span class="hljs-keyword">let</span> tempText = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> wordIndex = <span class="hljs-number">0</span>; wordIndex &lt; line.<span class="hljs-property">length</span>; wordIndex++) &#123;<br>      <span class="hljs-keyword">if</span> (ctx.<span class="hljs-title function_">measureText</span>(tempText).<span class="hljs-property">width</span> &lt; <span class="hljs-number">200</span> * dpr) &#123;<br>        tempText += line[wordIndex];<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        wordIndex--;<br>        row.<span class="hljs-title function_">push</span>(tempText);<br>        tempText = <span class="hljs-string">&quot;&quot;</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (tempText) row.<span class="hljs-title function_">push</span>(tempText);<br>  &#125;<br>  <span class="hljs-keyword">let</span> totalLineCount = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(row.<span class="hljs-property">length</span>, lineCount);<br>  <span class="hljs-keyword">if</span> (title) &#123;<br>    startX = canvas.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>;<br>    totalLineCount++;<br>    startY = <span class="hljs-number">539</span> * dpr - (lineHeight * totalLineCount) / <span class="hljs-number">2</span> + lineHeight / <span class="hljs-number">2</span>;<br>    <span class="hljs-title function_">drawText</span>(<br>      ctx,<br>      dpr,<br>      title,<br>      &#123; <span class="hljs-attr">x</span>: startX, <span class="hljs-attr">y</span>: startY &#125;,<br>      <span class="hljs-number">17</span>,<br>      <span class="hljs-string">&quot;normal&quot;</span>,<br>      <span class="hljs-string">&quot;#AD2700&quot;</span><br>    );<br>    startY += lineHeight;<br>    totalLineCount--;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    startY = <span class="hljs-number">539</span> * dpr - (lineHeight * totalLineCount) / <span class="hljs-number">2</span> + lineHeight / <span class="hljs-number">2</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(row.<span class="hljs-property">length</span>, lineCount); i++) &#123;<br>    startX = canvas.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>;<br>    <span class="hljs-title function_">drawText</span>(ctx, dpr, row[i], &#123; <span class="hljs-attr">x</span>: startX, <span class="hljs-attr">y</span>: startY &#125;, <span class="hljs-number">17</span>, <span class="hljs-string">&quot;bold&quot;</span>, <span class="hljs-string">&quot;#AD2700&quot;</span>);<br>    startY += lineHeight;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> imageURL = canvas.<span class="hljs-title function_">toDataURL</span>(<span class="hljs-string">&quot;image/png&quot;</span>); <span class="hljs-comment">// 将Canvas转换为PNG格式的图片URL</span><br>  <span class="hljs-keyword">return</span> imageURL;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">drawText</span>(<span class="hljs-params"></span><br><span class="hljs-params">  ctx,</span><br><span class="hljs-params">  dpr = <span class="hljs-number">2</span>,</span><br><span class="hljs-params">  text,</span><br><span class="hljs-params">  position = &#123; x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span> &#125;,</span><br><span class="hljs-params">  fontSize = <span class="hljs-number">30</span>,</span><br><span class="hljs-params">  fontWeight = <span class="hljs-string">&quot;normal&quot;</span>,</span><br><span class="hljs-params">  color = <span class="hljs-string">&quot;red&quot;</span></span><br><span class="hljs-params"></span>) &#123;<br>  ctx.<span class="hljs-property">fillStyle</span> = color;<br>  ctx.<span class="hljs-property">font</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;fontWeight&#125;</span> <span class="hljs-subst">$&#123;fontSize * dpr&#125;</span>px PingFangSC, PingFang SC`</span>; <span class="hljs-comment">// 设置字体样式和大小</span><br>  ctx.<span class="hljs-title function_">fillText</span>(text, position.<span class="hljs-property">x</span>, position.<span class="hljs-property">y</span>); <span class="hljs-comment">// 设置文字位置和内容</span><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">drawPic</span>(<span class="hljs-params"></span><br><span class="hljs-params">  ctx,</span><br><span class="hljs-params">  dpr = <span class="hljs-number">2</span>,</span><br><span class="hljs-params">  imgUrl,</span><br><span class="hljs-params">  position = &#123; x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span> &#125;,</span><br><span class="hljs-params">  rect = &#123; width: <span class="hljs-number">375</span>, height: <span class="hljs-number">667</span> &#125;</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> image = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();<br>    image.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;crossOrigin&quot;</span>, <span class="hljs-string">&quot;anonymous&quot;</span>);<br>    image.<span class="hljs-property">src</span> = imgUrl;<br>    image.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      ctx.<span class="hljs-title function_">drawImage</span>(<br>        image,<br>        position.<span class="hljs-property">x</span>,<br>        position.<span class="hljs-property">y</span>,<br>        rect.<span class="hljs-property">width</span> * dpr,<br>        rect.<span class="hljs-property">height</span> * dpr<br>      );<br>      <span class="hljs-title function_">resolve</span>();<br>    &#125;;<br>  &#125;);<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">drawArcFrame</span>(<span class="hljs-params">ctx, x, y, w, h, r</span>) &#123;<br>  ctx.<span class="hljs-title function_">beginPath</span>();<br>  <span class="hljs-comment">// 因为边缘描边存在锯齿，最好指定使用 transparent 填充</span><br>  ctx.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&quot;transparent&quot;</span>;<br>  <span class="hljs-comment">// 左上角</span><br>  ctx.<span class="hljs-title function_">arc</span>(x + r, y + r, r, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">1.5</span>);<br><br>  <span class="hljs-comment">// border-top</span><br>  ctx.<span class="hljs-title function_">moveTo</span>(x + r, y);<br>  ctx.<span class="hljs-title function_">lineTo</span>(x + w - r, y);<br>  ctx.<span class="hljs-title function_">lineTo</span>(x + w, y + r);<br>  <span class="hljs-comment">// 右上角</span><br>  ctx.<span class="hljs-title function_">arc</span>(x + w - r, y + r, r, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">1.5</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>);<br><br>  <span class="hljs-comment">// border-right</span><br>  ctx.<span class="hljs-title function_">lineTo</span>(x + w, y + h - r);<br>  ctx.<span class="hljs-title function_">lineTo</span>(x + w - r, y + h);<br>  <span class="hljs-comment">// 右下角</span><br>  ctx.<span class="hljs-title function_">arc</span>(x + w - r, y + h - r, r, <span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">0.5</span>);<br><br>  <span class="hljs-comment">// border-bottom</span><br>  ctx.<span class="hljs-title function_">lineTo</span>(x + r, y + h);<br>  ctx.<span class="hljs-title function_">lineTo</span>(x, y + h - r);<br>  <span class="hljs-comment">// 左下角</span><br>  ctx.<span class="hljs-title function_">arc</span>(x + r, y + h - r, r, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">0.5</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>);<br><br>  <span class="hljs-comment">// border-left</span><br>  ctx.<span class="hljs-title function_">lineTo</span>(x, y + r);<br>  ctx.<span class="hljs-title function_">lineTo</span>(x + r, y);<br><br>  <span class="hljs-comment">// 这里是使用 fill 还是 stroke都可以，二选一即可，但是需要与上面对应</span><br>  ctx.<span class="hljs-title function_">fill</span>();<br>  <span class="hljs-comment">// ctx.stroke()</span><br>  ctx.<span class="hljs-title function_">closePath</span>();<br>  <span class="hljs-comment">// 剪切</span><br>  ctx.<span class="hljs-title function_">clip</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>注意点：</p><ul><li>绘制图片属于异步操作，只能等图片加载完才能绘制，如果存在显示于图片之上的文字，必须要让文字的绘制在图片回调函数执行之后发生，不能同步执行</li><li>绘制圆角时，需使用函数 ctx.save()保存之前的绘制内容；圆角的实现本质是对画板进行了剪切、再填充绘制内容实现的，绘制完成后用 ctx.restore()将画板剩余部分恢复</li><li>文字绘制时起始坐标默认是文字的左下而不是左上</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近开发 canvas 绘制时发现自己有点忘了绘制规则了，所以贴一下代码做个备份。&lt;/p&gt;</summary>
    
    
    
    <category term="备忘录" scheme="https://unkonwn404.github.io/unknown404.github.io/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
    <category term="canvas" scheme="https://unkonwn404.github.io/unknown404.github.io/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>babel初识</title>
    <link href="https://unkonwn404.github.io/unknown404.github.io/2024/02/04/babel/"/>
    <id>https://unkonwn404.github.io/unknown404.github.io/2024/02/04/babel/</id>
    <published>2024-02-04T03:11:17.000Z</published>
    <updated>2024-02-06T03:38:21.503Z</updated>
    
    <content type="html"><![CDATA[<p>了解一下 babel 相关配置</p><span id="more"></span><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>babel 最初是用于 es6 转 es5，确保各端浏览器能支持代码逻辑的运行。但现在 babel 作为转译器，还可以实现其他的功能</p><h2 id="babel-作用"><a href="#babel-作用" class="headerlink" title="babel 作用"></a>babel 作用</h2><h3 id="转译-es、typescript、flow-等到目标环境支持的-js"><a href="#转译-es、typescript、flow-等到目标环境支持的-js" class="headerlink" title="转译 es、typescript、flow 等到目标环境支持的 js"></a>转译 es、typescript、flow 等到目标环境支持的 js</h3><p>这个是最常用的功能，用来把代码中的 es 的新的语法、typescript 和 flow 的语法转成基于目标环境支持的语法的实现。并且还可以把目标环境不支持的 api 进行 polyfill。</p><p>babel7 提供了 @babel&#x2F;preset-env 的包，可以指定目标 env 来按需转换，转换更加的精准，产物更小。</p><h3 id="一些特定用途的转换"><a href="#一些特定用途的转换" class="headerlink" title="一些特定用途的转换"></a>一些特定用途的转换</h3><p>比如函数插桩（函数中自动插入一些代码，例如埋点代码）、自动国际化等。</p><h3 id="代码的静态分析"><a href="#代码的静态分析" class="headerlink" title="代码的静态分析"></a>代码的静态分析</h3><p>对代码进行 parse 之后，会生成 AST，通过 AST 能够理解代码结构，除了转换 AST 再打印成目标代码之外，也同样可以用于分析代码的信息，进行一些静态检查。例如：</p><ul><li>linter 工具就是分析 AST 的结构，对代码规范进行检查。</li><li>api 文档自动生成工具，可以提取源码中的注释，然后生成文档。</li><li>…</li></ul><h2 id="babel-配置的方式"><a href="#babel-配置的方式" class="headerlink" title="babel 配置的方式"></a>babel 配置的方式</h2><ul><li>babel.config.json：在项目的根目录（package.json 文件所在的目录）下</li><li>.babelrc.json：在项目的根目录（package.json 文件所在的目录）下</li><li>@babel&#x2F;cli</li></ul><p>三种配置方式的权重排序（由小到大） babel.config.json &lt; .babelrc &lt; programmatic options from @babel&#x2F;cli</p><h2 id="常用-babel-配置"><a href="#常用-babel-配置" class="headerlink" title="常用 babel 配置"></a>常用 babel 配置</h2><p>babel 中插件可配置两个属性——presets 和 plugins，应用顺序是：先 plugin 再 preset，plugin 从左到右，preset 从右到左。</p><h3 id="presets"><a href="#presets" class="headerlink" title="presets"></a>presets</h3><p>一般情况下一个插件用来解决一个语法转译问题，例如@babel&#x2F;plugin-transform-arrow-functions 可以用于箭头函数转为一般函数，@babel&#x2F;plugin-transform-destructuring 则用于将 es6 的解构语法进行转译。而 presets 可以理解为官方预置的 es 的新的语法、typescript 和 flow 的语法转译为目标环境支持语法的插件的集合，省去了我们一个个引入插件的麻烦。<br>babel 官方目前提供的预设包括：</p><ul><li>@babel&#x2F;preset-env (转译 es 6+语法)</li><li>@babel&#x2F;preset-typescript （转译 ts 语法）</li><li>@babel&#x2F;preset-react （转译 react 语法）</li><li>@babel&#x2F;preset-flow （转译 flow 语法）</li></ul><h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><p>常用的插件有：</p><h4 id="babel-x2F-plugin-transform-runtime"><a href="#babel-x2F-plugin-transform-runtime" class="headerlink" title="@babel&#x2F;plugin-transform-runtime"></a>@babel&#x2F;plugin-transform-runtime</h4><p>转译 class 语法时 babel 注入了一些辅助函数的声明，以便语法转换后使用。但如果多个文件都使用了 class 语法，转译时这些辅助函数都会在转换文件里定义，尽管函数功能是相同的<br>plugin-transform-runtime 则是可以将 helper 和 polyfill 都改为从一个统一的地方引入，并且引入的对象和全局变量是完全隔离的</p><h4 id="babel-x2F-plugin-proposal-decorators"><a href="#babel-x2F-plugin-proposal-decorators" class="headerlink" title="@babel&#x2F;plugin-proposal-decorators"></a>@babel&#x2F;plugin-proposal-decorators</h4><p>转译 js 装饰器语法</p><h4 id="babel-plugin-import"><a href="#babel-plugin-import" class="headerlink" title="babel-plugin-import"></a>babel-plugin-import</h4><p>模块化导入插件，可以实现按需引入依赖包模块<br>使用示例：<br>使用指令<code>npm install babel-plugin-import --save-dev</code>安装该依赖后对 babel 配置文件进行如下配置</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123;<br>  plugins: [<br>    [<span class="hljs-string">&quot;import&quot;</span>, &#123;<br>      <span class="hljs-string">&quot;libraryName&quot;</span>: <span class="hljs-string">&quot;antd&quot;</span>, <span class="hljs-regexp">//</span> 指定导入包的名称<br>      <span class="hljs-string">&quot;libraryDirectory&quot;</span>: <span class="hljs-string">&quot;lib&quot;</span>, <span class="hljs-regexp">//</span> 指定模块的存放目录<br>      style: <span class="hljs-string">&quot;css&quot;</span>, <span class="hljs-regexp">//</span> 导入 css 样式<br>    &#125;]<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>不过理论上新版的 antd 和 material-ui 中，默认已支持基于 ES modules 的 tree shaking 功能；而打包工具如：Webpack、Rollup 等在打包层面也支持了 <a href="https://juejin.cn/post/7298966922329554995?searchId=20240206112751FE48D0DEEA2D4405759C">tree shaking</a>，使得我们不需要额外配置 babel-plugin-import 也能实现按需引入</p><h2 id="babel-编译流程"><a href="#babel-编译流程" class="headerlink" title="babel 编译流程"></a>babel 编译流程</h2><p>整体编译流程主要分为三步：</p><ul><li>parse：通过 parser 把源码转成抽象语法树（AST）</li><li>transform：遍历 AST，调用各种 transform 插件对 AST 进行增删改</li><li>generate：把转换后的 AST 打印成目标代码，并生成 sourcemap</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/7049160361173319693?from=search-suggest">一文轻松掌握 babel</a><br>（2）<a href="https://zhuanlan.zhihu.com/p/394783228?utm_id=0">Babel 教程 11：@babel&#x2F;plugin-transform-runtime</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;了解一下 babel 相关配置&lt;/p&gt;</summary>
    
    
    
    <category term="技术学习" scheme="https://unkonwn404.github.io/unknown404.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="babel" scheme="https://unkonwn404.github.io/unknown404.github.io/tags/babel/"/>
    
    <category term="前端编译" scheme="https://unkonwn404.github.io/unknown404.github.io/tags/%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>stylex</title>
    <link href="https://unkonwn404.github.io/unknown404.github.io/2024/01/25/stylex/"/>
    <id>https://unkonwn404.github.io/unknown404.github.io/2024/01/25/stylex/</id>
    <published>2024-01-25T06:40:51.000Z</published>
    <updated>2024-02-02T07:53:01.496Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>近日，Meta 开源了一款「CSS-in-JS 库」 —— StyleX。这个项目从提出到 Meta 内部使用到最终开源经历了大约 5 年的时间，据说这套解决方案让 facebook 首页样式文件体积减少了至少 80%。</p><h2 id="常见-css-方案"><a href="#常见-css-方案" class="headerlink" title="常见 css 方案"></a>常见 css 方案</h2><h3 id="BEM"><a href="#BEM" class="headerlink" title="BEM"></a>BEM</h3><p>BEM 是一种用于编写 CSS 类名的命名约定，它基于块（block）、元素（element）和修饰符（modifier）的概念。使用 BEM 命名约定，可以更清晰地表达 CSS 类之间的关系，并使代码更易于维护和扩展。<br>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card__header&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 块内的元素 --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card__body&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 块内的元素 --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card__footer card__footer--highlighted&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 块内的元素，并带有修饰符 --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在这个例子中，card 是一个块，它包含了 header、body 和 footer 这些元素。footer 元素还带有一个修饰符 highlighted，表示这个底部元素有一些突出显示的样式。</p><h3 id="CSS-Modules"><a href="#CSS-Modules" class="headerlink" title="CSS Modules"></a>CSS Modules</h3><p>CSS Modules 是一种将 CSS 文件与 JavaScript 模块分离的技术。通过使用 CSS Modules，可以将 CSS 类名限制在模块内部，从而避免全局命名冲突的问题。</p><p>示例：<br>在 webpack 中进行如下配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// webpack.config.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// 其他配置项</span><br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,<br>        <span class="hljs-attr">use</span>: [<span class="hljs-string">&quot;style-loader&quot;</span>, <span class="hljs-string">&quot;css-loader&quot;</span>],<br>      &#125;,<br>    ],<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>将 css 文件引入 js，样式表中的类名将被映射为一个对象，可以通过该对象访问局部化的类名，再在 jsx 或 html 中使用该类名。编译时会自动生成一个唯一的类名，避免全局命名冲突。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;<br>  <span class="hljs-attribute">overflow</span>: scroll;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#f5f7fa</span>;<br>  <span class="hljs-selector-class">.nav</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./styles.less&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">NavBar</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;antd-mobile&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyTask</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;styles.container&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">NavBar</span> <span class="hljs-attr">onBack</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;&#125;&#125; className=&#123;styles.nav&#125;&gt;</span><br><span class="language-xml">        我的任务</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">NavBar</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="原子-css"><a href="#原子-css" class="headerlink" title="原子 css"></a>原子 css</h3><p>原子 CSS 是一种将 CSS 属性分解为最基本的元素的技术。通过使用原子 CSS，可以将复杂的样式表分解为更小的、可重用和可维护的模块。目前这方面的实现有<a href="https://tailwindcss.com/">Tailwind CSS</a>、<a href="https://windicss.org/">Windi CSS</a>等<br>以 Tailwind CSS 为例，它提供了一组预定义的类名，每个类名都代表一个特定的样式属性。通过使用这些类名，可以轻松地创建具有不同样式和布局的组件。<br>示例：在 css 文件引入预设置的文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@tailwind</span> base;<br><span class="hljs-keyword">@tailwind</span> components;<br><span class="hljs-keyword">@tailwind</span> utilities;<br></code></pre></td></tr></table></figure><p>使用预设样式<br><img src="/unknown404.github.io/img/stylex/tailwind.jpg"></p><p>样式解释：</p><ul><li>max-w-7xl: 这个类设置了元素的宽度最大为 7XL 尺寸，其中 7XL 是 Tailwind CSS 的尺寸单位之一。7XL 通常对应于屏幕尺寸的非常大的屏幕。</li><li>mx-auto: 这个类设置元素的左右边距自动，使元素在水平方向上居中。</li><li>text-center: 这个类将文本内容居中对齐。</li><li>py-12: 这个类设置元素的上边距和下边距为 12 个尺寸单位。在 Tailwind CSS 中，py 是“padding-y”的缩写，表示元素的垂直内边距。</li><li>px-4: 这个类设置元素的左外边距和右外边距为 4 个尺寸单位。px 是“padding-x”的缩写，表示元素的水平内边距。</li><li>sm:px-6: 这个类是一个断点特定的类，它只在屏幕尺寸小于或等于小型设备时生效。在这种情况下，它将元素的水平内边距设置为 6 个尺寸单位。</li><li>lg:py-16: 这个类是一个断点特定的类，它只在屏幕尺寸大于或等于大型设备时生效。在这种情况下，它将元素的上边距和下边距设置为 16 个尺寸单位。</li><li>lg:px-8: 这个类也是一个断点特定的类，它只在屏幕尺寸大于或等于大型设备时生效。在这种情况下，它将元素的左外边距和右外边距设置为 8 个尺寸单位。</li></ul><h3 id="CSS-in-JS"><a href="#CSS-in-JS" class="headerlink" title="CSS-in-JS"></a>CSS-in-JS</h3><p>CSS 中的 JavaScript 是一种将 JavaScript 代码嵌入到 CSS 中的方式。通过这种方式，可以在 CSS 中使用 JavaScript 变量、函数和逻辑，以实现更灵活和动态的样式和布局。目前这方面实现的库有<a href="https://styled-components.com/docs/basics">style components</a>、<a href="https://emotion.sh/">Emotion</a>等</p><p>stylex 也属于 CSS-in-JS 库</p><h2 id="stylex-的基本用法"><a href="#stylex-的基本用法" class="headerlink" title="stylex 的基本用法"></a>stylex 的基本用法</h2><p>StyleX 的 API 很少，主要涉及两个常用方法：</p><ul><li>stylex.create，创建样式<br>代码示例如下，使用 stylex.create 函数创建了 4 个命名空间：header，logo，link，txtcenter</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> stylex <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@stylexjs/stylex&quot;</span>;<br><br><span class="hljs-keyword">const</span> styles = stylex.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-attr">header</span>: &#123;<br>    <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&quot;#282c34&quot;</span>,<br>    <span class="hljs-attr">minHeight</span>: <span class="hljs-string">&quot;100vh&quot;</span>,<br>    <span class="hljs-attr">display</span>: <span class="hljs-string">&quot;flex&quot;</span>,<br>    <span class="hljs-attr">flexDirection</span>: <span class="hljs-string">&quot;column&quot;</span>,<br>    <span class="hljs-attr">alignItems</span>: <span class="hljs-string">&quot;center&quot;</span>,<br>    <span class="hljs-attr">justifyContent</span>: <span class="hljs-string">&quot;center&quot;</span>,<br>    <span class="hljs-attr">fontSize</span>: <span class="hljs-string">&quot;calc(10px + 2vmin)&quot;</span>,<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;white&quot;</span>,<br>  &#125;,<br>  <span class="hljs-attr">logo</span>: &#123;<br>    <span class="hljs-attr">height</span>: <span class="hljs-string">&quot;40vmin&quot;</span>,<br>    <span class="hljs-attr">pointerEvents</span>: <span class="hljs-string">&quot;none&quot;</span>,<br>  &#125;,<br>  <span class="hljs-attr">link</span>: &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;#61dafb&quot;</span>,<br>  &#125;,<br>  <span class="hljs-attr">txtcenter</span>: &#123;<br>    <span class="hljs-attr">textAlign</span>: <span class="hljs-string">&quot;center&quot;</span>,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>stylex.props，定义 html 的 props，将 stylex.create 定义的样式应用到 html 上（如果定义的是静态样式，dom 上增加的属性为 class；如果定义的是动态样式，dom 上增加的属性为 style）<br>代码示例如下：</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> &#123;<span class="hljs-attr">...stylex.props</span>(<span class="hljs-attr">styles.txtcenter</span>)&#125;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">header</span> &#123;<span class="hljs-attr">...stylex.props</span>(<span class="hljs-attr">styles.header</span>)&#125;&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;logo&#125;</span> &#123;<span class="hljs-attr">...stylex.props</span>(<span class="hljs-attr">styles.logo</span>)&#125; <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;logo&quot;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">          Edit <span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>src/App.js<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span> and save to reload.</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">a</span></span></span><br><span class="hljs-tag"><span class="language-xml">          &#123;<span class="hljs-attr">...stylex.props</span>(<span class="hljs-attr">styles.link</span>)&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://reactjs.org&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;noopener noreferrer&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        &gt;</span></span><br><span class="language-xml">          Learn React</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>编译后运行的结果如图所示</p><p><img src="/unknown404.github.io/img/stylex/stylex.jpg"><br>可以看到命名空间的样式被拆成了多个类名</p><h2 id="stylex-优势"><a href="#stylex-优势" class="headerlink" title="stylex 优势"></a>stylex 优势</h2><h3 id="文件可扩展"><a href="#文件可扩展" class="headerlink" title="文件可扩展"></a>文件可扩展</h3><p>stylex 减少不必要的 CSS 规则和类名，从而减少最终输出的 CSS 文件大小；即使组件增加，css 大小也不会增加太多</p><p>假设样式设置为：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> logo <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./logo.svg&quot;</span>;<br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> stylex <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@stylexjs/stylex&quot;</span>;<br><br><span class="hljs-keyword">const</span> styles = stylex.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-attr">link</span>: &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;#61dafb&quot;</span>,<br>  &#125;,<br>  <span class="hljs-attr">txt</span>: &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;#61dafb&quot;</span>,<br>  &#125;,<br>&#125;);<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;logo&#125;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;logo&quot;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> &#123;<span class="hljs-attr">...stylex.props</span>(<span class="hljs-attr">styles.txt</span>)&#125;&gt;</span></span><br><span class="language-xml">          Edit <span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>src/App.js<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span> and save to reload.</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">a</span></span></span><br><span class="hljs-tag"><span class="language-xml">          &#123;<span class="hljs-attr">...stylex.props</span>(<span class="hljs-attr">styles.link</span>)&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://reactjs.org&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;noopener noreferrer&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        &gt;</span></span><br><span class="language-xml">          Learn React</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><p><img src="/unknown404.github.io/img/stylex/scaleable.jpg"></p><p>从编译结果可以看到即使命名空间不同，只要样式一致都会赋给相同的类名。这种原子类名的控制粒度确保了即使项目体积增大，样式表的体积也能控制在合理的范围内。</p><h3 id="样式效果可预测"><a href="#样式效果可预测" class="headerlink" title="样式效果可预测"></a>样式效果可预测</h3><p>没有特定的样式优先级问题，最后应用的样式将覆盖先前的样式。这使得样式的应用更加简单和一致。</p><p>假设存在如下 css 文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.blue</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br><span class="hljs-selector-class">.red</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p>以及如下 html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;red blue&quot;</span>&gt;</span>我是什么颜色？<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>最终显示的 p 标签是什么颜色的呢？实际上，样式取决于他们在样式表中定义的顺序，.red 的定义在.blue 后面，所以 p 应该是红色的。而如果 blue 和 red 分别在两个 css 文件里，则 p 标签的颜色取决于样式文件的加载顺序。</p><p>而在 stylex 中样式的优先级只需要考虑 styles.props 中的调用顺序，以最后一个为准。例如在下面的代码中 blue 在 red 后面，所以颜色为 blue</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> stylex <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;stylex&quot;</span>;<br><br><span class="hljs-comment">// 创建样式</span><br><span class="hljs-keyword">const</span> styles = stylex.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-attr">red</span>: &#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;red&quot;</span> &#125;,<br>  <span class="hljs-attr">blue</span>: &#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;blue&quot;</span> &#125;,<br>&#125;);<br><br><span class="hljs-comment">// 使用</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> &#123;<span class="hljs-attr">...styles.props</span>(<span class="hljs-attr">styles.red</span>, <span class="hljs-attr">styles.blue</span>)&#125;&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;<br></code></pre></td></tr></table></figure><h3 id="样式的类型安全"><a href="#样式的类型安全" class="headerlink" title="样式的类型安全"></a>样式的类型安全</h3><p>可以与 typescript 结合、定义类型声明限制自定义组件的样式传参。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> &#123;<span class="hljs-title class_">StyleXStyles</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@stylexjs/stylex&#x27;</span>;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Props</span> = &#123;<br>  <span class="hljs-comment">// ...</span><br>  style?: <span class="hljs-title class_">StyleXStyles</span>&lt;&#123;<br>    color?: <span class="hljs-built_in">string</span>;<br>    backgroundColor?: <span class="hljs-built_in">string</span>;<br>    borderColor?: <span class="hljs-built_in">string</span>;<br>    borderTopColor?: <span class="hljs-built_in">string</span>;<br>    borderEndColor?: <span class="hljs-built_in">string</span>;<br>    borderBottomColor?: <span class="hljs-built_in">string</span>;<br>    borderStartColor?: <span class="hljs-built_in">string</span>;<br>  &#125;&gt;;<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params">&#123;style, ...&#125;: Props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span></span></span><br><span class="hljs-tag"><span class="language-xml">      &#123;<span class="hljs-attr">...stylex.props</span>(<span class="hljs-attr">localStyles.foo</span>, <span class="hljs-attr">localStyles.bar</span>, <span class="hljs-attr">style</span>)&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">    &gt;</span></span><br><span class="language-xml">      &#123;/* ... */&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>例如在这段代码中限制了组件 MyComponent 的 style props 只能接受如下 stylex 样式</p><h2 id="stylex-缺点"><a href="#stylex-缺点" class="headerlink" title="stylex 缺点"></a>stylex 缺点</h2><ul><li>并不提供完整的 css 选择器功能，为了使应用可预测，一些伪类选择器可能并不支持，比如 .className &gt; _、.className ~ _、.className:hover &gt; div:first-child 等</li></ul><h2 id="stylex-适用范围"><a href="#stylex-适用范围" class="headerlink" title="stylex 适用范围"></a>stylex 适用范围</h2><ul><li>用 js 控制 ui 的框架项目如 react，angular 等，vue、svelte 使用的话需要额外的自定义配置</li><li>庞大且体积不断增加的项目</li><li>可复用组件项目</li></ul><h2 id="后续碎碎念"><a href="#后续碎碎念" class="headerlink" title="后续碎碎念"></a>后续碎碎念</h2><p>因为 stylex 提供的 demo 都太简陋了，所以自己尝试用 create-react-app 搭建了一个项目测试它的使用，结果发现居然没有修改打包配置的方法，要想实现还要安装 craco 脚手架，真是麻烦。。。node 版本还必须 16 以上才能运行正常，这个怎么没在文档里写啊。。。话说 create-react-app 这个框架这么封闭、复杂点的需求还要配router和redux、为什么这么多人还喜欢用啊不理解。。。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://stylexjs.com/docs/learn/">Introduction to StyleX</a><br>（2）<a href="https://mp.weixin.qq.com/s/ysFnkHSTSGBn1UIdapZGVg">你了解 JSX，那你了解 StyleX 么？</a></p>]]></content>
    
    
    <summary type="html">2024技术分享的文档备份</summary>
    
    
    
    <category term="技术分享" scheme="https://unkonwn404.github.io/unknown404.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="css" scheme="https://unkonwn404.github.io/unknown404.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>监控告警设计</title>
    <link href="https://unkonwn404.github.io/unknown404.github.io/2024/01/17/errorAlert/"/>
    <id>https://unkonwn404.github.io/unknown404.github.io/2024/01/17/errorAlert/</id>
    <published>2024-01-17T07:03:03.000Z</published>
    <updated>2024-01-18T07:15:52.014Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>监控告警是当年接手的第一个 nodejs 需求，本来想在网上搜搜成熟的方案，然而可能是由于自己搜索能力太差了，没有找到合适的方案，于是自己就按照自己的想法写了一个监控告警的方案。现在回看当时的代码还是觉得有点稚嫩，只能说功能实现了，代码确实能跑。但是不是个稳健的代码自己心里一直没数，也不知道怎么写总结文档，所以一直拖到现在才想起来。可能是个糟糕的方案，但涉及的知识点还是值得记录的。</p><h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><ul><li>所有的项目采集到的前端错误都写入了专门的 es 了</li><li>提供 es 增删改查的能力及可视化展示的服务器是用 eggjs 框架搭建的</li><li>前端组有自己的一个 redis 库可供全部成员使用</li></ul><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>每个项目都可以配置多个告警规则（例如 “5min 内 js 报错次数超过 10 次”连续触发了 3 次、“30min 内资源错误影响用户数不超过 100 人”连续触发了 4 次）</li><li>告警规则命中时可以利用飞书机器人发送告警信息</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="告警规则校验"><a href="#告警规则校验" class="headerlink" title="告警规则校验"></a>告警规则校验</h3><p>要实现如 5min 内 js 报错次数超过 10 次的验证，首先需要统计每 5min 内 js 报错次数。考虑到可能会出现某一时间点报错数激增的情况，5min 的时间窗不应该重叠，重叠的话连续触发次数很容易达成。告警太频繁相当于没有作用，所以希望通过连续次数进行限制，确保告警上报的问题是持续存在的，是必须要检查修正的。分析需求后得出结论：</p><ul><li>为了检测连续触发次数，<strong>需要建立一个新表</strong>，用于存储每个项目每个告警规则的设置时间间隔内、设置的错误类型它的报错次数</li><li><strong>新表的数据写入依赖于定时任务</strong>，考虑到不同规则的时间间隔可能设置的不同，定时任务的执行间隔应该为设置时间间隔的最小公约数</li></ul><p>因为前端有现成的 redis 库，所以直接用它来存储每个告警规则的设置时间间隔内、设置的错误类型它的报错次数的数据。eggjs 连接 mongo 库需要 npm 安装模块 egg-mongoose（感谢上帝官方有做这种扩展）。在 config&#x2F;config.default.js 中配置 mongo 连接信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">appInfo</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">const</span> mongoose = &#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">`mongodb://<span class="hljs-subst">$&#123;ip&#125;</span>/`</span>, <span class="hljs-comment">//端口号可以省略</span><br>    <span class="hljs-attr">options</span>: &#123;<br>      <span class="hljs-attr">useNewUrlParser</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">auth</span>: &#123;<br>        <span class="hljs-attr">user</span>: <span class="hljs-string">&quot;username&quot;</span>,<br>        <span class="hljs-attr">password</span>: <span class="hljs-string">&quot;pwd&quot;</span>,<br>      &#125;,<br>    &#125;,<br>    <span class="hljs-attr">plugins</span>: [],<br>    <span class="hljs-attr">loadModel</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">app</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">agent</span>: <span class="hljs-literal">false</span>,<br>  &#125;;<br>  <span class="hljs-keyword">return</span> &#123;<br>    mongoose,<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>之后在 app&#x2F;model&#x2F;alarm.js 中定义新表的模型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 分钟错误日志数记录</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">app</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> mongoose = app.<span class="hljs-property">mongoose</span>;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title class_">Schema</span> = mongoose.<span class="hljs-property">Schema</span>;<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title class_">RecordsSchema</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>(&#123;<br>    <span class="hljs-attr">total</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,<br>    &#125;,<br>    <span class="hljs-attr">timestamp</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,<br>    &#125;,<br>    <span class="hljs-attr">interval</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,<br>    &#125;,<br>    <span class="hljs-attr">projectType</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<br>    &#125;,<br>    <span class="hljs-attr">errorType</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<br>    &#125;,<br>    <span class="hljs-attr">ruleType</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<br>    &#125;,<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&quot;Records&quot;</span>, <span class="hljs-title class_">RecordsSchema</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>之后在 app&#x2F;service&#x2F; 中编写 redis 增删改查功能时，可以直接用 ctx.model.Records 代表表格操作<br>egg-mongoose 提供的函数比较有限，这里只写一下用到的几种：</p><ul><li>insertMany：插入多项数据</li><li>find：查找数据，没有设置条件则查全部</li><li>remove：删除数据</li><li>deleteMany：删除特定条件数据</li></ul><p>eggjs 为约定式目录，所以直接在 app&#x2F;schedule 下新建一个文件夹，然后在该文件夹下新建一个 js 文件，命名为<code>checkAlarm.js</code>，在该文件中编写定时任务。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">schedule</span>: &#123;<br>    <span class="hljs-attr">interval</span>: <span class="hljs-string">&quot;1m&quot;</span>, <span class="hljs-comment">// 1 分钟间隔</span><br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;worker&quot;</span>, <span class="hljs-comment">// 指定的 worker 执行</span><br>  &#125;,<br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">task</span>(<span class="hljs-params">ctx</span>) &#123;<br>    <span class="hljs-comment">// 单个报错规则判定</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">queryErrorRecords</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">rule</span>) =&gt; &#123;<br>      <span class="hljs-keyword">const</span> projectType = rule.<span class="hljs-property">projectType</span>;<br>      <span class="hljs-keyword">const</span> type = rule.<span class="hljs-property">errorType</span>;<br><br>      <span class="hljs-keyword">let</span> endTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();<br>      <span class="hljs-comment">// 如果没有错误数日志，或当前时间与上一次日志记录的时间点大于规定间隔时，向es发起查询</span><br>      <span class="hljs-keyword">if</span> (<br>        record.<span class="hljs-property">length</span> == <span class="hljs-number">0</span> ||<br>        <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(<br>          (endTime - record[record.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>].<span class="hljs-property">timestamp</span>) / (<span class="hljs-number">60</span> * <span class="hljs-number">1000</span>)<br>        ) &gt;= rule.<span class="hljs-property">interval</span><br>      ) &#123;<br>        <span class="hljs-keyword">let</span> startTime = endTime - rule.<span class="hljs-property">interval</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;<br>        <span class="hljs-keyword">const</span> queryBody = &#123;<br>          <span class="hljs-attr">track_total_hits</span>: <span class="hljs-literal">true</span>,<br>          <span class="hljs-attr">query</span>: &#123;<br>            <span class="hljs-attr">bool</span>: &#123;<br>              <span class="hljs-attr">must</span>: [<br>                &#123;<br>                  <span class="hljs-attr">term</span>: &#123;<br>                    <span class="hljs-string">&quot;projectType.keyword&quot;</span>: projectType,<br>                  &#125;,<br>                &#125;,<br>                &#123;<br>                  <span class="hljs-attr">match</span>: &#123;<br>                    type,<br>                  &#125;,<br>                &#125;,<br>              ],<br>              <span class="hljs-attr">filter</span>: [<br>                &#123;<br>                  <span class="hljs-attr">range</span>: &#123;<br>                    <span class="hljs-attr">time</span>: &#123;<br>                      <span class="hljs-attr">gte</span>: startTime,<br>                      <span class="hljs-attr">lte</span>: endTime,<br>                    &#125;,<br>                  &#125;,<br>                &#125;,<br>              ],<br>            &#125;,<br>          &#125;,<br>          <span class="hljs-attr">sort</span>: [<br>            &#123;<br>              <span class="hljs-attr">time</span>: <span class="hljs-string">&quot;asc&quot;</span>,<br>            &#125;,<br>          ],<br>        &#125;;<br>        <span class="hljs-keyword">const</span> body = <span class="hljs-keyword">await</span> ctx.<span class="hljs-property">service</span>.<span class="hljs-property">esClient</span>.<span class="hljs-title function_">search</span>(queryBody);<br>        <span class="hljs-keyword">const</span> &#123;<br>          <span class="hljs-attr">hits</span>: &#123; hits, total &#125;,<br>        &#125; = body;<br>        <span class="hljs-comment">// 分警报类型处理报错</span><br>        newRecords.<span class="hljs-title function_">push</span>(&#123;<br>          <span class="hljs-attr">total</span>: total.<span class="hljs-property">value</span>,<br>          <span class="hljs-attr">timestamp</span>: endTime,<br>          <span class="hljs-attr">interval</span>: rule.<span class="hljs-property">interval</span>,<br>          <span class="hljs-attr">projectType</span>: projectType,<br>          <span class="hljs-attr">errorType</span>: type,<br>          <span class="hljs-attr">ruleType</span>: rule.<span class="hljs-property">ruleType</span>,<br>        &#125;);<br>      &#125;<br>    &#125;;<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;调用定时器回调&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    <span class="hljs-comment">// 获取报警规则</span><br>    <span class="hljs-keyword">let</span> &#123; data, env &#125; = <span class="hljs-keyword">await</span> ctx.<span class="hljs-property">service</span>.<span class="hljs-property">alertRule</span>.<span class="hljs-title function_">getWarning</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;current env:&quot;</span>, env);<br>    <span class="hljs-comment">// 数据格式调整</span><br>    <span class="hljs-keyword">let</span> rules = <span class="hljs-title function_">flattenRuleObj</span>(data);<br>    <span class="hljs-comment">// 获取和报警轮询相关的错误数日志</span><br>    <span class="hljs-keyword">let</span> records = <span class="hljs-keyword">await</span> ctx.<span class="hljs-property">service</span>.<span class="hljs-property">errorRecord</span>.<span class="hljs-title function_">getRecord</span>();<br>    <span class="hljs-keyword">let</span> newRecords = [];<br>    <span class="hljs-keyword">let</span> originalRecords = newRecords.<span class="hljs-title function_">slice</span>();<br><br>    <span class="hljs-keyword">if</span> (rules.<span class="hljs-property">length</span>) &#123;<br>      <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(<br>        rules.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">async</span> (rule, idx) =&gt; &#123;<br>          <span class="hljs-keyword">await</span> <span class="hljs-title function_">queryErrorRecords</span>(rule);<br>        &#125;)<br>      );<br><br>      <span class="hljs-comment">// 减少不必要的数据更改</span><br>      <span class="hljs-keyword">if</span> (newRecords.<span class="hljs-property">length</span> != originalRecords.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">await</span> ctx.<span class="hljs-property">service</span>.<span class="hljs-property">errorRecord</span>.<span class="hljs-title function_">storeRecord</span>(newRecords, env);<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> currentTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>    <span class="hljs-keyword">if</span> (currentTime.<span class="hljs-title function_">getHours</span>() == <span class="hljs-number">2</span> &amp;&amp; currentTime.<span class="hljs-title function_">getMinutes</span>() == <span class="hljs-number">10</span>) &#123;<br>      <span class="hljs-keyword">await</span> ctx.<span class="hljs-property">service</span>.<span class="hljs-property">errorRecord</span>.<span class="hljs-title function_">clearRecord</span>(<br>        currentTime.<span class="hljs-title function_">getTime</span>() - <span class="hljs-number">2</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>,<br>        env<br>      );<br>    &#125;<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>为简化方便展示，这里只展示了部分代码。定时任务启动后，首先查询报警规则，有报警规则设置时针对每一个报警规则进行数据处理（queryErrorRecords）：</p><ul><li>用 ctx.service.errorRecord.getRecord 获取当前报警规则下时间间隔的报错数统计结果</li><li>当前定时任务时间点与上一条记录时间点进行对比，如果大于等于设定的时间点，则向 es 进行时间间隔内特定错误的报错数查询，并将新的查询数与之前的时间间隔的报错数数据一起传给 mongo，更新表格</li><li>为防止表格数据越来越多，每天凌晨 2 点 10 分定时清除 2 点之前的数据</li></ul><p>关于为什么用 ctx.service.errorRecord.getRecord 做了全查，是因为告警规则有连续触发次数的设置，同时告警规则的时间间隔是可变动的，所以不好设置查询范围；另一方面要对所有的报警规则都做一次筛选查询感觉对请求接口压力比较大，做一次全查然后在 queryErrorRecords 做筛选处理感觉更合理。</p><h3 id="告警规则触发"><a href="#告警规则触发" class="headerlink" title="告警规则触发"></a>告警规则触发</h3><p>这里只以”5min 内 js 报错次数超过 10 次”连续触发了 3 次 的规则为例进行描述</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (relevantRecord.<span class="hljs-property">length</span> &gt;= rule.<span class="hljs-property">count</span> - <span class="hljs-number">1</span> &amp;&amp; total.<span class="hljs-property">value</span> &gt;= rule.<span class="hljs-property">limitValue</span>) &#123;<br>  <span class="hljs-comment">// 判断是否符合规则</span><br>  <span class="hljs-comment">// 判别规则1:警报设置连续次数是1时判断本次轮询报错数超过阈值</span><br>  <span class="hljs-comment">// 判别规则2:警报设置连续次数大于1时判断最近几条轮询报错数是否超过阈值</span><br>  <span class="hljs-comment">// 规则2情况下需要考虑关闭警报一段时间重新开启的情况，判断中应该对relevantRecord里的时间戳做检查</span><br>  <span class="hljs-keyword">const</span> timeRange = rule.<span class="hljs-property">count</span> * rule.<span class="hljs-property">interval</span>;<br>  <span class="hljs-keyword">const</span> isHitRule =<br>    (relevantRecord.<span class="hljs-property">length</span> == <span class="hljs-number">0</span> &amp;&amp; rule.<span class="hljs-property">count</span> == <span class="hljs-number">1</span>) ||<br>    relevantRecord<br>      .<span class="hljs-title function_">slice</span>(relevantRecord.<span class="hljs-property">length</span> - rule.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>, relevantRecord.<span class="hljs-property">length</span>)<br>      .<span class="hljs-title function_">every</span>(<br>        <span class="hljs-function">(<span class="hljs-params">item, i</span>) =&gt;</span><br>          item.<span class="hljs-property">total</span> &gt;= rule.<span class="hljs-property">limitValue</span> &amp;&amp;<br>          endTime - item.<span class="hljs-property">timestamp</span> &lt; (timeRange + <span class="hljs-number">1</span>) * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span><br>      );<br>  <span class="hljs-comment">// 符合规则且设置了webhook时发送警报</span><br>  <span class="hljs-keyword">if</span> (isHitRule &amp;&amp; rule.<span class="hljs-property">webhook</span>) &#123;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> ctx.<span class="hljs-property">service</span>.<span class="hljs-property">robot</span>.<span class="hljs-title function_">sendSettingMessage</span>(&#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;rich-text&quot;</span>,<br>      <span class="hljs-attr">webhook</span>: rule.<span class="hljs-property">webhook</span>,<br>      <span class="hljs-attr">msgBody</span>: &#123;<br>        <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;监控报警通知&quot;</span>,<br>        <span class="hljs-attr">firstLine</span>: <span class="hljs-string">`项目<span class="hljs-subst">$&#123;projectType&#125;</span>在<span class="hljs-subst">$&#123;</span></span><br><span class="hljs-subst"><span class="hljs-string">          rule.interval</span></span><br><span class="hljs-subst"><span class="hljs-string">        &#125;</span>min间隔，发生<span class="hljs-subst">$&#123;printErrorName(type)&#125;</span>，错误数超过阈值<span class="hljs-subst">$&#123;</span></span><br><span class="hljs-subst"><span class="hljs-string">          rule.limitValue</span></span><br><span class="hljs-subst"><span class="hljs-string">        &#125;</span>，连续<span class="hljs-subst">$&#123;rule.count&#125;</span>次`</span>,<br>        <span class="hljs-attr">secondLine</span>: <span class="hljs-string">&quot;请点击&quot;</span>,<br>        <span class="hljs-attr">link</span>: <span class="hljs-string">`http://<span class="hljs-subst">$&#123;MainDomain(env)&#125;</span>/#/list/<span class="hljs-subst">$&#123;type&#125;</span>`</span>,<br>      &#125;,<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 relevantRecord 就表示与告警规则相关的数据。当本次定时任务发现命中告警规则的时间间隔和错误数时，开始判断规则连续次数是否符合条件（连续次数为 1 直接可以告警）。用于判断的变量是 isHitRule，其逻辑如下：</p><ol><li>连续次数为 1，符合告警条件</li><li>连续次数大于 1，判断最近几条记录的错误数是否都大于阈值（需滤除关闭告警的时间段带来的误差）<br>飞书告警具体实现可以参考之前的文章</li></ol><h3 id="部署优化"><a href="#部署优化" class="headerlink" title="部署优化"></a>部署优化</h3><p>将该定时任务写好后部署到服务器上，发现有时候告警会连续报两次。经过排查后发现部署上的是一个服务器集群，共 6 个服务器，有两个执行的时间太过接近、所以当一个服务器还未传新的数据时另一个服务器也认为符合判定执行了查询、判断、告警，就导致了两次，其他时候的服务器由于读到了之前服务器推入的数据，因此不命中我的时间间隔判断条件<br>之前本来是希望参考<a href="https://blog.csdn.net/qq_24884955/article/details/82856230">这篇文章</a>设置一个服务器运行该定时任务，但是 hostname 的 hash 码太乱了，且每次上线都更新一次，没什么用</p><p>最终采用的是利用 redis 实现分布式锁的方法。分布式锁是一种在分布式系统中实现资源互斥访问机制。在多个进程或多台机器同时操作一些资源时，redis 生成一个限时的 key，使用 Redis 的 expire 特征，所以最终当用户需要释放资源时，释放 key。</p><p>事务锁的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBLock</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">ctx</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_uuid</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">uuid</span>(); <span class="hljs-comment">// 分布式节点的uuid</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">_uuid</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">Lock</span> = ctx.<span class="hljs-property">model</span>.<span class="hljs-property">Lock</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 基于时间戳生成的uuid</span><br>  <span class="hljs-title function_">uuid</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> d = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&quot;</span>.<span class="hljs-title function_">replace</span>(<br>      <span class="hljs-regexp">/[xy]/g</span>,<br>      <span class="hljs-keyword">function</span> (<span class="hljs-params">c</span>) &#123;<br>        <span class="hljs-keyword">var</span> r = (d + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">16</span>) % <span class="hljs-number">16</span> | <span class="hljs-number">0</span>;<br>        d = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(d / <span class="hljs-number">16</span>);<br>        <span class="hljs-keyword">return</span> (c === <span class="hljs-string">&quot;x&quot;</span> ? r : (r &amp; <span class="hljs-number">0x3</span>) | <span class="hljs-number">0x8</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>);<br>      &#125;<br>    );<br>  &#125;<br><br>  <span class="hljs-comment">// 获取一次锁</span><br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">acquire</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">Lock</span>.<span class="hljs-title function_">create</span>(&#123;<br>        <span class="hljs-attr">_id</span>: name,<br>        <span class="hljs-attr">acquirer</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">_uuid</span>,<br>        <span class="hljs-attr">acquiredAt</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),<br>        <span class="hljs-attr">updatedAt</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),<br>      &#125;);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;error:&quot;</span> + e);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 获取锁, 每5s重试一次</span><br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">lock</span>(<span class="hljs-params">name, retryInterval = <span class="hljs-number">5000</span></span>) &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">acquire</span>(name)) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sleep</span>(retryInterval);<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 解锁</span><br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">unlock</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;unlock&quot;</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">Lock</span>.<span class="hljs-title function_">deleteMany</span>(&#123; <span class="hljs-attr">_id</span>: name, <span class="hljs-attr">acquirer</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">_uuid</span> &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">// 续期</span><br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">renew</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">Lock</span>.<span class="hljs-title function_">updateOne</span>(<br>      &#123; <span class="hljs-attr">_id</span>: name, <span class="hljs-attr">acquirer</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">_uuid</span> &#125;,<br>      &#123;<br>        <span class="hljs-attr">updatedAt</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),<br>      &#125;<br>    );<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;renew&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 睡眠</span><br>  <span class="hljs-title function_">sleep</span>(<span class="hljs-params">ms</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, ms));<br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">DBLock</span>;<br></code></pre></td></tr></table></figure><p>事务锁主要涉及的操作：</p><ul><li>uuid：唯一标识符生成，是为了解决错误删除其他线程的锁的问题，线程在删除锁的时候，用自己的 uuid 与 Redis 中锁的 uuid 进行比较，如果是自己的锁就进行删除，不是则不删除</li><li>lock：循环获取锁数据，如果获取到则跳出循环，否则等待 5s 后重试。锁数据生成：利用 Redis 的 setNx 命令在 Redis 数据库中创建一个&lt;Key，Value&gt;记录，这条命令只有当 Redis 中没有这个 Key 的时候才执行成功，当已经有这个 Key 的时候会返回失败</li><li>unlock：删除锁数据</li><li>renew：更新锁数据，延长锁的过期时间；主要用于由于业务执行时间长，最终可能导致在业务执行过程中，自己的锁超时，然后锁自动释放了</li></ul><p>在定时任务里的使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">schedule</span>: &#123;<br>    <span class="hljs-attr">interval</span>: <span class="hljs-string">&quot;1m&quot;</span>, <span class="hljs-comment">// 1 分钟间隔</span><br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;worker&quot;</span>, <span class="hljs-comment">// 指定的 worker 执行</span><br>  &#125;,<br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">task</span>(<span class="hljs-params">ctx</span>) &#123;<br>    <span class="hljs-comment">// 。。。</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;调用定时器回调&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    <span class="hljs-comment">// 获取报警规则</span><br>    <span class="hljs-keyword">let</span> &#123; data, env &#125; = <span class="hljs-keyword">await</span> ctx.<span class="hljs-property">service</span>.<span class="hljs-property">alertRule</span>.<span class="hljs-title function_">getWarning</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;current env:&quot;</span>, env);<br>    <span class="hljs-comment">// 数据格式调整</span><br>    <span class="hljs-keyword">let</span> rules = <span class="hljs-title function_">flattenRuleObj</span>(data);<br>    <span class="hljs-comment">// 获取和报警轮询相关的错误数日志</span><br>    <span class="hljs-keyword">let</span> records = <span class="hljs-keyword">await</span> ctx.<span class="hljs-property">service</span>.<span class="hljs-property">errorRecord</span>.<span class="hljs-title function_">getRecord</span>();<br>    <span class="hljs-keyword">let</span> newRecords = [];<br>    <span class="hljs-keyword">let</span> originalRecords = newRecords.<span class="hljs-title function_">slice</span>();<br><br>    <span class="hljs-keyword">if</span> (rules.<span class="hljs-property">length</span>) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">await</span> dblock.<span class="hljs-title function_">lock</span>(<span class="hljs-string">&quot;send_errcount&quot;</span>);<br>        <span class="hljs-keyword">if</span> (rules.<span class="hljs-property">length</span>) &#123;<br>          <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(<br>            rules.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">async</span> (rule, idx) =&gt; &#123;<br>              <span class="hljs-keyword">await</span> <span class="hljs-title function_">queryErrorRecords</span>(rule);<br>            &#125;)<br>          );<br><br>          <span class="hljs-comment">// 减少不必要的数据更改</span><br>          <span class="hljs-keyword">if</span> (newRecords.<span class="hljs-property">length</span> != originalRecords.<span class="hljs-property">length</span>) &#123;<br>            <span class="hljs-keyword">await</span> ctx.<span class="hljs-property">service</span>.<span class="hljs-property">errorRecord</span>.<span class="hljs-title function_">storeRecord</span>(newRecords, env);<br>          &#125;<br>        &#125;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">await</span> dblock.<span class="hljs-title function_">unlock</span>(<span class="hljs-string">&quot;send_errcount&quot;</span>);<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> currentTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>    <span class="hljs-keyword">if</span> (currentTime.<span class="hljs-title function_">getHours</span>() == <span class="hljs-number">2</span> &amp;&amp; currentTime.<span class="hljs-title function_">getMinutes</span>() == <span class="hljs-number">10</span>) &#123;<br>      <span class="hljs-keyword">await</span> ctx.<span class="hljs-property">service</span>.<span class="hljs-property">errorRecord</span>.<span class="hljs-title function_">clearRecord</span>(<br>        currentTime.<span class="hljs-title function_">getTime</span>() - <span class="hljs-number">2</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>,<br>        env<br>      );<br>    &#125;<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>在告警规则校验和告警规则触发的操作的之前设置锁，所有操作结束后解锁。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://blog.csdn.net/qq_24884955/article/details/82856230">egg 服务器集群情况下的定时任务执行操作（2 种方式）</a><br>（2）<a href="https://juejin.cn/post/7239058077273620536?searchId=2024011811013604AA57490988668AB93E">图解 Redis 和 Zookeeper 分布式锁 | 京东云技术团队</a></p>]]></content>
    
    
    <summary type="html">监控告警功能的实现</summary>
    
    
    
    <category term="工作技巧" scheme="https://unkonwn404.github.io/unknown404.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="前端监控" scheme="https://unkonwn404.github.io/unknown404.github.io/tags/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7/"/>
    
    <category term="redis" scheme="https://unkonwn404.github.io/unknown404.github.io/tags/redis/"/>
    
    <category term="eggjs" scheme="https://unkonwn404.github.io/unknown404.github.io/tags/eggjs/"/>
    
  </entry>
  
  <entry>
    <title>react-query状态管理</title>
    <link href="https://unkonwn404.github.io/unknown404.github.io/2023/11/09/react-query/"/>
    <id>https://unkonwn404.github.io/unknown404.github.io/2023/11/09/react-query/</id>
    <published>2023-11-09T07:31:00.000Z</published>
    <updated>2023-11-14T01:35:23.032Z</updated>
    
    <content type="html"><![CDATA[<p>起因是在阅读<a href="https://github.com/alan2207/bulletproof-react">某 react 项目</a>时看到作者提出的项目状态管理的规则，觉得很有意思；对于平常使用 redux 一把梭的人来说，他说的这个技术方案太过陌生，所以想随手记一下。</p><span id="more"></span><h2 id="状态管理方针"><a href="#状态管理方针" class="headerlink" title="状态管理方针"></a>状态管理方针</h2><p>以下是项目作者提出的状态管理的简要概述</p><h3 id="组件状态"><a href="#组件状态" class="headerlink" title="组件状态"></a>组件状态</h3><p>对于只有当前组件才用的状态可以直接用 react 的钩子函数</p><ul><li>useState</li><li>useReducer</li></ul><h3 id="应用状态"><a href="#应用状态" class="headerlink" title="应用状态"></a>应用状态</h3><p>应用状态指在交互时发生值的改变、以控制应用的状态的这种变量，例如弹出弹窗、提示语、夜间模式等。可以使用以下方式管理</p><ul><li>context</li><li>redux<br>以及其他看起来功能很类似的库</li></ul><h3 id="表格状态"><a href="#表格状态" class="headerlink" title="表格状态"></a>表格状态</h3><p>填写表单时的数据管理，有专门的解决方案</p><ul><li>React Hook Form</li><li>Formik</li><li>React Final Form</li></ul><h3 id="服务端数据管理"><a href="#服务端数据管理" class="headerlink" title="服务端数据管理"></a>服务端数据管理</h3><p>从服务器请求得到的数据，有时需要存储起来方便后续修改等操作。可以使用以下方案</p><ul><li>react-query</li><li>swr</li><li>apollo client</li><li>urql</li></ul><p>本文这次只记录 react-query 的使用方法</p><h2 id="react-query"><a href="#react-query" class="headerlink" title="react-query"></a>react-query</h2><h3 id="使用场景举例"><a href="#使用场景举例" class="headerlink" title="使用场景举例"></a>使用场景举例</h3><p>一般来说，如果一个页面要展示请求内容，需要以下代码来实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [data, updateData] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">const</span> [isError, setError] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">const</span> [isLoading, setLoading] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-title function_">setError</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/user&#x27;</span>);<br>      <span class="hljs-title function_">updateData</span>(data);<br>    &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>      <span class="hljs-title function_">setError</span>(<span class="hljs-literal">true</span>);<br>    &#125;<br>    <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">false</span>);<br>  &#125;, [])<br><br>  <span class="hljs-comment">// 处理data</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到至少需要 3 个 state，存储数据的 data、请求加载态的 isLoading 和请求失败的 isError。如果页面涉及多个请求，这样的 state 设置还要重复好多次。<br>如果使用 react-query 实现，则代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><br><span class="hljs-keyword">import</span> &#123; useQuery &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-query&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123;data, isLoading, isError&#125; = <span class="hljs-title function_">useQuery</span>(<span class="hljs-string">&#x27;userData&#x27;</span>, <span class="hljs-function">() =&gt;</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/user&#x27;</span>));<br><br>  <span class="hljs-keyword">if</span> (isLoading) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>loading<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">      &#123;data.map(user =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;user.id&#125;</span>&gt;</span>&#123;user.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>)&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到可以省去中间态的 state 设置，除此之外 react-query 还可以实现这些功能：</p><ul><li>多个组件请求同一个 query 时只发出一个请求</li><li>缓存数据失效&#x2F;更新策略（判断缓存合适失效，失效后自动请求数据）</li><li>对失效数据垃圾清理</li></ul><p>如何实现将在接下来的使用介绍里展开</p><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p>根据 react-query v4 的说明文档，可以在 App.tsx 文件做如下配置</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">QueryClientProvider</span>, <span class="hljs-title class_">ReactQueryProviderConfig</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-query&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">queryConfig</span>: <span class="hljs-title class_">ReactQueryProviderConfig</span> = &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * refetchOnWindowFocus 窗口获得焦点时重新获取数据</span><br><span class="hljs-comment">   * staleTime 过多久重新获取服务端数据</span><br><span class="hljs-comment">   * cacheTime 数据缓存时间 默认是 5 * 60 * 1000 5分钟</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">queries</span>: &#123;<br>    <span class="hljs-attr">refetchOnWindowFocus</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">staleTime</span>: <span class="hljs-number">5</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>,<br>    <span class="hljs-attr">retry</span>: <span class="hljs-number">0</span><br>  &#125;,<br>&#125;;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">QueryClientProvider</span> <span class="hljs-attr">client</span>=<span class="hljs-string">&#123;new</span> <span class="hljs-attr">QueryClient</span>(&#123; <span class="hljs-attr">defaultOptions:</span> <span class="hljs-attr">queryConfig</span> &#125;)&#125;&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">QueryClientProvider</span>&gt;</span></span><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)<br>  );<br><br></code></pre></td></tr></table></figure><p>QueryClient 是可以与缓存交互的实例，其他组件如果想要获取这个实例可以用 useQueryClient 函数实现。<br>QueryClient 实例可配置的参数包括：</p><div class="note note-info">            <p><strong>staleTime</strong> 重新获取数据的时间间隔 默认 0<br><strong>cacheTime</strong> 数据缓存时间<br><strong>retry</strong> 失败重试次数 默认 3 次<br><strong>refetchOnWindowFocus</strong> 窗口重新获得焦点时重新获取数据 默认 false<br><strong>refetchOnReconnect</strong> 网络重新链接<br><strong>refetchOnMount</strong> 实例重新挂载<br><strong>enabled</strong> 如果为“false”的化，“useQuery”不会触发</p>          </div><p>这些参数也可以在钩子函数里配置</p><p>react-query 常用的钩子函数有两个：useQuery 和 useMutation，用于应对常见的数据操作</p><h3 id="useQuery（数据查询）"><a href="#useQuery（数据查询）" class="headerlink" title="useQuery（数据查询）"></a>useQuery（数据查询）</h3><h4 id="书写规范"><a href="#书写规范" class="headerlink" title="书写规范"></a>书写规范</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useQuery &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-query&quot;</span>;<br><span class="hljs-comment">// v3写法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> info = <span class="hljs-title function_">useQuery</span>(<span class="hljs-string">&quot;todos&quot;</span>, fetchTodoList);<br>&#125;<br><span class="hljs-comment">// v4+写法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> info = <span class="hljs-title function_">useQuery</span>(&#123; <span class="hljs-attr">queryKey</span>: [<span class="hljs-string">&quot;todos&quot;</span>], <span class="hljs-attr">queryFn</span>: fetchTodoList &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="入参出参"><a href="#入参出参" class="headerlink" title="入参出参"></a>入参出参</h4><p>queryKey 可以都是字符串数组，也可以是 object 元素<br>queryFn 可以自动接收到 queryKey 的值，通常会返回 promise 值；如果考虑请求出错、返回 rejected 状态的情况的话，queryFn 的内部需要考虑做抛出错误的处理，以 fetch 请求为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">useQuery</span>(&#123;<br>  <span class="hljs-attr">queryKey</span>: [<span class="hljs-string">&quot;todos&quot;</span>, todoId],<br>  <span class="hljs-attr">queryFn</span>: <span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/todos/&quot;</span> + todoId);<br>    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Network response was not ok&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>当 queryKey 的内容发生变动时 queryFn 的内容就会自动执行<br>useQuery 返回的内容包括：</p><div class="note note-info">            <p><strong>isLoading</strong>：请求是否在加载数据<br><strong>isError</strong>：请求是否报错<br><strong>isFetching</strong>：是否有一个挂起的请求，适用于无限滚动<br><strong>data</strong>：请求返回数据</p>          </div><h3 id="useMutation（数据增删改）"><a href="#useMutation（数据增删改）" class="headerlink" title="useMutation（数据增删改）"></a>useMutation（数据增删改）</h3><p>该函数钩子通常用于有副作用的场景。</p><h4 id="书写规范-1"><a href="#书写规范-1" class="headerlink" title="书写规范"></a>书写规范</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useQuery &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-query&quot;</span>;<br><span class="hljs-comment">// v3写法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [mutate] = <span class="hljs-title function_">useMutation</span>(<span class="hljs-function">(<span class="hljs-params">newTodo</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/todos&quot;</span>, newTodo);<br>  &#125;);<br>&#125;<br><span class="hljs-comment">// v4+写法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> mutation = <span class="hljs-title function_">useMutation</span>(&#123;<br>    <span class="hljs-attr">mutationFn</span>: <span class="hljs-function">(<span class="hljs-params">newTodo</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/todos&quot;</span>, newTodo);<br>    &#125;,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="入参出参-1"><a href="#入参出参-1" class="headerlink" title="入参出参"></a>入参出参</h4><p>常用的入参包括：</p><div class="note note-info">            <p><strong>mutationFn</strong>：用于处理请求的函数，返回 promise 对象<br><strong>onMutate</strong>：请求触发、将要执行前触发的回调函数<br><strong>onError</strong>：请求失败时触发的回调函数<br><strong>onSuccess</strong>：请求失败时触发的回调函数<br><strong>onSettled</strong>：请求完成时触发的回调函数，不管成功与否；执行时机在 onSuccess 和 onError 之后</p>          </div><p>除此以外也可以配置请求操作相关的一些配置，例如重试、重试延迟等<br>返回的内容主要包括：</p><div class="note note-info">            <p><strong>mutate</strong>：在代码中运行突变的操作，接受的入参包括 mutationFn 的入参和 onSuccess、onError、onSettled<br><strong>isPending</strong>：请求是否在加载数据<br><strong>isError</strong>：请求是否报错</p>          </div><p>涉及增删改的操作可以使用乐观更新来减少等待加载的时间，让用户体验更好。所谓乐观更新、就是前端默认后端接口请求一定会成功、提前将修改结果展示出来。<br>以下面这段代码为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useDeleteDiscussion</span> = (<span class="hljs-params">&#123; config &#125;: UseDeleteDiscussionOptions = &#123;&#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> &#123; addNotification &#125; = <span class="hljs-title function_">useNotificationStore</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">useMutation</span>(&#123;<br>    <span class="hljs-attr">onMutate</span>: <span class="hljs-keyword">async</span> (deletedDiscussion) =&gt; &#123;<br>      <span class="hljs-keyword">await</span> queryClient.<span class="hljs-title function_">cancelQueries</span>(<span class="hljs-string">&#x27;discussions&#x27;</span>);<br><br>      <span class="hljs-keyword">const</span> previousDiscussions = queryClient.<span class="hljs-property">getQueryData</span>&lt;<span class="hljs-title class_">Discussion</span>[]&gt;(<span class="hljs-string">&#x27;discussions&#x27;</span>);<br><br>      queryClient.<span class="hljs-title function_">setQueryData</span>(<br>        <span class="hljs-string">&#x27;discussions&#x27;</span>,<br>        previousDiscussions?.<span class="hljs-title function_">filter</span>(<br>          <span class="hljs-function">(<span class="hljs-params">discussion</span>) =&gt;</span> discussion.<span class="hljs-property">id</span> !== deletedDiscussion.<span class="hljs-property">discussionId</span><br>        )<br>      );<br><br>      <span class="hljs-keyword">return</span> &#123; previousDiscussions &#125;;<br>    &#125;,<br>    <span class="hljs-attr">onError</span>: <span class="hljs-function">(<span class="hljs-params">_, __, context: any</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (context?.<span class="hljs-property">previousDiscussions</span>) &#123;<br>        queryClient.<span class="hljs-title function_">setQueryData</span>(<span class="hljs-string">&#x27;discussions&#x27;</span>, context.<span class="hljs-property">previousDiscussions</span>);<br>      &#125;<br>    &#125;,<br>    <span class="hljs-attr">onSuccess</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      queryClient.<span class="hljs-title function_">invalidateQueries</span>(<span class="hljs-string">&#x27;discussions&#x27;</span>);<br>      <span class="hljs-title function_">addNotification</span>(&#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;success&#x27;</span>,<br>        <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Discussion Deleted&#x27;</span>,<br>      &#125;);<br>    &#125;,<br>    ...config,<br>    <span class="hljs-attr">mutationFn</span>: <span class="hljs-function">(<span class="hljs-params">&#123; discussionId &#125;: &#123; discussionId: string &#125;</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> axios.<span class="hljs-title function_">delete</span>(<span class="hljs-string">`/discussions/<span class="hljs-subst">$&#123;discussionId&#125;</span>`</span>);<br>    &#125;<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><p>这段代码的大致逻辑是：</p><ul><li>删除请求触发onMutate回调，为了乐观更新首先取消已有的讨论的请求（应该是为了应对配置了更新策略的queryClient）；从缓存中取出已存储的讨论列表、滤除删除的目标讨论、利用setQueryData将结果存入缓存</li><li>删除请求成功时，用invalidateQueries清除缓存、重新拉取数据</li><li>删除请求失败时，缓存重新存入上一次缓存即未删除的内容，相当于回退</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>（1）<a href="https://juejin.cn/post/6882669076540456967">react-query</a><br>（2）<a href="https://juejin.cn/column/7105422212789714980">react-query手把手教程</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;起因是在阅读&lt;a href=&quot;https://github.com/alan2207/bulletproof-react&quot;&gt;某 react 项目&lt;/a&gt;时看到作者提出的项目状态管理的规则，觉得很有意思；对于平常使用 redux 一把梭的人来说，他说的这个技术方案太过陌生，所以想随手记一下。&lt;/p&gt;</summary>
    
    
    
    <category term="技术学习" scheme="https://unkonwn404.github.io/unknown404.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="React" scheme="https://unkonwn404.github.io/unknown404.github.io/tags/React/"/>
    
    <category term="状态管理" scheme="https://unkonwn404.github.io/unknown404.github.io/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>带缩略图的图片切换展示实现</title>
    <link href="https://unkonwn404.github.io/unknown404.github.io/2023/11/09/thumbSwipe/"/>
    <id>https://unkonwn404.github.io/unknown404.github.io/2023/11/09/thumbSwipe/</id>
    <published>2023-11-09T07:04:30.000Z</published>
    <updated>2023-12-05T03:14:12.850Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录一下做需求时遇到的问题和思考</p><span id="more"></span><h2 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h2><ol><li>实现一个带缩略图的图片切换模块；大图片支持左右翻页查看，也支持点选小图查看。</li><li>缩略图图片数量较少时整体居中；图片较多时缩略图支持滚动。点击缩略图选中的小图处于正中</li><li>点击大图打开预览弹窗，预览可左右滑动查看图片，再次点击退出预览态</li><li>预览态图片展示原则：过长的图片，放大且从顶部开始展示，可向下滑动查看；短图居中展示</li></ol><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ol><li>因为需求涉及到很多图片切换展示，可使用已有的方案 swiper 组件，如果使用了 vue 框架则使用 vue-awesome-swiper、配合 swiper 以前使用。安装时注意版本问题，高版本的 swiper 只能使用 vue 3 版本的 vue-awesome-swiper 调用，如果要使用 vue2 语法，版本可参考：</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;swiper&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^5.4.5&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;vue-awesome-swiper&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.1.1&quot;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>带缩略图的图片轮播官网有给实现<a href="https://github.com/surmon-china/surmon-china.github.io/blob/vue2/projects/vue-awesome-swiper/examples/30-thumbs-gallery.vue">案例</a><br>大图的展示使用 swiper 组件没有疑问。但实现的缩略图在轮播条件下样式比较合理，不然首图居中时左侧出现大片空白感觉很奇怪；因此缩略图的实现放弃用 swiper，将父容器设置为溢出滚动，小图包裹在一个容器里，在不滚动的时候利用 flex 布局让小图整体的容器居中</p><ol start="2"><li>缩略图较多、需要滑动查看缩略图并点击时使选中的缩略图位于父容器中间的实现可以利用浏览器的 API：scrollIntoView。一般说来使用这个 API 时可能直接就使用默认的方法、没有考虑过传参， 但实际上该 API 提供了入参让我们可以改变滚动进视野的方式：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> alignToTop = <span class="hljs-built_in">boolean</span>;<br><span class="hljs-keyword">type</span> scrollIntoViewOptions = &#123;<br>  <span class="hljs-attr">behavior</span>: <span class="hljs-string">&quot;auto&quot;</span> | <span class="hljs-string">&quot;smooth&quot;</span>;<br>  <span class="hljs-attr">block</span>: <span class="hljs-string">&quot;start&quot;</span> | <span class="hljs-string">&quot;center&quot;</span> | <span class="hljs-string">&quot;end&quot;</span> | <span class="hljs-string">&quot;nearest&quot;</span>;<br>  <span class="hljs-attr">inline</span>: <span class="hljs-string">&quot;start&quot;</span> | <span class="hljs-string">&quot;center&quot;</span> | <span class="hljs-string">&quot;end&quot;</span> | <span class="hljs-string">&quot;nearest&quot;</span>;<br>&#125;;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Element</span> &#123;<br>  <span class="hljs-title function_">scrollIntoView</span>(arg?: alignToTop | scrollIntoViewOptions): <span class="hljs-built_in">void</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 block 就是决定竖直方向的对齐方式，inline 是决定左右方向的对齐方式，可以对这两个参数进行操作。</p><ol start="3"><li>图片列表加载时可能需要一些时间，偶尔可能会出现部分图片加载失败。为避免显示失败，需要增加过渡态展示，这里以变量imgLoaded控制，通过监听图片加载的load过程来改变imgLoaded的值，当所有图片加载结束时变更imgLoaded、展示图片。</li></ol><p>最后带缩略的图片展示模块的实现大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;img-list-container&quot;&gt;<br>    &lt;div class=&quot;img-list-wrap&quot; v-show=&quot;imgList &amp;&amp; imgList.length&quot;&gt;<br>      &lt;!-- swiper1 --&gt;<br>      &lt;swiper<br>        class=&quot;swiper gallery-top&quot;<br>        :options=&quot;swiperOptionTop&quot;<br>        ref=&quot;swiperTop&quot;<br>        @slideChange=&quot;onSlideChange&quot;<br>      &gt;<br>        &lt;swiper-slide<br>          class=&quot;img-slide&quot;<br>          v-for=&quot;(item, idx) in imgList&quot;<br>          :key=&quot;idx&quot;<br>        &gt;<br>          &lt;img<br>            :src=&quot;item.url&quot;<br>            class=&quot;img-content&quot;<br>            @click=&quot;showPreviewModal&quot;<br>            v-show=&quot;imgLoaded&quot;<br>            @load=&quot;bigPicLoad(item.url, idx)&quot;<br>            @error=&quot;(event) =&gt; bigPicLoadFail(item.url, idx, event)&quot;<br>          /&gt;<br>          &lt;img<br>            src=&quot;./loading.gif&quot;<br>            class=&quot;img-content_0 center&quot;<br>            v-show=&quot;!imgLoaded&quot;<br>          /&gt;<br>        &lt;/swiper-slide&gt;<br>      &lt;/swiper&gt;<br>      &lt;!-- Thumbs --&gt;<br>      &lt;div<br>        :class=&quot;[<br>          &#x27;gallery-thumbs&#x27;,<br>          imgList &amp;&amp; imgList.length &lt; 6 &amp;&amp; &#x27;no-scroll&#x27;,<br>        ]&quot;<br>        ref=&quot;swiperThumbs&quot;<br>      &gt;<br>        &lt;div<br>          :class=&quot;[&#x27;thumb-wrap&#x27;, imgList &amp;&amp; imgList.length &lt; 6 &amp;&amp; &#x27;no-scroll&#x27;]&quot;<br>        &gt;<br>          &lt;div<br>            :class=&quot;[&#x27;img-thumb&#x27;, idx === activeIndex &amp;&amp; &#x27;img-thumb-active&#x27;]&quot;<br>            v-for=&quot;(item, idx) in imgList&quot;<br>            :key=&quot;idx&quot;<br>            @click=&quot;(event) =&gt; changeActiveIdx(event, idx)&quot;<br>          &gt;<br>            &lt;img<br>              :src=&quot;item.url&quot;<br>              class=&quot;img-content&quot;<br>              v-show=&quot;smallImgLoaded&quot;<br>              @load=&quot;smallPicLoad(item.url, idx)&quot;<br>            /&gt;<br>            &lt;img<br>              src=&quot;./loading.gif&quot;<br>              class=&quot;img-content_0&quot;<br>              v-show=&quot;!smallImgLoaded&quot;<br>            /&gt;<br>          &lt;/div&gt;<br>        &lt;/div&gt;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br><br>    &lt;img-preview<br>      :currentIdx=&quot;activeIndex&quot;<br>      :imgList=&quot;imgList&quot;<br>      ref=&quot;previewModal&quot;<br>    /&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>import ImgPreview from &quot;@/wap/components/ImgPreview.vue&quot;;<br><br>import &#123; Swiper, SwiperSlide &#125; from &quot;vue-awesome-swiper&quot;;<br>import &quot;swiper/css/swiper.css&quot;;<br><br>export default &#123;<br>  name: &quot;swiper-thumbs-gallery&quot;,<br>  props: &#123;<br>    imgList: &#123;<br>      type: Array,<br>      default: [],<br>    &#125;,<br>  &#125;,<br>  components: &#123;<br>    Swiper,<br>    SwiperSlide,<br>    ImgPreview,<br>  &#125;,<br><br>  watch: &#123;<br>    imgList: &#123;<br>      deep: true,<br>      handler(newVal) &#123;<br>        this.activeIndex = 0;<br>        this.imgLoaded = false;<br>        this.smallImgLoaded = false;<br>        this.topCount = 0;<br>        this.thumbCount = 0;<br>        this.swiperTop.slideTo(this.activeIndex);<br>      &#125;,<br>    &#125;,<br>  &#125;,<br>  data() &#123;<br>    return &#123;<br>      swiperOptionTop: &#123;<br>        loop: false,<br>        loopedSlides: this.imgList.length,<br>        spaceBetween: 10,<br>      &#125;,<br>      swiperTop: null,<br>      swiperThumbs: null,<br>      activeIndex: 0,<br>      imgLoaded: false,<br>      smallImgLoaded: false,<br>      topCount: 0,<br>      thumbCount: 0,<br>    &#125;;<br>  &#125;,<br>  mounted() &#123;<br>    this.$nextTick(() =&gt; &#123;<br>      this.swiperTop = this.$refs.swiperTop.$swiper;<br>      this.swiperThumbs = this.$refs.swiperThumbs.$swiper;<br>    &#125;);<br>  &#125;,<br>  methods: &#123;<br>    bigPicLoad(url, idx) &#123;<br>      this.topCount++;<br>      if (this.topCount === this.imgList.length) &#123;<br>        this.imgLoaded = true;<br>      &#125;<br>    &#125;,<br>    bigPicLoadFail(url, idx, event) &#123;<br>      event.target.style =<br>        &quot;width:57px;height:43px;position: absolute;left: 50%;top: 50%;transform: translate(-50%, -50%);&quot;;<br>      this.imgList[idx].url = &quot;./fail.png&quot;;<br>      this.topCount++;<br>      if (this.topCount === this.imgList.length) &#123;<br>        this.imgLoaded = true;<br>      &#125;<br>    &#125;,<br>    smallPicLoad(url, idx) &#123;<br>      console.log(&quot;small loaded&quot;, url, idx, this.imgList.length);<br>      this.thumbCount++;<br>      if (this.thumbCount === this.imgList.length) &#123;<br>        this.smallImgLoaded = true;<br>      &#125;<br>    &#125;,<br>    onSlideChange() &#123;<br>      console.log(&quot;swiper&quot;, this.swiperTop.activeIndex);<br>      this.activeIndex = this.swiperTop.activeIndex;<br>    &#125;,<br>    changeActiveIdx(event, idx) &#123;<br>      this.activeIndex = idx;<br>      this.swiperTop.slideTo(this.activeIndex);<br>      event.target.scrollIntoView(&#123;<br>        block: &quot;nearest&quot;,<br>        inline: &quot;center&quot;,<br>      &#125;);<br>    &#125;,<br>    showPreviewModal() &#123;<br>      this.$refs[&quot;previewModal&quot;].show();<br>    &#125;,<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;less&quot; scoped&gt;<br>.swiper &#123;<br>  .swiper-slide &#123;<br>    background-size: cover;<br>    background-position: center;<br>  &#125;<br>&#125;<br><br>.gallery-top &#123;<br>  height: 387px;<br>  width: 100%;<br><br>  .img-content_0 &#123;<br>    width: 42px;<br>    height: 58px;<br>    padding-top: 149px;<br>    box-sizing: content-box;<br>    margin: auto;<br>  &#125;<br><br>  .img-content_-1 &#123;<br>    width: 57px;<br>    height: 57px;<br>    padding-top: 156px;<br>    box-sizing: content-box;<br>    margin: auto;<br>  &#125;<br><br>  .txt &#123;<br>    font-size: 14px;<br>    font-weight: 400;<br>    color: #ffffff;<br>    line-height: 20px;<br>    margin-top: 13px;<br>  &#125;<br><br>  .img-content &#123;<br>    width: 100%;<br>    height: 100%;<br>    object-fit: cover;<br>  &#125;<br><br>  .watermark &#123;<br>    position: absolute;<br>    right: 7px;<br>    bottom: 10px;<br>    width: 79px;<br>    height: 22px;<br>  &#125;<br>&#125;<br><br>.gallery-thumbs &#123;<br>  height: 62px;<br>  box-sizing: border-box;<br>  padding: 8px 0;<br>  overflow-x: scroll;<br>  overflow-y: hidden;<br><br>  &amp;::-webkit-scrollbar &#123;<br>    display: none;<br>    width: 0;<br>    height: 0;<br>  &#125;<br><br>  &amp;.no-scroll &#123;<br>    display: flex;<br>    justify-content: center;<br>  &#125;<br><br>  .thumb-wrap &#123;<br>    display: flex;<br>  &#125;<br><br>  .img-thumb &#123;<br>    display: inline-block;<br>    width: 46px;<br>    height: 46px;<br>    border-radius: 6px;<br>    overflow: hidden;<br>    margin-right: 8px;<br>    flex-shrink: 0;<br>    box-sizing: border-box;<br><br>    .img-content &#123;<br>      width: 100%;<br>      height: 100%;<br>      object-fit: cover;<br>    &#125;<br>  &#125;<br><br>  .img-thumb-active &#123;<br>    border: 2px solid #3269ff;<br>  &#125;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><ol start="3"><li>图片的预览实现起来本身并不复杂，还是利用 swiper 组件，但一些细节点需要注意：</li></ol><ul><li>高度自适应尽量不要用 fit-content 而是 auto，因为在 iOS 系统，部分机型不支持这个属性</li><li>需要监听从图片展示模块传输的当前图片的 index，操作预览模块的 swiper 跳到该 index 的位置</li><li>点击事件不要挂在 swiper 和 swiper-slide 组件上，否则无法生效</li><li>为防止滚动查看预览弹窗时后面页面滚动，需要改变body的样式</li></ul><p>最终预览模块的实现大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;preview-list-container&quot; v-show=&quot;modalVisible&quot;&gt;<br>    &lt;!-- swiper1 --&gt;<br>    &lt;swiper<br>      class=&quot;swiper gallery-top&quot;<br>      :options=&quot;swiperOptionTop&quot;<br>      ref=&quot;swiperTop&quot;<br>      @slideChange=&quot;onSlideChange&quot;<br>    &gt;<br>      &lt;swiper-slide class=&quot;img-slide&quot; v-for=&quot;(item, idx) in imgList&quot; :key=&quot;idx&quot;&gt;<br>        &lt;div class=&quot;img-container&quot; @click=&quot;hidden&quot;&gt;<br>          &lt;div class=&quot;img-wrap&quot;&gt;<br>            &lt;img :src=&quot;item.url&quot; class=&quot;img-content&quot; /&gt;<br>          &lt;/div&gt;<br>        &lt;/div&gt;<br>      &lt;/swiper-slide&gt;<br>    &lt;/swiper&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; Swiper, SwiperSlide &#125; from &quot;vue-awesome-swiper&quot;;<br>import &quot;swiper/css/swiper.css&quot;;<br><br>export default &#123;<br>  name: &quot;img-preview&quot;,<br>  props: &#123;<br>    imgList: &#123;<br>      type: Array,<br>      default: [],<br>    &#125;,<br>    currentIdx: &#123;<br>      type: Number,<br>      default: 0,<br>    &#125;,<br>  &#125;,<br>  components: &#123;<br>    Swiper,<br>    SwiperSlide,<br>  &#125;,<br>  watch: &#123;<br>    currentIdx: &#123;<br>      handler(newVal) &#123;<br>        this.activeIndex = newVal;<br>        this.swiperTop.slideTo(this.activeIndex);<br>      &#125;,<br>    &#125;,<br>  &#125;,<br>  data() &#123;<br>    return &#123;<br>      swiperOptionTop: &#123;<br>        loop: false,<br>        loopedSlides: this.imgList.length,<br>        spaceBetween: 10,<br>      &#125;,<br>      swiperTop: null,<br>      activeIndex: 0,<br>      modalVisible: false,<br>    &#125;;<br>  &#125;,<br>  created() &#123;<br>    this.activeIndex = this.currentIdx;<br>  &#125;,<br>  mounted() &#123;<br>    this.$nextTick(() =&gt; &#123;<br>      this.swiperTop = this.$refs.swiperTop.$swiper;<br>    &#125;);<br>  &#125;,<br>  methods: &#123;<br>    onSlideChange() &#123;<br>      this.activeIndex = this.swiperTop.activeIndex;<br>    &#125;,<br>    show() &#123;<br>      this.modalVisible = true;<br>      document.body.style.overflow = &quot;hidden&quot;;<br>    &#125;,<br>    hidden() &#123;<br>      this.modalVisible = false;<br>      document.body.style.overflow = &quot;&quot;;<br>    &#125;,<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;less&quot; scoped&gt;<br>.preview-list-container &#123;<br>  position: fixed;<br>  width: 100%;<br>  height: 100vh;<br>  left: 0;<br>  top: 0;<br>  background: #000;<br>  z-index: 2000;<br><br>  .img-wrap &#123;<br>    position: relative;<br>    width: 100%;<br>  &#125;<br><br>  .toolkit-container &#123;<br>    position: fixed;<br>    left: 0;<br>    bottom: 0;<br>    width: 100%;<br>    padding: 15px 24px 48px;<br>    background: rgba(0, 0, 0, 0.5);<br>    display: flex;<br>    justify-content: space-between;<br>    align-items: center;<br>    color: #fff;<br>    font-size: 16px;<br>    line-height: 22px;<br>    z-index: 999;<br><br>    .toolkit-wrap &#123;<br>      display: flex;<br><br>      .toolkit &#123;<br>        display: flex;<br>        align-items: center;<br>        margin-left: 32px;<br><br>        .icon &#123;<br>          width: 16px;<br>          height: 16px;<br>          object-fit: contain;<br>          margin-right: 4px;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br>.swiper &#123;<br>  .swiper-slide &#123;<br>    background-size: cover;<br>    background-position: center;<br>  &#125;<br><br>  &amp;.gallery-top &#123;<br>    width: 100%;<br>    height: 100vh;<br><br>    .img-container &#123;<br>      width: 100%;<br>      height: 100vh;<br>      display: flex;<br>      align-items: center;<br>      overflow-y: scroll;<br>    &#125;<br><br>    .watermark &#123;<br>      position: absolute;<br>      right: 7px;<br>      bottom: 10px;<br>      width: 79px;<br>      height: 22px;<br>    &#125;<br><br>    .img-content &#123;<br>      width: 100%;<br>      height: auto;<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://segmentfault.com/a/1190000041886147">详细介绍 scrollIntoView 方法</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单记录一下做需求时遇到的问题和思考&lt;/p&gt;</summary>
    
    
    
    <category term="工作技巧" scheme="https://unkonwn404.github.io/unknown404.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="WEB API" scheme="https://unkonwn404.github.io/unknown404.github.io/tags/WEB-API/"/>
    
  </entry>
  
  <entry>
    <title>移动端开发时的系统兼容性问题</title>
    <link href="https://unkonwn404.github.io/unknown404.github.io/2023/10/27/iosCompat/"/>
    <id>https://unkonwn404.github.io/unknown404.github.io/2023/10/27/iosCompat/</id>
    <published>2023-10-27T13:10:36.000Z</published>
    <updated>2024-05-17T02:12:25.989Z</updated>
    
    <content type="html"><![CDATA[<p>吐槽一下移动端开发时碰到的各种意想不到的兼容性问题。</p><span id="more"></span><h1 id="浏览器篇"><a href="#浏览器篇" class="headerlink" title="浏览器篇"></a>浏览器篇</h1><h2 id="问题-1-ios-系统输入框-disabled-状态样式过浅"><a href="#问题-1-ios-系统输入框-disabled-状态样式过浅" class="headerlink" title="问题 1: ios 系统输入框 disabled 状态样式过浅"></a>问题 1: ios 系统输入框 disabled 状态样式过浅</h2><p>解决方法：增加 -webkit-text-fill-color 属性配置以及要调整 opacity。如下示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">textarea</span><span class="hljs-selector-pseudo">:disabled</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">1</span>);<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>  -webkit-text-fill-<span class="hljs-attribute">color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="问题-2-安卓移动端软键盘弹出时底部-fixed-定位被顶上去"><a href="#问题-2-安卓移动端软键盘弹出时底部-fixed-定位被顶上去" class="headerlink" title="问题 2:安卓移动端软键盘弹出时底部 fixed 定位被顶上去"></a>问题 2:安卓移动端软键盘弹出时底部 fixed 定位被顶上去</h2><p>原因是安卓系统和 ios 系统加载键盘的方式不同<br>解决方法：window.onresize 监听页面高度的变化，手动来控制吸底组件的显示和隐藏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;footer&quot; v-show=&quot;hideshow&quot;&gt;&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      docmHeight: &quot;&quot;, //第一次获取高度<br>      nowHeight: &quot;&quot;,<br>      hideshow: true,<br>      isResize: false,<br>    &#125;;<br>  &#125;,<br>  watch: &#123;<br>    // 如果 clientHeight 发生改变，这个函数就会运行<br>    nowHeight: function () &#123;<br>      if (this.docmHeight != this.nowHeight) &#123;<br>        this.hideshow = false;<br>      &#125; else &#123;<br>        this.hideshow = true;<br>      &#125;<br>    &#125;,<br>  &#125;,<br>  mounted() &#123;<br>    // 获取浏览器可视区域高度<br>    this.docmHeight = document.documentElement.clientHeight; // document.body.clientWidth;<br>    window.onresize = () =&gt; &#123;<br>      // 在窗口或框架被调整大小时触发<br>      return (() =&gt; &#123;<br>        this.nowHeight = document.documentElement.clientHeight;<br>        console.log(&quot;当前高度&quot;, this.nowHeight);<br>      &#125;)();<br>    &#125;;<br>  &#125;,<br>  methods: &#123;&#125;,<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><em>个人碎碎念：其实我觉得这个方法并不好，有的手机支持横屏，横屏时页面肯定会触发 resize 事件，然后底部组件消失了？毕竟 mounted 生命周期不会再次触发。之前自己想的是键盘弹起事件和 input 组件聚焦强关联，把隐藏底部组件的触发时机放在聚焦上。但此时遇到较真的产品就会认为页面滚动时应该让 input 失焦，但浏览器并不会实现这个效果，逻辑的实现又十分复杂。所以最好的解决方案就是换个设计吧。。。</em></p><h2 id="问题-3-针对整个屏幕竖直居中的图片在-ios-的-Safari-和-Chrome-浏览器不居中"><a href="#问题-3-针对整个屏幕竖直居中的图片在-ios-的-Safari-和-Chrome-浏览器不居中" class="headerlink" title="问题 3: 针对整个屏幕竖直居中的图片在 ios 的 Safari 和 Chrome 浏览器不居中"></a>问题 3: 针对整个屏幕竖直居中的图片在 ios 的 Safari 和 Chrome 浏览器不居中</h2><p>原因：书写样式时父元素的高度设置为 100vh，也就是屏幕高度，而 Safari 和 Chrome 都有工具栏，在工具栏显示的情况下看起来就不怎么竖直居中了。其实这是 100vh 的一个 bug，可以详见<a href="https://juejin.cn/post/7313979304513552435">这篇文章</a><br>解决方法：外层父元素高度设置为 100%，因为 position 的设置该元素已经脱离了原本文本流、基准变为视口，高度设置为 100%也不会出现撑不起高度的情况，会依照视口高度定值；虽然 document.documentElement.clientHeight 和 window.innerHeight 可获取可视高度，但 Safari 的工具栏是下滑时可隐藏的，所以需要反复监听高度进行调整也比较麻烦</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.modal-container</span> &#123;<br>  <span class="hljs-attribute">position</span>: fixed;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#000</span>;<br>  <span class="hljs-attribute">z-index</span>: <span class="hljs-number">2000</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="问题-4-小米浏览器夜间模式白色图片发黑"><a href="#问题-4-小米浏览器夜间模式白色图片发黑" class="headerlink" title="问题 4:小米浏览器夜间模式白色图片发黑"></a>问题 4:小米浏览器夜间模式白色图片发黑</h2><p>原因：好像是特定的浏览器版本，会在夜间模式对白色图片进行反色<br>反色原理接近<code>filter: invert(110%) hue-rotate(180deg)</code>，但实际操作时按这个方法反色回去发现透明部分也被反色了，所以可能 filter 的方法还缺少参数<br>解决方法：一个可能性比较高的解决方法是：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">prefers-color-scheme</span>: dark) &#123;<br>  <span class="hljs-selector-tag">img</span> &#123;<br>    <span class="hljs-attribute">filter</span>: none <span class="hljs-meta">!important</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样可以去除夜间模式的过滤器效果</p><h2 id="问题-5-使用-vue-lazyload-懒加载图片流时，安卓手机会出现某一页面的第一帧图片流呈加载态，只有滚动后才变为有图片的情况"><a href="#问题-5-使用-vue-lazyload-懒加载图片流时，安卓手机会出现某一页面的第一帧图片流呈加载态，只有滚动后才变为有图片的情况" class="headerlink" title="问题 5:使用 vue-lazyload 懒加载图片流时，安卓手机会出现某一页面的第一帧图片流呈加载态，只有滚动后才变为有图片的情况"></a>问题 5:使用 vue-lazyload 懒加载图片流时，安卓手机会出现某一页面的第一帧图片流呈加载态，只有滚动后才变为有图片的情况</h2><p>原因：不是很明了，可能与<a href="https://juejin.cn/post/7015142066145460231">这篇文章</a>说的有关系，iOS 会触发 resize 事件，android 不会。<br>解决方法：在页面加载或者激活的生命周期加一个滚动函数，滚 1px，触发加载</p><h2 id="问题-6-粘贴板功能在部分环境失效"><a href="#问题-6-粘贴板功能在部分环境失效" class="headerlink" title="问题 6:粘贴板功能在部分环境失效"></a>问题 6:粘贴板功能在部分环境失效</h2><p>原因：粘贴板使用的是 navigator.clipboard，该方法在 iOS 或比较先进的浏览器才会生效，而微信小程序安卓 webview 环境下使用用这个方法会报错<br>解决方法：增加 navigator.clipboard 的 api 使用检查和设备识别，如果不存在该 api 则使用 npm 包 copy-to-clipboard 的方法</p><h2 id="问题-7-安卓-qq-浏览器点击图片会自动放大"><a href="#问题-7-安卓-qq-浏览器点击图片会自动放大" class="headerlink" title="问题 7:安卓 qq 浏览器点击图片会自动放大"></a>问题 7:安卓 qq 浏览器点击图片会自动放大</h2><p>原因：qq 浏览器的自发行为（就跟他有时候会自动屏蔽 ad-wrap 的元素一样离谱）<br>解决方法：使用 css 样式 pointer-events: none;可以阻止浏览器默认行为，但是如果希望保留一些浏览器默认行为如长按保存就不能使用该样式</p><h2 id="问题-8-ios-的-safari-下拉页面时页面外区域是黑的"><a href="#问题-8-ios-的-safari-下拉页面时页面外区域是黑的" class="headerlink" title="问题 8:ios 的 safari 下拉页面时页面外区域是黑的"></a>问题 8:ios 的 safari 下拉页面时页面外区域是黑的</h2><p>原因：和 meta 上设置的 theme color 有关<br>解决方法：document.querySelector(‘meta[name&#x3D;”theme-color”]’).setAttribute(‘content’, bgColor || “#141416”)</p><h1 id="小程序篇"><a href="#小程序篇" class="headerlink" title="小程序篇"></a>小程序篇</h1><h2 id="问题-1-弹窗滚动穿透问题（即弹窗出现时页面还可以做滚动操作）"><a href="#问题-1-弹窗滚动穿透问题（即弹窗出现时页面还可以做滚动操作）" class="headerlink" title="问题 1: 弹窗滚动穿透问题（即弹窗出现时页面还可以做滚动操作）"></a>问题 1: 弹窗滚动穿透问题（即弹窗出现时页面还可以做滚动操作）</h2><p>解决方法：跟使用的技术及小程序平台有关，如果只有<a href="https://developers.weixin.qq.com/community/develop/doc/d615c9a8957a00225ae66b65a8c2bd01?highLine=%25E6%25BB%259A%25E5%258A%25A8%25E7%25A9%25BF%25E9%2580%258F">微信小程序</a>可以用官方提供的 page-meta，或者在弹窗上增加 catchtouchmove 属性；如果使用了跨端框架（例如<a href="https://taro-docs.jd.com/docs/vue-overall#taro-3-%E5%9C%A8%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AB%AF%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6">Taro</a>），可能这些属性不生效，只能通过改变页面样式如固定高度、溢出隐藏等来禁止页面的滚动</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;吐槽一下移动端开发时碰到的各种意想不到的兼容性问题。&lt;/p&gt;</summary>
    
    
    
    <category term="踩坑经历" scheme="https://unkonwn404.github.io/unknown404.github.io/categories/%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="iOS" scheme="https://unkonwn404.github.io/unknown404.github.io/tags/iOS/"/>
    
    <category term="Android" scheme="https://unkonwn404.github.io/unknown404.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>cover-view在webview上显示</title>
    <link href="https://unkonwn404.github.io/unknown404.github.io/2023/10/07/cover-view/"/>
    <id>https://unkonwn404.github.io/unknown404.github.io/2023/10/07/cover-view/</id>
    <published>2023-10-07T03:18:04.000Z</published>
    <updated>2023-10-07T03:35:40.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>根据微信小程序官方文档，webview 覆盖全组件，是不支持其他组件进行覆盖的。但有些需求希望在小程序的 webview 页增加浮动图标、提供引导作用。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>利用 webview 的 bindload 属性或者页面的onShow周期、在 webivew 加载完成后显示 cover-view 的内容，为保证 cover-view 能出现最好加上一点时延。<br>这只是一个临时解决方法，并不是官方提供的实现。所以在开发者工具上无法看出效果，只有真机才能看到，日后也有无法生效的可能。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://developers.weixin.qq.com/community/develop/doc/000a40ddcac42010f5ba0737c56800">cover-view能否覆盖webview?</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;根据微信小程序官方文档，webview 覆盖全组件，是不支持其他组件进行覆盖的。但有些需求希望在小程序的 webview 页</summary>
      
    
    
    
    <category term="工作技巧" scheme="https://unkonwn404.github.io/unknown404.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="小程序" scheme="https://unkonwn404.github.io/unknown404.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>自定义tabbar的实现</title>
    <link href="https://unkonwn404.github.io/unknown404.github.io/2023/09/21/tabBarMid/"/>
    <id>https://unkonwn404.github.io/unknown404.github.io/2023/09/21/tabBarMid/</id>
    <published>2023-09-21T07:25:02.000Z</published>
    <updated>2023-10-17T10:41:55.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>根据产品需求，要实现小程序的 tabbar 样式自定义、中间按钮凸起的效果</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li><p>pages.json文件和一般带tabbar的项目一样进行配置（不做配置的话切换页面顶部导航会出现回退键）</p></li><li><p>自定义tabbar中实现tab页面切换的逻辑：每个tab页都设置id值，切换页面时传入自定义tabbar组件的id值变化，改变tabbar的icon激活样式；在mounted周期隐藏默认的tabbar</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;view class=&quot;tab-container&quot;&gt;<br>        &lt;view class=&quot;tabbar-item&quot; v-for=&quot;(item, index) in tabBarList&quot; :class=&quot;[item.centerItem ? &#x27; center-item&#x27; : &#x27;&#x27;]&quot;<br>            @click=&quot;changeItem(item)&quot; :key=&quot;index&quot;&gt;<br>            &lt;view class=&quot;item-top&quot;&gt;<br>                &lt;image :src=&quot;currentItem == item.id ? item.selectIcon : item.icon&quot;&gt;&lt;/image&gt;<br>            &lt;/view&gt;<br>            &lt;view class=&quot;item-bottom&quot; :class=&quot;[currentItem == item.id ? &#x27;item-active&#x27; : &#x27;&#x27;]&quot;&gt;<br>                &lt;text&gt;&#123;&#123; item.text &#125;&#125;&lt;/text&gt;<br>            &lt;/view&gt;<br>        &lt;/view&gt;<br>    &lt;/view&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; tabBarList &#125; from &#x27;../utils/constants&#x27;<br>export default &#123;<br>    props: &#123;<br>        currentPageId: &#123;<br>            type: Number,<br>            default: 0<br>        &#125;<br>    &#125;,<br>    data() &#123;<br>        return &#123;<br>            currentItem: 0,<br>            tabBarList: tabBarList<br>        &#125;<br>    &#125;,<br>    methods: &#123;<br>        changeItem(item) &#123;<br>            uni.switchTab(&#123;<br>                url: item.path<br>            &#125;);<br>        &#125;<br><br>    &#125;,<br>    mounted() &#123;<br>        this.currentItem = this.currentPageId<br>        uni.hideTabBar();<br>    &#125;,<br><br>&#125;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;less&quot;&gt;<br>.tab-container &#123;<br>    position: fixed;<br>    bottom: 0;<br>    left: 0;<br>    width: 100%;<br>    height: 120rpx;<br>    padding: 10rpx 80rpx 0;<br>    display: flex;<br>    justify-content: space-between;<br>    box-sizing: border-box;<br>    border-top: 1rpx solid #999;<br>    background: #fff;<br><br>    .tabbar-item &#123;<br>        display: flex;<br>        flex-direction: column;<br>        justify-content: center;<br>        align-items: center;<br>        text-align: center;<br><br>        .item-top &#123;<br>            width: 64rpx;<br>            height: 64rpx;<br>            margin-bottom: 10rpx;<br><br>            image &#123;<br>                width: 100%;<br>                height: 100%;<br>                object-fit: contain;<br>            &#125;<br>        &#125;<br><br>        .item-bottom &#123;<br>            font-size: 20rpx;<br>            color: #999;<br>        &#125;<br><br>        &amp;.center-item &#123;<br>            position: absolute;<br>            top: -50rpx;<br>            left: calc(50% - 50rpx);<br>            background: #fff;<br>            width: 100rpx;<br>            border: 1px solid;<br>            border-radius: 10rpx;<br>            padding: 20rpx 0;<br>            box-sizing: border-box;<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure></li><li><p>将自定义的tabbar引入页面</p></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://blog.csdn.net/weixin_56650035/article/details/118027317">uniapp 自定义 tabbar，中间凸起</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;根据产品需求，要实现小程序的 tabbar 样式自定义、中间按钮凸起的效果&lt;/p&gt;
&lt;h2 id=&quot;解决方法&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="工作技巧" scheme="https://unkonwn404.github.io/unknown404.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="小程序" scheme="https://unkonwn404.github.io/unknown404.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>ios踩坑经历——页面在键盘弹出时上移</title>
    <link href="https://unkonwn404.github.io/unknown404.github.io/2023/09/18/iosScroll/"/>
    <id>https://unkonwn404.github.io/unknown404.github.io/2023/09/18/iosScroll/</id>
    <published>2023-09-18T08:16:26.000Z</published>
    <updated>2023-09-19T02:45:41.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>iOS 环境下当 input 组件聚焦、弹出键盘时，页面整体位置上移</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>这属于 iOS 系统的特殊操作，必然会出现。解决思路是键盘弹出时记录下当前滚动的位置，用 js 进行位置还原。但考虑执行时可能无法完全抵消 ios 的默认操作，实际展示可能会出现页面上移后迅速回位的奇怪效果，设置为在键盘隐藏时页面回归原位。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;container&quot;&gt;<br>    &lt;input ref=&quot;input&quot; /&gt;<br>    &lt;button @click=&quot;focusInput&quot; /&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      scrollTop: 0,<br>    &#125;;<br>  &#125;,<br><br>  mounted() &#123;<br>    var UA = navigator.userAgent.toLowerCase();<br>    if (<br>      UA.indexOf(&quot;iphone&quot;) &gt; -1 ||<br>      UA.indexOf(&quot;ipad&quot;) &gt; -1 ||<br>      UA.indexOf(&quot;ios&quot;) &gt; -1<br>    ) &#123;<br>      // 监听键盘收起操作<br>      document.body.addEventListener(&quot;focusout&quot;, this.pageRecover);<br>    &#125;<br>  &#125;,<br>  destroyed() &#123;<br>    var UA = navigator.userAgent.toLowerCase();<br>    if (<br>      UA.indexOf(&quot;iphone&quot;) &gt; -1 ||<br>      UA.indexOf(&quot;ipad&quot;) &gt; -1 ||<br>      UA.indexOf(&quot;ios&quot;) &gt; -1<br>    ) &#123;<br>      document.body.removeEventListener(&quot;focusout&quot;, this.pageRecover);<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    focusInput() &#123;<br>      // 触发键盘出现、页面上推<br>      this.$refs[&quot;input&quot;].focus();<br>      this.scrollTop = window.pageYOffset;<br>    &#125;,<br>    //软键盘收起的事件处理<br>    pageRecover() &#123;<br>      setTimeout(() =&gt; &#123;<br>        window.scrollTo(0, this.scrollTop);<br>      &#125;, 500);<br>    &#125;,<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/6844904083438977032">由 Vant Field 组件得到解决 IOS 输入框 键盘上推问题</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;iOS 环境下当 input 组件聚焦、弹出键盘时，页面整体位置上移&lt;/p&gt;
&lt;h2 id=&quot;解决方法&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="踩坑经历" scheme="https://unkonwn404.github.io/unknown404.github.io/categories/%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="iOS" scheme="https://unkonwn404.github.io/unknown404.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>vscode指令</title>
    <link href="https://unkonwn404.github.io/unknown404.github.io/2023/09/07/vscodeCmd/"/>
    <id>https://unkonwn404.github.io/unknown404.github.io/2023/09/07/vscodeCmd/</id>
    <published>2023-09-07T06:45:32.000Z</published>
    <updated>2023-09-07T07:33:29.609Z</updated>
    
    <content type="html"><![CDATA[<p>记录下几个提升效率的 vscode 指令，免得自己突然想不起来又专门查。</p><span id="more"></span><h2 id="打开-vscode-的-setting"><a href="#打开-vscode-的-setting" class="headerlink" title="打开 vscode 的 setting"></a>打开 vscode 的 setting</h2><p>方法一：找到 vscode 顶部菜单，点击首个 tab，按“preferences - setting”的顺序点开</p><p>方法二：IDE 界面的左下角的齿轮点开，选择菜单里的 setting</p><p>方法三：使用指令<code>Cmd + Shift + P</code>（mac）打开命令面板 Command Palette，输入 setting 后点击“Preference：Open User Settings (JSON) ”就会打开用户的设置 json</p><p>举例可以修改 editor.stickyScroll.enabled 属性的状态，让 ide 屏幕顶部显示你所在的函数&#x2F;类，这在阅读较长的代码时比较有用</p><h2 id="项目切换"><a href="#项目切换" class="headerlink" title="项目切换"></a>项目切换</h2><p>指令<code>control + R</code>，可在最近打开的几个项目间进行切换</p><h2 id="文档查找"><a href="#文档查找" class="headerlink" title="文档查找"></a>文档查找</h2><p>指令<code>Cmd + P</code>，搜索当前项目的文件名</p><h2 id="函数查找"><a href="#函数查找" class="headerlink" title="函数查找"></a>函数查找</h2><p>指令<code>Cmd + Shift + O</code>，搜索当前所在文件里的函数名</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/7270061728897204282">你一定要知道的 7 个 VS Code 技巧</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录下几个提升效率的 vscode 指令，免得自己突然想不起来又专门查。&lt;/p&gt;</summary>
    
    
    
    <category term="备忘录" scheme="https://unkonwn404.github.io/unknown404.github.io/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
    <category term="vscode" scheme="https://unkonwn404.github.io/unknown404.github.io/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>css文件px转rem操作</title>
    <link href="https://unkonwn404.github.io/unknown404.github.io/2023/08/28/postcss/"/>
    <id>https://unkonwn404.github.io/unknown404.github.io/2023/08/28/postcss/</id>
    <published>2023-08-28T03:04:08.000Z</published>
    <updated>2024-01-24T02:53:03.516Z</updated>
    
    <content type="html"><![CDATA[<p>前端尤其是移动端开发时，对屏幕适配换设计稿的要求比较高。常见的方法是将 px 转为 rem，主要有两种实现方式。</p><h3 id="使用-CSS-预处理器（如-Sass-或-Less）"><a href="#使用-CSS-预处理器（如-Sass-或-Less）" class="headerlink" title="使用 CSS 预处理器（如 Sass 或 Less）"></a>使用 CSS 预处理器（如 Sass 或 Less）</h3><p>通过编写变量和函数来实现</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs less">$base-<span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;<br><br><span class="hljs-variable">@function</span> px2rem($px) &#123;<br>  <span class="hljs-variable">@return</span> $px / $base-font-size * <span class="hljs-number">1rem</span>;<br>&#125;<br><br>.example &#123;<br>  <span class="hljs-attribute">font-size</span>: px2rem(<span class="hljs-number">24px</span>); <span class="hljs-comment">// 1.5rem</span><br>  <span class="hljs-attribute">width</span>: px2rem(<span class="hljs-number">200px</span>); <span class="hljs-comment">// 12.5rem</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用-postcss-插件"><a href="#使用-postcss-插件" class="headerlink" title="使用 postcss 插件"></a>使用 postcss 插件</h3><p>PostCSS 是一个用于转换 CSS 的工具，可以通过插件来实现将 px 转换为 rem。常用的插件包括 postcss-pxtorem 和 postcss-plugin-px2rem。配置插件后，它会自动将 CSS 文件中的 px 单位转换为 rem。</p><p>如果想实现整个项目自动将 px 转为 rem，主要有两个步骤</p><h4 id="1-根元素挂载-font-size-样式"><a href="#1-根元素挂载-font-size-样式" class="headerlink" title="1.根元素挂载 font-size 样式"></a>1.根元素挂载 font-size 样式</h4><p>rem 单位是相对于根节点的字体大小的，所以需要设置根节点的字体大小。当窗口大小调整时，通过调整根节点的字体大小来实现自适应。</p><p>实现代码如下（一般来说设计稿都是 750 的宽度）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span> (<span class="hljs-params">designWidth, maxWidth</span>) &#123;<br>  <span class="hljs-keyword">var</span> doc = <span class="hljs-variable language_">document</span>,<br>    timer;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">refreshRem</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> width = doc.<span class="hljs-property">documentElement</span>.<span class="hljs-title function_">getBoundingClientRect</span>().<span class="hljs-property">width</span>;<br>    <span class="hljs-comment">// *** 一定程度的适配pc ***</span><br>    <span class="hljs-keyword">var</span> rem;<br>    <span class="hljs-keyword">if</span> (width &gt; maxWidth) &#123;<br>      rem = <span class="hljs-number">72</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      rem = (width * <span class="hljs-number">100</span>) / designWidth;<br>    &#125;<br>    <span class="hljs-comment">// *** 适配pc结束 ***</span><br>    doc.<span class="hljs-property">documentElement</span>.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = rem + <span class="hljs-string">&quot;px&quot;</span>;<br>  &#125;<br>  <span class="hljs-comment">// rem初始化开始</span><br>  <span class="hljs-title function_">refreshRem</span>();<br>  <span class="hljs-comment">// 改变窗口大小时重新设置 rem</span><br>  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<br>    <span class="hljs-string">&quot;resize&quot;</span>,<br>    <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timer); <span class="hljs-comment">//防止执行两次</span><br>      timer = <span class="hljs-built_in">setTimeout</span>(refreshRem, <span class="hljs-number">300</span>);<br>    &#125;,<br>    <span class="hljs-literal">false</span><br>  );<br>  <span class="hljs-comment">// 浏览器后退的时候重新计算</span><br>  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<br>    <span class="hljs-string">&quot;pageshow&quot;</span>,<br>    <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>      <span class="hljs-comment">// 页面从缓存加载时</span><br>      <span class="hljs-keyword">if</span> (e.<span class="hljs-property">persisted</span>) &#123;<br>        <span class="hljs-built_in">clearTimeout</span>(timer);<br>        timer = <span class="hljs-built_in">setTimeout</span>(refreshRem, <span class="hljs-number">300</span>);<br>      &#125;<br>    &#125;,<br>    <span class="hljs-literal">false</span><br>  );<br>&#125;)(<span class="hljs-number">750</span>, <span class="hljs-number">540</span>);<br></code></pre></td></tr></table></figure><p>将这段 js 引入到项目的入口文件 app.html 后，查看页面的 html 节点，是否有被自动添加 font-size。</p><h4 id="2-配置-postcss"><a href="#2-配置-postcss" class="headerlink" title="2.配置 postcss"></a>2.配置 postcss</h4><ol><li>安装 postcss-pxtorem</li><li>在项目根目录下创建一个名为 postcss.config.js 的文件，用于配置 PostCSS 插件。（如果像 nuxt 的项目已经安装了 postcss，可以直接在 nuxt.config.js 文件里配置</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">plugins</span>: &#123;<br>    <span class="hljs-string">&quot;postcss-pxtorem&quot;</span>: &#123;<br>      <span class="hljs-attr">rootValue</span>: <span class="hljs-number">50</span>,<br>      <span class="hljs-attr">propList</span>: [<span class="hljs-string">&quot;*&quot;</span>],<br>    &#125;,<br>    <span class="hljs-attr">autoprefixer</span>: &#123;&#125;,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="备注：viewpoint-适配方法"><a href="#备注：viewpoint-适配方法" class="headerlink" title="备注：viewpoint 适配方法"></a>备注：viewpoint 适配方法</h3><p>到这里 rem 适配方法已经结束了。现在更为流行的是使用 vw、vh 单位进行适配。但满屏的宽度为 100vw，与设计稿的 750 进行手动换算还是比较麻烦。所以仍需要一些适配操作。原理大体同 rem 类似，主要两种：</p><ol><li>使用 CSS 预处理器（如 Sass 或 Less）</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@windowWidth:</span> <span class="hljs-number">100vw</span>;<br><span class="hljs-selector-class">.rpxToVW</span>(<span class="hljs-variable">@name</span>,<span class="hljs-variable">@rpx</span>) &#123;<br>  <span class="hljs-comment">//传入不带单位的rpx数值，将rpx转为vw</span><br>  @&#123;name&#125;: <span class="hljs-selector-tag">unit</span>(<span class="hljs-variable">@rpx</span> / <span class="hljs-number">750</span> * <span class="hljs-variable">@windowWidth</span>, vw);<br>&#125;<br><span class="hljs-selector-class">.taskBlock</span> &#123;<br>  <span class="hljs-selector-class">.rpxToVW</span>(margin,<span class="hljs-number">20</span>);<br>  <span class="hljs-selector-class">.rpxToVW</span>(padding,<span class="hljs-number">30</span>);<br>  <span class="hljs-selector-class">.rpxToVW</span>(border-radius,<span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>postcss</li></ol><ul><li>安装 postcss-px-to-viewport</li><li>在根目录新建一个名为 postcss.config.js 的文件</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">plugins</span>: &#123;<br>    <span class="hljs-string">&quot;postcss-px-to-viewport&quot;</span>: &#123;<br>      <span class="hljs-attr">unitToConvert</span>: <span class="hljs-string">&quot;px&quot;</span>, <span class="hljs-comment">// 要转化的单位</span><br>      <span class="hljs-attr">viewportWidth</span>: <span class="hljs-number">375</span>, <span class="hljs-comment">// UI设计稿的宽度</span><br>      <span class="hljs-attr">unitPrecision</span>: <span class="hljs-number">6</span>, <span class="hljs-comment">// 转换后的精度，即小数点位数</span><br>      <span class="hljs-attr">propList</span>: [<span class="hljs-string">&quot;*&quot;</span>], <span class="hljs-comment">// 指定转换的css属性的单位，*代表全部css属性的单位都进行转换</span><br>      <span class="hljs-attr">viewportUnit</span>: <span class="hljs-string">&quot;vw&quot;</span>, <span class="hljs-comment">// 指定需要转换成的视窗单位，默认vw</span><br>      <span class="hljs-attr">fontViewportUnit</span>: <span class="hljs-string">&quot;vw&quot;</span>, <span class="hljs-comment">// 指定字体需要转换成的视窗单位，默认vw</span><br>      <span class="hljs-attr">selectorBlackList</span>: [<span class="hljs-string">&quot;wrap&quot;</span>], <span class="hljs-comment">// 指定不转换为视窗单位的类名，</span><br>      <span class="hljs-attr">minPixelValue</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">// 默认值1，小于或等于1px则不进行转换</span><br>      <span class="hljs-attr">mediaQuery</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否在媒体查询的css代码中也进行转换，默认false</span><br>      <span class="hljs-attr">replace</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否转换后直接更换属性值</span><br>      <span class="hljs-attr">exclude</span>: [<span class="hljs-regexp">/node_modules/</span>], <span class="hljs-comment">// 设置忽略文件，用正则做目录名匹配</span><br>    &#125;,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>备注： webpack 5 版本 postcss 配置书写方式有差别，从对象形式变为函数形式，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;postcss-px-to-viewport&quot;</span>)(&#123;<br>      <span class="hljs-attr">unitToConvert</span>: <span class="hljs-string">&quot;px&quot;</span>, <span class="hljs-comment">// 要转化的单位</span><br>      <span class="hljs-attr">viewportWidth</span>: <span class="hljs-number">375</span>, <span class="hljs-comment">// UI设计稿的宽度</span><br>      <span class="hljs-attr">unitPrecision</span>: <span class="hljs-number">6</span>, <span class="hljs-comment">// 转换后的精度，即小数点位数</span><br>      <span class="hljs-attr">propList</span>: [<span class="hljs-string">&quot;*&quot;</span>], <span class="hljs-comment">// 指定转换的css属性的单位，*代表全部css属性的单位都进行转换</span><br>      <span class="hljs-attr">viewportUnit</span>: <span class="hljs-string">&quot;vw&quot;</span>, <span class="hljs-comment">// 指定需要转换成的视窗单位，默认vw</span><br>      <span class="hljs-attr">fontViewportUnit</span>: <span class="hljs-string">&quot;vw&quot;</span>, <span class="hljs-comment">// 指定字体需要转换成的视窗单位，默认vw</span><br>      <span class="hljs-attr">minPixelValue</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">// 默认值1，小于或等于1px则不进行转换</span><br>      <span class="hljs-attr">mediaQuery</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否在媒体查询的css代码中也进行转换，默认false</span><br>      <span class="hljs-attr">replace</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否转换后直接更换属性值</span><br>      <span class="hljs-attr">selectorBlackList</span>: [<span class="hljs-string">&quot;wrap&quot;</span>], <span class="hljs-comment">// 指定不转换为视窗单位的类名</span><br>      <span class="hljs-attr">exclude</span>: [<span class="hljs-regexp">/node_modules/</span>, <span class="hljs-regexp">/src\/views/</span>, <span class="hljs-regexp">/src\/components/</span>, <span class="hljs-regexp">/src\/App/</span>], <span class="hljs-comment">// 设置忽略文件，用正则做目录名匹配</span><br>    &#125;),<br>    <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;autoprefixer&quot;</span>)(),<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://juejin.cn/post/6844903557930418189?searchId=202308281046059EA791D01FCE5880F623">Vue 项目自动转换 px 为 rem，高保真还原设计图</a></li><li><a href="https://juejin.cn/post/7061866685166256142?searchId=2023082811284766FD14F856BCD7817236">移动端适配解决方案(二)</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前端尤其是移动端开发时，对屏幕适配换设计稿的要求比较高。常见的方法是将 px 转为 rem，主要有两种实现方式。&lt;/p&gt;
&lt;h3 id=&quot;使用-CSS-预处理器（如-Sass-或-Less）&quot;&gt;&lt;a href=&quot;#使用-CSS-预处理器（如-Sass-或-Less）&quot; cl</summary>
      
    
    
    
    <category term="工作技巧" scheme="https://unkonwn404.github.io/unknown404.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="postcss" scheme="https://unkonwn404.github.io/unknown404.github.io/tags/postcss/"/>
    
    <category term="rem" scheme="https://unkonwn404.github.io/unknown404.github.io/tags/rem/"/>
    
  </entry>
  
  <entry>
    <title>浅谈WEB前端性能监控</title>
    <link href="https://unkonwn404.github.io/unknown404.github.io/2023/08/25/performanceMonitor/"/>
    <id>https://unkonwn404.github.io/unknown404.github.io/2023/08/25/performanceMonitor/</id>
    <published>2023-08-25T01:45:27.000Z</published>
    <updated>2023-08-25T04:04:56.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>前端页面性能对用户留存、用户直观体验有着重要影响。有调查显示，当页面加载时间超过 2 秒后，加载时间每增加一秒，就会有大量的用户流失，所以做好页面性能优化，无疑对网站来说是一个非常重要的步骤。</p><h2 id="二、前端性能评判指标"><a href="#二、前端性能评判指标" class="headerlink" title="二、前端性能评判指标"></a>二、前端性能评判指标</h2><p>对于 Web 开发人员来说，如何衡量一个 Web 页面的性能一直是一个难题。在这一方面，谷歌团队一直致力于提供各种质量信号的统一指南。</p><h3 id="2-1-核心-Web-指标"><a href="#2-1-核心-Web-指标" class="headerlink" title="2.1 核心 Web 指标"></a>2.1 核心 Web 指标</h3><p>核心 Web 指标旨在适用于所有网页，反映出以用户为中心的结果。该指标并不是固定不变的。2020 年谷歌团队从加载性能、交互性和视觉稳定性方面考虑提出了 3 个核心 Web 指标：最大内容绘制（LCP）、首次输入延迟（FID）、累积布局偏移（CLS）</p><p><img src="/unknown404.github.io/img/performanceMonitor/web_vital.png"></p><h4 id="2-1-1-最大内容绘制（Largest-Contentful-Paint-LCP）"><a href="#2-1-1-最大内容绘制（Largest-Contentful-Paint-LCP）" class="headerlink" title="2.1.1 最大内容绘制（Largest Contentful Paint, LCP）"></a>2.1.1 最大内容绘制（Largest Contentful Paint, LCP）</h4><p>定义：页面首次开始加载时可视区域内可见的最大图像或文本块完成渲染的相对时间。</p><p>LCP 考量的元素类型为：</p><ul><li><p><code>&lt;img&gt;</code>元素</p></li><li><p>内嵌在<code>&lt;svg&gt;</code>元素内的<code>&lt;image&gt;</code>元素</p></li><li><p><code>&lt;video&gt;</code>元素（使用封面图像）</p></li><li><p>通过 url()函数（而非使用 CSS 渐变）加载的带有背景图像的元素</p></li><li><p>包含文本节点或其他行内级文本元素子元素的块级元素。</p></li></ul><h4 id="2-1-2-首次输入延迟（First-Input-Delay-FID）"><a href="#2-1-2-首次输入延迟（First-Input-Delay-FID）" class="headerlink" title="2.1.2 首次输入延迟（First Input Delay, FID）"></a>2.1.2 首次输入延迟（First Input Delay, FID）</h4><p>定义：用户第一次与页面交互（例如当他们单击链接、点按按钮或使用由 JavaScript 驱动的自定义控件）直到浏览器对交互作出响应、并实际开始处理事件处理程序所经过的时间。</p><p>特点：</p><ul><li><p>需要在真实用户环境下测量</p></li><li><p>实际数据与预期可能会有差距较大的情况。真实环境下会出现几种可能性：</p></li></ul><p>a）并非所有用户都会在每次访问您的网站时进行交互。用户发出的交互可能与 FID 无关（如滚动和缩放之类的交互）-&gt; FID 没有值</p><p>b）一些用户的首次交互会处于不利的时间段内（当主线程长时间处于繁忙时）-&gt; FID 值较高</p><p>c）一些用户的首次交互会处于有利的时间段内（当主线程完全空闲时）-&gt; FID 值较低</p><p>由于 FID 值的预期差异，在查看 FID 上报数据时主要关注值的分布并注意较高的百分位数</p><h4 id="2-1-3-累积布局偏移（Cumulative-Layout-Shift-CLS）"><a href="#2-1-3-累积布局偏移（Cumulative-Layout-Shift-CLS）" class="headerlink" title="2.1.3 累积布局偏移（Cumulative Layout Shift, CLS）"></a>2.1.3 累积布局偏移（Cumulative Layout Shift, CLS）</h4><p>定义：整个页面生命周期内发生的所有单次布局偏移分数的总和。</p><p>计算方式：</p><p><em>布局偏移分数 &#x3D; 影响分数 * 距离分数</em></p><p><em>布局偏移分数得分范围 0-1，0 表示没有偏移，1 表示最大偏移</em></p><p><strong>影响分数</strong></p><p>影响分数测量 <em>不稳定元素</em> 对两帧之间的可视区域产生的影响。</p><p>前一帧 <em>和</em> 当前帧的所有 <em>不稳定元素</em> 的可见区域集合（占总可视区域的部分）就是当前帧的 <em>影响分数</em> 。</p><p><img src="/unknown404.github.io/img/performanceMonitor/cls.png"></p><p>在上图中，有一个元素在一帧中占据了一半的可视区域。接着，在下一帧中，元素下移了可视区域高度的 25%。红色虚线矩形框表示两帧中元素的可见区域集合，在本示例中，该集合占总可视区域的 75%，因此其 <em>影响分数</em> 为 0.75 。</p><p><strong>距离分数</strong></p><p>布局偏移分数计算公式的另一部分测量不稳定元素相对于可视区域位移的距离。 <em>距离分数</em> 指的是任何 <em>不稳定元素</em> 在一帧中位移的最大距离（水平或垂直）除以可视区域的最大尺寸维度（宽度或高度，以较大者为准）。</p><p>在刚才的示例中，最大的可视区域尺寸维度是高度，不稳定元素的位移距离为可视区域高度的 25%，因此 <em>距离分数</em> 为 0.25。</p><p>所以，在这个示例中， <em>影响分数</em> 是 0.75 ， <em>距离分数</em> 是 0.25 ，所以 <em>布局偏移分数</em> 是 0.75 * 0.25 &#x3D; 0.1875</p><h3 id="2-2-Web-指标"><a href="#2-2-Web-指标" class="headerlink" title="2.2 Web 指标"></a>2.2 Web 指标</h3><p>除了核心 Web 指标外，还有其他的指标也可用于加载、交互等性能评估</p><h4 id="2-2-1-文档加载相关指标"><a href="#2-2-1-文档加载相关指标" class="headerlink" title="2.2.1 文档加载相关指标"></a>2.2.1 文档加载相关指标</h4><h5 id="第一字节时间（Time-to-First-Byte，TTFB）"><a href="#第一字节时间（Time-to-First-Byte，TTFB）" class="headerlink" title="第一字节时间（Time to First Byte，TTFB）"></a>第一字节时间（Time to First Byte，TTFB）</h5><p>浏览器从请求页面开始到接收第一字节的时间，这个时间段内包括 DNS 查找、TCP 连接和发出请求直到响应的第一个字节到达为止的时延。<br><img src="/unknown404.github.io/img/performanceMonitor/performancetiming.png"></p><p><img src="/unknown404.github.io/img/performanceMonitor/ttfb.png"></p><h5 id="DOM-解析完成时间（DOMContentLoaded，DCL）"><a href="#DOM-解析完成时间（DOMContentLoaded，DCL）" class="headerlink" title="DOM 解析完成时间（DOMContentLoaded，DCL）"></a>DOM 解析完成时间（DOMContentLoaded，DCL）</h5><p>DomContentLoaded 事件触发的时间。当 **HTML 文档被完全加载和解析完成之后，DOMContentLoaded ** 事件被触发，而无需等待样式表、图像和子框架加载完成。早期网络性能的测量参量</p><h5 id="页面加载耗时（Load，L）"><a href="#页面加载耗时（Load，L）" class="headerlink" title="页面加载耗时（Load，L）"></a>页面加载耗时（Load，L）</h5><p>onLoad 事件触发的时间。页面所有资源都加载完毕后（比如图片，CSS），onLoad 事件才被触发。早期网络性能的测量参量</p><h4 id="2-2-2-内容呈现相关指标"><a href="#2-2-2-内容呈现相关指标" class="headerlink" title="2.2.2 内容呈现相关指标"></a>2.2.2 内容呈现相关指标</h4><h5 id="首次绘制（-First-Paint，FP）"><a href="#首次绘制（-First-Paint，FP）" class="headerlink" title="首次绘制（ First Paint，FP）"></a>首次绘制（ First Paint，FP）</h5><p>从开始加载到浏览器 <strong>首次绘制像素</strong> 到屏幕上的时间，也就是页面在屏幕上首次发生视觉变化的时间。但此变化可能是简单的背景色更新或不引人注意的内容，它并不表示页面内容完整性，可能会报告没有任何可见的内容被绘制的时间。</p><h5 id="首次内容绘制-（First-Contentful-Paint，FCP）"><a href="#首次内容绘制-（First-Contentful-Paint，FCP）" class="headerlink" title="首次内容绘制 （First Contentful Paint，FCP）"></a>首次内容绘制 （First Contentful Paint，FCP）</h5><p>浏览器 <strong>首次绘制来自 DOM 的内容</strong> 的时间，内容必须是文本、图片（包含背景图）、非白色的 canvas 或 SVG，也包括带有正在加载中的 Web 字体的文本。</p><p>这是用户第一次开始看到页面内容，但仅仅有内容，并不意味着它是有用的内容（例如 Header、导航栏等），也不意味着有用户要消费的内容。</p><p><strong>辨析：FCP 和 LCP 区别</strong></p><p>FCP：第一次看到的内容，不一定有用</p><p>LCP：最大内容，在页面加载过程中对应的元素是会发生变化的</p><p><img src="/unknown404.github.io/img/performanceMonitor/fcpvslcp.png"></p><h4 id="2-2-3-交互响应性相关指标"><a href="#2-2-3-交互响应性相关指标" class="headerlink" title="2.2.3 交互响应性相关指标"></a>2.2.3 交互响应性相关指标</h4><h5 id="可交互时间（Time-to-Interactive，TTI）"><a href="#可交互时间（Time-to-Interactive，TTI）" class="headerlink" title="可交互时间（Time to Interactive，TTI）"></a>可交互时间（Time to Interactive，TTI）</h5><p>表示网页第一次 <strong>完全达到可交互状态</strong> 的时间点，浏览器已经可以持续性的响应用户的输入。完全达到可交互状态的时间点是在最后一个长任务（Long Task）完成的时间, 并且在随后的 5 秒内网络和主线程是空闲的。</p><p><img src="/unknown404.github.io/img/performanceMonitor/tti.png"></p><h2 id="三、性能监控模式"><a href="#三、性能监控模式" class="headerlink" title="三、性能监控模式"></a>三、性能监控模式</h2><p>从技术方面来讲，前端性能监控主要分为两种方式，一种叫做合成监控（Synthetic Monitoring，SYN），另一种是真实用户监控（Real User Monitoring，RUM）。</p><p>合成监控：在一个模拟场景里，去提交一个需要做性能审计的页面，通过一系列的工具、规则去运行你的页面，提取一些性能指标，得出一个审计报告。</p><p>真实用户监控：在用户结束页面访问的时候，把此次访问产生的性能指标上传到日志服务器、进行数据的提取清洗加工，最后在监控平台上进行展示。</p><table><thead><tr><th align="center"></th><th align="center">合成监控</th><th align="center">真实用户监控</th></tr></thead><tbody><tr><td align="center">实现难度及成本</td><td align="center">较低</td><td align="center">较高</td></tr><tr><td align="center">采集数据丰富度</td><td align="center">丰富</td><td align="center">基础</td></tr><tr><td align="center">数据样本量</td><td align="center">较小</td><td align="center">较大</td></tr><tr><td align="center">是否有侵入性</td><td align="center">否</td><td align="center">是</td></tr></tbody></table><h3 id="3-1-合成监控"><a href="#3-1-合成监控" class="headerlink" title="3.1 合成监控"></a>3.1 合成监控</h3><p>常见工具： <strong>Lighthouse、PageSpeed、 WebPageTest</strong></p><h4 id="自研合成监控方案"><a href="#自研合成监控方案" class="headerlink" title="自研合成监控方案"></a>自研合成监控方案</h4><p>目前常见的合成监控的实现方案为在服务端通过 Puppeteer 访问检测页面，调用 Lighthouse 获取相应指标，计算目标得分并将结果保存在数据库，同时提供给前台页面进行可视化展示。</p><p><strong>Puppeteer</strong></p><p>一个 Node 库，它提供了一个高级 API 来通过 DevTools 协议控制 Chrome。利用 Puppeteer 可以生成一个 Browser 对象，Browser 可以拥有多个页面对象。</p><p><strong>Lighthouse</strong></p><p>Lighthouse 是 Google 开源的自动化工具，用于改进网络应用的质量。它可以作为一个 Chrome 扩展程序运行，或从命令行运行。只需要为 Lighthouse 提供一个要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告，从中看看可以采取哪些措施来改进应用。</p><p><img src="/unknown404.github.io/img/performanceMonitor/lighthouse.png"></p><p>Lighthouse 由这几部分组成</p><p>Driver（驱动）—— 通过 Chrome Debugging Protocol 和 Chrome 进行交互。</p><p>Gatherer（采集器）—— 决定在页面加载过程中采集哪些信息，将采集的信息输出为 Artifact。可自定义。</p><p>Audit（审查器）—— 将 Gatherer 采集的 Artifact 作为输入，审查器会对其测试，然后得出相应的测评结果。可自定义。</p><p>Report（报告）—— 将审查的结果通过指定的方式报告出来。</p><p>合成监控的大致流程为：建立连接-&gt; 收集数据-&gt; 评估结果-&gt; 生成报告-&gt; 数据存储</p><h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><p>利用 Puppeteer 启动一个无头浏览器，打开一个空白页面。利用 Page 对象的 goto 方法打开目标 URL。然后将 Puppeteer 移交给 Lighthouse，实现方式就是确保 Puppeteer 和 lighthouse 启动时使用同一个端口号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> browser = <span class="hljs-keyword">await</span> puppeteer.<span class="hljs-title function_">launch</span>(); <span class="hljs-comment">//生成browser实例</span><br><span class="hljs-keyword">const</span> page = <span class="hljs-keyword">await</span> browser.<span class="hljs-title function_">newPage</span>(); <span class="hljs-comment">//解析一个新的页面。</span><br><span class="hljs-keyword">await</span> page.<span class="hljs-title function_">goto</span>(url); <span class="hljs-comment">//跳转到 目标url</span><br><span class="hljs-keyword">const</span> options = &#123;<br>  <span class="hljs-attr">logLevel</span>: <span class="hljs-string">&quot;info&quot;</span>,<br>  <span class="hljs-attr">output</span>: <span class="hljs-string">&quot;html&quot;</span>,<br>  <span class="hljs-attr">port</span>: <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(browser.<span class="hljs-title function_">wsEndpoint</span>()).<span class="hljs-property">port</span>,<br>&#125;;<br><span class="hljs-keyword">const</span> runnerResult = <span class="hljs-keyword">await</span> <span class="hljs-title function_">lighthouse</span>(url, options);<br></code></pre></td></tr></table></figure><p>移交之后 Lighthouse 通过 Chrome DevTools Protocol 定义的主动指令与事件通知，就实现了操控 Chrome 浏览器，和感知页面加载过程中的各个事件。</p><h4 id="收集数据"><a href="#收集数据" class="headerlink" title="收集数据"></a>收集数据</h4><p>lighthouse 默认会调用 css-usage、js-usage、viewport-dimensions 等采集器获取数据，同时我们也可以自己设置采集器。所有的采集器继承同一父类 Gatherer，其内部结构为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Gatherer</span> &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">keyof LH.GathererArtifacts</span>&#125;</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>() &#123;<br>    <span class="hljs-comment">// @ts-expect-error - assume that class name has been added to LH.GathererArtifacts.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">constructor</span>.<span class="hljs-property">name</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 在页面导航前触发</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">LH.Gatherer.PassContext</span>&#125; <span class="hljs-variable">passContext</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">LH.Gatherer.PhaseResult</span>&#125;</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">beforePass</span>(<span class="hljs-params">passContext</span>) &#123;&#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 在页面加载完后</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">LH.Gatherer.PassContext</span>&#125; <span class="hljs-variable">passContext</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">LH.Gatherer.PhaseResult</span>&#125;</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">pass</span>(<span class="hljs-params">passContext</span>) &#123;&#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 在页面加载完毕，且gatherer全部执行完成</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">LH.Gatherer.PassContext</span>&#125; <span class="hljs-variable">passContext</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">LH.Gatherer.LoadData</span>&#125; <span class="hljs-variable">loadData</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">LH.Gatherer.PhaseResult</span>&#125;</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">afterPass</span>(<span class="hljs-params">passContext, loadData</span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中只需要重点关注 3 个钩子方法：beforePass、pass、afterPass，Artifact 取最后一次 Hook 输出的结果，e.g.当 afterPass 未吐出，则采用 pass 结果，以此类推。</p><p>以收集器 viewport-dimensions 为例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewportDimensions</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Gatherer</span> &#123;<br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">afterPass</span>(<span class="hljs-params">passContext</span>) &#123;<br>    <span class="hljs-keyword">const</span> driver = passContext.<span class="hljs-property">driver</span>;<br>    <span class="hljs-keyword">const</span> dimensions = <span class="hljs-keyword">await</span> driver.<span class="hljs-property">executionContext</span>.evaluate(<br>      <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>          <span class="hljs-attr">innerWidth</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>,<br>          <span class="hljs-attr">innerHeight</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>,<br>          <span class="hljs-attr">outerWidth</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">outerWidth</span>,<br>          <span class="hljs-attr">outerHeight</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">outerHeight</span>,<br>          <span class="hljs-attr">devicePixelRatio</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span>,<br>        &#125;;<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">args</span>: [],<br>        <span class="hljs-attr">useIsolation</span>: <span class="hljs-literal">true</span>,<br>      &#125;<br>    );<br><br>    <span class="hljs-keyword">const</span> allNumeric = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(dimensions).<span class="hljs-title function_">every</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-property">isFinite</span>);<br>    <span class="hljs-keyword">if</span> (!allNumeric) &#123;<br>      <span class="hljs-keyword">const</span> results = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(dimensions);<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<br>        <span class="hljs-string">`ViewportDimensions results were not numeric: <span class="hljs-subst">$&#123;results&#125;</span>`</span><br>      );<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dimensions;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所有 gatherers 运行完后，就会生成一个中间产物 artifacts，此后 Lighthouse 就可以断开与浏览器的连接，只使用 artifacts 进行后续的分析。</p><h4 id="评估结果"><a href="#评估结果" class="headerlink" title="评估结果"></a>评估结果</h4><p>审查器将 gather 传来的 artifacts 作为输入进行分数评估操作。和采集器一样，lighthouse 提供标准的审查器，我们可以在继承标准审查器的基础上写自己的审查器，在自己的审查器里，我们通常会用到两个方法：一个是 meta，一个是 audit。meta 方法返回一个对象，该对象包含了该审查器的信息，特别注意的是 requiredArtifacts 字段和 id 字段，requiredArtifacts 字段的值对应着相对应的采集器，id 对应着 config 文件中对应的 audits 数组的内容。audit 方法返回一个对象，内容为这次审查的最终结果，包括 score、details 等字段。</p><p>以利用收集器 viewport-dimensions 数据的审查器 content-width 为例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ContentWidth</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Audit</span> &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">LH.Audit.Meta</span>&#125;</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">get</span> <span class="hljs-title function_">meta</span>() &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;content-width&quot;</span>,<br>      <span class="hljs-comment">// 审查通过时的标题</span><br>      <span class="hljs-attr">title</span>: <span class="hljs-title function_">str_</span>(<span class="hljs-title class_">UIStrings</span>.<span class="hljs-property">title</span>),<br>      <span class="hljs-comment">// 审查失败时的标题</span><br>      <span class="hljs-attr">failureTitle</span>: <span class="hljs-title function_">str_</span>(<span class="hljs-title class_">UIStrings</span>.<span class="hljs-property">failureTitle</span>),<br>      <span class="hljs-comment">//标题下关于该指标的描述</span><br>      <span class="hljs-attr">description</span>: <span class="hljs-title function_">str_</span>(<span class="hljs-title class_">UIStrings</span>.<span class="hljs-property">description</span>),<br>      <span class="hljs-attr">requiredArtifacts</span>: [<span class="hljs-string">&quot;ViewportDimensions&quot;</span>],<br>    &#125;;<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">LH.Artifacts</span>&#125; <span class="hljs-variable">artifacts</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">LH.Audit.Context</span>&#125; <span class="hljs-variable">context</span></span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">LH.Audit.Product</span>&#125;</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">audit</span>(<span class="hljs-params">artifacts, context</span>) &#123;<br>    <span class="hljs-keyword">const</span> viewportWidth = artifacts.<span class="hljs-property">ViewportDimensions</span>.<span class="hljs-property">innerWidth</span>;<br>    <span class="hljs-keyword">const</span> windowWidth = artifacts.<span class="hljs-property">ViewportDimensions</span>.<span class="hljs-property">outerWidth</span>;<br>    <span class="hljs-keyword">const</span> widthsMatch = viewportWidth === windowWidth;<br>    <span class="hljs-keyword">if</span> (context.<span class="hljs-property">settings</span>.<span class="hljs-property">formFactor</span> === <span class="hljs-string">&quot;desktop&quot;</span>) &#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">score</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">notApplicable</span>: <span class="hljs-literal">true</span>,<br>      &#125;;<br>    &#125;<br>    <span class="hljs-keyword">let</span> explanation;<br>    <span class="hljs-keyword">if</span> (!widthsMatch) &#123;<br>      explanation = <span class="hljs-title function_">str_</span>(<span class="hljs-title class_">UIStrings</span>.<span class="hljs-property">explanation</span>, &#123;<br>        <span class="hljs-attr">innerWidth</span>: artifacts.<span class="hljs-property">ViewportDimensions</span>.<span class="hljs-property">innerWidth</span>,<br>        <span class="hljs-attr">outerWidth</span>: artifacts.<span class="hljs-property">ViewportDimensions</span>.<span class="hljs-property">outerWidth</span>,<br>      &#125;);<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">score</span>: <span class="hljs-title class_">Number</span>(widthsMatch),<br>      explanation,<br>    &#125;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="生成报告"><a href="#生成报告" class="headerlink" title="生成报告"></a>生成报告</h4><p>审查器的分数结果并不是最终出现在报告的结果，报告是以测试类别 category 为统计结果，配置文件会定义每个测试类别所需的审计项及其分数所占的权重。以 performance 为例，其权重设置为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&#x27;performance&#x27;</span>: &#123;<br>    <span class="hljs-attr">title</span>: <span class="hljs-title function_">str_</span>(<span class="hljs-title class_">UIStrings</span>.<span class="hljs-property">performanceCategoryTitle</span>),<br>    <span class="hljs-attr">auditRefs</span>: [<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;first-contentful-paint&#x27;</span>, <span class="hljs-attr">weight</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">group</span>: <span class="hljs-string">&#x27;metrics&#x27;</span>&#125;,<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;interactive&#x27;</span>, <span class="hljs-attr">weight</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">group</span>: <span class="hljs-string">&#x27;metrics&#x27;</span>&#125;,<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;speed-index&#x27;</span>, <span class="hljs-attr">weight</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">group</span>: <span class="hljs-string">&#x27;metrics&#x27;</span>&#125;,<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;total-blocking-time&#x27;</span>, <span class="hljs-attr">weight</span>: <span class="hljs-number">30</span>, <span class="hljs-attr">group</span>: <span class="hljs-string">&#x27;metrics&#x27;</span>&#125;,<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;largest-contentful-paint&#x27;</span>, <span class="hljs-attr">weight</span>: <span class="hljs-number">25</span>, <span class="hljs-attr">group</span>: <span class="hljs-string">&#x27;metrics&#x27;</span>&#125;,<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;cumulative-layout-shift&#x27;</span>, <span class="hljs-attr">weight</span>: <span class="hljs-number">15</span>, <span class="hljs-attr">group</span>: <span class="hljs-string">&#x27;metrics&#x27;</span>&#125;,<br>    <span class="hljs-comment">// 省略</span><br>    ]<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>content-width 审查结果在报告中的展示：</p><p><img src="/unknown404.github.io/img/performanceMonitor/content_width.png"></p><h3 id="3-2-真实用户监控"><a href="#3-2-真实用户监控" class="headerlink" title="3.2 真实用户监控"></a>3.2 真实用户监控</h3><h4 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h4><p>数据的收集主要利用浏览器提供的 API，performance 提供了多种 API，不同的 API 之间可能会有重叠的部分。</p><h5 id="PerformanceTiming-数据收集"><a href="#PerformanceTiming-数据收集" class="headerlink" title="PerformanceTiming 数据收集"></a>PerformanceTiming 数据收集</h5><p>performance.getEntriesByType(“navigation”)：可返回从输入 url 到用户可以使用页面的全过程时间统计，单位均为毫秒。（该数据也可通过 new PerformanceObserver.observe(‘navigation’, entryHandler)获取）</p><p><img src="/unknown404.github.io/img/performanceMonitor/performancetiming.png"></p><p>TTFB：responseStart - requestStart</p><p>DCL：domContentLoadedEventEnd - fetchStart</p><p>L：loadEventStart - fetchStart</p><p>performance.getEntriesByType(‘paint’)：可返回 FP 和 FCP 两个时间点的值（该数据也可通过 new PerformanceObserver.observe(‘paint’, entryHandler)获取）</p><p><img src="/unknown404.github.io/img/performanceMonitor/example.png"></p><p><strong>PerformanceObserver API 相关的数据收集</strong></p><p><strong>LCP</strong></p><p>利用 PerformanceObserver API 可获取 LCP 相关的信息。由于页面转移到后台后，PerformanceObserver API 仍会继续分发 largest-contentful-paint 条目，所以这部分的数据不能做考虑。如果发生页面隐藏、输入事件(用户的交互行为可能会导致页面元素的可见性变化)则停止 PerformanceObserver 的性能监听，计算 LCP；由于最大内容可能随加载变化，所以选取最后一个作为本次页面加载的 lcp 的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getLCP</span> = (<span class="hljs-params">lcp</span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isPerformanceObserverSupported</span>()) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&quot;browser do not support performanceObserver&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> firstHiddenTime = <span class="hljs-title function_">getFirstHiddenTime</span>();<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">entryHandler</span> = (<span class="hljs-params">entry</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">startTime</span> &lt; firstHiddenTime.<span class="hljs-property">timeStamp</span>) &#123;<br>      lcp.<span class="hljs-property">value</span> = entry;<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">observe</span>(<span class="hljs-string">&quot;largest-contentful-paint&quot;</span>, entryHandler);<br>&#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">initLCP</span> = (<span class="hljs-params">store, report, immediately = <span class="hljs-literal">true</span></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> lcp = &#123; <span class="hljs-attr">value</span>: &#123;&#125;, <span class="hljs-attr">entries</span>: [] &#125;;<br>  <span class="hljs-keyword">const</span> po = <span class="hljs-title function_">getLCP</span>(lcp);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">stopListening</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (po) &#123;<br>      <span class="hljs-keyword">if</span> (po.<span class="hljs-property">takeRecords</span>) &#123;<br>        po.<span class="hljs-title function_">takeRecords</span>().<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">entry</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">const</span> firstHiddenTime = <span class="hljs-title function_">getFirstHiddenTime</span>();<br>          <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">startTime</span> &lt; firstHiddenTime.<span class="hljs-property">timeStamp</span>) &#123;<br>            lcp.<span class="hljs-property">value</span> = entry;<br>            lcp.<span class="hljs-property">entries</span>.<span class="hljs-title function_">push</span>(entry);<br>          &#125;<br>        &#125;);<br>      &#125;<br>      po.<span class="hljs-title function_">disconnect</span>();<br><br>      <span class="hljs-keyword">if</span> (!store.<span class="hljs-title function_">has</span>(metricsName.<span class="hljs-property">LCP</span>)) &#123;<br>        <span class="hljs-keyword">const</span> value = lcp.<span class="hljs-property">value</span>;<br>        <span class="hljs-keyword">const</span> metrics = &#123;<br>          <span class="hljs-attr">name</span>: metricsName.<span class="hljs-property">LCP</span>,<br>          <span class="hljs-attr">value</span>: <span class="hljs-title function_">roundByFour</span>(value.<span class="hljs-property">startTime</span>, <span class="hljs-number">2</span>),<br>          <span class="hljs-attr">entries</span>: value,<br>        &#125;;<br><br>        <span class="hljs-keyword">if</span> (immediately) &#123;<br>          <span class="hljs-title function_">report</span>(metrics);<br>        &#125;<br><br>        store.<span class="hljs-title function_">set</span>(metricsName.<span class="hljs-property">LCP</span>, metrics);<br>      &#125;<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-title function_">onHidden</span>(stopListening, <span class="hljs-literal">true</span>);<br>  [<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-string">&quot;keydown&quot;</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">addEventListener</span>(event, stopListening, &#123; <span class="hljs-attr">once</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">capture</span>: <span class="hljs-literal">true</span> &#125;);<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>FID</strong></p><p>和 LCP 的计算类似，需要忽视页面转移到后台后 PerformanceObserver API 继续分发的 first-input 条目。first-input 条目的延迟值是通过获取条目的 startTime 和 processingStart 时间戳之间的差值来测量的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getFID</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isPerformanceObserverSupported</span>()) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&quot;browser do not support performanceObserver&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> firstHiddenTime = <span class="hljs-title function_">getFirstHiddenTime</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">eventHandler</span> = (<span class="hljs-params">entry</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">startTime</span> &lt; firstHiddenTime.<span class="hljs-property">timeStamp</span>) &#123;<br>        <span class="hljs-keyword">if</span> (po) &#123;<br>          po.<span class="hljs-title function_">disconnect</span>();<br>        &#125;<br>        <span class="hljs-title function_">resolve</span>(entry);<br>      &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">const</span> po = <span class="hljs-title function_">observe</span>(<span class="hljs-string">&quot;first-input&quot;</span>, eventHandler);<br><br>    <span class="hljs-keyword">if</span> (po) &#123;<br>      <span class="hljs-title function_">onHidden</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (po?.<span class="hljs-property">takeRecords</span>) &#123;<br>          po.<span class="hljs-title function_">takeRecords</span>().<span class="hljs-title function_">map</span>(eventHandler);<br>        &#125;<br>        po.<span class="hljs-title function_">disconnect</span>();<br>      &#125;, <span class="hljs-literal">true</span>);<br>    &#125;<br>  &#125;);<br>&#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">initFID</span> = (<span class="hljs-params">store, report, immediately = <span class="hljs-literal">true</span></span>) =&gt; &#123;<br>  <span class="hljs-title function_">getFID</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">entry</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> metrics = &#123;<br>      <span class="hljs-attr">name</span>: metricsName.<span class="hljs-property">FID</span>,<br>      <span class="hljs-attr">value</span>: <span class="hljs-title function_">roundByFour</span>(entry.<span class="hljs-property">processingStart</span> - entry.<span class="hljs-property">startTime</span>, <span class="hljs-number">2</span>),<br>    &#125;;<br><br>    <span class="hljs-keyword">if</span> (immediately) &#123;<br>      <span class="hljs-title function_">report</span>(metrics);<br>    &#125;<br><br>    store.<span class="hljs-title function_">set</span>(metricsName.<span class="hljs-property">FID</span>, metrics);<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>CLS</strong></p><p>计算 CLS 时需注意布局偏移并不总是坏事，对用户交互（单击链接、点选按钮、在搜索框中键入信息等）进行响应的布局偏移是可以被使用者所接受的。PerformanceObserver 对用户输入 500 毫秒内发生的布局偏移会带有标志，方便在计算中排除这些偏移。</p><p>在 CLS 中，有一个叫 <strong>会话窗口</strong> 的术语：一个或多个快速连续发生的单次布局偏移，每次偏移相隔的时间少于 1 秒，且整个窗口的最大持续时长为 5 秒。计算会话窗口时取所有会话窗口中的最大值作为 CLS 的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getCLS</span> = (<span class="hljs-params">cls</span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isPerformanceObserverSupported</span>()) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&quot;browser do not support performanceObserver&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">entryHandler</span> = (<span class="hljs-params">entry</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (!entry.<span class="hljs-property">hadRecentInput</span>) &#123;<br>      cls.<span class="hljs-property">value</span> += entry.<span class="hljs-property">value</span>;<br>    &#125;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">observe</span>(<span class="hljs-string">&quot;layout-shift&quot;</span>, entryHandler);<br>&#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">initCLS</span> = (<span class="hljs-params">store, report, immediately = <span class="hljs-literal">true</span></span>) =&gt; &#123;<br>  <span class="hljs-keyword">let</span> sessionValue = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> sessionEntries = [];<br>  <span class="hljs-keyword">const</span> cls = &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">entries</span>: [] &#125;;<br><br>  <span class="hljs-keyword">const</span> po = <span class="hljs-title function_">getCLS</span>(cls);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">stopListening</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (po?.<span class="hljs-property">takeRecords</span>) &#123;<br>      po.<span class="hljs-title function_">takeRecords</span>().<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">entry</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (!entry.<span class="hljs-property">hadRecentInput</span>) &#123;<br>          <span class="hljs-keyword">const</span> firstSessionEntry = sessionEntries[<span class="hljs-number">0</span>];<br>          <span class="hljs-keyword">const</span> lastSessionEntry = sessionEntries[sessionEntries.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>          <span class="hljs-keyword">if</span> (<br>            sessionValue &amp;&amp;<br>            entry.<span class="hljs-property">startTime</span> - lastSessionEntry.<span class="hljs-property">startTime</span> &lt; <span class="hljs-number">1000</span> &amp;&amp;<br>            entry.<span class="hljs-property">startTime</span> - firstSessionEntry.<span class="hljs-property">startTime</span> &lt; <span class="hljs-number">5000</span><br>          ) &#123;<br>            sessionValue += entry.<span class="hljs-property">value</span>;<br>            sessionEntries.<span class="hljs-title function_">push</span>(entry);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            sessionValue = entry.<span class="hljs-property">value</span>;<br>            sessionEntries = [entry];<br>          &#125;<br>          <span class="hljs-keyword">if</span> (sessionValue &gt; metric.<span class="hljs-property">value</span>) &#123;<br>            cls.<span class="hljs-property">value</span> = sessionValue;<br>            cls.<span class="hljs-property">entries</span> = sessionEntries;<br>          &#125;<br>        &#125;<br>      &#125;);<br>    &#125;<br>    po?.<span class="hljs-title function_">disconnect</span>();<br><br>    <span class="hljs-keyword">const</span> metrics = &#123;<br>      <span class="hljs-attr">name</span>: metricsName.<span class="hljs-property">CLS</span>,<br>      <span class="hljs-attr">value</span>: <span class="hljs-title function_">roundByFour</span>(cls.<span class="hljs-property">value</span>),<br>      <span class="hljs-attr">entries</span>: cls.<span class="hljs-property">entries</span>,<br>    &#125;;<br><br>    <span class="hljs-keyword">if</span> (immediately) &#123;<br>      <span class="hljs-title function_">report</span>(metrics);<br>    &#125;<br><br>    store.<span class="hljs-title function_">set</span>(metricsName.<span class="hljs-property">CLS</span>, metrics);<br>  &#125;;<br><br>  <span class="hljs-title function_">onHidden</span>(stopListening, <span class="hljs-literal">true</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="数据上报"><a href="#数据上报" class="headerlink" title="数据上报"></a>数据上报</h4><p><strong>上报时机</strong>：可以选择拿到数据后立即上报，也可以等用户页面操作结束、关闭隐藏页面时上报</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">[beforeUnload, unload, onHidden].<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">fn</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> metrics = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getCurrentMetrics</span>();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(metrics).<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> &amp;&amp; !immediately) &#123;<br>      <span class="hljs-title function_">reporter</span>(metrics);<br>    &#125;<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>上报方式</strong></p><table><thead><tr><th align="center"></th><th align="center">img 请求</th><th align="center">fetch&#x2F;xhr</th><th align="center">navigator.sendBeacon()</th></tr></thead><tbody><tr><td align="center">优点</td><td align="center">兼容性</td><td align="center">兼容性</td><td align="center">不丢点不延迟加载</td></tr><tr><td align="center">缺点</td><td align="center">部分浏览器丢点；延时页面加载；get 长度限制</td><td align="center">fetch 丢点，同步 xhr 不丢点，延迟页面卸载</td><td align="center">兼容性</td></tr></tbody></table><p>丢点：页面卸载时正在上报的请求丢失</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://web.dev/vitals/">web vitals</a></li><li><a href="https://github.com/GoogleChrome/lighthouse">lighthouse</a></li><li><a href="https://juejin.cn/post/7017974567943536671">前端监控 SDK 的一些技术要点原理分析</a></li><li><a href="https://juejin.cn/post/6844903992380637198">Lighthouse 测试内幕</a></li></ol>]]></content>
    
    
    <summary type="html">2023技术分享的文档备份</summary>
    
    
    
    <category term="技术分享" scheme="https://unkonwn404.github.io/unknown404.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="前端监控" scheme="https://unkonwn404.github.io/unknown404.github.io/tags/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7/"/>
    
    <category term="分享记录" scheme="https://unkonwn404.github.io/unknown404.github.io/tags/%E5%88%86%E4%BA%AB%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>jsconfig的简要说明</title>
    <link href="https://unkonwn404.github.io/unknown404.github.io/2023/07/24/jsconfig/"/>
    <id>https://unkonwn404.github.io/unknown404.github.io/2023/07/24/jsconfig/</id>
    <published>2023-07-24T14:07:31.000Z</published>
    <updated>2023-10-07T02:19:32.845Z</updated>
    
    <content type="html"><![CDATA[<p>最近整理旧项目，遇到一些使用简化路径的引用模块，无法直接导向原文件，遂进行的简单研究。</p><span id="more"></span><h2 id="jsconfig-文件是什么"><a href="#jsconfig-文件是什么" class="headerlink" title="jsconfig 文件是什么"></a>jsconfig 文件是什么</h2><p>一个在 JavaScript 项目中的配置文件。它用于指定项目的 JavaScript 语言服务选项，让编辑器或 IDE（集成开发环境）了解项目的结构和语法，以便在编辑过程中提供更好的代码提示、补全和错误检查。</p><p>jsconfig.json 是 tsconfig.json 的子集。如果该项目为 ts 项目，应该使用 tsconfig.json</p><ul><li><strong>文件位置</strong>：JavaScript 项目的根目录下</li><li><strong>文件作用</strong>：</li></ul><ol><li>代码智能感知：通过 jsconfig.json，可以配置项目中的模块、库、路径，让编辑器能够正确地识别它们，提供智能感知和自动补全功能。</li><li>导入路径的简化：可以设置路径映射，让导入模块时的路径更加简洁。</li><li>错误检查：jsconfig.json 定义了项目的语法规范和特性，编辑器可以根据这些规则进行代码错误检查。</li><li>重构支持：可以支持一些重构功能，比如重命名变量、函数等。</li></ol><h2 id="jsconfig-文件的配置"><a href="#jsconfig-文件的配置" class="headerlink" title="jsconfig 文件的配置"></a>jsconfig 文件的配置</h2><p>一个用于智能感知的配置文件大致情况如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;es6&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;baseUrl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;.&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;paths&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;@/*&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;src/*&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;@com/*&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;./src/components/*&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;@api&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;./src/model/api.js&quot;</span><span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;src/**/*&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>compilerOptions: 编译选项，可以设置编译目标、模块解析、是否允许隐式的任意类型等。</li><li>baseUrl: 设置项目中的基本路径，这样在导入模块时，可以使用相对于基本路径的路径。</li><li>paths: 路径映射，用于简化导入模块时的路径，可以使用自定义的别名。</li><li>include: 设置需要包含的文件&#x2F;目录，通常是匹配模式，指定哪些文件应该被包含在项目中。</li><li>exclude: 设置需要排除的文件&#x2F;目录，通常是匹配模式，指定哪些文件不应该被包含在项目中。</li></ul><p>实际上 compilerOptions 包含的可配置属性众多，这里就不一一列举了。<br><strong>注意点</strong>：配好 jsconfig 文件后最好重新打开一下这个项目，否则可能不会立即生效。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://juejin.cn/post/7004748084374831117">你需要知道 jsconfig.json 都在这里啦</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近整理旧项目，遇到一些使用简化路径的引用模块，无法直接导向原文件，遂进行的简单研究。&lt;/p&gt;</summary>
    
    
    
    <category term="工作技巧" scheme="https://unkonwn404.github.io/unknown404.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="js" scheme="https://unkonwn404.github.io/unknown404.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>小程序踩坑经历--feed乱流</title>
    <link href="https://unkonwn404.github.io/unknown404.github.io/2023/06/30/feedFix/"/>
    <id>https://unkonwn404.github.io/unknown404.github.io/2023/06/30/feedFix/</id>
    <published>2023-06-30T03:49:48.000Z</published>
    <updated>2023-06-30T06:17:21.423Z</updated>
    
    <content type="html"><![CDATA[<p>记录维护项目时碰到的问题。</p><span id="more"></span><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>小程序的 feed 流内容带有关闭按钮，点击后该条目从 feed 流移除。但移除后后续条目的图片发生了错位。</p><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>根据 skype 给出的提示，主要有几个可能：</p><ol><li><p><a href="https://blog.csdn.net/u013633921/article/details/119922467">分页逻辑有问题，导致删除数据后，下一页的数据重复了上一页的数据</a>。可以尝试使用 last_id 来记录上一页最后一条数据的 id，然后根据这个 id 来获取下一页的数据，避免重复。</p></li><li><p><a href="https://blog.csdn.net/qq_41930094/article/details/106230395">删除操作没有正确更新页面的数据，导致页面显示的数据和数据库不一致</a>。可以使用 setData()方法来更新页面的数据，让页面重新渲染。</p></li><li><p><a href="https://blog.csdn.net/Bat_Reality/article/details/104721839">数组删除操作使用了 splice()方法，但是没有注意它会改变原始数组的长度和索引</a>。可以使用 filter()方法来删除数组中的元素，它不会改变原始数组，而是返回一个新的数组。</p></li></ol><p>虽然这些原因并不符合项目的实际情况，但也提供了思路：1）feed 数组在删除操作后的 js 更新逻辑可能有问题；2）渲染 feed 的模板结构可能有问题，导致删除的条目在模版上没对应</p><p>最后经过排查发现 feed 的模版代码中，key 值的设置不正确，导致模版在删除操作时再次渲染数据出错。至于为什么 key 值不对，则是项目的脚手架编译逻辑出现了问题，不在讨论范围。就是这样～</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录维护项目时碰到的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="踩坑经历" scheme="https://unkonwn404.github.io/unknown404.github.io/categories/%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="小程序" scheme="https://unkonwn404.github.io/unknown404.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>nodeJs网络框架简介</title>
    <link href="https://unkonwn404.github.io/unknown404.github.io/2023/05/04/BFF/"/>
    <id>https://unkonwn404.github.io/unknown404.github.io/2023/05/04/BFF/</id>
    <published>2023-05-04T03:44:16.000Z</published>
    <updated>2023-05-05T09:24:18.747Z</updated>
    
    <content type="html"><![CDATA[<p>想针对一直在使用的 nodeJs 框架做一个梳理归纳。</p><span id="more"></span><p>根据我的个人理解，目前常见的 nodeJS 框架可以分为基础框架和企业级框架。<br>所谓基础框架就是将 nodeJs 的 http 模块的方法进行了包装，提供了中间件、路由设置、模版渲染等方法。代表性的框架有 express、koa、fastify<br>而企业级框架则是在基础框架的基础上进一步架构，规定了代码组织复用的规则，集成了数据库、模板引擎的使用方案等，使后端的开发更加轻松，也更贴近业务需求。</p><h2 id="基础框架"><a href="#基础框架" class="headerlink" title="基础框架"></a>基础框架</h2><h3 id="express"><a href="#express" class="headerlink" title="express"></a>express</h3><p>express 是 2010 年提出的框架，目前与其他框架相比更加成熟和稳定，具有更广泛的社区支持和生态系统。<br>特点：</p><ul><li>请求处理对象：Node 的 req 和 res 对象</li><li>异步代码风格：依赖于回调函数和 Promise</li><li>中间件模式：通过调用 next 函数来链式传递</li><li>路由处理：express 框架已经集成，不需要额外引入插件</li></ul><h3 id="KOA"><a href="#KOA" class="headerlink" title="KOA"></a>KOA</h3><p>由 express 团队开发的，基于 ES6 新特性<br>特点：</p><ul><li>请求处理对象：Koa 框架自己封装的对象 ctx.request 和 ctx.response</li><li>异步代码风格：使用 async 和 await 语言的特性</li><li>中间件模式：洋葱模型，中间件可以直接返回 promise 对象</li><li>路由处理：需要中间件如 koa-route</li></ul><h3 id="fastify"><a href="#fastify" class="headerlink" title="fastify"></a>fastify</h3><p>号称是快速且低开销的 Web 框架。社区插件丰富，可扩展性强。内置 logger，可以用于代码分析调试。<br>特点：</p><ul><li>请求处理对象：Node 的 req 和 res 对象</li><li>异步代码风格：可使用 async 和 await 语言的特性，也可使用回调函数和 Promise 的书写方式</li><li>中间件模式：可以直接返回处理结果，也可以使用 next 回调函数来调用下一个中间件</li><li>路由处理：框架已经集成，不需要额外引入插件</li></ul><h2 id="企业级框架"><a href="#企业级框架" class="headerlink" title="企业级框架"></a>企业级框架</h2><h3 id="eggJs"><a href="#eggJs" class="headerlink" title="eggJs"></a>eggJs</h3><p>Egg.js 是一个基于 koa2 的开源框架。框架本身并没有集成如数据库、模板引擎、前端框架等功能，而是需要引入对应功能的插件（个人认为对于使用者来说这并不是一个非常好的选择，因为如果社区活跃度低，插件的丰富度和质量都会成为问题，最终只能自己花时间去开发）</p><h4 id="有明确的约定规范"><a href="#有明确的约定规范" class="headerlink" title="有明确的约定规范"></a>有明确的约定规范</h4><p>eggJs 的目录结构大致如下所示，这里相对说明文档做了简化</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stata">egg-project<br>├── package.json<br>├── <span class="hljs-keyword">app</span>.js (可选)<br>├── agent.js (可选)<br>├── <span class="hljs-keyword">app</span><br>|   ├── router.js<br>│   ├── controller<br>│   ├── service (可选)<br>│   ├── middleware (可选)<br>│   ├── schedule (可选)<br>│   ├── <span class="hljs-keyword">view</span> (可选)<br>│   └── extend (可选)<br>├── config<br>└── <span class="hljs-keyword">test</span><br></code></pre></td></tr></table></figure><p>目录文件的作用：</p><ul><li>app.js 和 agent.js 用于自定义启动时的初始化工作</li><li>app&#x2F;router.js 用于配置 URL 路由规则，将符合规则的路由请求发送给对应的目标控制器或模板</li><li>app&#x2F;controller&#x2F;** 用于解析用户请求传入的参数，处理后返回相应的结果</li><li>app&#x2F;service&#x2F;** 用于编写接口的业务逻辑，内容可以直接写在 controller 文件内部，但分离出来文件逻辑更清晰</li><li>app&#x2F;middleware&#x2F;** 用于编写中间件</li><li>app&#x2F;schedule&#x2F;** 用于定时任务</li><li>app&#x2F;view&#x2F;** 用于放置模板文件</li><li>app&#x2F;extend&#x2F;** 用于框架的扩展</li></ul><p>eggJs 约定了这些文件后，使用者只需要将实现的代码逻辑放在对应的文件夹下。在框架内部 egg-core 的 loader 会自动去读取对应文件夹下的文件，获取文件名、并将逻辑挂到指定的全局变量中。这里以 service 为例，在<a href="https://github.com/eggjs/egg-core/blob/2920f6eade07959d25f5c4f96b154d3fbae877db/lib/loader/mixin/service.js">egg-core 的代码中</a>读取了 app&#x2F;service 目录下的文件，将文件名称作为一个作为属性，挂载在 context 上下文上，然后将对应的 js 文件，暴露的方法赋值在这个属性上。例如 service 文件夹下有一个 alertRule 的 js 文件，内部有 getWarning 方法。在运行项目时 alertRule 就会挂在 ctx.service 下，在 controller 中就可以通过 ctx.service.alertRule.getWarning()调用 service 里的逻辑代码<br>更详细的内容可以参考<a href="https://juejin.cn/post/6844903716777099278">这篇文章</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-meta">&quot;use strict&quot;</span>;<br><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Load app/service</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@function</span> EggLoader#loadService</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Object</span>&#125; <span class="hljs-variable">opt</span> - LoaderOptions</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@since</span> 1.0.0</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">loadService</span>(<span class="hljs-params">opt</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">timing</span>.<span class="hljs-title function_">start</span>(<span class="hljs-string">&quot;Load Service&quot;</span>);<br>    <span class="hljs-comment">// 载入到 app.serviceClasses</span><br>    opt = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<br>      &#123;<br>        <span class="hljs-attr">call</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">caseStyle</span>: <span class="hljs-string">&quot;lower&quot;</span>,<br>        <span class="hljs-attr">fieldClass</span>: <span class="hljs-string">&quot;serviceClasses&quot;</span>,<br>        <span class="hljs-attr">directory</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getLoadUnits</span>().<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">unit</span>) =&gt;</span><br>          path.<span class="hljs-title function_">join</span>(unit.<span class="hljs-property">path</span>, <span class="hljs-string">&quot;app/service&quot;</span>)<br>        ),<br>      &#125;,<br>      opt<br>    );<br>    <span class="hljs-keyword">const</span> servicePaths = opt.<span class="hljs-property">directory</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">loadToContext</span>(servicePaths, <span class="hljs-string">&quot;service&quot;</span>, opt);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">timing</span>.<span class="hljs-title function_">end</span>(<span class="hljs-string">&quot;Load Service&quot;</span>);<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="插件机制"><a href="#插件机制" class="headerlink" title="插件机制"></a>插件机制</h4><p>模板引擎、数据库连接都需要下载对应的 plugin；插件的配置需要在 config 文件夹下进行声明</p><h4 id="多线程管理"><a href="#多线程管理" class="headerlink" title="多线程管理"></a>多线程管理</h4><p>eggJs 的进程模型如下</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">                +--------+          +-------+<br>                |<span class="hljs-string"> Master </span>|<span class="hljs-string">&lt;--------&gt;</span>|<span class="hljs-string"> Agent </span>|<br>                +--------+          +-------+<br>                ^   ^    ^<br>               /    |<span class="hljs-string">     \</span><br><span class="hljs-string">             /      </span>|<span class="hljs-string">       \</span><br><span class="hljs-string">           /        </span>|<span class="hljs-string">         \</span><br><span class="hljs-string">         v          v          v</span><br><span class="hljs-string">+----------+   +----------+   +----------+</span><br><span class="hljs-string"></span>|<span class="hljs-string"> Worker 1 </span>|<span class="hljs-string">   </span>|<span class="hljs-string"> Worker 2 </span>|<span class="hljs-string">   </span>|<span class="hljs-string"> Worker 3 </span>|<br>+----------+   +----------+   +----------+<br></code></pre></td></tr></table></figure><p>Master 作为主线程，启动 Agent 作为秘书进程协助 Worker 处理一些公共事务（日志之类），同时启动 Worker 进程执行真正的业务代码。</p><h3 id="nestJs"><a href="#nestJs" class="headerlink" title="nestJs"></a>nestJs</h3><p>nestJs 是基于 express 的开源框架，目录的结构据说和 Spring 有异曲同工之妙(但我没学过)。对 ts 的支持比较好。nestJs 的构建思路和 eggJs 几乎大相径庭。它具有以下特点</p><h4 id="去中心化路由"><a href="#去中心化路由" class="headerlink" title="去中心化路由"></a>去中心化路由</h4><p>nest 项目没有 router.js 文件，所有的路由通过装饰器与 Controller 绑定。</p><h4 id="依赖注入（DI-Dependency-Injection）思想"><a href="#依赖注入（DI-Dependency-Injection）思想" class="headerlink" title="依赖注入（DI, Dependency Injection）思想"></a>依赖注入（DI, Dependency Injection）思想</h4><p>依赖注入是控制反转（IOC，Inversion of Control）的一种应用形式。可以用于解决一个类依赖于另外一个类的情况。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> _pet<br><br>  constructor () &#123;<br>    <span class="hljs-built_in">this</span>._pet = <span class="hljs-keyword">new</span> <span class="hljs-type">Dog</span>()<br>  &#125;<br>&#125;<br><br>const xiaoming = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>()<br></code></pre></td></tr></table></figure><p>例如上面这段代码，存在着两个问题：</p><ul><li>Person 类固定依赖于 Dog 类，如果后续 Person 想要依赖于其他宠物类，是无法轻易修改的。</li><li>Dog 类有所变化，比如其属性颜色染成了黑色，Person 类也会直接受到影响。</li></ul><p>而如果将 Dog 的实例注入到 Person 类中，则 pet 属性不再强依赖 Dog 类。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-keyword">private</span> _pet<br><br>  constructor (pet) &#123;<br>    <span class="hljs-keyword">this</span>._pet = pet<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> doggy = <span class="hljs-keyword">new</span> Dog()<br><span class="hljs-keyword">const</span> xiaoming = <span class="hljs-keyword">new</span> Person(doggy) <span class="hljs-comment">// 将实例化的 dog 传入 person 类</span><br></code></pre></td></tr></table></figure><p>在 nestJs 框架中就承担了这样一个任务：一个容器来维护各个对象实例，当用户需要使用实例时，容器会自动将对象实例化给用户。<br>以初始化的 app 文件为例，在 app.controller.ts 中就是在构造器函数部分注入了 AppService 模块的实例 appService，controller 方法中就可以直接用 this.appService 访问 service 内部的方法，实例化的操作在框架内实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Controller</span>, <span class="hljs-title class_">Get</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/common&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">AppService</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./app.service&#x27;</span>;<br><br><span class="hljs-meta">@Controller</span>()<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppController</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> appService: AppService</span>) &#123;&#125;<br><br>  <span class="hljs-meta">@Get</span>()<br>  <span class="hljs-title function_">getHello</span>(): <span class="hljs-built_in">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">appService</span>.<span class="hljs-title function_">getHello</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="模块化思想"><a href="#模块化思想" class="headerlink" title="模块化思想"></a>模块化思想</h4><p>Nest.js 应用程序都是由一个或多个模块组成的。每个模块都是一个独立的、封闭的功能单元，负责处理某个具体的业务逻辑或功能。使用指令<code>nest g resource xxx</code>就会生成以 xxx 命名的文件夹，内部包括了 controller、service、module 的文件,同时在 app.module.ts 也进行了自动导入，模块加入 imports 中。具体文件结构如下所示</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">test<br>├── test<span class="hljs-selector-class">.controller</span><span class="hljs-selector-class">.ts</span><br>├── test<span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.ts</span><br>├── test<span class="hljs-selector-class">.controller</span><span class="hljs-selector-class">.spec</span><span class="hljs-selector-class">.ts</span><br>├── test<span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.spec</span><span class="hljs-selector-class">.ts</span><br>├── test<span class="hljs-selector-class">.module</span><span class="hljs-selector-class">.ts</span><br>└── dto<br>    ├── create-test<span class="hljs-selector-class">.dto</span><span class="hljs-selector-class">.ts</span><br>    └── update-test<span class="hljs-selector-class">.dto</span>.ts<br></code></pre></td></tr></table></figure><p>其中 test.controller.spec.ts 和 test.service.spec.ts 为测试文件。如果不想生成测试文件,可以在 nest-cli.json 中配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;generateOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>   <span class="hljs-attr">&quot;spec&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><br> <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>test.controller.ts 用于处理路由传来的数据<br>test.service.ts 用于写业务相关的逻辑<br>test.module.ts 相当于一个应用程序的根模块，可以看到它将 TestController 和 TestService 都通过@Module 进行了一个注入<br>@Module 主要包括以下属性：</p><ul><li>providers：由 Nest 注入器实例化的 provider，并且可以至少在整个模块中共享</li><li>controllers：在这个模块内定义的 controller</li><li>imports：可以注入 其他 module 或者 provider</li><li>exports：引入该模块时可以自动使用的 provider</li></ul><p>这里需要注明 provider 其实就是不仅仅是 Service 层，还包括：Sql 的 Dao 层、工具方法等提供</p><h4 id="面向切面编程（AOP，Aspect-Oriented-Programming）"><a href="#面向切面编程（AOP，Aspect-Oriented-Programming）" class="headerlink" title="面向切面编程（AOP，Aspect Oriented Programming）"></a>面向切面编程（AOP，Aspect Oriented Programming）</h4><p>当一个请求打过来时，一般会经过 Controller（控制器）、Service（服务）、Repository（数据库访问） 的链路。如果想在这个调用链路里加入日志记录、权限控制、异常处理等设置时，在调用 Controller 之前和之后加入一个执行通用逻辑的阶段，这个切面的逻辑编程就是 AOP。具体到 nest 中就是 Middleware、Guard、Pipe、Interceptor、ExceptionFilter 的实现<br>关于这些模块怎么使用，官方文档大致有写，这里只辨析一下 Middleware 和 Interceptor 区别</p><ul><li>Middleware：调用时机发生在路由处理前；书写方式和 express 的中间件相似，回调函数接收 req、res、next 参数</li><li>Interceptor：基于 AOP（面向切面编程）的概念实现的，它可以在请求处理管道的不同阶段中插入逻辑，例如在调用控制器方法之前或之后；Interceptor 内部实现了 intercept 函数，接收了 context 和 next 两个参数，context 是请求上下文，next 是调用链接的切面对象，执行 next.handle() 就会调用目标 Controller，不调用就不会执行</li></ul><h4 id="不特别依赖于平台"><a href="#不特别依赖于平台" class="headerlink" title="不特别依赖于平台"></a>不特别依赖于平台</h4><p>nest 虽然基于 express，但可以灵活的切换 http 框架和 socket 框架<br>它采用了适配器模式，express 或者别的平台比如 fastify 只要继承这个适配器的类，实现其中的抽象方法，就能接入到 Nest.js 里。在项目的 main.ts 中调整 NestFactory.create 的入参，增加 serverOrOptions 参数即可实现</p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>文末的碎碎念吧。其实个人感觉框架本身的使用并不是很难，一些日常开发照着开发文档抄基本上都能出来。但是对框架的架构去理解就感觉很难：规范内部的代码是怎么整合的？为什么要这么做？这些的理解就很难，如果不涉及深层的开发，读源码也觉得有点浪费时间，毕竟阅历及惯性思维等限制很难去快速理解开发者的思路，而如果没有做架构师、只是开发的话，这个时间的必要性感觉实在是。。。</p><p>现在记录下的内容说实话感觉还是很浅层次的内容，也许意义不是很大。但也许当我很久没开发 egg 项目再改写时，不会因为找不到 ctx 上的一些对象名感到疑惑（也许吧。。。）</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/7192528039945699386">浅谈 NestJS 设计思想（分层、IOC、AOP）</a><br>（2）<a href="https://juejin.cn/post/6844903716777099278">Egg.js 源码分析-项目启动</a><br>（3）<a href="https://juejin.cn/post/7070377945553977357">Nest.js 基于 Express 但也不是完全基于</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;想针对一直在使用的 nodeJs 框架做一个梳理归纳。&lt;/p&gt;</summary>
    
    
    
    <category term="前端基础" scheme="https://unkonwn404.github.io/unknown404.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="node.js" scheme="https://unkonwn404.github.io/unknown404.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>页面埋点基础概念</title>
    <link href="https://unkonwn404.github.io/unknown404.github.io/2023/04/25/eventTracking/"/>
    <id>https://unkonwn404.github.io/unknown404.github.io/2023/04/25/eventTracking/</id>
    <published>2023-04-25T14:34:53.000Z</published>
    <updated>2023-05-12T08:40:54.599Z</updated>
    
    <content type="html"><![CDATA[<p>所谓埋点可以理解为在应用中通过代码来采集上报一些信息，用于分析应用使用的状况，后续用来进一步优化产品或是提供运营的数据支撑。对于公司来说埋点的业务意义非常重要。</p><span id="more"></span><h2 id="常见的埋点方式"><a href="#常见的埋点方式" class="headerlink" title="常见的埋点方式"></a>常见的埋点方式</h2><p>埋点常用的技术方案有三种：代码侵入埋点、可视化埋点、无埋点。</p><h3 id="代码侵入埋点"><a href="#代码侵入埋点" class="headerlink" title="代码侵入埋点"></a>代码侵入埋点</h3><p>代码埋点就是在你需要统计数据的地方植入 N 行代码，统计用户的关键行为。</p><ul><li>优点：使用者控制精准，可以非常精确地选择什么时候发送数据；使用者可以比较方便地设置自定义属性、自定义事件，传递比较丰富的数据到服务端</li><li>缺点：每一个控件的埋点都需要添加相应的代码，工作量大，对业务代码的侵入性高；存在更新代价，每一次更新，都需要通过各个应用市场进行分发，而且有的用户还不一定更新，就会流失这部分客户的数据</li></ul><p>但综合来说代码埋点对于公司自研的角度是最容易实现的。</p><p>主流的埋点模型目前有两种：utm 埋点和 spm 埋点</p><h4 id="utm-埋点"><a href="#utm-埋点" class="headerlink" title="utm 埋点"></a>utm 埋点</h4><p>由 Google Analytics 提出，utm 是“Urchin Tracking Module”的简写，大意就是跟踪模块。主要的参数包括这些</p><table><thead><tr><th align="center">参数</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">utm_campaign</td><td align="center">推广活动名称</td></tr><tr><td align="center">utm_content</td><td align="center">推广活动内容</td></tr><tr><td align="center">utm_source</td><td align="center">推广活动来源，例如：baidu</td></tr><tr><td align="center">utm_medium</td><td align="center">推广活动媒介，例如：email</td></tr><tr><td align="center">utm_term</td><td align="center">推广活动关键词</td></tr></tbody></table><h4 id="spm-埋点"><a href="#spm-埋点" class="headerlink" title="spm 埋点"></a>spm 埋点</h4><p>由阿里提出，主要是用于追踪具体的站内位置。阿里的 SPM 位置编码由 A.B.C.D 四段构成, 各分段分别代表</p><ul><li>A:站点&#x2F;业务；</li><li>B:页面；</li><li>C:页面区块；</li><li>D:区块内点位。</li></ul><p>SPM 的基本功能个人认为包括这些：</p><p>跳转拼接：通过页面，区块，点位信息去拼接 spm 码，页面跳转时将 spm 添加到 url 的 query 参数。<br>埋点上报：通过解析 URL 提取参数，完善 pv 链的顺序，页面的 pv 上报时就能获取当前页面信息和上一个页面信息。</p><h3 id="可视化埋点"><a href="#可视化埋点" class="headerlink" title="可视化埋点"></a>可视化埋点</h3><p>可视化埋点的具体操作是：在可视化界面上打开项目地址，并圈选需要埋点的 DOM 元素，对选中的 DOM 元素添加自定义埋点事件；完成后可视化平台会根据保存的事件列表生成一个 JS 文件，需要将其埋入应用。<br>该方式的实现原理是：在进行事件设置的时候，“可视化埋点工具”会利用它部署在网站页面（或者 app）上的基础代码对网站（或 app）上所有的可交互事件元素进行解析，获取它们的 DOM path。</p><ul><li>优点：操作简单</li><li>缺点：上报的场景比较受限，跟事件操作强关联；埋点配置需要独立发布</li></ul><p>该方式实现的代表三方为 talkingData、Mixpanel</p><h3 id="无埋点"><a href="#无埋点" class="headerlink" title="无埋点"></a>无埋点</h3><p>无埋点也可以理解为全埋点，前端引入的 SDK 会自动劫持页面所有的事件、进行自主上报。</p><ul><li>优点：对业务代码的侵入量少，操作简单</li><li>缺点：会产生大量的上报请求，服务器的压力会比较大；如果没有合适的数据清洗规范，后台看到的数据就难以进行分析</li></ul><p>一般来说无埋点方案可能会直接使用现有的三方 SDK 如 GrowingIO、神策等。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/7151400818594283557">初识 SPM</a><br>（2）<a href="https://www.shangyexinzhi.com/article/4258360.html">流量追踪：如何通过URL进行数据采集？谷歌UTM参数及阿里SPM介绍</a><br>（3）<a href="http://www.imooc.com/article/27151">前端埋点的那些事</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;所谓埋点可以理解为在应用中通过代码来采集上报一些信息，用于分析应用使用的状况，后续用来进一步优化产品或是提供运营的数据支撑。对于公司来说埋点的业务意义非常重要。&lt;/p&gt;</summary>
    
    
    
    <category term="技术学习" scheme="https://unkonwn404.github.io/unknown404.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="JavaScript" scheme="https://unkonwn404.github.io/unknown404.github.io/tags/JavaScript/"/>
    
    <category term="埋点" scheme="https://unkonwn404.github.io/unknown404.github.io/tags/%E5%9F%8B%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>小程序踩坑经历--CDN域名替换</title>
    <link href="https://unkonwn404.github.io/unknown404.github.io/2023/04/15/appletCDN/"/>
    <id>https://unkonwn404.github.io/unknown404.github.io/2023/04/15/appletCDN/</id>
    <published>2023-04-15T03:42:17.000Z</published>
    <updated>2023-04-28T09:16:33.603Z</updated>
    
    <content type="html"><![CDATA[<p>记录项目迁移时碰到的问题。</p><span id="more"></span><h2 id="问题-1-关于-CDN-域名替换"><a href="#问题-1-关于-CDN-域名替换" class="headerlink" title="问题 1:关于 CDN 域名替换"></a>问题 1:关于 CDN 域名替换</h2><h3 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h3><p>替换了静态资源使用的域名后，是否需要在开发者平台上修改 request 合法域名或 downloadFile 合法域名？</p><h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p>需要根据代码情况来看：</p><ol><li>如果直接在 scss 文件引入 url 链接的情况，不需要进行配置。</li><li>使用 wx.downloadFile 相关 API 时需要配置 downloadFile 合法域名列表。需要注意的是使用 wx.getImageInfo 和 wx.loadFontFace 等 API 实际上也会向对应的域名发起请求，如果该域名不在小程序开发者平台的 downloadFile 合法域名列表中，就会出现跨域问题，从而导致请求失败。</li></ol><h2 id="问题-2-使用的特殊字体文件在-ios-和开发者工具上显示正常，安卓上无法显示"><a href="#问题-2-使用的特殊字体文件在-ios-和开发者工具上显示正常，安卓上无法显示" class="headerlink" title="问题 2:使用的特殊字体文件在 ios 和开发者工具上显示正常，安卓上无法显示"></a>问题 2:使用的特殊字体文件在 ios 和开发者工具上显示正常，安卓上无法显示</h2><h3 id="场景描述-1"><a href="#场景描述-1" class="headerlink" title="场景描述"></a>场景描述</h3><p>使用了如下代码来调用 icon 字体文件，域名链接可以正常访问，但会出现上述问题；且远程调试和真机调试平台都没有任何报错信息。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@font-face</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;icon2018&quot;</span>;<br>  <span class="hljs-attribute">src</span>: url(<span class="hljs-string">&quot;https://statics.xxx.com/iconfont.ttf?t=1539342297740&quot;</span>),<br>    <span class="hljs-comment">/* chrome, firefox, opera, Safari, Android, iOS 4.2+*/</span><br>      url(<span class="hljs-string">&quot;https://statics.xxx.com/iconfont.svg?t=1539342297740#icon2018&quot;</span>)<br>      format(<span class="hljs-string">&quot;svg&quot;</span>); <span class="hljs-comment">/* iOS 4.1- */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解决方式-1"><a href="#解决方式-1" class="headerlink" title="解决方式"></a>解决方式</h3><p>CDN 的 nginx 配置需要进行跨域处理</p><h2 id="问题-3-同路径页面跳转时，页面-data-没更新"><a href="#问题-3-同路径页面跳转时，页面-data-没更新" class="headerlink" title="问题 3:同路径页面跳转时，页面 data 没更新"></a>问题 3:同路径页面跳转时，页面 data 没更新</h2><h3 id="场景描述-2"><a href="#场景描述-2" class="headerlink" title="场景描述"></a>场景描述</h3><p>页面切换大概是这样一个过程 pageA -&gt; pageB?id&#x3D;1 -&gt; pageB?id&#x3D;2<br>当跳 pageB?id&#x3D;2 时，data 中的一个对象数据还保持为 pageB?id&#x3D;1 的数据</p><h3 id="解决方式-2"><a href="#解决方式-2" class="headerlink" title="解决方式"></a>解决方式</h3><p>目前无法分析具体原因，有可能是 mpvue 的框架问题，但这个问题不是稳定触发的，当跳转事件绑定的是@click.stop 的时候才发生。<br>当前保守的解决方式是在 onHide 或 onUnload 周期对 data 数据进行重置</p><h2 id="问题-4-小程序全局变量"><a href="#问题-4-小程序全局变量" class="headerlink" title="问题 4:小程序全局变量"></a>问题 4:小程序全局变量</h2><h3 id="场景描述-3"><a href="#场景描述-3" class="headerlink" title="场景描述"></a>场景描述</h3><p>不同小程序框架，全局变量设置的方式有细微的差别</p><h3 id="解决方式-3"><a href="#解决方式-3" class="headerlink" title="解决方式"></a>解决方式</h3><ol><li>uni-app、mpvue</li></ol><p>在 App.vue 中定义 globalData 的相关配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">globalData</span>: &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;text&#x27;</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>js 中操作 globalData 的方式如下： getApp().globalData.text &#x3D; ‘test’</p><p>在应用 onLaunch 时，getApp 对象还未获取，暂时可以使用 this.globalData 获取 globalData。</p><ol start="2"><li>taro</li></ol><p>虽然官方文档给出了<a href="https://docs.taro.zone/docs/come-from-miniapp#react">react 语法</a>的定义方法，然而设置的 taroGlobalData 只能维持初始化的值，而无法被改动。<br>想要解决这个问题，可以自己维护一个 globalData 对象，定义获取和修改该对象的方法。</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">const</span> globalData = &#123;&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setGlobalData</span> (<span class="hljs-params">key, val</span>) </span>&#123;<br>  globalData[key] = val<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getGlobalData</span> (<span class="hljs-params">key</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> globalData[key]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://leiem.cn/2022/01/21/46155/">小程序引用网络字体在安卓无效</a><br>（2）<a href="https://github.com/meituan-dianping/mpvue/issues/140">同一路由切换时，上一次的页面数据会保留</a><br>（3）<a href="https://www.cnblogs.com/juewuzhe/p/11097146.html">Taro – 定义全局变量</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录项目迁移时碰到的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="踩坑经历" scheme="https://unkonwn404.github.io/unknown404.github.io/categories/%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="小程序" scheme="https://unkonwn404.github.io/unknown404.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>docker基础知识</title>
    <link href="https://unkonwn404.github.io/unknown404.github.io/2023/03/24/docker/"/>
    <id>https://unkonwn404.github.io/unknown404.github.io/2023/03/24/docker/</id>
    <published>2023-03-24T09:36:32.000Z</published>
    <updated>2023-09-13T08:11:39.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么选择-docker-进行部署"><a href="#为什么选择-docker-进行部署" class="headerlink" title="为什么选择 docker 进行部署"></a>为什么选择 docker 进行部署</h2><p>个人理解有以下几点：</p><ol><li>docker 能提供一致性的运行环境。让程序在一致性的环境中运行：不管是开发环境、测试环境、还是生产环境；不管是开发时、构建时、还是运行时。</li><li>Kubernetes（又称 k8s）的容器集群管理系统因具有完备的集群管理能力（容器的高可用、负载均衡和故障恢复等）而广泛应用，为 docker 提供了自动化管理和编排的能力，让 docker 部署更容易被接受</li><li>标准化的服务程序封装技术-镜像，包含了程序以及程序对运行环境的依赖</li></ol><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>Client：客户端</li><li>Daemon：守护进程</li><li>Image：镜像，一个容器的模板，通过一个镜像可以创建多个容器</li><li>Container：容器，是镜像的运行实例</li><li>Repository：仓库，分为公开仓库（Public）和私有仓库（Private）两种形式。最大的公开仓库是 Docker Hub， 存放了数量庞大的镜像供用户下载。私有仓库是指用户在本地搭建的私有 Docker Registry。</li></ul><p>Client 通过命令行与 Daemon 交互。Daemon 通过 Image 镜像创建了一个容器去运行命令。</p><h2 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h2><p>Mac 电脑如果没有安装 homebrew，可以通过 <a href="https://www.docker.com/get-started/">Docker Desktop</a>下载 docker 后，双击安装即可。</p><p>安装完成后可以使用指令<code>docker -v</code>查看 docker 版本号，确认是否安装成功。</p><h2 id="docker-常见指令"><a href="#docker-常见指令" class="headerlink" title="docker 常见指令"></a>docker 常见指令</h2><h3 id="容器相关指令"><a href="#容器相关指令" class="headerlink" title="容器相关指令"></a>容器相关指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看运行中的容器</span><br><span class="hljs-comment"># 可以查看容器ID、基础镜像、容器名称、运行状态、端口映射等</span><br>docker ps<br><br><span class="hljs-comment"># 查看所有容器：包括停止的</span><br>docker ps -a<br><br><span class="hljs-comment"># 查看容器的信息</span><br><span class="hljs-comment"># 例如端口号的映射、目录挂载</span><br>docker inspect [images_name/images_id]<br><br><span class="hljs-comment"># 启动和停止容器</span><br>docker start/stop [container_name/container_id]<br><br><span class="hljs-comment">#  重启容器</span><br><span class="hljs-comment">#  使用场景实例：</span><br><span class="hljs-comment">#  在加入新的npm包依赖需要重新编译的时候使用重启运行编译</span><br><span class="hljs-comment">#  nginx容器的配置更新后需要重启生效</span><br>docker restart [container_name/container_id]<br><br><span class="hljs-comment"># 进入容器</span><br><span class="hljs-comment"># ps:有些容器没有bash,需要改成/bin/sh，例如mysql、mongodb的</span><br><span class="hljs-comment"># 退出容器输入exit 回车键</span><br>docker <span class="hljs-built_in">exec</span> -it [container_name/container_id] /bin/bash<br><br><span class="hljs-comment"># 删除容器</span><br><span class="hljs-comment"># 在容器停止的状态才能删</span><br>docker <span class="hljs-built_in">rm</span> [container_name/container_id]<br><br><span class="hljs-comment"># 容器主机文件拷</span><br><span class="hljs-comment"># 将容器文件拷贝到主机</span><br>docker <span class="hljs-built_in">cp</span> [container_id/container_name] : [文件目录] [主机目录]<br><br><span class="hljs-comment"># 将主机的目录拷贝到容器</span><br>docker <span class="hljs-built_in">cp</span> [主机目录] [container_id/container_name] : [文件目录]<br></code></pre></td></tr></table></figure><h3 id="镜像相关指令"><a href="#镜像相关指令" class="headerlink" title="镜像相关指令"></a>镜像相关指令</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 搜索镜像</span><br><span class="hljs-attribute">docker</span> search<span class="hljs-meta"> [images_name:tag]</span><br><br><span class="hljs-comment"># 下载镜像（：指定版本）</span><br><span class="hljs-attribute">docker</span> pull<span class="hljs-meta"> [images_name:tag]</span><br><br><span class="hljs-comment"># 查看本地下载的镜像</span><br><span class="hljs-attribute">docker</span> images<br><br><span class="hljs-comment"># 自己构建镜像</span><br><span class="hljs-comment"># 根据dockerfile的路径或者url构建镜像</span><br><span class="hljs-attribute">docker</span> build<span class="hljs-meta"> [OPTIONS] PATH|URL|-</span><br><span class="hljs-meta"></span><br><span class="hljs-meta"># 查看镜像的构建历史</span><br><span class="hljs-meta">docker history [images_name]</span><br><br><span class="hljs-comment"># 删除镜像</span><br><span class="hljs-comment"># 需要先删除以此镜像为基础的容器</span><br><span class="hljs-attribute">docker</span> rmi<span class="hljs-meta"> [images_name]</span><br><br><span class="hljs-comment"># 运行镜像</span><br><span class="hljs-comment">##</span><br><span class="hljs-attribute">docker</span> run<span class="hljs-meta"> [OPTIONS] [images_name] [COMMAND] [ARG...]</span><br></code></pre></td></tr></table></figure><h3 id="镜像迁移相关"><a href="#镜像迁移相关" class="headerlink" title="镜像迁移相关"></a>镜像迁移相关</h3><h4 id="docker-save-docker-load"><a href="#docker-save-docker-load" class="headerlink" title="docker save + docker load"></a>docker save + docker load</h4><p>docker save 命令用于将 Docker 镜像导出为一个 tar 归档文件，该文件包含了镜像的全部文件系统层，包括 Dockerfile 中定义的命令、环境变量等。导出的镜像可以使用 docker load 命令重新导入到 Docker 中，或者将其传输到其他 Docker 安装实例中。由于 docker save 导出的文件包含了完整的镜像层，因此可以用来备份或迁移整个镜像。</p><h4 id="docker-export-docker-import"><a href="#docker-export-docker-import" class="headerlink" title="docker export + docker import"></a>docker export + docker import</h4><p>docker export 命令用于将 Docker 容器的文件系统导出为一个 tar 归档文件，该文件不包含容器的元数据（比如容器的标签、端口号、环境变量等），仅包含容器中运行的应用程序和文件。导出的容器文件系统可以使用 docker import 命令导入为一个新的 Docker 镜像，或者在需要时手动将其中的文件复制到本地系统中。由于 docker export 不包含镜像的元数据，因此它通常用于容器的临时备份和文件传输。</p><p>总之，docker save 适用于备份、迁移整个 Docker 镜像，docker export 适用于容器的临时备份和文件传输。</p><h2 id="docker-镜像运行实践：Jenkins-安装"><a href="#docker-镜像运行实践：Jenkins-安装" class="headerlink" title="docker 镜像运行实践：Jenkins 安装"></a>docker 镜像运行实践：Jenkins 安装</h2><h3 id="Jenkins-简介"><a href="#Jenkins-简介" class="headerlink" title="Jenkins 简介"></a>Jenkins 简介</h3><p>Jenkins 是一款业界流行的开源持续集成工具，广泛用于项目开发，具有自动化构建、测试和部署等功能。前端自动化部署的重要工具。</p><h3 id="Jenkins-镜像获取"><a href="#Jenkins-镜像获取" class="headerlink" title="Jenkins 镜像获取"></a>Jenkins 镜像获取</h3><p>dockerHub 网站已经提供了对应的镜像<a href="https://hub.docker.com/r/jenkins/jenkins">jenkins</a>。个人理解 dockerHub 网站类似依赖包的一个集合网站 npmjs，而镜像则类似于依赖包。开发者可以从 dockerHub 下载需要的镜像，也可以把自己生成的镜像打包上传到网站。在运行类似 docker run 等指令时如果镜像不存在当前 docker 内就会去网站拉取同名镜像。<br>执行指令<code>docker pull jenkins/jenkins:lts-jdk11</code>就可以下载 Jenkins 的稳定镜像版本。</p><h3 id="Jenkins-容器创建"><a href="#Jenkins-容器创建" class="headerlink" title="Jenkins 容器创建"></a>Jenkins 容器创建</h3><p>执行如下指令，在 docker volume 会自动产生一个叫 jenkins_home 的空间，无论 docker 的容器是运行还是停止或删除 jenkins_home 都会存在；同时指令还做了端口的映射：将宿主机 8080 端口映射到容器 8080 端口，50000 端口是基于 JNLP 的 Jenkins 代理（slave）通过 TCP 与 Jenkins master 进行通信的端口。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -p <span class="hljs-number">8080</span>:<span class="hljs-number">8080</span> -p <span class="hljs-number">50000</span>:<span class="hljs-number">50000</span> --restart=<span class="hljs-literal">on</span>-failure -v jenkins_home:/var/jenkins_home jenkins/jenkins:lts-jdk11<br></code></pre></td></tr></table></figure><p>执行完后可以用指令 docker ps 查看容器运行情况。运行完成就可以在本地打开网址 <a href="http://localhost:8080/">http://localhost:8080</a> 即可访问。<br>正常运行时应该可以看到一个登录界面，需要输入管理员密码才可正常进入，该密码在命令行中可以看到。但有时可能会遇到”Please wait while Jenkins is getting ready to work”，需要重启 container 才能完成，原因不明。</p><h2 id="前端部署说明"><a href="#前端部署说明" class="headerlink" title="前端部署说明"></a>前端部署说明</h2><p>目前来说，前端部署的流程可以认为是将静态文件 html、css 和 js 上传到服务器的目录下，用户通过域名+路径进行访问；如果配置了 nginx，则增加了静态文件放在 nginx 文件夹下（例如&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;）、Nginx 启动做简单配置的操作。因为 docker 隔离性、安全性的特点，所以整个部署资源一般放在 docker 内。<br>实现步骤大致如下：</p><ol><li>连接服务器<br>使用指令 <code>ssh root@[IP]</code>来连接远程服务器，通常需要输入用户名和密码</li><li>安装 docker、拉取 nginx 的 docker 镜像</li><li>增加配置文件</li></ol><ul><li>1）增加 Dockerfile：在前端项目的根目录下创建 Dockerfile，添加如下内容</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">FROM nginx  <span class="hljs-regexp">//</span>该镜像是基于 nginx:latest 镜像而构建的<br>COPY dist<span class="hljs-regexp">/ /u</span>sr<span class="hljs-regexp">/share/</span>nginx<span class="hljs-regexp">/html/</span>  <span class="hljs-regexp">//</span>将项目根目录下 dist 文件夹下的所有文件复制到镜像中 <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html/ 目录下<br>COPY default.conf <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/conf.d/</span>default.conf  <span class="hljs-regexp">//</span>将 项目根目录下 default.conf 复制到 etc<span class="hljs-regexp">/nginx/</span>conf.d/default.conf，用本地的 default.conf 配置来替换 Nginx 镜像里的默认配置<br></code></pre></td></tr></table></figure><p><strong>备注：Dockerfile 常用指令</strong></p><ul><li><p>FROM：指定基础镜像，后续的指令将在该镜像上执行。</p></li><li><p>RUN：在镜像上执行 Linux 命令，并形成一个新的层。</p></li><li><p>CMD：指定启动镜像容器时的默认行为，一个 Dockerfile 中只能有一个 CMD 指令。</p></li><li><p>ENTRYPOINT：指定容器启动后执行的命令，可以覆盖 CMD 指令中的命令。</p></li><li><p>ENV：设置环境变量。</p></li><li><p>COPY：将文件系统中的文件复制到镜像中。</p></li><li><p>WORKDIR：设置工作目录。</p></li><li><p>EXPOSE：设置向外暴露的端口。</p></li><li><p>VOLUME：设置容器与外界映射的目录。</p></li><li><p>2）增加 nginx 的配置替换文件 default.conf。示例如下</p></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk">server &#123;<br>    listen       <span class="hljs-number">80</span>;<br>    server_name  localhost; <span class="hljs-comment"># 此处可修改为docker服务宿主机的ip/域名</span><br><br>    <span class="hljs-comment">#charset koi8-r;</span><br>    access_log  <span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/nginx/</span>host.access.log  main;<br>    error_log  <span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/nginx/</span>error.log  error;<br><br>    location / &#123;<br>        root   <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html;<br>        index  index.html index.htm;<br>    &#125;<br><br>    error_page   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /<span class="hljs-number">50</span>x.html;<br>    location = /<span class="hljs-number">50</span>x.html &#123;<br>        root   <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>使用指令<code>docker build -t vue-init .</code>构建镜像</li><li>使用指令<code>docker run -d -p 8136:80 --name vue-init-container vue-init</code>创建容器、运行。此时打开浏览器输入 服务器 ip&#x2F;域名 端口号:8136，就能看到前端页面了</li></ol><h3 id="部署优化说明"><a href="#部署优化说明" class="headerlink" title="部署优化说明"></a>部署优化说明</h3><p>以上只是部署的一个大致流程，实际公司项目的部署应该会考虑很多优化点，例如：</p><ul><li>为了提升页面首屏性能，对 html 走协商缓存，css、js 走强缓存；同时采用 name-hash 的打包方式防止上线过程中资源请求错乱</li><li>为了减轻服务器压力，不选择将文件存储在 Nginx Web 服务器内某目录下，而是将静态资源部署到 CDN 上，再将 Nginx 上的流量转发到 CDN 上</li><li>。。。等等</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/7209900557712212026">Win10 安装 Docker 以及 Jenkins(超级详细篇)</a><br>（2）<a href="https://juejin.cn/post/7187326853336530981">Docker 安装 Jenkins，Nginx，实现前端项目自动化构建</a><br>（3）<a href="https://github.com/jenkinsci/docker/blob/master/README.md#connecting-agents">Docker Image Jenkins</a><br>（4）<a href="https://juejin.cn/post/6992848354753380389?searchId=202309061616378C8D0FA3A38070899341">【前端 Docker 部署实战】Docker 镜像+Nginx 配置部署 Vue 项目</a><br>（5）<a href="https://juejin.cn/post/7017710911443959839">2021 年当我们聊前端部署时，我们在聊什么</a><br>（6）<a href="https://juejin.cn/post/7269668219488354361">使用 Docker 实现前端应用的标准化构建、部署和运行</a></p>]]></content>
    
    
    <summary type="html">docker知识笔记</summary>
    
    
    
    <category term="前端扩展" scheme="https://unkonwn404.github.io/unknown404.github.io/categories/%E5%89%8D%E7%AB%AF%E6%89%A9%E5%B1%95/"/>
    
    
    <category term="docker" scheme="https://unkonwn404.github.io/unknown404.github.io/tags/docker/"/>
    
  </entry>
  
</feed>
