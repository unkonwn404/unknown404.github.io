<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小白的文件整理箱</title>
  
  
  <link href="https://unkonwn404.github.io/unkown404.github.io/atom.xml" rel="self"/>
  
  <link href="https://unkonwn404.github.io/unkown404.github.io/"/>
  <updated>2023-04-15T03:42:17.986Z</updated>
  <id>https://unkonwn404.github.io/unkown404.github.io/</id>
  
  <author>
    <name>小白的文件整理箱</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>appletCDN</title>
    <link href="https://unkonwn404.github.io/unkown404.github.io/2023/04/15/appletCDN/"/>
    <id>https://unkonwn404.github.io/unkown404.github.io/2023/04/15/appletCDN/</id>
    <published>2023-04-15T03:42:17.000Z</published>
    <updated>2023-04-15T03:42:17.986Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>docker基础知识</title>
    <link href="https://unkonwn404.github.io/unkown404.github.io/2023/03/24/docker/"/>
    <id>https://unkonwn404.github.io/unkown404.github.io/2023/03/24/docker/</id>
    <published>2023-03-24T09:36:32.000Z</published>
    <updated>2023-04-15T03:41:47.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>Client：客户端</li><li>Daemon：守护进程</li><li>Image：镜像，一个容器的模板，通过一个镜像可以创建多个容器</li><li>Container：容器，是镜像的运行实例</li><li>Repository：仓库，分为公开仓库（Public）和私有仓库（Private）两种形式。最大的公开仓库是 Docker Hub， 存放了数量庞大的镜像供用户下载。私有仓库是指用户在本地搭建的私有 Docker Registry。</li></ul><p>Client 通过命令行与 Daemon 交互。Daemon 通过 Image 镜像创建了一个容器去运行命令。</p><h2 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h2><p>Mac 电脑如果没有安装 homebrew，可以通过 <a href="https://www.docker.com/get-started/">Docker Desktop</a>下载 docker 后，双击安装即可。</p><p>安装完成后可以使用指令<code>docker -v</code>查看 docker 版本号，确认是否安装成功。</p><h2 id="docker-常见指令"><a href="#docker-常见指令" class="headerlink" title="docker 常见指令"></a>docker 常见指令</h2><h3 id="容器相关指令"><a href="#容器相关指令" class="headerlink" title="容器相关指令"></a>容器相关指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看运行中的容器</span><br><span class="hljs-comment"># 可以查看容器ID、基础镜像、容器名称、运行状态、端口映射等</span><br>docker ps<br><br><span class="hljs-comment"># 查看所有容器：包括停止的</span><br>docker ps -a<br><br><span class="hljs-comment"># 查看容器的信息</span><br><span class="hljs-comment"># 例如端口号的映射、目录挂载</span><br>docker inspect [images_name/images_id]<br><br><span class="hljs-comment"># 启动和停止容器</span><br>docker start/stop [container_name/container_id]<br><br><span class="hljs-comment">#  重启容器</span><br><span class="hljs-comment">#  使用场景实例：</span><br><span class="hljs-comment">#  在加入新的npm包依赖需要重新编译的时候使用重启运行编译</span><br><span class="hljs-comment">#  nginx容器的配置更新后需要重启生效</span><br>docker restart [container_name/container_id]<br><br><span class="hljs-comment"># 进入容器</span><br><span class="hljs-comment"># ps:有些容器没有bash,需要改成/bin/sh，例如mysql、mongodb的</span><br><span class="hljs-comment"># 退出容器输入exit 回车键</span><br>docker <span class="hljs-built_in">exec</span> -it [container_name/container_id] /bin/bash<br><br><span class="hljs-comment"># 删除容器</span><br><span class="hljs-comment"># 在容器停止的状态才能删</span><br>docker <span class="hljs-built_in">rm</span> [container_name/container_id]<br><br><span class="hljs-comment"># 容器主机文件拷</span><br><span class="hljs-comment"># 将容器文件拷贝到主机</span><br>docker <span class="hljs-built_in">cp</span> [container_id/container_name] : [文件目录] [主机目录]<br><br><span class="hljs-comment"># 将主机的目录拷贝到容器</span><br>docker <span class="hljs-built_in">cp</span> [主机目录] [container_id/container_name] : [文件目录]<br></code></pre></td></tr></table></figure><h3 id="镜像相关指令"><a href="#镜像相关指令" class="headerlink" title="镜像相关指令"></a>镜像相关指令</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 搜索镜像</span><br><span class="hljs-attribute">docker</span> search<span class="hljs-meta"> [images_name:tag]</span><br><br><span class="hljs-comment"># 下载镜像（：指定版本）</span><br><span class="hljs-attribute">docker</span> pull<span class="hljs-meta"> [images_name:tag]</span><br><br><span class="hljs-comment"># 查看本地下载的镜像</span><br><span class="hljs-attribute">docker</span> images<br><br><span class="hljs-comment"># 自己构建镜像</span><br><span class="hljs-comment"># 根据dockerfile的路径或者url构建镜像</span><br><span class="hljs-attribute">docker</span> build<span class="hljs-meta"> [OPTIONS] PATH|URL|-</span><br><span class="hljs-meta"></span><br><span class="hljs-meta"># 查看镜像的构建历史</span><br><span class="hljs-meta">docker history [images_name]</span><br><br><span class="hljs-comment"># 删除镜像</span><br><span class="hljs-comment"># 需要先删除以此镜像为基础的容器</span><br><span class="hljs-attribute">docker</span> rmi<span class="hljs-meta"> [images_name]</span><br><br><span class="hljs-comment"># 运行镜像</span><br><span class="hljs-comment">## </span><br><span class="hljs-attribute">docker</span> run<span class="hljs-meta"> [OPTIONS] [images_name] [COMMAND] [ARG...]</span><br></code></pre></td></tr></table></figure><h3 id="镜像迁移相关"><a href="#镜像迁移相关" class="headerlink" title="镜像迁移相关"></a>镜像迁移相关</h3><h4 id="docker-save-docker-load"><a href="#docker-save-docker-load" class="headerlink" title="docker save + docker load"></a>docker save + docker load</h4><p>docker save 命令用于将 Docker 镜像导出为一个 tar 归档文件，该文件包含了镜像的全部文件系统层，包括 Dockerfile 中定义的命令、环境变量等。导出的镜像可以使用 docker load 命令重新导入到 Docker 中，或者将其传输到其他 Docker 安装实例中。由于 docker save 导出的文件包含了完整的镜像层，因此可以用来备份或迁移整个镜像。</p><h4 id="docker-export-docker-import"><a href="#docker-export-docker-import" class="headerlink" title="docker export + docker import"></a>docker export + docker import</h4><p>docker export 命令用于将 Docker 容器的文件系统导出为一个 tar 归档文件，该文件不包含容器的元数据（比如容器的标签、端口号、环境变量等），仅包含容器中运行的应用程序和文件。导出的容器文件系统可以使用 docker import 命令导入为一个新的 Docker 镜像，或者在需要时手动将其中的文件复制到本地系统中。由于 docker export 不包含镜像的元数据，因此它通常用于容器的临时备份和文件传输。</p><p>总之，docker save 适用于备份、迁移整个 Docker 镜像，docker export 适用于容器的临时备份和文件传输。</p><h2 id="docker-镜像运行实践：Jenkins-安装"><a href="#docker-镜像运行实践：Jenkins-安装" class="headerlink" title="docker 镜像运行实践：Jenkins 安装"></a>docker 镜像运行实践：Jenkins 安装</h2><h3 id="Jenkins-简介"><a href="#Jenkins-简介" class="headerlink" title="Jenkins 简介"></a>Jenkins 简介</h3><p>Jenkins 是一款业界流行的开源持续集成工具，广泛用于项目开发，具有自动化构建、测试和部署等功能。前端自动化部署的重要工具。</p><h3 id="Jenkins-镜像获取"><a href="#Jenkins-镜像获取" class="headerlink" title="Jenkins 镜像获取"></a>Jenkins 镜像获取</h3><p>dockerHub 网站已经提供了对应的镜像<a href="https://hub.docker.com/r/jenkins/jenkins">jenkins</a>。个人理解 dockerHub 网站类似依赖包的一个集合网站 npmjs，而镜像则类似于依赖包。开发者可以从 dockerHub 下载需要的镜像，也可以把自己生成的镜像打包上传到网站。在运行类似 docker run 等指令时如果镜像不存在当前 docker 内就会去网站拉取同名镜像。<br>执行指令<code>docker pull jenkins/jenkins:lts-jdk11</code>就可以下载 Jenkins 的稳定镜像版本。</p><h3 id="Jenkins-容器创建"><a href="#Jenkins-容器创建" class="headerlink" title="Jenkins 容器创建"></a>Jenkins 容器创建</h3><p>执行如下指令，在 docker volume 会自动产生一个叫 jenkins_home 的空间，无论 docker 的容器是运行还是停止或删除 jenkins_home 都会存在；同时指令还做了端口的映射：将宿主机 8080 端口映射到容器 8080 端口，50000 端口是基于 JNLP 的 Jenkins 代理（slave）通过 TCP 与 Jenkins master 进行通信的端口。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -p <span class="hljs-number">8080</span>:<span class="hljs-number">8080</span> -p <span class="hljs-number">50000</span>:<span class="hljs-number">50000</span> --restart=<span class="hljs-literal">on</span>-failure -v jenkins_home:/var/jenkins_home jenkins/jenkins:lts-jdk11<br></code></pre></td></tr></table></figure><p>执行完后可以用指令 docker ps 查看容器运行情况。运行完成就可以在本地打开网址 <a href="http://localhost:8080/">http://localhost:8080</a> 即可访问。<br>正常运行时应该可以看到一个登录界面，需要输入管理员密码才可正常进入，该密码在命令行中可以看到。但有时可能会遇到”Please wait while Jenkins is getting ready to work”，需要重启 container 才能完成，原因不明。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/7209900557712212026">Win10 安装 Docker 以及 Jenkins(超级详细篇)</a><br>（2）<a href="https://juejin.cn/post/7187326853336530981">Docker 安装 Jenkins，Nginx，实现前端项目自动化构建</a><br>（3）<a href="https://github.com/jenkinsci/docker/blob/master/README.md#connecting-agents">Docker Image Jenkins</a></p>]]></content>
    
    
    <summary type="html">docker知识笔记</summary>
    
    
    
    <category term="前端扩展" scheme="https://unkonwn404.github.io/unkown404.github.io/categories/%E5%89%8D%E7%AB%AF%E6%89%A9%E5%B1%95/"/>
    
    
    <category term="docker" scheme="https://unkonwn404.github.io/unkown404.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>飞书机器人验证实现</title>
    <link href="https://unkonwn404.github.io/unkown404.github.io/2023/03/15/feishuEncode/"/>
    <id>https://unkonwn404.github.io/unkown404.github.io/2023/03/15/feishuEncode/</id>
    <published>2023-03-15T09:46:58.000Z</published>
    <updated>2023-03-15T10:27:34.921Z</updated>
    
    <content type="html"><![CDATA[<p>因工作需要设计了一个调用飞书机器人的接口，主要的实现点在于 webHook 的验证通过。</p><span id="more"></span><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入加密模块crypto</span><br><span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto&#x27;</span>)<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sendMsg</span>(<span class="hljs-params">&#123;url,secret&#125;</span>)&#123;<br>    <span class="hljs-keyword">const</span> &#123;ctx&#125; = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">let</span> dataBody=&#123;<br>        <span class="hljs-attr">msg_type</span>: <span class="hljs-string">&quot;text&quot;</span>,<br>        <span class="hljs-attr">content</span>: &#123;<br>            <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;test&#x27;</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 加密。时间戳单位是s</span><br>    <span class="hljs-keyword">const</span> timestamp = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>() / <span class="hljs-number">1000</span> + <span class="hljs-string">&#x27;&#x27;</span>) + <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-comment">// 存储到buffer时说明数据类型</span><br>    <span class="hljs-keyword">const</span> stringify = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;timestamp&#125;</span>\n<span class="hljs-subst">$&#123;secret&#125;</span>`</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>);<br>    <span class="hljs-comment">// sha256加密</span><br>    <span class="hljs-keyword">const</span> shasign = crypto.<span class="hljs-title function_">createHmac</span>(<span class="hljs-string">&#x27;SHA256&#x27;</span>, stringify);<br>    <span class="hljs-comment">// 只有调用update后才能通过调用 digest() 方法来生成加密结果，update内部传入的参数是一个长度为 0 的空缓冲区，表示此时没有要加密的数据</span><br>    shasign.<span class="hljs-title function_">update</span>(<span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">0</span>));<br>    <span class="hljs-comment">// base64加密</span><br>    <span class="hljs-keyword">const</span> sign = shasign.<span class="hljs-title function_">digest</span>(<span class="hljs-string">&#x27;base64&#x27;</span>)<br>    dataBody = &#123;<br>            timestamp,<br>            sign,<br>            ...dataBody<br>        &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> &#123;<br>            res<br>        &#125; = <span class="hljs-keyword">await</span> ctx.<span class="hljs-title function_">curl</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>`</span>, &#123;<br><br>            <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>            <span class="hljs-attr">rejectUnauthorized</span>: <span class="hljs-literal">false</span>,<br>            <span class="hljs-attr">headers</span>: &#123;<br>                <span class="hljs-string">&quot;content-type&quot;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>            &#125;,<br>            <span class="hljs-attr">data</span>: dataBody,<br>            <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span><br>        &#125;)<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">code</span>: res.<span class="hljs-property">data</span>.<span class="hljs-property">code</span>,<br>            <span class="hljs-attr">message</span>: res.<span class="hljs-property">data</span>.<span class="hljs-property">msg</span><br>        &#125;;<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://blog.csdn.net/weixin_43110609/article/details/121082091">飞书自定义机器人签名-node</a><br>（2）<a href="https://open.feishu.cn/document/ukTMukTMukTM/ucTM5YjL3ETO24yNxkjN?lang=zh-CN">飞书自定义机器人文档</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;因工作需要设计了一个调用飞书机器人的接口，主要的实现点在于 webHook 的验证通过。&lt;/p&gt;</summary>
    
    
    
    <category term="工作技巧" scheme="https://unkonwn404.github.io/unkown404.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="node.js" scheme="https://unkonwn404.github.io/unkown404.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>面向面试的算法题</title>
    <link href="https://unkonwn404.github.io/unkown404.github.io/2023/03/08/jsFunction/"/>
    <id>https://unkonwn404.github.io/unkown404.github.io/2023/03/08/jsFunction/</id>
    <published>2023-03-08T01:55:56.000Z</published>
    <updated>2023-03-08T01:59:36.688Z</updated>
    
    <content type="html"><![CDATA[<p>数组展平</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const flat = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">array</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">array</span>.<span class="hljs-built_in">reduce</span>(<br>    <span class="hljs-function">(<span class="hljs-params">acc, it</span>) =&gt;</span> acc.concat(<span class="hljs-built_in">Array</span>.isArray(it) ? flat(it) : it),<br>    []<br>  );<br>&#125;;<br>const <span class="hljs-built_in">array</span> = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, [<span class="hljs-number">5</span>]]]]];<br>const flatArray = flat(<span class="hljs-built_in">array</span>); <span class="hljs-comment">// [1, 2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure><p>compose函数实现</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span><span class="hljs-params">(<span class="hljs-rest_arg">...funcs</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (funcs.length === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> arg =&gt; arg<br>    &#125;<br> <br>    <span class="hljs-keyword">if</span> (funcs.length === <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> funcs[<span class="hljs-number">0</span>]<br>    &#125;<br> <br>    <span class="hljs-keyword">return</span> funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))<br>&#125; <br></code></pre></td></tr></table></figure><p>限制并发请求数</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">multiRequest</span>(<span class="hljs-params">urls = [], maxNum</span>) &#123;<br>  <span class="hljs-comment">// 请求总数量</span><br>  const len = urls.<span class="hljs-built_in">length</span>;<br>  <span class="hljs-comment">// 根据请求数量创建一个数组来保存请求的结果</span><br>  const result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len).fill(<span class="hljs-literal">false</span>);<br>  <span class="hljs-comment">// 当前完成的数量</span><br>  let <span class="hljs-built_in">count</span> = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 请求maxNum个</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">count</span> &lt; maxNum) &#123;<br>      next();<br>    &#125;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>      let current = <span class="hljs-built_in">count</span>++;<br>      <span class="hljs-comment">// 处理边界条件</span><br>      <span class="hljs-keyword">if</span> (current &gt;= len) &#123;<br>        <span class="hljs-comment">// 请求全部完成就将promise置为成功状态, 然后将result作为promise值返回</span><br>        !result.<span class="hljs-built_in">includes</span>(<span class="hljs-literal">false</span>) &amp;&amp; resolve(result);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      const url = urls[current];<br>      <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`开始 <span class="hljs-subst">$&#123;current&#125;</span>`</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toLocaleString());<br>      fetch(url)<br>        .then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>          <span class="hljs-comment">// 保存请求结果</span><br>          result[current] = res;<br>          <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`完成 <span class="hljs-subst">$&#123;current&#125;</span>`</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toLocaleString());<br>          <span class="hljs-comment">// 请求没有全部完成, 就递归</span><br>          <span class="hljs-keyword">if</span> (current &lt; len) &#123;<br>            next();<br>          &#125;<br>        &#125;)<br>        .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>          <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`结束 <span class="hljs-subst">$&#123;current&#125;</span>`</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toLocaleString());<br>          result[current] = err;<br>          <span class="hljs-comment">// 请求没有全部完成, 就递归</span><br>          <span class="hljs-keyword">if</span> (current &lt; len) &#123;<br>            next();<br>          &#125;<br>        &#125;);<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jb51.net/article/211898.htm">字节跳动面试之如何用JS实现Ajax并发请求控制</a></p>]]></content>
    
    
    <summary type="html">这一部分想不出来怎么描述了，就纯纯面向面试的算法题</summary>
    
    
    
    <category term="前端基础" scheme="https://unkonwn404.github.io/unkown404.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="算法" scheme="https://unkonwn404.github.io/unkown404.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="JavaScript" scheme="https://unkonwn404.github.io/unkown404.github.io/tags/JavaScript/"/>
    
    <category term="面试" scheme="https://unkonwn404.github.io/unkown404.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构</title>
    <link href="https://unkonwn404.github.io/unkown404.github.io/2023/03/02/algorithm/"/>
    <id>https://unkonwn404.github.io/unkown404.github.io/2023/03/02/algorithm/</id>
    <published>2023-03-02T09:38:44.000Z</published>
    <updated>2023-03-24T06:00:41.071Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="字符串相加（大数相加）"><a href="#字符串相加（大数相加）" class="headerlink" title="字符串相加（大数相加）"></a>字符串相加（大数相加）</h4><p>解题思路：按数学加法的思路，需维护进位符 flag，从个位开始，每次将两个字符串的个位和 flag 相加如果结果有进位则将进位符 flag 设为 1，没有则置 0，进入下一位的运算。如此循环，直到遍历完所有位数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">num1</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">num2</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">string</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> addStrings = <span class="hljs-keyword">function</span> (<span class="hljs-params">num1, num2</span>) &#123;<br>  <span class="hljs-keyword">let</span> flag = <span class="hljs-number">0</span>,<br>    numArr1 = num1.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>),<br>    numArr2 = num2.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>),<br>    res = [];<br>  <span class="hljs-keyword">for</span> (<br>    <span class="hljs-keyword">let</span> i = numArr1.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>, j = numArr2.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span> || flag;<br>    i--, j--<br>  ) &#123;<br>    <span class="hljs-keyword">let</span> count1 = i &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : numArr1[i];<br>    <span class="hljs-keyword">let</span> count2 = j &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : numArr2[j];<br>    <span class="hljs-keyword">let</span> tmp = (count1 + count2 + flag) % <span class="hljs-number">10</span>;<br>    flag = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((count1 + count2 + flag) / <span class="hljs-number">10</span>);<br>    res.<span class="hljs-title function_">push</span>(tmp);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="最长字符串"><a href="#最长字符串" class="headerlink" title="最长字符串"></a>最长字符串</h4><p>解题思路： 使用一个数组来维护滑动窗口<br>遍历字符串，判断字符是否在滑动窗口数组里</p><ul><li>不在则 push 进数组</li><li>在则删除滑动窗口数组里相同字符及相同字符前的字符，然后将当前字符 push 进数组</li><li>然后将 max 更新为当前最长子串的长度</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> lengthOfLongestSubstring = <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">let</span> arr = [], max = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">let</span> index = arr.<span class="hljs-title function_">indexOf</span>(s[i])<br>        <span class="hljs-keyword">if</span>(index !== -<span class="hljs-number">1</span>) &#123;<br>            arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, index+<span class="hljs-number">1</span>);<br>        &#125;<br>        arr.<span class="hljs-title function_">push</span>(s.<span class="hljs-title function_">charAt</span>(i))<br>        max = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(arr.<span class="hljs-property">length</span>, max)<br>    &#125;<br>    <span class="hljs-keyword">return</span> max<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h4><ol><li>indexOf</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">unique</span> = arr =&gt; arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">e,i</span>) =&gt;</span> arr.<span class="hljs-title function_">indexOf</span>(e) === i);<br></code></pre></td></tr></table></figure><ol start="2"><li>Set</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">unique</span> = arr =&gt; [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)];<br></code></pre></td></tr></table></figure><h4 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h4><ol><li>递归</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">flat</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">const</span> result = []<br>    arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(item)) &#123;<br>            result.<span class="hljs-title function_">push</span>(...<span class="hljs-title function_">flat</span>(item))<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            result.<span class="hljs-title function_">push</span>(item)<br>        &#125;<br>    &#125;)<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><span class="hljs-keyword">const</span> arr = <span class="hljs-title function_">flat</span>(arr)<br></code></pre></td></tr></table></figure><ol start="2"><li>现成 API</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 第一种方案：用现成flat</span><br><span class="hljs-keyword">const</span> arr1 = arr.<span class="hljs-title function_">flat</span>(<span class="hljs-title class_">Infinity</span>)<br><br><span class="hljs-comment">// 第二种方案：利用join展平</span><br><span class="hljs-keyword">const</span> arr2 = arr.<span class="hljs-title function_">join</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>)<br><br><span class="hljs-comment">// 第三种方案：利用toString直接展平</span><br><span class="hljs-keyword">const</span> arr3 = arr.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>)<br></code></pre></td></tr></table></figure><h4 id="两数之和、三数之和"><a href="#两数之和、三数之和" class="headerlink" title="两数之和、三数之和"></a>两数之和、三数之和</h4><h5 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h5><p>情景：给定一个整数数组 nums 和一个目标值 target，请在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。<br>思路：使用一个 map 将遍历过的数字存起来，值作为 key，下标作为值。</p><p>对于每一次遍历：</p><p>取 map 中查找是否有 key 为<code>target-nums[i]</code>的值<br>如果取到了，则条件成立，返回。<br>如果没有取到，将当前值作为 key，下标作为值存入 map</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">arr,target</span>)&#123;<br>    <span class="hljs-keyword">var</span> res=[],map=&#123;&#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-property">length</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(map[target-arr[i]]!=<span class="hljs-literal">undefined</span>)&#123;<br>            res= [i,map[target-arr[i]]]<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            map[arr[i]]=i<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h5><p>情景：给定一个整数数组 nums 和一个目标值 target，请在该数组中找出和为目标值的那 3 个整数，并返回他们的数组。<br>思路：需要考虑结果去重。思路与两数之和有类似的地方，遍历数组时选定基准值<code>arr[i]</code>，在数组最左和最右设立指针，判断左指针+基准值+右指针的和是否等于目标值，如果不是需移动指针来靠近</p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>特点：每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。<br>数据结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">TreeNode</span>(<span class="hljs-params">x</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = x;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">left</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">right</span> = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>特点：</p><ul><li>所有叶子节点都出现在 k 或者 k-1 层，而且从 1 到 k-1 层必须达到最大节点数；(第 n 层的节点数最多为 2^n 个节点 n 层二叉树最多有 2^0+…+2^n&#x3D;2^(n+1)-1 个节点)</li><li>第 k 层可以不是满的，但是第 k 层的所有节点必须集中在最左边。</li><li>任何一个节点不能只有左子树没有右子树</li></ul><h4 id="二叉查找树（又叫二叉排序树）"><a href="#二叉查找树（又叫二叉排序树）" class="headerlink" title="二叉查找树（又叫二叉排序树）"></a>二叉查找树（又叫二叉排序树）</h4><p>特点：</p><ul><li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</li><li>左、右子树也分别为二叉排序树。</li><li>二叉排序树的中序遍历一定是从小到大的</li></ul><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>前序遍历：根节点 + 左子树前序遍历 + 右子树前序遍历<br>中序遍历：左子树中序遍历 + 根节点 + 右字数中序遍历<br>后序遍历：左子树后序遍历 + 右子树后序遍历 + 根节点</p><h5 id="递归遍历法"><a href="#递归遍历法" class="headerlink" title="递归遍历法"></a>递归遍历法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">preOrder</span>(<span class="hljs-params">root,arr=[]</span>)&#123;<br>    <span class="hljs-keyword">if</span>(root)&#123;<br>        arr.<span class="hljs-title function_">push</span>(root.<span class="hljs-property">val</span>)<br>        <span class="hljs-title function_">preOrder</span>(root.<span class="hljs-property">left</span>,arr)<br>        <span class="hljs-title function_">preOrder</span>(root.<span class="hljs-property">right</span>,arr)<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">inOrder</span>(<span class="hljs-params">root,arr=[]</span>)&#123;<br>    <span class="hljs-keyword">if</span>(root)&#123;<br>        <span class="hljs-title function_">inOrder</span>(root.<span class="hljs-property">left</span>,arr)<br>        arr.<span class="hljs-title function_">push</span>(root.<span class="hljs-property">val</span>)<br>        <span class="hljs-title function_">inOrder</span>(root.<span class="hljs-property">right</span>,arr)<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">postOrder</span>(<span class="hljs-params">root,arr=[]</span>)&#123;<br>    <span class="hljs-keyword">if</span>(root)&#123;<br>        <span class="hljs-title function_">postOrder</span>(root.<span class="hljs-property">left</span>,arr)<br>        <span class="hljs-title function_">postOrder</span>(root.<span class="hljs-property">right</span>,arr)<br>        arr.<span class="hljs-title function_">push</span>(root.<span class="hljs-property">val</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h5><p>思路：利用栈的特性<br>前序遍历：前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。(保证入栈顺序和遍历顺序相反)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">preOrder</span>(<span class="hljs-params">root</span>)&#123;<br>    <span class="hljs-keyword">let</span> stack=[],current=root,res=[]<br>    stack.<span class="hljs-title function_">push</span>(current)<br>    <span class="hljs-keyword">while</span>(stack.<span class="hljs-property">length</span>)&#123;<br>        current=stack.<span class="hljs-title function_">pop</span>()<br>        res.<span class="hljs-title function_">push</span>(current.<span class="hljs-property">val</span>)<br>        <span class="hljs-keyword">if</span>(current.<span class="hljs-property">right</span>)&#123;<br>            stack.<span class="hljs-title function_">push</span>(current.<span class="hljs-property">right</span>)<br>        &#125;<br>        <span class="hljs-keyword">if</span>(current.<span class="hljs-property">left</span>)&#123;<br>            stack.<span class="hljs-title function_">push</span>(current.<span class="hljs-property">left</span>)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>中序遍历：中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">inOrder</span>(<span class="hljs-params">root</span>)&#123;<br>    <span class="hljs-keyword">let</span> stack=[],current=root,res=[]<br>    <span class="hljs-keyword">while</span>(current||stack.<span class="hljs-property">length</span>!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">while</span>(current)&#123;<br>            stack.<span class="hljs-title function_">push</span>(current)<br>            current=current.<span class="hljs-property">left</span><br>        &#125;<br>        <span class="hljs-keyword">let</span> node=stack.<span class="hljs-title function_">pop</span>()<br>        res.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>)<br>        current=current.<span class="hljs-property">right</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br><br>&#125;<br></code></pre></td></tr></table></figure><p>后序遍历：后序遍历是左右中，可以看作是前序遍历的逆序，先将根节点放入栈中。只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转 result 数组，输出的结果顺序就是左右中了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">postOrder</span>(<span class="hljs-params">root</span>)&#123;<br>    <span class="hljs-keyword">let</span> stack=[],current=root,res=[]<br>    stack.<span class="hljs-title function_">push</span>(current)<br>    <span class="hljs-keyword">while</span>(stack.<span class="hljs-property">length</span>)&#123;<br>        current=stack.<span class="hljs-title function_">pop</span>()<br>        res.<span class="hljs-title function_">push</span>(current.<span class="hljs-property">val</span>)<br>        <span class="hljs-keyword">if</span>(node.<span class="hljs-property">left</span>)stack.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">left</span>)<br>        <span class="hljs-keyword">if</span>(node.<span class="hljs-property">right</span>)stack.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">reverse</span>()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>特点：用一组任意存储的单元来存储线性表的数据元素。一个对象存储着本身的值和下一个元素的地址。<br>数据结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ListNode</span>(<span class="hljs-params">x</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = x;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>val 属性存储当前的值，next 属性存储下一个节点的引用。当 next 节点是 null 时，说明是最后一个节点，停止遍历。<br>解题思路：</p><ol><li>涉及到可能对头部节点变动时，可以设置虚拟节点 dummy 与 head 连接</li><li>双指针思想：利用两个或多个不同位置的指针，通过速度和方向的变换解决问题。</li></ol><h4 id="链表常规操作"><a href="#链表常规操作" class="headerlink" title="链表常规操作"></a>链表常规操作</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 插入节点</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertNode</span>(<span class="hljs-params">head,index,val</span>)&#123;<br>    <span class="hljs-keyword">const</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>)<br>    dummy.<span class="hljs-property">next</span> = head<br>    <span class="hljs-keyword">const</span> target=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(val)<br>    <span class="hljs-keyword">let</span> start=<span class="hljs-number">0</span>,current=dummy<br>    <span class="hljs-keyword">while</span>(current.<span class="hljs-property">next</span>)&#123;<br>        <span class="hljs-keyword">if</span>(start===index)&#123;<br>            target.<span class="hljs-property">next</span>=current.<span class="hljs-property">next</span><br>            current.<span class="hljs-property">next</span>=target<br>        &#125;<br>        start++<br>        current=current.<span class="hljs-property">next</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span><br>&#125;<br><span class="hljs-comment">// 删除节点</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteNode</span>(<span class="hljs-params">head,index</span>)&#123;<br>    <span class="hljs-keyword">const</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>)<br>    dummy.<span class="hljs-property">next</span> = head<br>    <span class="hljs-keyword">let</span> start=<span class="hljs-number">0</span>,current=dummy<br>    <span class="hljs-keyword">while</span>(current.<span class="hljs-property">next</span>)&#123;<br>        <span class="hljs-keyword">if</span>(start===index)&#123;<br>            current.<span class="hljs-property">next</span>=current.<span class="hljs-property">next</span>.<span class="hljs-property">next</span><br>        &#125;<br>        start++<br>        current=current.<span class="hljs-property">next</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span><br>&#125;<br><span class="hljs-comment">// 从尾到头打印指针</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printListNode</span>(<span class="hljs-params">head</span>)&#123;<br>    <span class="hljs-keyword">let</span> arr=[],current=head<br>    <span class="hljs-keyword">while</span>(current)&#123;<br>        arr.<span class="hljs-title function_">unshift</span>(current.<span class="hljs-property">val</span>)<br>        current=current.<span class="hljs-property">next</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="翻转列表"><a href="#翻转列表" class="headerlink" title="翻转列表"></a>翻转列表</h4><p>思路：双指针，慢指针保存前一个节点的值，快指针进行遍历修改指针方向</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">revertListNode</span>(<span class="hljs-params">head</span>)&#123;<br>    <span class="hljs-keyword">let</span> current=head<br>    <span class="hljs-keyword">let</span> pre=<span class="hljs-literal">null</span><br>    <span class="hljs-keyword">while</span>(current)&#123;<br>        <span class="hljs-keyword">const</span> tmp=current.<span class="hljs-property">next</span><br>        current.<span class="hljs-property">next</span>=pre<br>        pre=current<br>        current=tmp<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="链表倒数第-K-个节点"><a href="#链表倒数第-K-个节点" class="headerlink" title="链表倒数第 K 个节点"></a>链表倒数第 K 个节点</h4><p>思路：双指针，快指针比慢指针间隔 k 步当快指针移动到 null 时慢指针位于 n-k 处</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findKthFromTail</span>(<span class="hljs-params">head,k</span>)&#123;<br>    <span class="hljs-keyword">let</span> fast=head,slow=head,index=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span>(fast)&#123;<br>        fast=fast.<span class="hljs-property">next</span><br>        index++<br>        <span class="hljs-keyword">if</span>(index&gt;k)&#123;<br>            slow=slow.<span class="hljs-property">next</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="延伸：删除倒数第-K-个节点"><a href="#延伸：删除倒数第-K-个节点" class="headerlink" title="延伸：删除倒数第 K 个节点"></a>延伸：删除倒数第 K 个节点</h5><p>思路：类似链表倒数第 K 个节点，只是需要找到的节点是倒数 K+1，方便做指针操作；由于删除操作有可能涉及头部节点操作，最好加 dummy</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteKthFromTail</span>(<span class="hljs-params">head,k</span>)&#123;<br>    <span class="hljs-keyword">const</span> dummy=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>)<br>    dummy.<span class="hljs-property">next</span>=head<br>    <span class="hljs-keyword">let</span> fast=dummy,slow=dummy,index=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span>(fast)&#123;<br>        fast=fast.<span class="hljs-property">next</span><br>        index++<br>        <span class="hljs-keyword">if</span>(index&gt;k+<span class="hljs-number">1</span>)&#123;<br>            slow=slow.<span class="hljs-property">next</span><br>        &#125;<br>    &#125;<br>    slow.<span class="hljs-property">next</span>=slow.<span class="hljs-property">next</span>.<span class="hljs-property">next</span><br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="链表是否含环"><a href="#链表是否含环" class="headerlink" title="链表是否含环"></a>链表是否含环</h4><p>思路：快慢指针，快指针移动的速度是慢指针的 2 倍，如果快指针和慢指针相遇说明有环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hasCircle</span>(<span class="hljs-params">head</span>)&#123;<br>    <span class="hljs-keyword">let</span> fast=head,slow=head,index<br>    <span class="hljs-keyword">while</span>(fast&amp;&amp;fast.<span class="hljs-property">next</span>)&#123;<br>        fast=fast.<span class="hljs-property">next</span>.<span class="hljs-property">next</span><br>        slow=slow.<span class="hljs-property">fast</span><br>        <span class="hljs-keyword">if</span>(fast.<span class="hljs-property">val</span>===slow.<span class="hljs-property">val</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="延伸：找出环起点"><a href="#延伸：找出环起点" class="headerlink" title="延伸：找出环起点"></a>延伸：找出环起点</h5><p>思路：相遇时快慢指针的路程差，是环周长的整数倍。如果相遇以后慢指针回到 head、两指针同速，则两指针到环起点会相遇</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findCircleStart</span>(<span class="hljs-params">head</span>)&#123;<br>    <span class="hljs-keyword">let</span> fast=head,slow=head,index<br>    <span class="hljs-keyword">while</span>(fast&amp;&amp;fast.<span class="hljs-property">next</span>)&#123;<br>        fast=fast.<span class="hljs-property">next</span>.<span class="hljs-property">next</span><br>        slow=slow.<span class="hljs-property">fast</span><br>        <span class="hljs-keyword">if</span>(fast.<span class="hljs-property">val</span>===slow.<span class="hljs-property">val</span>)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//判断是否有环</span><br>    <span class="hljs-keyword">if</span>(fast==<span class="hljs-literal">null</span>||fast.<span class="hljs-property">next</span>==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span><br>    slow=head<br>    <span class="hljs-keyword">while</span>(slow!=fast)&#123;<br>        slow=slow.<span class="hljs-property">next</span><br>        fast=fast.<span class="hljs-property">next</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> slow<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="链表合并"><a href="#链表合并" class="headerlink" title="链表合并"></a>链表合并</h4><p>思路：创建新的链表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeList</span>(<span class="hljs-params">list1,list2</span>)&#123;<br>    <span class="hljs-keyword">const</span> dummy=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">let</span> p1=list1,p2=list2,p=dummy<br>    <span class="hljs-keyword">while</span>(p1&amp;&amp;p2)&#123;<br>        <span class="hljs-keyword">if</span>(p1.<span class="hljs-property">val</span>&gt;p2.<span class="hljs-property">val</span>)&#123;<br>            p.<span class="hljs-property">next</span>=p2<br>            p2=p2.<span class="hljs-property">next</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            p.<span class="hljs-property">next</span>=p1<br>            p1=p1.<span class="hljs-property">next</span><br>        &#125;<br>        p=p.<span class="hljs-property">next</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(p1)&#123;<br>        p.<span class="hljs-property">next</span>=p1<br>    &#125;<br>    <span class="hljs-keyword">if</span>(p2)&#123;<br>        p.<span class="hljs-property">next</span>=p2<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><h4 id="有效括号"><a href="#有效括号" class="headerlink" title="有效括号"></a>有效括号</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> isValid = <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">let</span> map = &#123;<br>        <span class="hljs-string">&#x27;&#123;&#x27;</span>: <span class="hljs-string">&#x27;&#125;&#x27;</span>,<br>        <span class="hljs-string">&#x27;(&#x27;</span>: <span class="hljs-string">&#x27;)&#x27;</span>,<br>        <span class="hljs-string">&#x27;[&#x27;</span>: <span class="hljs-string">&#x27;]&#x27;</span><br>    &#125;<br>    <span class="hljs-keyword">let</span> stack = []<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span> ; i++) &#123;<br>        <span class="hljs-keyword">if</span>(map[s[i]]) &#123;<br>            stack.<span class="hljs-title function_">push</span>(s[i])<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] !== map[stack.<span class="hljs-title function_">pop</span>()])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stack.<span class="hljs-property">length</span> === <span class="hljs-number">0</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>思路：双循环，外层循环确定冒泡执行的范围；内层循环执行冒泡，冒泡的原理是内循环的首元素跟附近的元素比较，如果大小顺序相反则进行置换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bubbleSort</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> outer=arr.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>;outer&gt;<span class="hljs-number">0</span>;outer--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> inner=<span class="hljs-number">0</span>;inner&lt;outer;inner++)&#123;<br>            <span class="hljs-keyword">if</span>(arr[inner]&gt;arr[inner+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">const</span> tmp=arr[inner]<br>                arr[inner]=arr[inner+<span class="hljs-number">1</span>]<br>                arr[inner+<span class="hljs-number">1</span>]=tmp<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>思路：双循环，外层循环确定选择执行的范围；内层循环执行选择排序，找到本次循环的最值移动到对应的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">selectSort</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">if</span>(arr.<span class="hljs-property">length</span>&lt;=<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> arr<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> outer=arr.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>;outer&gt;<span class="hljs-number">0</span>;outer--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> inner=<span class="hljs-number">0</span>;inner&lt;outer;inner++)&#123;<br>            <span class="hljs-keyword">if</span>(arr[inner]&gt;arr[outer])&#123;<br>                <span class="hljs-keyword">const</span> tmp=arr[inner]<br>                arr[inner]=arr[outer]<br>                arr[outer]=tmp<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>思路：递归，函数体内以传入数组长度小于等于 1 的情况作为结束递归的方式。选取数组内的一个值作为基准，将其他的值分为两个数组存储，一个是大于基准的数组，一个是小于基准的数组，对这两个数组进行快速排序后和基准值进行连接</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">quickSort</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">if</span>(arr.<span class="hljs-property">length</span>&lt;=<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> arr<br>    <span class="hljs-keyword">const</span> ele=arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>),left=[],right=[]<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-property">length</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(arr[i]&lt;ele)&#123;<br>            left.<span class="hljs-title function_">push</span>(arr[i])<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            right.<span class="hljs-title function_">push</span>(arr[i])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">quickSort</span>(left).<span class="hljs-title function_">concat</span>(ele,<span class="hljs-title function_">quickSort</span>(right))<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h4><p>情景：有一楼梯共 n 级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第 n 级，共有多少种走法<br>思路：倒退，完成最后一步时可能是 n-1 级台阶走一级，也可能是 n-2 级台阶走两级。在完成 n-1 级台阶走法的计算方式和 n 级走法计算本质是一样的。所以需要找基本情况即递归的结束情况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">climbStairs</span>(<span class="hljs-params">n</span>)&#123;<br>    <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span>(n===<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span>(n===<span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">climbStairs</span>(n-<span class="hljs-number">1</span>)+<span class="hljs-title function_">climbStairs</span>(n-<span class="hljs-number">2</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>回溯是递归的副产品，只要有递归就会有回溯。</p><p>回溯模版：<br>回溯算法中函数通常没有返回值</p><ol><li>设置终止条件</li><li>回溯遍历：回溯法的搜索过程就是一个树型结构的遍历过程，for 循环用来横向遍历，递归的过程是纵向遍历。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">backtracking</span>(<span class="hljs-params">参数</span>) &#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        <span class="hljs-title function_">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>回溯解决问题类型：</p><ol><li>组合问题：N 个数里面按一定规则找出 k 个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个 N 个数的集合里有多少符合条件的子集</li><li>排列问题：N 个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N 皇后，解数独等等</li></ol><h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><p>情景：给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。<br>解题思路：</p><ul><li>增加存储变量：k 个数组合的结果可以用 tmp 暂时存储，最终的结果用 res 存储；组合内部是没有顺序要求的，因此需要记录起始点</li><li>设置回溯函数形参：存储变量一定也加到形参</li><li>设置回溯函数终止条件：tmp 推入的数据长度等于目标长度 k 时需要将本次组合推入 res 结束递归，注意要传 tmp 的复制而不是本身，因为 tmp 后续还要做操作</li><li>设置回溯函数循环体：循环体的起始点取形参的传入变量，tmp 推入元素，backtrack 函数调用更新 startIdx，再退出路径</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">n</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">k</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[][]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> combine = <span class="hljs-keyword">function</span>(<span class="hljs-params">n, k</span>) &#123;<br>    <span class="hljs-keyword">let</span> tmp=[],res=[]<br>    <span class="hljs-title function_">backtrack</span>(n,k,tmp,res,<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;;<br><span class="hljs-keyword">var</span> backtrack=<span class="hljs-keyword">function</span>(<span class="hljs-params">n,k,tmp,res,startIdx</span>)&#123;<br>    <span class="hljs-keyword">if</span>(tmp.<span class="hljs-property">length</span>===k)&#123;<br>        res.<span class="hljs-title function_">push</span>(tmp.<span class="hljs-title function_">slice</span>())<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=startIdx;i&lt;=n;i++)&#123;<br>        tmp.<span class="hljs-title function_">push</span>(i)<br>        <span class="hljs-title function_">backtrack</span>(n,k,tmp,res,i+<span class="hljs-number">1</span>)<br>        tmp.<span class="hljs-title function_">pop</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="和为-sum-的-n-个数"><a href="#和为-sum-的-n-个数" class="headerlink" title="和为 sum 的 n 个数"></a>和为 sum 的 n 个数</h4><p>情景：给你一个 无重复元素 的整数数组  candidates 和一个目标整数  target ，找出  candidates  中可以使数字和为目标数  target 的 所有   不同组合 ，并以列表形式返回。<br>解题思路：</p><ul><li>增加存储变量：k 个数组合的结果可以用 tmp 暂时存储，最终的结果用 res 存储；组合内部是没有顺序要求的，因此需要记录起始点</li><li>设置回溯函数形参：存储变量一定也加到形参</li><li>设置回溯函数终止条件：tmp 推入的数据和等于目标值 时需要将本次组合推入 res 结束递归，大于目标值 时直接结束递归；注意要传 tmp 的复制而不是本身，因为 tmp 后续还要做操作</li><li>设置回溯函数循环体：循环体的起始点取形参的传入变量，tmp 推入元素，backtrack 函数调用更新 startIdx（startIdx 是当前索引值即可），再退出路径</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">candidates</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">target</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[][]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> combinationSum = <span class="hljs-keyword">function</span>(<span class="hljs-params">candidates, target</span>) &#123;<br>    <span class="hljs-keyword">var</span> res=[],tmp=[]<br>    <span class="hljs-title function_">backtracking</span>(candidates,target,tmp,res,<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;;<br><span class="hljs-keyword">var</span> backtracking=<span class="hljs-keyword">function</span>(<span class="hljs-params">candidates,target,tmp,res,startIdx</span>)&#123;<br>    <span class="hljs-keyword">if</span>(tmp.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>)=&gt;</span>pre+cur,<span class="hljs-number">0</span>)&gt;target)&#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(tmp.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>)=&gt;</span>pre+cur,<span class="hljs-number">0</span>)===target)&#123;<br>        res.<span class="hljs-title function_">push</span>(tmp.<span class="hljs-title function_">slice</span>())<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=startIdx;i&lt;candidates.<span class="hljs-property">length</span>;i++)&#123;<br>        tmp.<span class="hljs-title function_">push</span>(candidates[i])<br>        <span class="hljs-title function_">backtracking</span>(candidates,target,tmp,res,i)<br>        tmp.<span class="hljs-title function_">pop</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="延伸情景"><a href="#延伸情景" class="headerlink" title="延伸情景"></a>延伸情景</h5><ol><li>给定一个候选人编号的集合  candidates  和一个目标数  target ，找出  candidates  中所有可以使数字和为  target  的组合。<br>candidates  中的每个数字在每个组合中只能使用   一次  。<br>思路：与上一题相比需要排除相同元素的组合结果。解决方法是需要先进行排序，让相同的元素靠在一起，如果发现 <code>nums[i] == nums[i-1]</code>，则跳过</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">candidates</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">target</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[][]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> combinationSum2 = <span class="hljs-keyword">function</span>(<span class="hljs-params">candidates, target</span>) &#123;<br><span class="hljs-keyword">var</span> res=[],tmp=[]<br>    <span class="hljs-title function_">backtracking</span>(candidates.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>a-b),target,tmp,res,<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;;<br><span class="hljs-keyword">var</span> backtracking=<span class="hljs-keyword">function</span>(<span class="hljs-params">candidates,target,tmp,res,startIdx</span>)&#123;<br>    <span class="hljs-keyword">if</span>(tmp.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>)=&gt;</span>pre+cur,<span class="hljs-number">0</span>)&gt;target)&#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(tmp.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>)=&gt;</span>pre+cur,<span class="hljs-number">0</span>)===target)&#123;<br>        res.<span class="hljs-title function_">push</span>(tmp.<span class="hljs-title function_">slice</span>())<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=startIdx;i&lt;candidates.<span class="hljs-property">length</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(i&gt;startIdx&amp;&amp;candidates[i]===candidates[i-<span class="hljs-number">1</span>])<span class="hljs-keyword">continue</span><br>        tmp.<span class="hljs-title function_">push</span>(candidates[i])<br>        <span class="hljs-title function_">backtracking</span>(candidates,target,tmp,res,i+<span class="hljs-number">1</span>)<br>        tmp.<span class="hljs-title function_">pop</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h4><p>情景：给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。<br>解题思路：<br><strong>思路 1</strong></p><ul><li>增加存储变量：全排列组合的结果可以用 tmp 暂时存储，最终的结果用 res 存储；组合内部有顺序要求，只是使用过的元素不可以再次使用，因此使用 boolean 数组 used 存储</li><li>设置回溯函数形参：存储变量一定也加到形参</li><li>设置回溯函数终止条件：tmp 推入的数据长度等于目标长度 k 时需要将本次组合推入 res 结束递归，注意要传 tmp 的复制而不是本身，因为 tmp 后续还要做操作</li><li>设置回溯函数循环体：循环体内部判断元素是否已经使用，使用则 continue 跳过此次循环 tmp 推入元素，used 更新，backtrack 函数调用更新 used，再退出路径</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[][]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> permute = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-keyword">var</span> tmp=[],res=[],used=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(nums.<span class="hljs-property">length</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-title function_">backtracking</span>(tmp,res,nums,used)<br>    <span class="hljs-keyword">return</span> res;<br><br>&#125;;<br><span class="hljs-keyword">var</span> backtracking=<span class="hljs-keyword">function</span>(<span class="hljs-params">tmp,res,nums,used</span>)&#123;<br>    <span class="hljs-keyword">if</span>(nums.<span class="hljs-property">length</span>==tmp.<span class="hljs-property">length</span>)&#123;<br>        res.<span class="hljs-title function_">push</span>(tmp.<span class="hljs-title function_">slice</span>())<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-property">length</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(used[i])<span class="hljs-keyword">continue</span><br>        tmp.<span class="hljs-title function_">push</span>(nums[i]);<br>        used[i]=<span class="hljs-literal">true</span><br>        <span class="hljs-title function_">backtracking</span>(tmp,res,nums,used)<br>        tmp.<span class="hljs-title function_">pop</span>();<br>        used[i]=<span class="hljs-literal">false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路 2</strong><br>全排列的思路是使用数组的一个元素，剩下的元素接着进行全排列，再与提取出来的元素组合。因此可以在回溯算法内部改变使用的数组内容，同时终止条件也需要改变</p><ul><li>增加存储变量：全排列组合的结果可以用 tmp 暂时存储，最终的结果用 res 存储</li><li>设置回溯函数形参：存储变量一定也加到形参</li><li>设置回溯函数终止条件：nums 长度为 0 即所有元素全排列结束时需要将本次组合推入 res 结束递归，注意要传 tmp 的复制而不是本身，因为 tmp 后续还要做操作</li><li>设置回溯函数循环体：循环体内部 tmp 推入元素，backtrack 函数调用更新 传入的数组 nums，再退出路径</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[][]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> permute = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-keyword">var</span> tmp=[],res=[];<br>    <span class="hljs-title function_">backtracking</span>(tmp,res,nums)<br>    <span class="hljs-keyword">return</span> res;<br><br>&#125;;<br><span class="hljs-keyword">var</span> backtracking=<span class="hljs-keyword">function</span>(<span class="hljs-params">tmp,res,nums</span>)&#123;<br>    <span class="hljs-keyword">if</span>(nums.<span class="hljs-property">length</span>==<span class="hljs-number">0</span>)&#123;<br>        res.<span class="hljs-title function_">push</span>(tmp.<span class="hljs-title function_">slice</span>())<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-property">length</span>;i++)&#123;<br>        tmp.<span class="hljs-title function_">push</span>(nums[i]);<br>        <span class="hljs-title function_">backtracking</span>(tmp,res,nums.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>,i).<span class="hljs-title function_">concat</span>(nums.<span class="hljs-title function_">slice</span>(i+<span class="hljs-number">1</span>)))<br>        tmp.<span class="hljs-title function_">pop</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索(BFS)"></a>广度优先搜索(BFS)</h3><p>特点:越是接近根结点的结点将越早地遍历。<br>在 BFS 中，结点的处理顺序与它们添加到队列的顺序是完全相同的顺序，即先进先出，所以广度优先搜索一般使用队列实现。<br>适用场景：</p><ol><li>前序遍历、层序遍历、之字遍历，树的最左最右点，二叉树最小深度</li><li>矩阵&#x2F;网格的最短路径</li></ol><p>模版：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params"></span>)&#123;<br>    queue.<span class="hljs-title function_">push</span>(start)<br>    <span class="hljs-keyword">while</span>(queue.<span class="hljs-property">length</span>)&#123;<br>        <span class="hljs-keyword">var</span> size=queue.<span class="hljs-property">length</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>            <span class="hljs-keyword">var</span> node=queue.<span class="hljs-title function_">shift</span>()<br>            <span class="hljs-keyword">var</span> next=node+dir<br>            <span class="hljs-keyword">if</span>(越界)<span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span>(满足条件)queue.<span class="hljs-title function_">push</span>(next)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉树层序遍历"><a href="#二叉树层序遍历" class="headerlink" title="二叉树层序遍历"></a>二叉树层序遍历</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[][]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> levelOrder = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!root)<span class="hljs-keyword">return</span> []<br>    <span class="hljs-keyword">let</span> res=[],queue=[root],tmp=[]<br>    <span class="hljs-keyword">while</span>(queue.<span class="hljs-property">length</span>)&#123;<br>        <span class="hljs-keyword">let</span> size=queue.<span class="hljs-property">length</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>            <span class="hljs-keyword">let</span> node=queue.<span class="hljs-title function_">shift</span>()<br>            tmp.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>)<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">left</span>)queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">left</span>)<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">right</span>)queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>)<br>        &#125;<br>        res.<span class="hljs-title function_">push</span>(tmp)<br>        tmp=[]<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉树最小深度"><a href="#二叉树最小深度" class="headerlink" title="二叉树最小深度"></a>二叉树最小深度</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">minDepth</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!root)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">let</span> queue=[],dep=<span class="hljs-number">0</span><br>    queue.<span class="hljs-title function_">push</span>(root)<br>    <span class="hljs-keyword">while</span>(queue.<span class="hljs-property">length</span>)&#123;<br>        <span class="hljs-keyword">let</span> size=queue.<span class="hljs-property">length</span><br>        dep++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>            <span class="hljs-keyword">let</span> node=queue.<span class="hljs-title function_">shift</span>()<br>            <span class="hljs-keyword">if</span>(!node.<span class="hljs-property">left</span>&amp;&amp;!node.<span class="hljs-property">right</span>)<span class="hljs-keyword">return</span> dep<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">left</span>)queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">left</span>)<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">right</span>)queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索(DFS)"></a>深度优先搜索(DFS)</h3><p>特点：更早访问的结点可能不是更靠近根结点的结点。<br>结点的处理顺序是完全相反的顺序，就像它们被添加到栈中一样，它是后进先出。所以深度优先搜索一般使用栈实现。</p><p>模版：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 二叉树的遍历</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root</span>)&#123;<br>   <span class="hljs-title function_">dfs</span>(root.<span class="hljs-property">left</span>)<br>   <span class="hljs-title function_">dfs</span>(root.<span class="hljs-property">right</span>)<br>&#125;<br><span class="hljs-comment">// 二维矩阵的遍历</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">grid:number[][],i:number,j:number,visited:boolean[][]</span>)&#123;<br>    <span class="hljs-keyword">let</span> m = grid.<span class="hljs-property">length</span>, n = grid[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= m || j &gt;= n) &#123;<br>        <span class="hljs-comment">// 超出索引边界</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (visited[i][j]) &#123;<br>        <span class="hljs-comment">// 已遍历过 (i, j)</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 进⼊节点 (i, j)</span><br>    visited[i][j] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-title function_">dfs</span>(grid, i - <span class="hljs-number">1</span>, j, visited); <span class="hljs-comment">// 上</span><br>    <span class="hljs-title function_">dfs</span>(grid, i + <span class="hljs-number">1</span>, j, visited); <span class="hljs-comment">// 下</span><br>    <span class="hljs-title function_">dfs</span>(grid, i, j - <span class="hljs-number">1</span>, visited); <span class="hljs-comment">// 左</span><br>    <span class="hljs-title function_">dfs</span>(grid, i, j + <span class="hljs-number">1</span>, visited); <span class="hljs-comment">// 右</span><br>&#125;<br></code></pre></td></tr></table></figure><p>适用场景：</p><ol><li>中序遍历、二叉树最大深度</li><li>岛屿数量</li></ol><h4 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">targetSum</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> hasPathSum = <span class="hljs-keyword">function</span>(<span class="hljs-params">root, targetSum</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!root)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">if</span>(!root.<span class="hljs-property">left</span>&amp;&amp;!root.<span class="hljs-property">right</span>)<span class="hljs-keyword">return</span> root.<span class="hljs-property">val</span>===targetSum<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">hasPathSum</span>(root.<span class="hljs-property">left</span>,targetSum-root.<span class="hljs-property">val</span>)||<span class="hljs-title function_">hasPathSum</span>(root.<span class="hljs-property">right</span>,targetSum-root.<span class="hljs-property">val</span>)<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h4><p>思路：遍历二维数组，同时维护一个与原数组同样大小的 boolean 数组 visited（创建二维数组时避免数组元素指向同一引用）记录已经遍历过的元素；也可以使用海水淹没法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">character[][]</span>&#125; <span class="hljs-variable">grid</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> numIslands = <span class="hljs-keyword">function</span> (<span class="hljs-params">grid</span>) &#123;<br>    <span class="hljs-keyword">const</span> m = grid.<span class="hljs-property">length</span>, n = grid[<span class="hljs-number">0</span>].<span class="hljs-property">length</span><br>    <span class="hljs-keyword">let</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(m).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">false</span>)), res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; visited[i][j] === <span class="hljs-literal">false</span>) &#123;<br>                res++;<br>                <span class="hljs-title function_">dfs</span>(grid, visited, i, j, m, n)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;;<br><span class="hljs-keyword">var</span> dfs = <span class="hljs-keyword">function</span> (<span class="hljs-params">grid, visited, i, j, m, n</span>) &#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= m || i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || j &gt;= n) <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span> || visited[i][j] === <span class="hljs-literal">true</span>) <span class="hljs-keyword">return</span><br>    visited[i][j] = <span class="hljs-literal">true</span><br>    <span class="hljs-title function_">dfs</span>(grid, visited, i - <span class="hljs-number">1</span>, j, m, n)<br>    <span class="hljs-title function_">dfs</span>(grid, visited, i + <span class="hljs-number">1</span>, j, m, n)<br>    <span class="hljs-title function_">dfs</span>(grid, visited, i, j - <span class="hljs-number">1</span>, m, n)<br>    <span class="hljs-title function_">dfs</span>(grid, visited, i, j + <span class="hljs-number">1</span>, m, n)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/6844903919722692621">前端该如何准备数据结构和算法</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h2&gt;&lt;h3 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符</summary>
      
    
    
    
    <category term="前端基础" scheme="https://unkonwn404.github.io/unkown404.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="算法" scheme="https://unkonwn404.github.io/unkown404.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>前端监控平台搭建</title>
    <link href="https://unkonwn404.github.io/unkown404.github.io/2023/03/02/errorMonitor/"/>
    <id>https://unkonwn404.github.io/unkown404.github.io/2023/03/02/errorMonitor/</id>
    <published>2023-03-02T05:20:45.000Z</published>
    <updated>2023-03-02T09:28:56.011Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>通常情况下对上线的前端项目进行修改 bug 时，只能依赖用户使用时的反馈，开发者来根据用户所描述的场景去模拟这个错误的产生，效率较低</p><h3 id="1-1-常见的监控平台"><a href="#1-1-常见的监控平台" class="headerlink" title="1.1 常见的监控平台"></a>1.1 常见的监控平台</h3><table><thead><tr><th align="center"></th><th align="center">sentry</th><th align="center">webfunny</th><th align="center">fundebug</th></tr></thead><tbody><tr><td align="center">支持平台</td><td align="center">前端 JavaScript、Vue、React、Angular、React Native 以及后端 Node.js</td><td align="center">h5，PC，微信小程序，uni-app</td><td align="center">前端 JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native 以及后端 Node.js</td></tr><tr><td align="center">是否开源</td><td align="center">是</td><td align="center">否</td><td align="center">否</td></tr><tr><td align="center">支持私有化部署</td><td align="center">是</td><td align="center">是</td><td align="center">否</td></tr><tr><td align="center">费用</td><td align="center">80 美元&#x2F;月</td><td align="center">1500 元&#x2F;年</td><td align="center">159 元&#x2F;月</td></tr></tbody></table><p>使用三方监控的缺点：SDK 并非都是开源，扩展性差，难以覆盖到全端；报错数据不能完全保证私有；要管理公司内部的多个项目时 sentry 的收费会增加</p><h3 id="1-2-监控平台构成"><a href="#1-2-监控平台构成" class="headerlink" title="1.2 监控平台构成"></a>1.2 监控平台构成</h3><p>SDK 模块：负责采集和上报功能，数据如何采集、采集哪些端，上报哪些信息<br>服务器：负责存储和管理功能，上报的数据结构应该是什么样，数据怎么分类<br>可视化平台：总结异常情况，发送给使用者</p><h2 id="二、SDK-实现"><a href="#二、SDK-实现" class="headerlink" title="二、SDK 实现"></a>二、SDK 实现</h2><h3 id="2-1-SDK-架构"><a href="#2-1-SDK-架构" class="headerlink" title="2.1 SDK 架构"></a>2.1 SDK 架构</h3><p>monorepo<br>特点：一种管理代码的方式，即一个大的 Git 仓库，管理所有的代码。所有的代码处于同样的规则，同样的约束。</p><p>优势： 1.分模块打包、分模块热更新、分包发布（提高开发体验） 2.抽离抽象类、工具类到某个包，代码结构清晰（降低耦合性，提高代码可读性）<br>包与包之间关系（mito 为例）</p><p>各端 SDK 依赖相同的公共包和核心包，core 将客户端的一些共通操作抽离成 baseClient 下的方法由客户端 SDK 继承和实现</p><h3 id="2-2-SDK-原理"><a href="#2-2-SDK-原理" class="headerlink" title="2.2 SDK 原理"></a>2.2 SDK 原理</h3><h4 id="2-2-1-SDK-报错实现"><a href="#2-2-1-SDK-报错实现" class="headerlink" title="2.2.1 SDK 报错实现"></a>2.2.1 SDK 报错实现</h4><p>整体代码架构使用发布-订阅设计模式以便后续迭代功能，处理逻辑基本都在 HandleEvents 文件中</p><h5 id="2-2-1-1-监听-x2F-重写原生事件"><a href="#2-2-1-1-监听-x2F-重写原生事件" class="headerlink" title="2.2.1.1 监听&#x2F;重写原生事件"></a>2.2.1.1 监听&#x2F;重写原生事件</h5><p>SDK 采集的常见错误包括：</p><ol><li>JS 错误和资源错误<br>通过 window.addEventListener 来监听 window 的 error 事件，注意拦截操作放在捕获阶段，一方面因为资源加载错误不会冒泡到 window 上，另一方面防止业务代码的阻止冒泡捕获不到事件<br>判断是否是资源错误的要点：判断 e.target.localName 是否有值，有的话就是资源错误</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">handleError</span>(<span class="hljs-params">errorEvent</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; target &#125; = errorEvent;<br>    <span class="hljs-keyword">if</span> (target.<span class="hljs-property">localName</span>) &#123;<br>    <span class="hljs-comment">// 资源加载错误 提取有用数据</span><br>        <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">resourceTransform</span>(errorEvent.<span class="hljs-property">target</span>);<br>        <span class="hljs-keyword">return</span> reportData.<span class="hljs-title function_">send</span>(data);<br>    &#125;<br>    <span class="hljs-comment">// code error</span><br>    <span class="hljs-keyword">const</span> &#123;<br>    message, filename, lineno, colno, error,<br>    &#125; = errorEvent;<br>    <span class="hljs-keyword">let</span> result;<br>    <span class="hljs-keyword">if</span> (error &amp;&amp; <span class="hljs-title function_">isError</span>(error)) &#123;<br>        result = <span class="hljs-title function_">extractErrorStack</span>(error, <span class="hljs-variable constant_">LEVEL</span>.<span class="hljs-property">Normal</span>);<br>    &#125;<br>    <span class="hljs-comment">// 处理 SyntaxError，stack 没有 lineno、colno</span><br>    <span class="hljs-keyword">if</span> (result) &#123;<br>        <span class="hljs-title class_">HandleEvents</span>.<span class="hljs-title function_">handleNotErrorInstance</span>(message, filename, lineno, colno);<br>    &#125;<br>    result.<span class="hljs-property">type</span> = <span class="hljs-variable constant_">ERRORTYPES</span>.<span class="hljs-property">JAVASCRIPT_ERROR</span>;<br>    reportData.<span class="hljs-title function_">send</span>(result);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>接口错误：所有的请求第三方库都是基于 xhr、fetch 二次封装的，所以只需要重写这两个事件就可以拿到所有的接口请求的信息，通过判断 status 的值来判断当前接口是否是正常的。<br>监控原生事件，如果不支持 addEventListener，那么就是重写原生函数拿到入参，再将原函数返回。<br>以 fetch 为例：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchIntercept</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//拿到老的 fetch 函数</span><br>    <span class="hljs-keyword">const</span> oldFetch = <span class="hljs-variable language_">window</span>.<span class="hljs-property">fetch</span>;<br>    <span class="hljs-comment">// 重写</span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">fetch</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">url, config</span>) &#123;<br>        <span class="hljs-keyword">return</span> oldFetch.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">window</span>, [url, config]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">const</span> tempRes = res.<span class="hljs-title function_">clone</span>()<br>                tempRes.<span class="hljs-title function_">text</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;method&#x27;</span>,config.<span class="hljs-property">method</span>)<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;url&#x27;</span>,url)<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;reqData&#x27;</span>,config.<span class="hljs-property">body</span>)<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;status&#x27;</span>, tempRes.<span class="hljs-property">status</span>)<br>            &#125;)<br>            <span class="hljs-keyword">return</span> res<br>        &#125;,<br>        <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>        <span class="hljs-keyword">throw</span> err<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>unhandledrejection 错误<br>当 Promise 被 reject 且没有 reject 处理器的时候，会触发 unhandledrejection 事件<br>通过 window.addEventListener 可以监听 window 的 unhandledrejection 事件</li></ol><p><strong>Vue 报错捕获</strong><br>Vue 提供了一个函数 errorHandler 供开发者来获取框架层面的错误，所以直接重写该方法并拿到入参即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">errorHandler</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">err, vm, info</span>) &#123;<br>    handleVueError.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, [err, vm, info, <span class="hljs-variable constant_">LEVEL</span>.<span class="hljs-property">Normal</span>, <span class="hljs-variable constant_">LEVEL</span>.<span class="hljs-property">Error</span>, <span class="hljs-title class_">Vue</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p>重写函数需要区分 vue2 和 vue3 的区别</p><p><strong>React 报错捕获</strong></p><ul><li>渲染错误：errorBoundary 组件 React16.13 中提供了 componentDidCatch 钩子函数来回调错误信息，所以我们可以新建一个类 ErrorBoundary 来继承 React，然后然后声明 componentDidCatch 钩子函数，可以拿到错误信息</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> h = <span class="hljs-title class_">React</span>.<span class="hljs-property">createElement</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span> &#125;<br>    &#125;<br><br>    <span class="hljs-title function_">componentDidCatch</span>(<span class="hljs-params">error, errorInfo</span>) &#123;<br>        <span class="hljs-variable constant_">MITO</span>.<span class="hljs-title function_">errorBoundaryReport</span>(error)<br>        <span class="hljs-keyword">if</span> (error) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>                <span class="hljs-attr">hasError</span>: <span class="hljs-literal">true</span><br>            &#125;)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">hasError</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;子组件抛出异常&#x27;</span>)<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">children</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JSX"><span class="hljs-comment">// 然后用 ErrorBoundary 包裹需要处理的组件</span><br>&lt;<span class="hljs-title class_">ErrorBoundary</span>&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><br>&lt;/<span class="hljs-title class_">ErrorBoundary</span>&gt;<br></code></pre></td></tr></table></figure><ul><li>非渲染错误：window.onerror 可以捕捉到</li></ul><h5 id="2-2-1-2-错误上报"><a href="#2-2-1-2-错误上报" class="headerlink" title="2.2.1.2 错误上报"></a>2.2.1.2 错误上报</h5><p><strong>常见的错误上报方式</strong></p><table><thead><tr><th align="center"></th><th align="center">img 请求</th><th align="center">fetch&#x2F;xhr</th><th align="center">navigator.sendBeacon()</th></tr></thead><tbody><tr><td align="center">优点</td><td align="center">兼容性</td><td align="center">兼容性</td><td align="center">不丢点不延迟加载</td></tr><tr><td align="center">缺点</td><td align="center">部分浏览器丢点；延时页面加载；get 长度限制</td><td align="center">fetch 丢点，同步 xhr 不丢点，延迟页面卸载</td><td align="center">兼容性</td></tr></tbody></table><p>丢点：页面卸载时正在上报的请求丢失</p><p><strong>采样上报</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 只采集 20%</span><br><span class="hljs-keyword">if</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &lt; <span class="hljs-number">0.2</span>) &#123;<br><span class="hljs-title function_">collect</span>(data) <span class="hljs-comment">// 记录错误信息</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-2-性能上报原理"><a href="#2-2-2-性能上报原理" class="headerlink" title="2.2.2 性能上报原理"></a>2.2.2 性能上报原理</h4><p>PerformanceTiming：会返回一个对象，从输入 url 到用户可以使用页面的全过程时间统计，单位均为毫秒</p><p>SDK 总结：<br>监听 &#x2F; 劫持 原始方法，获取需要上报的数据、调整数据结构，在错误发生时触发函数上报。</p><h2 id="三、服务器"><a href="#三、服务器" class="headerlink" title="三、服务器"></a>三、服务器</h2><p>这个环节，输入是接口接收到的错误记录，输出是有效的数据入库。其核心功能包括对数据进行清洗和对数据进行入库。</p><h3 id="3-1-数据收集"><a href="#3-1-数据收集" class="headerlink" title="3.1 数据收集"></a>3.1 数据收集</h3><p>主要工作： 提供无状态的 API 服务，逻辑较轻。功能包括为 SDK 提供上报接口，进行 cookie 的识别鉴权</p><h3 id="3-2-数据处理"><a href="#3-2-数据处理" class="headerlink" title="3.2 数据处理"></a>3.2 数据处理</h3><p>•可为报错信息提供纬度补充（IP -&gt; 地理位置）， 设备情况（User-Agent ）等 SDK 拿不到的信息。<br>•由于数据量较大，所以所有数据并不是写在 elasticsearch 的一个索引里面的，这个时候就需要按天建立索引保存数据。</p><h3 id="3-3-错误存储"><a href="#3-3-错误存储" class="headerlink" title="3.3 错误存储"></a>3.3 错误存储</h3><p>常见的技术选型包括：ELK 类系统、Hadoop&#x2F;Hive、日志服务（SLS）</p><ul><li>ELK 系统：Elasticsearch、Logstash、Kibana 三个系统的合称<ul><li>Elasticsearch：一个近实时的分系统的分布式搜索和分析引擎，它可以用于全文搜索，结构化搜索以及分析。监控系统中 Elasticsearch 可以用来完成日志的检索、分析工作。</li><li>Logstash：一个用于管理日志和事件的工具，你可以用它去收集日志、转换日志、解析日志并将他们作为数据提供给其它模块调用，例如搜索、存储等。</li><li>Kibana：一个优秀的前端日志展示框架，它可以非常详细的将日志转化为各种图表，为用户提供强大的数据可视化支持。</li></ul></li></ul><p>日志数据在 ELK 系统流向</p><ul><li><p>Hadoop&#x2F;Hive：Hadoop 是一个存储计算框架，其核心的设计就是：HDFS 和 MapReduce。HDFS 为海量的数据提供了存储，则 MapReduce 为海量的数据提供了计算。Hive 是基于 Hadoop 的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表并提供类 sql 查询功能，减小学习成本。</p></li><li><p>日志服务：由阿里云提供，需要付费。日志服务（SLS）一站式提供数据采集、加工、查询与分析、可视化、告警、消费与投递等功能。</p><table><thead><tr><th align="center"></th><th align="center">ELK 类系统</th><th align="center">Hadoop + Hive</th><th align="center">日志服务</th></tr></thead><tbody><tr><td align="center">可查延时</td><td align="center">1~60 秒</td><td align="center">几分钟~数小时</td><td align="center">实时</td></tr><tr><td align="center">查询延时</td><td align="center">小于 1 秒</td><td align="center">分钟级</td><td align="center">小于 1 秒</td></tr></tbody></table></li></ul><h2 id="四、可视化平台（dofin-为例）"><a href="#四、可视化平台（dofin-为例）" class="headerlink" title="四、可视化平台（dofin 为例）"></a>四、可视化平台（dofin 为例）</h2><p>涉及技术：umi+ant design pro</p><h3 id="4-1-为什么不直接用-Kibana-作为展示的可视化平台？"><a href="#4-1-为什么不直接用-Kibana-作为展示的可视化平台？" class="headerlink" title="4.1 为什么不直接用 Kibana 作为展示的可视化平台？"></a>4.1 为什么不直接用 Kibana 作为展示的可视化平台？</h3><p>在测试 SDK 的时候会对 Kibana 打印的日志数据进行分析。但 Kibana 的日志查询、筛选需要对 Lucene 语法有一定的掌握，面向用户性并不是很好；另一方面 Kinbana 不便于前端做很灵活的扩展，例如用户的身份关联、未来的报警等功能实现；使用 Kibana 做如均值的运算并不利于前端人员做后续维护</p><h3 id="4-2-页面基本需求"><a href="#4-2-页面基本需求" class="headerlink" title="4.2 页面基本需求"></a>4.2 页面基本需求</h3><h4 id="4-2-1-错误查看页面"><a href="#4-2-1-错误查看页面" class="headerlink" title="4.2.1 错误查看页面"></a>4.2.1 错误查看页面</h4><p>可视化平台的最终目的-&gt;how：怎么定位问题<br>实现目的所需要的信息-&gt;what：是什么错误<br>when：什么时候发生的<br>where：发生错误所处的环境、问题所在的页面<br>主要页面 基本需求<br>错误列表 支持多种类型条件搜索，通过筛选来观察错误情况的共通性；通过报错时间来观察同类错误报错频繁度<br>错误详情 能确认错误的特征信息；对同类错误可以提供趋势表，便于观察错误的波动情况</p><h4 id="4-2-2-性能查看页面"><a href="#4-2-2-性能查看页面" class="headerlink" title="4.2.2 性能查看页面"></a>4.2.2 性能查看页面</h4><p>CDN 测距：监听的是 front-end 工程的一个图片加载的起始时间和结束时间<br>server 测距：监听的是目标工程域名下的请求</p><h3 id="4-3-页面扩展需求"><a href="#4-3-页面扩展需求" class="headerlink" title="4.3 页面扩展需求"></a>4.3 页面扩展需求</h3><h4 id="4-3-1-权限管理"><a href="#4-3-1-权限管理" class="headerlink" title="4.3.1 权限管理"></a>4.3.1 权限管理</h4><p>通常一个项目的维护需要一个团队的协作，如果刚接手项目的成员不熟悉系统误操作了工程的删除会对后端维护造成一定的麻烦，因此参考了 gitlab 成员管理原则进行了权限限制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">//route.ts</span><br><span class="hljs-attr">routes</span>: [<br>&#123;<br><span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br><span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;../layouts/BasicLayout&#x27;</span>,<br><span class="hljs-attr">authority</span>: [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>],<br><span class="hljs-attr">routes</span>: [<br>&#123;<br><span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/admin&#x27;</span>,<br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;创建者管理页&#x27;</span>,<br><span class="hljs-attr">authority</span>: [<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>],<span class="hljs-comment">//管理员以上可访问</span><br>],<br>&#125;,<br>......<br><span class="hljs-comment">//basicLayout</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">setAuthorized</span>(<span class="hljs-title function_">getMatchMenu</span>(location.<span class="hljs-property">pathname</span> || <span class="hljs-string">&#x27;/&#x27;</span>, menu, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>).<span class="hljs-title function_">pop</span>() <span class="hljs-keyword">as</span> any || &#123;<br>        <span class="hljs-attr">authority</span>: <span class="hljs-string">&#x27;4&#x27;</span>,<br>    &#125;);<br>&#125;, [location.<span class="hljs-property">pathname</span>,menu.<span class="hljs-property">length</span>]);<br>......<br> &lt;<span class="hljs-title class_">Authorized</span> authority=&#123;authorized!.<span class="hljs-property">authority</span>&#125; noMatch=&#123;noMatch&#125;&gt;<br>    &#123;children&#125;<br>&lt;/<span class="hljs-title class_">Authorized</span>&gt;<br></code></pre></td></tr></table></figure><p>方法：在渲染前获取当前访问的页面的权限（与路由设置的 authority 相关），赋值 authorized.authority，在 Authorized 组件中会将存储在 localStorage 的用户权限等级与组件的 authority 属性进行比较，不匹配则展现默认页面</p><h4 id="4-3-2-未来展望：报警系统"><a href="#4-3-2-未来展望：报警系统" class="headerlink" title="4.3.2 未来展望：报警系统"></a>4.3.2 未来展望：报警系统</h4><p>报警创建思路</p><ol><li>前端针对业务需求设置某类错误的阈值、报警轮询间隔等规则，点击提交时请求与已有的报警规则数据比较，确定是新规则会传到后端</li><li>后端根据规则创建定时任务，定时任务的回调函数判断报错数是否超过设定阈值；同时将报警规则传入数据库</li><li>从日志服务器获取的每分钟错误数超过设定阈值时通过飞书 hook 报警到对应的群</li></ol><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li><a href="https://juejin.cn/post/6987681953424080926#heading-17">https://juejin.cn/post/6987681953424080926#heading-17</a></li><li><a href="https://juejin.cn/post/7016897995031445511#heading-14">https://juejin.cn/post/7016897995031445511#heading-14</a></li><li><a href="https://juejin.cn/post/6862559324632252430#heading-7">https://juejin.cn/post/6862559324632252430#heading-7</a></li><li><a href="https://hub.fastgit.org/kisslove/web-monitoring/blob/e06d28312a17d8a09dbc2997a437f952075c8868/backend_server/business/site.js#L111">https://hub.fastgit.org/kisslove/web-monitoring/blob/e06d28312a17d8a09dbc2997a437f952075c8868/backend_server/business/site.js#L111</a></li><li><a href="https://juejin.cn/post/6960919409267474439#heading-4">https://juejin.cn/post/6960919409267474439#heading-4</a></li></ol>]]></content>
    
    
    <summary type="html">2020技术分享的文档备份</summary>
    
    
    
    <category term="技术分享" scheme="https://unkonwn404.github.io/unkown404.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="前端监控" scheme="https://unkonwn404.github.io/unkown404.github.io/tags/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7/"/>
    
    <category term="分享记录" scheme="https://unkonwn404.github.io/unkown404.github.io/tags/%E5%88%86%E4%BA%AB%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序基础知识</title>
    <link href="https://unkonwn404.github.io/unkown404.github.io/2023/02/27/applet/"/>
    <id>https://unkonwn404.github.io/unkown404.github.io/2023/02/27/applet/</id>
    <published>2023-02-27T13:42:19.000Z</published>
    <updated>2023-02-27T14:57:28.959Z</updated>
    
    <content type="html"><![CDATA[<p>小程序基础知识汇总。</p><span id="more"></span><h2 id="微信小程序结构"><a href="#微信小程序结构" class="headerlink" title="微信小程序结构"></a>微信小程序结构</h2><p>小程序的运行环境分成渲染层和逻辑层，其中 WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。视图层和逻辑层通过 Native 层进行进行通信，并且通过 Native 层获得原生能力。<br>逻辑层和视图层之间的工作方式为：数据变更通过 setData 驱动视图更新；视图层交互触发事件，然后触发逻辑层的事件响应函数，函数中修改数据再次触发视图更新。</p><h2 id="小程序框架"><a href="#小程序框架" class="headerlink" title="小程序框架"></a>小程序框架</h2><p>常见框架：mpvue、taro、uni-app<br>实现流程：</p><ul><li>编译阶段：将其他 DSL（domain-specific language） 转换为符合小程序语法的 WXML、WXSS、JS、JSON；</li><li>运行阶段：数据、事件、生命周期等部分的处理和对接；</li></ul><h3 id="mpvue"><a href="#mpvue" class="headerlink" title="mpvue"></a>mpvue</h3><p>特点：将 Vue 实例和小程序页面实例简单粗暴地做了关联，以达到使用 Vue 开发小程序的目的。</p><h3 id="taro"><a href="#taro" class="headerlink" title="taro"></a>taro</h3><p>特点：</p><ul><li>无 DSL 限制：无论是你们团队是 React 还是 Vue 技术栈，都能够使用 Taro 开发。</li><li>新特性无缝支持：由于 Taro Next 本质上是将 React&#x2F;Vue 运行在小程序上，因此，各种新特性也就无缝支持了。</li></ul><h3 id="uni-app"><a href="#uni-app" class="headerlink" title="uni-app"></a>uni-app</h3><p>特点：</p><ul><li>支持组件局部更新：mpvue 时小程序不支持自定义组件，所以组件编进 Page，更新也是 Page 级</li><li>setData 优化：将数据进行 diff，然后通过 setData 进行路径级别的更新</li></ul><h2 id="微信小程序生命周期"><a href="#微信小程序生命周期" class="headerlink" title="微信小程序生命周期"></a>微信小程序生命周期</h2><p>全局文件 app.js 中定义了一些声明周期的方法</p><p>onLaunch() 监听小程序初始化 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）<br>onShow() 监听小程序显示 当小程序启动，或从后台进入前台显示，会触发 onShow<br>onHide() 监听小程序隐藏 当小程序从前台进入后台，会触发 onHide</p><p>这是每个 page 页面的周期函数</p><p>onLoad() 页面加载时触发，全局只会调用一次，在该周期内可获取当前页面路径的参数<br>onShow() 页面显示时触发或者切入前台时触发，也就是在该周期内可以获取请求数据<br>onReady() 页面初次渲染完成时触发，只会调用一次，代表页面已经可以和视图层进行交互<br>onHide() 页面隐藏或者切入后台时触发，如底部 tab 切换到其他页面或小程序切入后台时触发。<br>onUnload() 页面卸载时触发</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;小程序基础知识汇总。&lt;/p&gt;</summary>
    
    
    
    <category term="前端基础" scheme="https://unkonwn404.github.io/unkown404.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="小程序" scheme="https://unkonwn404.github.io/unkown404.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>英语笔记</title>
    <link href="https://unkonwn404.github.io/unkown404.github.io/2023/02/26/EnglishNotes/"/>
    <id>https://unkonwn404.github.io/unkown404.github.io/2023/02/26/EnglishNotes/</id>
    <published>2023-02-26T09:53:37.000Z</published>
    <updated>2023-02-27T01:50:52.561Z</updated>
    
    <content type="html"><![CDATA[<p>虽然自己现在不需要考证了，不过遇到有意思的演讲、文章还是记录一下自己不熟的词汇之类的，以防水平退步。</p><span id="more"></span><p>adrift adj. 漂流的，随波逐流的；松动的；<br>The survivors were adrift in a lifeboat for six days. 幸存者在救生艇上漂流了六天。<br>young people adrift in the big city 在大城市漂泊的年轻人</p><p>conceivable adj. 可想象的；可信的（possible）<br>It is conceivable that I’ll see her tomorrow. 我可能明天会见到她。</p><p>objective<br>n. 目标；目的<br>meet&#x2F;achieve your objectives 达到 ╱ 实现你的目标<br>adj. 客观的；(objectively adv.)</p><p>gnaw v.咬；啃；啮<br>She gnawed at her fingernails. 她咬手指甲。<br>Self-doubt began to gnaw away at her confidence. 对自己的怀疑渐渐吞噬了她的自信心。</p><p>resilient adj. 可迅速恢复的；有适应力的</p><p>renowned adj.~ (as&#x2F;for sth)有名的；闻名的；受尊敬的<br>It is renowned as one of the region’s best restaurants. 这是本地区最好的饭店之一。<br>She is renowned for her patience. 她的耐心是出了名的。</p><p>flounder<br>v.不知所措;艰苦挣扎<br>She was floundering around in the deep end of the swimming pool. 她在游泳池深水区挣扎着。<br>At that time the industry was floundering. 那时这个行业举步维艰。</p><p>transcendent adj. 卓越的；超常的；出类拔萃的<br>…the idea of a transcendent God who stood apart from mankind. …超越于人类之上的上帝的观点。</p><p>redeem v.补救，掩饰……之不足；挽回（声誉）;偿清；遵守（诺言）<br>The only redeeming feature of the job (&#x3D; good thing about it) is the salary. 这份工作唯一的可取之处就是它的工资。<br>redeem a loan&#x2F;mortgage 清偿贷款╱按揭贷款<br>redeem a pledge&#x2F;promise 遵守诺言</p><p>redemption n.拯救；救赎<br>BEYOND&#x2F;PAST REDEMPTION(too bad to be saved or improved) 无法挽救；不可救药</p><p>smug adj.沾沾自喜的；自鸣得意的</p><p>gist n. ~ (of sth)要点；主旨；大意<br>get (&#x3D; understand) the gist of an argument 理解辩论的主旨</p><p>banal adj.  平庸的；</p><p>cliché n.   陈词滥调；<br>She trotted out the old cliché that ‘a trouble shared is a trouble halved.’ 她又重复了“与人说愁愁减半”的陈词滥调。</p><p>malfunction n. 运转失常；失灵；出现故障</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;虽然自己现在不需要考证了，不过遇到有意思的演讲、文章还是记录一下自己不熟的词汇之类的，以防水平退步。&lt;/p&gt;</summary>
    
    
    
    <category term="英语学习" scheme="https://unkonwn404.github.io/unkown404.github.io/categories/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="词汇" scheme="https://unkonwn404.github.io/unkown404.github.io/tags/%E8%AF%8D%E6%B1%87/"/>
    
  </entry>
  
  <entry>
    <title>node.js</title>
    <link href="https://unkonwn404.github.io/unkown404.github.io/2023/02/26/nodeJs/"/>
    <id>https://unkonwn404.github.io/unkown404.github.io/2023/02/26/nodeJs/</id>
    <published>2023-02-26T08:50:00.000Z</published>
    <updated>2023-03-02T12:52:04.464Z</updated>
    
    <content type="html"><![CDATA[<p>node 基础知识记录</p><span id="more"></span><h2 id="node-模块机制"><a href="#node-模块机制" class="headerlink" title="node 模块机制"></a>node 模块机制</h2><h3 id="require-的模块加载机制"><a href="#require-的模块加载机制" class="headerlink" title="require 的模块加载机制"></a>require 的模块加载机制</h3><ol><li>先计算模块路径</li><li>如果模块在缓存里面，取出缓存</li><li>加载模块</li><li>输出模块的 exports 属性即可</li></ol><h3 id="module-exports-vs-exports"><a href="#module-exports-vs-exports" class="headerlink" title="module.exports vs exports"></a>module.exports vs exports</h3><ul><li>exports 其实就是 module.exports，引用相同（module.exports 默认提供了空对象）</li><li>module.exports 可以直接赋值，exports 不可以，只能以增加健值的方式（模块加载时返回的是 module.exports 的内容）</li><li>如果要输出一个函数或数组，必须直接对 module.exports 对象赋值</li></ul><h3 id="npm-run-XXX-的流程"><a href="#npm-run-XXX-的流程" class="headerlink" title="npm run XXX 的流程"></a>npm run XXX 的流程</h3><ul><li>运行 npm run xxx 的时候，npm 会先在当前目录的 node_modules&#x2F;.bin 查找要执行的程序，如果找到则运行；</li><li>没有找到则从全局的 node_modules&#x2F;.bin 中查找，npm i -g xxx 就是安装到到全局目录；</li><li>如果全局目录还是没找到，那么就从 path 环境变量中查找有没有其他同名的可执行程序。</li></ul><h2 id="node-进程和线程"><a href="#node-进程和线程" class="headerlink" title="node 进程和线程"></a>node 进程和线程</h2><h3 id="进程和线程辨析"><a href="#进程和线程辨析" class="headerlink" title="进程和线程辨析"></a>进程和线程辨析</h3><p>进程：资源分配的最小单位，进程是线程的容器。<br>线程：操作系统能够进行运算调度的最小单位。线程是隶属于进程的，被包含于进程之中。一个线程只能隶属于一个进程，但是一个进程是可以拥有多个线程的。</p><h3 id="node-多进程架构"><a href="#node-多进程架构" class="headerlink" title="node 多进程架构"></a>node 多进程架构</h3><p>使用 child_process 开启多个进程实现多进程单线程模式，使 CPU 的利用率提升。子进程独立于父进程</p><h3 id="创建子进程方法"><a href="#创建子进程方法" class="headerlink" title="创建子进程方法"></a>创建子进程方法</h3><p>模块 child_process 具有以下方法：</p><ul><li>spawn()： 启动一个子进程来执行命令</li><li>exec(): 启动一个子进程来执行命令，与 spawn()不同的是其接口不同，它有一个回调函数获知子进程的状况</li><li>execFlie(): 启动一个子进程来执行可执行文件</li><li>fork(): 与 spawn()类似，不同在于它创建 Node 子进程需要执行 js 文件</li></ul><h2 id="express-vs-koa"><a href="#express-vs-koa" class="headerlink" title="express vs koa"></a>express vs koa</h2><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>Express 中间件实现是基于 Callback 回调函数同步的，它不会去等待异步（Promise）完成<br>Koa 的中间件机制中使用 Async&#x2F;Await（背后全是 Promise）以同步的方式来管理异步代码</p><h4 id="中间件原理"><a href="#中间件原理" class="headerlink" title="中间件原理"></a>中间件原理</h4><p>内部维护一个函数数组，这个函数数组表示在发出响应之前要执行的所有函数，也就是中间件数组使用 app.use(fn)后，传进来的 fn 就会被扔到这个数组里，执行完毕后调用 next()方法执行函数数组里的下一个函数，如果没有调用 next()的话，就不会调用下一个函数了，也就是说调用就会被终止</p><h3 id="洋葱模型实现"><a href="#洋葱模型实现" class="headerlink" title="洋葱模型实现"></a>洋葱模型实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 中间件组合函数，可以参考 https://github.com/koajs/compose/blob/master/index.js</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> Array </span>&#125; <span class="hljs-variable">middlewares</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span>(<span class="hljs-params">ctx, middlewares</span>) &#123;<br>  <span class="hljs-comment">// &#123;1&#125;</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(middlewares)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Middlewares stack must be an array!&#x27;</span>)<br><br>  <span class="hljs-comment">// &#123;2&#125;</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> fn <span class="hljs-keyword">of</span> middlewares) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Middleware must be composed of functions!&#x27;</span>)<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> len = middlewares.<span class="hljs-property">length</span>; <span class="hljs-comment">// &#123;3&#125; 获取数组长度</span><br>    <span class="hljs-keyword">const</span> dispatch = <span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) &#123; <span class="hljs-comment">// &#123;4&#125; 这里是我们实现的关键</span><br>      <span class="hljs-keyword">if</span> (len === i) &#123; <span class="hljs-comment">// &#123;5&#125; 中间件执行完毕</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">const</span> fn = middlewares[i]; <span class="hljs-comment">// &#123;6&#125;</span><br><br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// &#123;7&#125; 这里一定要 bind 下，不要立即执行</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">fn</span>(ctx, dispatch.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, (i + <span class="hljs-number">1</span>))));<br>        &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>          <span class="hljs-comment">// &#123;8&#125; 返回错误</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(err);<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> fn = <span class="hljs-title function_">compose</span>(ctx, middlewares);<br><br><span class="hljs-title function_">fn</span>();<br><br></code></pre></td></tr></table></figure><h2 id="数据库比较：mysql-vs-mongodb"><a href="#数据库比较：mysql-vs-mongodb" class="headerlink" title="数据库比较：mysql vs mongodb"></a>数据库比较：mysql vs mongodb</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>MySQL</strong></p><ul><li>关系型数据库，存储结构化数据</li><li>可以通过外键，主键将不同表中的属性关联起来</li><li>读取数据可以使用 sql</li><li>需通过新增服务器配置来支持规模扩张</li></ul><p><strong>MongoDB</strong></p><ul><li>非关系型数据库，可以在不首先定义结构的情况下创建记录</li><li>不支持表关联</li><li>不能用 sql 查询</li><li>可通过新增服务器实现扩展，解决大量查询问题</li></ul><h3 id="术语对比"><a href="#术语对比" class="headerlink" title="术语对比"></a>术语对比</h3><table><thead><tr><th align="center">MySQL</th><th align="center">MongoDB</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">database</td><td align="center">database</td><td align="center">数据库</td></tr><tr><td align="center">table</td><td align="center">collection</td><td align="center">表&#x2F;集合</td></tr><tr><td align="center">row</td><td align="center">document</td><td align="center">行&#x2F;文档</td></tr><tr><td align="center">column</td><td align="center">field</td><td align="center">字段&#x2F;域</td></tr><tr><td align="center">index</td><td align="center">index</td><td align="center">索引</td></tr><tr><td align="center">join</td><td align="center">嵌入文档</td><td align="center">表关联&#x2F;MongoDB 不支持 join，MongoDB 通过嵌入式文档来替代多表连接</td></tr><tr><td align="center">primary key</td><td align="center">primary key</td><td align="center">主键&#x2F;MongoDB 自动将_id 字段设置为主键</td></tr></tbody></table><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>(1)<a href="https://juejin.cn/post/6844903951742025736">NodeJS 有难度的面试题，你能答对几个？</a><br>(2)<a href="https://juejin.cn/post/6844904071501971469">挑战一轮大厂后的面试总结 (含六个方向) - nodejs 篇</a><br>(3)<a href="https://juejin.cn/post/7078924628525056007">三面面试官：运行 npm run xxx 的时候发生了什么？</a><br>(4)<a href="https://juejin.cn/post/6844904099767386126">多维度分析 Express、Koa 之间的区别</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;node 基础知识记录&lt;/p&gt;</summary>
    
    
    
    <category term="前端基础" scheme="https://unkonwn404.github.io/unkown404.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="node.js" scheme="https://unkonwn404.github.io/unkown404.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>webpack</title>
    <link href="https://unkonwn404.github.io/unkown404.github.io/2023/02/19/webpack/"/>
    <id>https://unkonwn404.github.io/unkown404.github.io/2023/02/19/webpack/</id>
    <published>2023-02-19T06:44:52.000Z</published>
    <updated>2023-02-19T07:14:09.022Z</updated>
    
    <content type="html"><![CDATA[<p>前端 webpack 打包工具方面知识整理。</p><span id="more"></span><h2 id="webpack-基本概念"><a href="#webpack-基本概念" class="headerlink" title="webpack 基本概念"></a>webpack 基本概念</h2><h3 id="webpack-作用"><a href="#webpack-作用" class="headerlink" title="webpack 作用"></a>webpack 作用</h3><p>静态模块打包工具。主要作用：</p><ul><li>模块打包。可以将不同模块的文件打包整合在一起，并且保证它们之间的引用正确，执行有序。</li><li>编译兼容。通过 webpack 的 Loader 机制，编译转换诸如.less，.vue，.jsx 这类在浏览器无法识别的格式文件</li><li>能力扩展。通过 webpack 的 Plugin 机制，我可以进一步实现诸如按需加载，代码压缩等一系列功能</li></ul><h3 id="webpack-构建流程"><a href="#webpack-构建流程" class="headerlink" title="webpack 构建流程"></a>webpack 构建流程</h3><p>初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler<br>编译：从 entry 出发，针对每个 Module 串行调用对应的 loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理<br>输出：将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中</p><h3 id="loader-和-plugin-区别"><a href="#loader-和-plugin-区别" class="headerlink" title="loader 和 plugin 区别"></a>loader 和 plugin 区别</h3><ul><li>功能方面：loader 是文件加载器，能够加载资源文件，并对这些文件进行一些处理；plugin 可以扩展 Webpack 的功能，监听在 Webpack 运行的生命周期中会广播出的许多事件并做处理，解决 loader 无法实现的其他事。</li><li>运行时机方面：loader 运行在打包文件之前；plugin 则是在整个编译周期都起作用。</li><li>配置书写方面：loader 在 module.rules 中配置，作为模块的解析规则，类型为数组，内部包含了 test(类型文件)、loader、options (参数)等属性需要配置。plugin 在 plugins 中单独配置，类型为数组，每一项是一个 plugin 的实例，参数都通过构造函数传入。</li></ul><h3 id="webpack-热更新原理"><a href="#webpack-热更新原理" class="headerlink" title="webpack 热更新原理"></a>webpack 热更新原理</h3><p>webpack-dev-server 与浏览器之间维护了一个 websocket，当本地资源发生变化时，webpack-dev-server 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 webpack-dev-server 发起 Ajax 请求来获取更改内容。后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由 HotModulePlugin 来完成</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/7196630860811075642">2023 前端面试系列– webpack &amp; Git 篇</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前端 webpack 打包工具方面知识整理。&lt;/p&gt;</summary>
    
    
    
    <category term="前端基础" scheme="https://unkonwn404.github.io/unkown404.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="webpack" scheme="https://unkonwn404.github.io/unkown404.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>vscode调试Node代码</title>
    <link href="https://unkonwn404.github.io/unkown404.github.io/2023/02/17/vscodeRunNode/"/>
    <id>https://unkonwn404.github.io/unkown404.github.io/2023/02/17/vscodeRunNode/</id>
    <published>2023-02-17T01:46:55.000Z</published>
    <updated>2023-02-19T05:12:04.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现操作"><a href="#实现操作" class="headerlink" title="实现操作"></a>实现操作</h2><ol><li>点击vscode左侧边栏的三角形状加🐛的符号，如果直接调试当前文件可以先打好断点、点击按钮Run and Debug；如果需要自定义然后点击create a launch.json file</li><li>编辑launch.json<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123;<br>    <span class="hljs-regexp">//</span> 使用 IntelliSense 了解相关属性。 <br>    <span class="hljs-regexp">//</span> 悬停以查看现有属性的描述。<br>    <span class="hljs-regexp">//</span> 欲了解更多信息，请访问: https:<span class="hljs-regexp">//g</span>o.microsoft.com<span class="hljs-regexp">/fwlink/</span>?linkid=<span class="hljs-number">830387</span><br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.2.0&quot;</span>,<br>    <span class="hljs-string">&quot;configurations&quot;</span>: [<br>        &#123;<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;node&quot;</span>,<br>            <span class="hljs-string">&quot;request&quot;</span>: <span class="hljs-string">&quot;launch&quot;</span>,<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;启动程序&quot;</span>,<br>            <span class="hljs-string">&quot;skipFiles&quot;</span>: [<br>                <span class="hljs-string">&quot;&lt;node_internals&gt;/**&quot;</span><br>            ],<br>            <span class="hljs-string">&quot;program&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ul><li>执行单一文件时：修改program的内容，改为要运行的可执行文件或源代码的路径</li><li>调试服务器时：将配置文件修改为如下内容：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;attach&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Attach NestJS WS&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9229</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;restart&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;stopOnEntry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;protocol&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;inspector&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure>request由launch改为了attach，目的是为了将Visual Studio Code的调试器绑定到一个已经处于运行状态的应用。这个配置文件的含义是告诉Visual Studio Code的调试进程，去连接127.0.0.1:9229上的应用调试进程去调试。</li></ul><ol start="3"><li>配置完后点击调试栏的运行，如果是调试服务器接口需要先执行debug指令运行起服务器，以eggjs为例是<code>egg-bin debug</code>；以nest为例是<code>nest start --debug --watch</code>。此时会启动127.0.0.1:9229的调试进程，如果事先打好断点，在postman上调试本地接口时会在对应接口的逻辑断点前停止运行。<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2>（1）<a href="https://juejin.cn/post/6981820158046109703">让你 nodejs 水平暴增的 debugger 技巧</a><br>（2）<a href="https://juejin.cn/post/6844903838864900110">如何用Visual Studio Code远程调试运行在服务器上的nodejs应用</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实现操作&quot;&gt;&lt;a href=&quot;#实现操作&quot; class=&quot;headerlink&quot; title=&quot;实现操作&quot;&gt;&lt;/a&gt;实现操作&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;点击vscode左侧边栏的三角形状加🐛的符号，如果直接调试当前文件可以先打好断点、点击按钮Run and De</summary>
      
    
    
    
    <category term="工作技巧" scheme="https://unkonwn404.github.io/unkown404.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="node.js" scheme="https://unkonwn404.github.io/unkown404.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>面试技巧</title>
    <link href="https://unkonwn404.github.io/unkown404.github.io/2023/02/15/interviewSkill/"/>
    <id>https://unkonwn404.github.io/unkown404.github.io/2023/02/15/interviewSkill/</id>
    <published>2023-02-15T14:15:30.000Z</published>
    <updated>2023-02-19T03:40:53.749Z</updated>
    
    <content type="html"><![CDATA[<ol><li>项目中你遇到的难解决的问题有哪些，最后怎么处理的这种问题<br>难解决的问题分为两种：1.业务问题，需求不清。这时需要拉上懂业务的同事理清需求，必要的时候需要调整设计。同时自主学习，增强对业务的了解。2.技术问题，可能是由于之前技术栈限制导致需求难以实现，或者说现有技术导致实现需求会有性能、可维护性问题，或者是自身储备或者周边资源不足(比如说没有现成的组件库)导致工期比预想长。可以通过最小限度实现需求、请教公司或同项目组的同事寻找合适的工具、交叉集成其他框架等方式解决，但最重要的是及早沟通。</li></ol>]]></content>
    
    
    <summary type="html">面试中常见问题记录</summary>
    
    
    
    <category term="工作技巧" scheme="https://unkonwn404.github.io/unkown404.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="面试" scheme="https://unkonwn404.github.io/unkown404.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端使用shell指令</title>
    <link href="https://unkonwn404.github.io/unkown404.github.io/2023/01/16/shelljs/"/>
    <id>https://unkonwn404.github.io/unkown404.github.io/2023/01/16/shelljs/</id>
    <published>2023-01-16T02:10:25.000Z</published>
    <updated>2023-02-02T10:21:28.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="node-js-使用-shell-指令"><a href="#node-js-使用-shell-指令" class="headerlink" title="node.js 使用 shell 指令"></a>node.js 使用 shell 指令</h2><h3 id="child-process"><a href="#child-process" class="headerlink" title="child_process"></a>child_process</h3><p>node 提供的一个子进程 API</p><h4 id="常见指令"><a href="#常见指令" class="headerlink" title="常见指令"></a>常见指令</h4><h5 id="child-process-spawn-command-args-options"><a href="#child-process-spawn-command-args-options" class="headerlink" title="child_process.spawn(command[, args][, options])"></a>child_process.spawn(command[, args][, options])</h5><p>创建一个新进程来执行指令。指令执行的参数为该函数传入的第二个参数。child_process.spawn 返回 stdout 和 stderr 流对象。 程序可以通过 stdout 的 data、end 或者其他事件来获取子进程返回的数据。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> &#123; spawn &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>);<br><span class="hljs-keyword">const</span> ls = <span class="hljs-title function_">spawn</span>(<span class="hljs-string">&#x27;ls&#x27;</span>, [<span class="hljs-string">&#x27;-lh&#x27;</span>, <span class="hljs-string">&#x27;/usr&#x27;</span>]);<br><br>ls.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`stdout: <span class="hljs-subst">$&#123;data&#125;</span>`</span>);<br>&#125;);<br><br>ls.<span class="hljs-property">stderr</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`stderr: <span class="hljs-subst">$&#123;data&#125;</span>`</span>);<br>&#125;);<br><br>ls.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">code</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`child process exited with code <span class="hljs-subst">$&#123;code&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="child-process-exec-command-options-callback"><a href="#child-process-exec-command-options-callback" class="headerlink" title="child_process.exec(command[, options][, callback])"></a>child_process.exec(command[, options][, callback])</h5><p>创建一个 shell 执行指令。存在数据大小限制。 当子进程返回的数据超过默认大小时，程序就会产生”Error: maxBuffer exceeded”异常。</p><h5 id="child-process-execFile-file-args-options-callback"><a href="#child-process-execFile-file-args-options-callback" class="headerlink" title="child_process.execFile(file[, args][, options][, callback])"></a>child_process.execFile(file[, args][, options][, callback])</h5><p>同 exec 类似，但使用的是制定的文件创建进程执行。需要单独写.sh 文件，可编写复杂逻辑，但在 windows 上使用时会有兼容问题</p><h3 id="shelljs"><a href="#shelljs" class="headerlink" title="shelljs"></a>shelljs</h3><p>基于 nodeAPI 的一个扩展，要引入插件。相比原生的 child_process 的兼容性更好，使用更灵活。<br><strong>安装指令</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span>--save-dev <span class="hljs-keyword">shelljs</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">or</span><br><span class="hljs-keyword"></span>yarn <span class="hljs-keyword">add </span><span class="hljs-keyword">shelljs </span>-D<br></code></pre></td></tr></table></figure><p><strong>使用方法</strong></p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-comment">// 局部模式</span><br><span class="hljs-variable">var</span> <span class="hljs-variable">shell</span> = <span class="hljs-function"><span class="hljs-title">require</span>(<span class="hljs-string">&#x27;shelljs&#x27;</span>);</span><br><span class="hljs-function"><span class="hljs-variable">shell.exec</span>(<span class="hljs-string">&#x27;git add .&#x27;</span>);</span><br><span class="hljs-function"><span class="hljs-variable">shell.exec</span>(<span class="hljs-string">&quot;git commit -m &#x27;auto-commit&#x27;&quot;</span>)</span><br><span class="hljs-variable">shell.exec</span>(<span class="hljs-string">&#x27;git push&#x27;</span>)<br><br><span class="hljs-comment">// 全局模式下，就不需要用shell开头了。</span><br><span class="hljs-function"><span class="hljs-title">require</span>(<span class="hljs-string">&#x27;shelljs/global&#x27;</span>);</span><br><span class="hljs-function"><span class="hljs-title">exec</span>(<span class="hljs-string">&#x27;git add .&#x27;</span>);</span><br><span class="hljs-function"><span class="hljs-title">exec</span>(<span class="hljs-string">&quot;git commit -m &#x27;auto-commit&#x27;&quot;</span>)</span><br><span class="hljs-function"><span class="hljs-title">exec</span>(<span class="hljs-string">&#x27;git push&#x27;</span>)</span><br></code></pre></td></tr></table></figure><h2 id="shell-常用指令"><a href="#shell-常用指令" class="headerlink" title="shell 常用指令"></a>shell 常用指令</h2><h3 id="pwd-显示当前目录名称"><a href="#pwd-显示当前目录名称" class="headerlink" title="pwd - 显示当前目录名称"></a>pwd - 显示当前目录名称</h3><h3 id="ls-显示目录信息"><a href="#ls-显示目录信息" class="headerlink" title="ls - 显示目录信息"></a>ls - 显示目录信息</h3><p><strong>使用参数</strong></p><p>-a :显示包括隐藏文件和目录在内的所有目录和文件</p><p>-l :显示文件的详细信息</p><p>-h :配合-l 以人性化的方式显示文件大小</p><p>-t :按文件最后修改时间排序文件</p><h3 id="cd-目录切换"><a href="#cd-目录切换" class="headerlink" title="cd - 目录切换"></a>cd - 目录切换</h3><p><strong>使用示例</strong></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span> 返回根目录<br><span class="hljs-keyword">cd</span><br><span class="hljs-string">//</span> 返回上一级目录<br><span class="hljs-keyword">cd</span> <span class="hljs-string">..</span><br><span class="hljs-string">//</span> 前往当前文件夹下的某目录<br><span class="hljs-keyword">cd</span> &lt;directory&gt;<br></code></pre></td></tr></table></figure><h3 id="rm-删除文件"><a href="#rm-删除文件" class="headerlink" title="rm - 删除文件"></a>rm - 删除文件</h3><p><strong>使用参数</strong></p><p>-f :强制删除文件</p><p>-r :递归删除目录及内容</p><h3 id="cp-复制文件"><a href="#cp-复制文件" class="headerlink" title="cp - 复制文件"></a>cp - 复制文件</h3><p><strong>指令格式</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cp</span> [<span class="hljs-keyword">options</span>] <span class="hljs-symbol">&lt;source&gt;</span> <span class="hljs-symbol">&lt;dest&gt;</span><br></code></pre></td></tr></table></figure><p><strong>使用参数</strong><br>-a :复制时保留链接、文件属性</p><p>-f :覆盖已经存在的目标文件而不给出提示</p><p>-r :若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件</p><h3 id="echo-显示指定文本"><a href="#echo-显示指定文本" class="headerlink" title="echo - 显示指定文本"></a>echo - 显示指定文本</h3><p><strong>使用示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 显示普通字符串</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello world&quot;</span><br><br><span class="hljs-comment"># 显示转义字符</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\&quot;hello world\&quot;&quot;</span> <span class="hljs-comment"># 此时结果显示为&quot;hello world&quot;</span><br><br><span class="hljs-comment"># 显示变量</span><br>content=<span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;He said <span class="hljs-variable">$&#123;content&#125;</span>&quot;</span><br><br><span class="hljs-comment"># 显示换行</span><br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;hello \n&quot;</span> <span class="hljs-comment"># -e开启转义，即\n可以换行</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;world&quot;</span><br><br><span class="hljs-comment"># 显示结果定向至文件</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello world &gt; test&quot;</span><br></code></pre></td></tr></table></figure><h3 id="chmod-控制用户对文件的权限"><a href="#chmod-控制用户对文件的权限" class="headerlink" title="chmod - 控制用户对文件的权限"></a>chmod - 控制用户对文件的权限</h3><p><strong>指令格式</strong></p><ol><li>参数法</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">chmod <span class="hljs-selector-attr">[user]</span><span class="hljs-selector-attr">[operator]</span><span class="hljs-selector-attr">[permission]</span> &lt;filename&gt;<br></code></pre></td></tr></table></figure><p><strong>使用参数</strong><br><strong>user</strong>：限定权限调整的用户范围</p><ul><li>u：user 表示该文件的所有者</li><li>g：group 表示与该文件的所有者属于同一组( group )者，即用户组</li><li>o：other 表示其它用户组</li><li>a：all 表示这三者皆是</li></ul><p><strong>operator</strong>：权限调整内容</p><ul><li>+：增加权限</li><li>-：撤销权限</li><li>&#x3D;：设定权限</li></ul><p><strong>permission</strong>：权限内容</p><ul><li>r：read，表示可读取，对于一个目录，如果没有 r 权限，那么就意味着不能通过 ls 查看这个目录的内容。</li><li>w：write，表示可写入，对于一个目录，如果没有 w 权限，那么就意味着不能在目录下创建新的文件。</li><li>x：excute，表示可执行，对于一个目录，如果没有 x 权限，那么就意味着不能通过 cd 进入这个目录。</li></ul><ol start="2"><li>数字法</li></ol><p>chmod 命令可以使用八进制数来指定权限。文件或目录的权限位是由 9 个权限位来控制，每三位为一组，它们分别是文件所有者（User）的读、写、执行，用户组（Group）的读、写、执行以及其它用户（Other）的读、写、执行。一组权限位中已设置时置为 1，不设置时置为 0。<br>以权限 rwx 为例，其对应的二进制表示为 111，即 4+2+1，也就是 7.<br><strong>使用示例</strong></p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi"># 表示所有的用户都有读写执行文件<span class="hljs-keyword">file</span>的权利，等同于chmod a=wrx <span class="hljs-keyword">file</span><br>chmod <span class="hljs-number">777</span> <span class="hljs-keyword">file</span><br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://nodejs.org/dist/latest-v12.x/docs/api/child_process.html">Nodejs 文档</a><br>（2）<a href="https://juejin.cn/post/6921734567342637070">如何在 nodejs 执行 shell 指令</a><br>（3）<a href="https://juejin.cn/post/7161392772665540644">package.json 配置完全解读</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;node-js-使用-shell-指令&quot;&gt;&lt;a href=&quot;#node-js-使用-shell-指令&quot; class=&quot;headerlink&quot; title=&quot;node.js 使用 shell 指令&quot;&gt;&lt;/a&gt;node.js 使用 shell 指令&lt;/h2&gt;&lt;h3 i</summary>
      
    
    
    
    <category term="工作技巧" scheme="https://unkonwn404.github.io/unkown404.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="node.js" scheme="https://unkonwn404.github.io/unkown404.github.io/tags/node-js/"/>
    
    <category term="Shell" scheme="https://unkonwn404.github.io/unkown404.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>hash路由使用锚点解决方案</title>
    <link href="https://unkonwn404.github.io/unkown404.github.io/2022/12/16/hashAnchor/"/>
    <id>https://unkonwn404.github.io/unkown404.github.io/2022/12/16/hashAnchor/</id>
    <published>2022-12-16T02:57:34.000Z</published>
    <updated>2023-02-19T03:30:41.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>页面的锚点功能需要 url 的 hash 值与页面的 DOM id 相一致才能进行跳转；而路由在 hash 模式下已经将#占用, 页面的锚点功能失效</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="场景-1-原生锚点"><a href="#场景-1-原生锚点" class="headerlink" title="场景 1:原生锚点"></a>场景 1:原生锚点</h3><p>需要手动获取锚点元素，再使用scrollIntoView方法</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs JSX"><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">CustomLink</span>=(<span class="hljs-params">props:&#123;id:string, children:any&#125;</span>)=&gt; &#123;<br>  <span class="hljs-keyword">const</span> &#123;id,children&#125;=props<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClick</span> = (<span class="hljs-params">e:any</span>) =&gt; &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>();<br>    <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(id);<br>    <span class="hljs-comment">// scrollIntoView()将目标元素移动到浏览器顶部</span><br>    <span class="hljs-comment">// scrollIntoView(false)将目标元素移动到浏览器底部</span><br>    element?.<span class="hljs-title function_">scrollIntoView</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onClick&#125;</span>&gt;</span>&#123;children&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> &gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;anchor&#x27;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">CustomLink</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;test1&#x27;</span>&gt;</span>test1<span class="hljs-tag">&lt;/<span class="hljs-name">CustomLink</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">CustomLink</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;test2&#x27;</span>&gt;</span>test2<span class="hljs-tag">&lt;/<span class="hljs-name">CustomLink</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">height:</span> &#x27;<span class="hljs-attr">600vh</span>&#x27;, <span class="hljs-attr">padding:</span> <span class="hljs-attr">8</span> &#125;&#125;&gt;</span>Scroll to bottom<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;test1&#x27;</span>&gt;</span>test1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Scroll to bottom<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">height:</span> &#x27;<span class="hljs-attr">600vh</span>&#x27;, <span class="hljs-attr">padding:</span> <span class="hljs-attr">8</span> &#125;&#125;&gt;</span>Scroll to bottom<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Scroll to bottom<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">height:</span> &#x27;<span class="hljs-attr">600vh</span>&#x27;, <span class="hljs-attr">padding:</span> <span class="hljs-attr">8</span> &#125;&#125; <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;test2&#x27;</span>&gt;</span>test2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Scroll to bottom<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="场景-2-antd-的-anchor-组件"><a href="#场景-2-antd-的-anchor-组件" class="headerlink" title="场景 2:antd 的 anchor 组件"></a>场景 2:antd 的 anchor 组件</h3><p>anchor 组件在点击锚点后会修改 URL，而单页应用中如果使用哈希模式的路由，当 URL 被修改后，刷新页面会导致当前路由没有定义而出现 404 的情况。<br>对于这一情况的解决方案就是利用组件的 onClick 事件阻止默认的 url 修改</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JSX"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Anchor</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;antd&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; useHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;umi&#x27;</span>;<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Link</span> &#125; = <span class="hljs-title class_">Anchor</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> history = <span class="hljs-title function_">useHistory</span>();<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Anchor</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;(event:</span> <span class="hljs-attr">Event</span>, <span class="hljs-attr">link:</span> &#123; <span class="hljs-attr">href:</span> <span class="hljs-attr">string</span>; <span class="hljs-attr">title</span>?<span class="hljs-attr">:</span> <span class="hljs-attr">string</span> &#125;) =&gt;</span> &#123;</span><br><span class="language-xml">        event.preventDefault();</span><br><span class="language-xml">        history.push(`$&#123;history.location.pathname&#125;$&#123;link.href&#125;`);</span><br><span class="language-xml">      &#125;&#125;</span><br><span class="language-xml">    &gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#何时使用&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;何时使用&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#代码演示&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;代码演示&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#api&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;API&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#anchor-props&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Anchor Props&quot;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#link-props&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Link Props&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#faq&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;FAQ&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Anchor</span>&gt;</span></span><br>  );<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>经过实际测试发现，调用 event.preventDefault()之后，只会阻止 URL 被修改，并不会阻止点击锚点后的滚动事件。所以不需要像原生场景一样使用 scrollView 函数。但为了url和锚点相对应，增加了history.push函数来实现。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://blog.csdn.net/weixin_43487782/article/details/108873639">antd的anchor组件点击锚点导致路由发生变化</a><br>（2）<a href="https://blog.csdn.net/Whoopsina/article/details/123804087">项目中使用了Hash路由时如何同时使用锚点？</a></p>]]></content>
    
    
    <summary type="html">路由在 hash 模式下已经将#占用, 页面的锚点功能失效</summary>
    
    
    
    <category term="踩坑经历" scheme="https://unkonwn404.github.io/unkown404.github.io/categories/%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="前端路由" scheme="https://unkonwn404.github.io/unkown404.github.io/tags/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>代码样式调整</title>
    <link href="https://unkonwn404.github.io/unkown404.github.io/2022/12/15/codeFormat/"/>
    <id>https://unkonwn404.github.io/unkown404.github.io/2022/12/15/codeFormat/</id>
    <published>2022-12-15T14:25:36.000Z</published>
    <updated>2023-02-19T03:19:04.422Z</updated>
    
    <content type="html"><![CDATA[<p>为了使代码风格统一，更有利于阅读，可以借助一些工具进行优化。</p><span id="more"></span><h2 id="prettier"><a href="#prettier" class="headerlink" title="prettier"></a>prettier</h2><p>代码格式化工具。</p><h3 id="安装指令"><a href="#安装指令" class="headerlink" title="安装指令"></a>安装指令</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span>--save-dev prettier<br><span class="hljs-keyword">or</span><br><span class="hljs-keyword"></span>yarn <span class="hljs-keyword">add </span>prettier -D<br></code></pre></td></tr></table></figure><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><p>在根目录新建 .prettierrc.json，配置自己所需要的参数：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123;<br>  <span class="hljs-string">&quot;singleQuote&quot;</span>: true,  <span class="hljs-regexp">//</span> 使用单引号<br>  <span class="hljs-string">&quot;semi&quot;</span>: false,  <span class="hljs-regexp">//</span> 不使用分号<br>  <span class="hljs-string">&quot;bracketSpacing&quot;</span>: true,  <span class="hljs-regexp">//</span> 在对象,数组括号与文字之间加空格<br>  <span class="hljs-string">&quot;htmlWhitespaceSensitivity&quot;</span>: <span class="hljs-string">&quot;ignore&quot;</span>,  <span class="hljs-regexp">//</span> 对html的空格不敏感<br>  <span class="hljs-string">&quot;endOfLine&quot;</span>: <span class="hljs-string">&quot;auto&quot;</span>,  <span class="hljs-regexp">//</span> 行结尾统一样式，保持现有的行尾<br>  <span class="hljs-string">&quot;trailingComma&quot;</span>: <span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-regexp">//</span> 对象，数组等末尾不加逗号<br>  <span class="hljs-string">&quot;tabWidth&quot;</span>: <span class="hljs-number">2</span> <span class="hljs-regexp">//</span>  水平缩进的空格数为<span class="hljs-number">2</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="lint-staged"><a href="#lint-staged" class="headerlink" title="lint-staged"></a>lint-staged</h2><p>本地暂存代码检查工具。只检测 git add . 中暂存区的文件，对过滤出的文件执行脚本。</p><h3 id="安装指令-1"><a href="#安装指令-1" class="headerlink" title="安装指令"></a>安装指令</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span>lint-staged --save-dev<br><span class="hljs-keyword">or</span><br><span class="hljs-keyword"></span>yarn <span class="hljs-keyword">add </span>lint-staged -D<br></code></pre></td></tr></table></figure><h3 id="配置方式-1"><a href="#配置方式-1" class="headerlink" title="配置方式"></a>配置方式</h3><p>lint-staged 从 v3.1 开始可以使用不同的方式进行配置：</p><ul><li>package.json<br>示例：</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;lint-staged&quot;</span>: &#123;<br>    <span class="hljs-regexp">//</span> 匹配暂存区所有的js，vue文件，并执行命令<br>  <span class="hljs-string">&quot;*.&#123;js,vue,jsx,tsx&#125;&quot;</span>: [<br>    <span class="hljs-string">&quot;prettier --write&quot;</span>,<br>    <span class="hljs-string">&quot;eslint --cache --fix&quot;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>配置对象的 key 值为匹配的文件，右侧 value 对应执行指令。lint-staged 指令自动在最后包含了 git add 的操作，所以可以不用专门去写</p><ul><li>.lintstagedrc JSON 或 YML 格式的文件</li><li>lint-staged.config.js 格式的文件</li></ul><h2 id="husky"><a href="#husky" class="headerlink" title="husky"></a>husky</h2><p>Git hooks 工具，对 git 执行的一些命令，通过对应的 hooks 钩子触发，执行自定义的脚本程序。<br>常用的 gitHooks 包括：</p><ul><li>pre-commit：每次 commit 之前会执行的操作，常用于触发时进行代码格式验证</li><li>commit-msg：启动提交信息编辑器，常用于对 commit 消息和用户进行校验</li><li>pre-push：远程推代码前执行，常用于推代码前做单元测试和 e2e</li></ul><h3 id="安装指令-2"><a href="#安装指令-2" class="headerlink" title="安装指令"></a>安装指令</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">npm</span> install husky@<span class="hljs-number">4</span>.<span class="hljs-number">3</span> --save-dev<br><span class="hljs-attribute">or</span><br><span class="hljs-attribute">yarn</span> add husky@<span class="hljs-number">4</span>.<span class="hljs-number">3</span> -D<br></code></pre></td></tr></table></figure><h3 id="配置方式-2"><a href="#配置方式-2" class="headerlink" title="配置方式"></a>配置方式</h3><p>husky 版本在 6 以下时可以直接在 package.json 配置，例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;husky&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;hooks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;pre-commit&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;lint-staged&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>6 版本以上的 husky 把的配置提取到了根目录，package.json 中的配置在 husky 升级后无效了。需要执行指令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">npx husky <span class="hljs-keyword">add</span><span class="language-bash"> .husky/pre-commit <span class="hljs-string">&quot;npx lint-staged&quot;</span></span><br></code></pre></td></tr></table></figure><p>指令执行后会在根目录创建 .husky 文件夹，文件夹内部有一个 pre-commit 文件，包含指令 npx lint-staged</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://www.npmjs.com/package/lint-staged#Configuration">lint-staged 官方文档</a><br>（2）<a href="https://www.prettier.cn/docs/index.html">prettier 官方文档</a><br>（3）<a href="https://juejin.cn/post/6947200436101185566">GitHook 工具 —— husky（格式化代码）</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;为了使代码风格统一，更有利于阅读，可以借助一些工具进行优化。&lt;/p&gt;</summary>
    
    
    
    <category term="工作技巧" scheme="https://unkonwn404.github.io/unkown404.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="代码规范" scheme="https://unkonwn404.github.io/unkown404.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>package.json分析</title>
    <link href="https://unkonwn404.github.io/unkown404.github.io/2022/12/15/packageJson/"/>
    <id>https://unkonwn404.github.io/unkown404.github.io/2022/12/15/packageJson/</id>
    <published>2022-12-15T02:41:29.000Z</published>
    <updated>2023-02-19T03:19:04.429Z</updated>
    
    <content type="html"><![CDATA[<p>虽然管理维护前端项目时经常需要跟该文件打交道，但在安装代码规范相关工具时，发现自己对其中的配置并不十分了解，所以想记录一下。</p><span id="more"></span><h2 id="文件配置"><a href="#文件配置" class="headerlink" title="文件配置"></a>文件配置</h2><p>描述配置在这里略过不计，除非自己要写包，不然感觉记忆没什么用</p><h3 id="workspaces"><a href="#workspaces" class="headerlink" title="workspaces"></a>workspaces</h3><p>workspaces 主要用于 monorepo 仓库管理模式、解决如何在一个顶层 root package 下管理多个子 packages 的问题，在 workspaces 声明目录下的 package 会软链到最上层 root package 的 node_modules 中，不用手动执行 npm link 操作。</p><p>通常子项目都会平铺管理在 packages 目录下，所以根目录下 workspaces 通常配置为：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-string">&quot;workspaces&quot;</span>: [<br>  <span class="hljs-string">&quot;packages/*&quot;</span><br>]<br></code></pre></td></tr></table></figure><h2 id="脚本配置"><a href="#脚本配置" class="headerlink" title="脚本配置"></a>脚本配置</h2><h3 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h3><p>指定项目的一些内置脚本命令，这些命令可以通过 npm run 来执行。npm run 的时候，就会自动创建一个 shell 脚本，将本地目录的 node_modules&#x2F;.bin 子目录加入 PATH 变量。这意味着，当前目录的 node_modules&#x2F;.bin 子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>  <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack&quot;</span>,<br>  <span class="hljs-string">&quot;prebuild&quot;</span>: <span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-regexp">//</span> build 执行之前的钩子<br>  <span class="hljs-string">&quot;postbuild&quot;</span>: <span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-regexp">//</span> build 执行之后的钩子<br>&#125;<br></code></pre></td></tr></table></figure><p>如果存在前缀指令<code>pre-*</code>、<code>post-*</code>的话，执行指令 npm run build 时会按照<code>prebuild - build - postbuild</code>执行顺序执行，这种语法现在并不推崇，需谨慎使用。</p><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>用于设置 scripts 里的脚本在运行时的参数。</p><h2 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h2><h3 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h3><p>运行依赖，也就是项目生产环境下需要用到的依赖。比如 react，vue，状态管理库以及组件库等。</p><p>使用 npm install xxx 或则 npm install xxx –save 时，会被自动插入到该字段中。</p><h3 id="devDependencies"><a href="#devDependencies" class="headerlink" title="devDependencies"></a>devDependencies</h3><p>开发依赖，项目开发环境需要用到而运行时不需要的依赖，用于辅助开发，通常包括项目工程化工具比如 webpack，vite，eslint 等。<br>使用 npm install xxx -D 或者 npm install xxx –save-dev 时，会被自动插入到该字段中。</p><h2 id="三方配置"><a href="#三方配置" class="headerlink" title="三方配置"></a>三方配置</h2><p>package.json 中也存在很多三方属性，比如 tsc 中使用的 types、构建工具中使用的 sideEffects,git 中使用的 husky，eslint 使用的 eslintIgnore。这里只列举部分属性。</p><h3 id="lint-staged"><a href="#lint-staged" class="headerlink" title="lint-staged"></a>lint-staged</h3><p>lint-staged 是一个在 Git 暂存文件上运行 linters 的工具，配置后每次修改一个文件即可给所有文件执行一次 lint 检查，通常配合 gitHooks 一起使用。</p><h3 id="browserslist"><a href="#browserslist" class="headerlink" title="browserslist"></a>browserslist</h3><p>browserslist 字段用来告知支持哪些浏览器及版本。也可以使用 .browserslistrc 单文件配置。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-string">&quot;browserslist&quot;</span>: [<br>  <span class="hljs-string">&quot;&gt; 1%&quot;</span>,<br>  <span class="hljs-string">&quot;last 2 versions&quot;</span><br>]<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://juejin.cn/post/7099041402771734559">深入浅出 package.json</a><br>（2）<a href="https://juejin.cn/post/7023539063424548872">关于前端大管家 package.json，你知道多少？</a><br>（3）<a href="https://juejin.cn/post/7161392772665540644">package.json 配置完全解读</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;虽然管理维护前端项目时经常需要跟该文件打交道，但在安装代码规范相关工具时，发现自己对其中的配置并不十分了解，所以想记录一下。&lt;/p&gt;</summary>
    
    
    
    <category term="技术学习" scheme="https://unkonwn404.github.io/unkown404.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="前端依赖包管理" scheme="https://unkonwn404.github.io/unkown404.github.io/tags/%E5%89%8D%E7%AB%AF%E4%BE%9D%E8%B5%96%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>react中获取ref相关的函数总结</title>
    <link href="https://unkonwn404.github.io/unkown404.github.io/2022/12/09/reactRef/"/>
    <id>https://unkonwn404.github.io/unkown404.github.io/2022/12/09/reactRef/</id>
    <published>2022-12-09T06:15:58.000Z</published>
    <updated>2023-02-19T03:19:04.431Z</updated>
    
    <content type="html"><![CDATA[<p>虽然 react 中很少使用操作 DOM 的逻辑，但为了能够理解开源代码，还是整理记录了常用的几个相关函数。</p><span id="more"></span><h2 id="获取-react-元素"><a href="#获取-react-元素" class="headerlink" title="获取 react 元素"></a>获取 react 元素</h2><h3 id="createRef"><a href="#createRef" class="headerlink" title="createRef"></a>createRef</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>常用于 class 组件（函数组件也可以用）</li><li>可获取原生 DOM 和自定义 class 组件的引用</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">//父组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoFocusTextInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  constructor(props) &#123;<br>    <span class="hljs-keyword">super</span>(props);<br>    <span class="hljs-keyword">this</span>.textInput = <span class="hljs-type">React</span>.createRef();<br>  &#125;<br><br>  componentDidMount() &#123;<br>    <span class="hljs-keyword">this</span>.textInput.current.focusTextInput();<br>  &#125;<br><br>  render() &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;<span class="hljs-type">CustomTextInput</span> ref=&#123;<span class="hljs-keyword">this</span>.textInput&#125; /&gt;<br>    );<br>  &#125;<br>&#125;<br><span class="hljs-comment">//子组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomTextInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  constructor(props) &#123;<br>    <span class="hljs-keyword">super</span>(props);<br>    <span class="hljs-comment">// 创建一个 ref 来存储 textInput 的 DOM 元素</span><br>    <span class="hljs-keyword">this</span>.textInput = <span class="hljs-type">React</span>.createRef();<br>    <span class="hljs-keyword">this</span>.focusTextInput = <span class="hljs-keyword">this</span>.focusTextInput.bind(<span class="hljs-keyword">this</span>);<br>  &#125;<br><br>  focusTextInput() &#123;<br>    <span class="hljs-comment">// 直接使用原生 API 使 text 输入框获得焦点</span><br>    <span class="hljs-comment">// 注意：我们通过 &quot;current&quot; 来访问 DOM 节点</span><br>    <span class="hljs-keyword">this</span>.textInput.current.focus();<br>  &#125;<br><br>  render() &#123;<br>    <span class="hljs-comment">// 告诉 React 我们想把 &lt;input&gt; ref 关联到</span><br>    <span class="hljs-comment">// 构造器里创建的 `textInput` 上</span><br>    <span class="hljs-keyword">return</span> (<br>      &lt;div&gt;<br>        &lt;input<br>          <span class="hljs-class"><span class="hljs-keyword">type</span></span>=<span class="hljs-string">&quot;text&quot;</span><br>          ref=&#123;<span class="hljs-keyword">this</span>.textInput&#125; /&gt;<br>        &lt;input<br>          <span class="hljs-class"><span class="hljs-keyword">type</span></span>=<span class="hljs-string">&quot;button&quot;</span><br>          value=<span class="hljs-string">&quot;Focus the text input&quot;</span><br>          onClick=&#123;<span class="hljs-keyword">this</span>.focusTextInput&#125;<br>        /&gt;<br>      &lt;/div&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>createRef 每次渲染都会返回一个新的引用</li></ol><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const createRef = <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> &#123; current: <span class="hljs-literal">null</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol><li>只能用于函数组件</li><li>useRef 的引用存在于组件的整个生命周期</li></ol><h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">let obj = &#123; current: <span class="hljs-literal">null</span> &#125;<br><br>const useRef = <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> obj<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>createRef 与 useRef 区别</strong><br>虽然都是用于创建 ref 属性、访问 DOM 实例对象，但两者适用的组件语法略有差异：createRef 更适用于 class 组件，由于其并没有 Hooks 的效果，其内部的值会随着函数组件重复执行而不断被初始化，而在 class 组件中由于分离了生命周期，使初始化时机仅执行一次。</p></blockquote><p>以下面的代码为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; createRoot &#125; = <span class="hljs-title class_">ReactDOM</span>;<br><span class="hljs-keyword">const</span> &#123; useRef, useState, createRef &#125; = <span class="hljs-title class_">React</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>   <span class="hljs-keyword">const</span> [renderIndex,setRenderIndex] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> refFromUseRef = <span class="hljs-title function_">useRef</span>();<br>   <span class="hljs-keyword">const</span> refFromCreateRef = <span class="hljs-title function_">createRef</span>();<br><br><br>    <span class="hljs-keyword">if</span> (!refFromUseRef.<span class="hljs-property">current</span>)&#123;<br>       refFromUseRef.<span class="hljs-property">current</span>=renderIndex<br>   &#125;<br>    <span class="hljs-keyword">if</span> (!refFromCreateRef.<span class="hljs-property">current</span>) &#123;<br>        refFromCreateRef.<span class="hljs-property">current</span> = renderIndex<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>index &#123;renderIndex&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>refFromUseRef &#123;refFromUseRef.current&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>refFromCreateRef &#123;refFromCreateRef.current&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123; setRenderIndex(p=&gt;p+1)&#125;&#125;&gt;a<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ComponentDemo</span> = <span class="hljs-title class_">App</span>;<br><span class="hljs-title function_">createRoot</span>(mountNode).<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ComponentDemo</span> /&gt;</span></span>);<br><br></code></pre></td></tr></table></figure><p>在执行的过程中会发现即使组件重新渲染, 由于 refFromUseRef 的值一直存在(类似于 this ) , 无法重新赋值；而 refFromCreateRef 会随组件渲染不断改变引用值。</p><h2 id="父组件获取子组件内部的一个元素"><a href="#父组件获取子组件内部的一个元素" class="headerlink" title="父组件获取子组件内部的一个元素"></a>父组件获取子组件内部的一个元素</h2><h3 id="forwardRef"><a href="#forwardRef" class="headerlink" title="forwardRef"></a>forwardRef</h3><p>获取函数子组件内部元素的 ref 得用 forwardRef，因为 ref 不像 props 作为参数可以传递。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 父元素。可以直接获取 DOM button 的 ref：</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span>=(<span class="hljs-params"></span>)=&gt;&#123;<br>    <span class="hljs-keyword">const</span> ref = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>();<br>    <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">FancyButton</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span>&gt;</span>Click me!<span class="hljs-tag">&lt;/<span class="hljs-name">FancyButton</span>&gt;</span></span>)<br>&#125;<br><br><span class="hljs-comment">//子元素</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">FancyButton</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;FancyButton&quot;</span>&gt;</span></span><br><span class="language-xml">    &#123;props.children&#125;</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>));<br></code></pre></td></tr></table></figure><h2 id="父组件获取子组件内部多个元素-x2F-方法"><a href="#父组件获取子组件内部多个元素-x2F-方法" class="headerlink" title="父组件获取子组件内部多个元素&#x2F;方法"></a>父组件获取子组件内部多个元素&#x2F;方法</h2><h3 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h3><p>useImperativeHandle 需要和 forwardRef 结合使用。可以让你在使用 ref 时自定义暴露给父组件的实例值。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const FancyInput= React.forwardRef(props, ref) =&gt; &#123;<br>  const inputRef = useRef();<br>  useImperativeHandle(ref, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (&#123;<br>    focus: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      inputRef.current.focus();<br>    &#125;<br>  &#125;));<br>  <span class="hljs-keyword">return</span> &lt;input ref=&#123;inputRef&#125; ... /&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>本例中渲染<code> &lt;FancyInput ref=&#123;inputRef&#125; /&gt;</code> 的父组件可以调用 inputRef.current.focus()。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://blog.csdn.net/frontend_frank/article/details/104243286">什么是 useRef , useRef 与 createRef 区别, 以及在什么情况下使用 useRef</a><br>（2）<a href="https://juejin.cn/post/6844904079164964878">精读《useRef 与 createRef 的区别》</a><br>（3）<a href="https://juejin.cn/post/7146095092674068487">一文学会 useImperativeHandle</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;虽然 react 中很少使用操作 DOM 的逻辑，但为了能够理解开源代码，还是整理记录了常用的几个相关函数。&lt;/p&gt;</summary>
    
    
    
    <category term="前端技术体系" scheme="https://unkonwn404.github.io/unkown404.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="React" scheme="https://unkonwn404.github.io/unkown404.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>页面置灰的实现方式</title>
    <link href="https://unkonwn404.github.io/unkown404.github.io/2022/12/02/cssUsage/"/>
    <id>https://unkonwn404.github.io/unkown404.github.io/2022/12/02/cssUsage/</id>
    <published>2022-12-02T01:46:33.000Z</published>
    <updated>2022-12-13T08:57:22.748Z</updated>
    
    <content type="html"><![CDATA[<p>记一次 css 踩坑经历</p><span id="more"></span><h2 id="业务需求描述"><a href="#业务需求描述" class="headerlink" title="业务需求描述"></a>业务需求描述</h2><p>涉及一些重要的悼念活动时，需要将网站主页面置为灰色，同时希望不要影响其他功能页面的颜色</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>可将页面的 CSS 样式设置为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css">.<span class="hljs-selector-attr">[classname]</span>  &#123;<br>    -webkit-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    -moz-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    -ms-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    -o-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    <span class="hljs-attribute">filter</span>: gray;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的点是如果页面组件有 fixed 定位，上述 css 写法可能会导致组件位置出现问题，根据 MDN 的文档，对 position 定位有下面一段描述：</p><blockquote><p><strong>fixed</strong><br>元素会被移出正常文档流，并不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform, perspective 或 filter 属性非 none 时，容器由视口改为该祖先。</p></blockquote><p><strong>解决方法：</strong><br>将 filter 的样式写在 html 上。<br><strong>注意点：</strong></p><ol><li>非 SPA 项目处理时书写方式最好是：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>  &#123;<br>    -webkit-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    -moz-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    -ms-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    -o-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    <span class="hljs-attribute">filter</span>: gray;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是因为尽管 html5.0 规范允许在<code>&lt;html&gt;</code>标签上添加 class 属性，但没有保证该 class 属性一定能生效。</p><ol start="2"><li>处理 SPA 页面时如果书写上述样式，会导致所有页面样式都会变灰。比较好的实现方式是利用页面的生命周期，为 html 节点手动添加样式。并在页面跳转时去除变灰样式。这里以 react 为例：</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">componentDidMount</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">if</span>(global.document)&#123;<br>      const html=document<span class="hljs-selector-class">.getElementsByTagName</span>(<span class="hljs-string">&#x27;html&#x27;</span>)<br>      <span class="hljs-built_in">if</span>(<span class="hljs-selector-tag">html</span><span class="hljs-selector-attr">[0]</span>)&#123;<br>        <span class="hljs-selector-tag">html</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.style</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;filter&#x27;</span> as any]</span>=<span class="hljs-string">&#x27;grayscale(100%)&#x27;</span><br>      &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">componentWillUnmount</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">if</span>(global.document)&#123;<br>        const html=document<span class="hljs-selector-class">.getElementsByTagName</span>(<span class="hljs-string">&#x27;html&#x27;</span>)<br>        <span class="hljs-built_in">if</span>(<span class="hljs-selector-tag">html</span><span class="hljs-selector-attr">[0]</span>)&#123;<br>            <span class="hljs-selector-tag">html</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.style</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;filter&#x27;</span>  as any]</span>=<span class="hljs-string">&#x27;none&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>使用 js 添加样式时，如果代码使用了 ts 语法，可能会报错：<code>Element implicitly has an &#39;any&#39; type because index expression is not of type &#39;number&#39;</code>，这是因为 CSSStyleDeclaration 它的 index 值设置为了 number 而不是 string，这个报错的根本原因，兼容浏览器的 css 属性<code>-webkit-*</code>、<code>-o-*</code>等已经不在 CSSStyleDeclaration 内部了。考虑到现在大部分浏览器都支持 css3 了，兼容性写法可以适时去掉</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position">MDN position</a><br>（2）<a href="https://stackoverflow.com/questions/53526178/element-implicitly-has-an-any-type-because-index-expression-is-not-of-type-nu">Element implicitly has an ‘any’ type because index expression is not of type ‘number’ [7015]</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记一次 css 踩坑经历&lt;/p&gt;</summary>
    
    
    
    <category term="踩坑经历" scheme="https://unkonwn404.github.io/unkown404.github.io/categories/%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="CSS" scheme="https://unkonwn404.github.io/unkown404.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>js实现从utf-8到base64编码</title>
    <link href="https://unkonwn404.github.io/unkown404.github.io/2022/11/29/encodeBase64/"/>
    <id>https://unkonwn404.github.io/unkown404.github.io/2022/11/29/encodeBase64/</id>
    <published>2022-11-29T13:42:55.000Z</published>
    <updated>2022-12-13T08:57:22.748Z</updated>
    
    <content type="html"><![CDATA[<p>编码知识小记</p><span id="more"></span><h2 id="编码相关概念的辨析"><a href="#编码相关概念的辨析" class="headerlink" title="编码相关概念的辨析"></a>编码相关概念的辨析</h2><h3 id="编码历史"><a href="#编码历史" class="headerlink" title="编码历史"></a>编码历史</h3><p>计算机起源之初，科学家对英语字符与二进制位之间的关系做了统一规定，定义了 128 个字符的编码规则，用七位二进制表示。这套编码规则被称为 ASCII 编码。随着计算机的普及，在不同的地区和国家，当地程序员为了适应本地的语言使用创建了新的字符编码。但不同国家间读取内容时由于编码方式的差异会导致内容乱码，对国际沟通交流造成了障碍。</p><p>这时候 Unicode 就出现了。 Unicode 是国际标准字符集，它将世界各种语言的每个字符定义一个唯一的编码，以满足跨语言、跨平台的文本信息转换。Unicode 字符集的编码范围是 0x0000 - 0x10FFFF , 可以容纳一百多万个字符， 每个字符都有一个独一无二的编码，也即每个字符都有一个二进制数值和它对应。</p><h3 id="Unicode、utf-8、utf-16-辨析"><a href="#Unicode、utf-8、utf-16-辨析" class="headerlink" title="Unicode、utf-8、utf-16 辨析"></a>Unicode、utf-8、utf-16 辨析</h3><p>Unicode 只是字符集，即很多个字符的集合；而 UTF-8、UTF-16、UTF-32 才是真正的字符编码规则：utf-8 是用一个字节来编码所有的字符，utf-16 是用两个字节来编码所有的字符，utf-32 则选择用 4 个字节来编码。<br>其中最常见的编码规则是 utf-8，因为互联网的大部分资源都是英文的，使用 utf-8 保存更节省空间。Unicode 转 utf-8 主要是变长编码，有具体表格展示不同 unicode 的编码规则，这里不再赘述。</p><h3 id="Base64-编码"><a href="#Base64-编码" class="headerlink" title="Base64 编码"></a>Base64 编码</h3><p>Base64 的编码方法要求把每三个 8bit 的字节转换成四个 6bit 的字节，然后把 6Bit 再添两位高位 0，组成四个 8Bit 的字节。经过 base64 编码后的字符串会比原来长 1&#x2F;3。</p><h2 id="前端页面表单数据转-base64"><a href="#前端页面表单数据转-base64" class="headerlink" title="前端页面表单数据转 base64"></a>前端页面表单数据转 base64</h2><p>需要注意的点是虽然 html 和 js 的编码是 utf-8，但 js 从页面得到的中文是 utf-16 编码，直接转 base64 是会出错的。<br>MDN 上给出了最简单的解决方法：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> utf8<span class="hljs-constructor">_to_b64(<span class="hljs-params">str</span>)</span> &#123;<br>  return window.btoa(unescape(encode<span class="hljs-constructor">URIComponent(<span class="hljs-params">str</span>)</span>));<br>&#125;<br><br><span class="hljs-keyword">function</span> b64<span class="hljs-constructor">_to_utf8(<span class="hljs-params">str</span>)</span> &#123;<br>  return decode<span class="hljs-constructor">URIComponent(<span class="hljs-params">escape</span>(<span class="hljs-params">window</span>.<span class="hljs-params">atob</span>(<span class="hljs-params">str</span>)</span>));<br>&#125;<br><br><span class="hljs-comment">// Usage:</span><br>utf8<span class="hljs-constructor">_to_b64(<span class="hljs-string">&quot;✓ à la mode&quot;</span>)</span>; <span class="hljs-comment">// &quot;4pyTIMOgIGxhIG1vZGU=&quot;</span><br>b64<span class="hljs-constructor">_to_utf8(<span class="hljs-string">&quot;4pyTIMOgIGxhIG1vZGU=&quot;</span>)</span>; <span class="hljs-comment">// &quot;✓ à la mode&quot;</span><br></code></pre></td></tr></table></figure><p>里面涉及的流程是：</p><ol><li>先用 encodeURIComponent 把 js 的字符串转成 UTF-8 的百分号编码形式。该方法不会对 ASCII 字母和数字及部分 ASCII 标点符号进行编码，非英文字符会先转为 UTF8 的字节码，然后前面加个%进行拼接；</li><li>再用 unescape 把百分号编码按字节转化成对应的含有 Latin-1 字符集字符的 js 字符串 （即使它是乱码）；</li><li>最后用 btoa 把只含有 Latin-1 的 js 字符串转换成 Base64 编码；根据 MDN 文档，btoa 可以将二进制字符串转为 base64 编码的 ASCII 字符串，在实际操作中发现如果直接对中文编码会抛出错误：‘The string to be encoded contains characters outside of the Latin1 range.’，可以推断 btoa 是可以处理 Latin-1 字符集字符的。</li></ol><p>关于这种编码方式，网上也看到有去掉 escape&#x2F;unescape 的版本，似乎同样能得到预期结果。但是这得到的编码并非 utf-8 转 base64 的结果，在只有 ASCII 码时 unescape 使用与否都能得到一样的答案，然而出现带百分号编码的字符串时省去 unescape 会使编码结果的长度增加了，因为 btoa 编码了百分号；且如果是将编码结果传给其他 API 时会很难理解其内容</p><h2 id="前端-node-js-转-base64"><a href="#前端-node-js-转-base64" class="headerlink" title="前端 node.js 转 base64"></a>前端 node.js 转 base64</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">//utf-8 转 base64</span><br>const txt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Buffer</span>(<span class="hljs-string">&#x27;文字&#x27;</span>).toString(<span class="hljs-string">&#x27;base64&#x27;</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(txt)<br><br><span class="hljs-comment">//base64 转 utf-8</span><br>const ztxt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Buffer</span>(txt, <span class="hljs-string">&#x27;base64&#x27;</span>).toString(<span class="hljs-string">&#x27;utf8&#x27;</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(ztxt)<br></code></pre></td></tr></table></figure><p>处理起来相对简单，可以直接用 buffer 模块的 api</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>（1）<a href="https://zhuanlan.zhihu.com/p/427488961">Unicode、UTF-8、UTF-16 终于懂了</a><br>（2）<a href="https://developer.mozilla.org/en-US/docs/Glossary/Base64#Solution_2_%E2%80%93_escaping_the_string_before_encoding_it">Base64</a><br>（3）<a href="https://best33.com/311.moe">为什么 escape 可以使 btoa 正确处理 UTF-8 编码的字符串？</a><br>（4）<a href="https://stackoverflow.com/questions/30631927/converting-to-base64-in-javascript-without-deprecated-escape-call">Converting to Base64 in JavaScript without Deprecated ‘Escape’ call</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;编码知识小记&lt;/p&gt;</summary>
    
    
    
    <category term="工作技巧" scheme="https://unkonwn404.github.io/unkown404.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="WEB API" scheme="https://unkonwn404.github.io/unkown404.github.io/tags/WEB-API/"/>
    
  </entry>
  
  <entry>
    <title>依赖失踪之谜 —— 记一次失败的问题查找</title>
    <link href="https://unkonwn404.github.io/unkown404.github.io/2022/11/29/nvmProblemSearch/"/>
    <id>https://unkonwn404.github.io/unkown404.github.io/2022/11/29/nvmProblemSearch/</id>
    <published>2022-11-29T10:08:22.000Z</published>
    <updated>2023-02-19T03:19:04.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>全局安装的依赖包突然找不到了，调用指令返回 <code>zsh: command not found:xxx</code> 的报错。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>对于上述报错问题，网上的回复基本统一是缺少环境变量配置。MAC 电脑的环境变量文件加载顺序为：</p><ul><li>&#x2F;etc&#x2F;profile，系统级文件，系统启动即加载</li><li>&#x2F;etc&#x2F;path，系统级文件，系统启动即加载</li><li>&#x2F;.bash_profile，用户级的环境变量配置文件，当该文件存在时忽略<del>&#x2F;.bash_login 、</del>&#x2F;.profile 、~&#x2F;.bashrc 文件的配置</li></ul><p>解决环境变量问题步骤：</p><ol><li>打开 zsh 控制台，输入指令：<code>open .zshrc</code></li><li>查看环境变量 PATH。PATH 的通常写法为</li></ol><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">export <span class="hljs-built_in">PATH</span> = &lt;<span class="hljs-built_in">path</span> <span class="hljs-number">1</span>&gt; : &lt;<span class="hljs-built_in">path</span> <span class="hljs-number">2</span>&gt; ... : &lt;<span class="hljs-built_in">path</span> n&gt; : $<span class="hljs-built_in">PATH</span><br></code></pre></td></tr></table></figure><p>涉及多个环境变量时用分号隔开。</p><p>当前电脑配置的 zshrc 内容为：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">NVM_DIR</span>=<span class="hljs-string">&quot;/Users/danhuipeng/.nvm&quot;</span><br>[ -s <span class="hljs-string">&quot;<span class="hljs-variable">$NVM_DIR</span>/nvm.sh&quot;</span> ] &amp;&amp; \. <span class="hljs-string">&quot;<span class="hljs-variable">$NVM_DIR</span>/nvm.sh&quot;</span>  # This loads nvm<br><br><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.yarn/bin:<span class="hljs-variable">$HOME</span>/.config/yarn/global/node_modules/.bin:<span class="hljs-variable">$PATH</span>&quot;</span><br><br>source ~/.bash_profile<br></code></pre></td></tr></table></figure><p>虽然有 yarn 的路径在环境变量中，但因为全局依赖包没有使用 yarn，所以现在的设置并不能解决问题。推测可能是因为当前的 path 内容并没有指向全局 npm 的依赖包目录下 。</p><ol start="3"><li>添加环境变量。使用指令<code>npm config get prefix</code>获取全局安装包时使用的 node，使用指令<code>npm root -g</code>来寻找全局仓库路径。得到的结果分别为：</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">～<span class="hljs-regexp">/.nvm/</span>versions<span class="hljs-regexp">/node/</span>v15.<span class="hljs-number">14.0</span><br>～<span class="hljs-regexp">/.nvm/</span>versions<span class="hljs-regexp">/node/</span>v15.<span class="hljs-number">14.0</span><span class="hljs-regexp">/lib/</span>node_modules<br></code></pre></td></tr></table></figure><p>根目录已省略。尝试将这两个变量添加到 path 后，执行指令发<code>source .zshrc</code>现并没有解决问题。为了明确为什么找不到依赖包执行了指令<code>cd ~/.nvm/versions/node/v15.14.0/lib/node_modules</code>到全局依赖目录下，尝试查看内容列表，然而执行指令<code>ls</code>后什么也没发生，即该目录下的内容已空！！为什么会空了呢？完全不知道原因，和其他版本的依赖目录比较发现连 npm 都没有了？？<br><img src="/unkown404.github.io/img/log.png"></p><p>问题排查到这里已经进行不下去了，只能进行依赖重装。</p><p>考虑到本人使用 node 15 的时候比较少，大多数项目使用的都是 14，所以采用指令<code>nvm alias default v14</code>调整 node 的默认版本。因为 node 15 现在连 npm 都没有了，所以使用<code>nvm uninstall v15</code>指令卸载 node15。使用指令<code>nvm ls</code>检查发现现在已经开始使用 node v14 了</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xl">       v10.<span class="hljs-number">24.1</span><br>       v12.<span class="hljs-number">16.3</span><br>       v12.<span class="hljs-number">22.1</span><br>-&gt;     v14.<span class="hljs-number">19.3</span><br><span class="hljs-function"><span class="hljs-title">default</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">v14</span> (-&gt;</span> v14.<span class="hljs-number">19.3</span>)<br><span class="hljs-function"><span class="hljs-title">iojs</span> -&gt;</span> N/A (default)<br><span class="hljs-function"><span class="hljs-title">unstable</span> -&gt;</span> N/A (default)<br><span class="hljs-function"><span class="hljs-title">node</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">stable</span> (-&gt;</span> v14.<span class="hljs-number">19.3</span>) (default)<br><span class="hljs-function"><span class="hljs-title">stable</span> -&gt;</span> <span class="hljs-number">14.19</span> (-&gt; v14.<span class="hljs-number">19.3</span>) (default)<br><span class="hljs-function"><span class="hljs-title">lts</span>/* -&gt;</span> <span class="hljs-function"><span class="hljs-title">lts</span>/hydrogen (-&gt;</span> N/A)<br><span class="hljs-function"><span class="hljs-title">lts</span>/argon -&gt;</span> <span class="hljs-function"><span class="hljs-title">v4</span>.9.1 (-&gt;</span> N/A)<br><span class="hljs-function"><span class="hljs-title">lts</span>/boron -&gt;</span> <span class="hljs-function"><span class="hljs-title">v6</span>.17.1 (-&gt;</span> N/A)<br><span class="hljs-function"><span class="hljs-title">lts</span>/carbon -&gt;</span> <span class="hljs-function"><span class="hljs-title">v8</span>.17.0 (-&gt;</span> N/A)<br><span class="hljs-function"><span class="hljs-title">lts</span>/dubnium -&gt;</span> v10.<span class="hljs-number">24.1</span><br><span class="hljs-function"><span class="hljs-title">lts</span>/erbium -&gt;</span> <span class="hljs-function"><span class="hljs-title">v12</span>.22.12 (-&gt;</span> N/A)<br><span class="hljs-function"><span class="hljs-title">lts</span>/fermium -&gt;</span> <span class="hljs-function"><span class="hljs-title">v14</span>.21.1 (-&gt;</span> N/A)<br><span class="hljs-function"><span class="hljs-title">lts</span>/gallium -&gt;</span> <span class="hljs-function"><span class="hljs-title">v16</span>.18.1 (-&gt;</span> N/A)<br><span class="hljs-function"><span class="hljs-title">lts</span>/hydrogen -&gt;</span> <span class="hljs-function"><span class="hljs-title">v18</span>.12.1 (-&gt;</span> N/A)<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>(1)<a href="https://wenku.baidu.com/view/2cb4a1ffae51f01dc281e53a580216fc700a53a9.html?_wkts_=1669702352151&bdQuery=zsh%E6%80%8E%E4%B9%88%E9%85%8D%E5%A4%9A%E4%B8%AA%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">Mac 在 bash 和 zsh 配置环境变量 path 的几种方法</a><br>(2)<a href="https://blog.csdn.net/Wildpiglolo/article/details/123828019">npm 全局安装后，对应的环境变量目录下找不到文件</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大无语事件。。。&lt;/p&gt;</summary>
    
    
    
    <category term="踩坑经历" scheme="https://unkonwn404.github.io/unkown404.github.io/categories/%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/"/>
    
    
    <category term="依赖安装" scheme="https://unkonwn404.github.io/unkown404.github.io/tags/%E4%BE%9D%E8%B5%96%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
</feed>
